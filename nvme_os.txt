
nvme_os:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006ab4  30000000  30000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000178  30006ab4  30006ab4  0000eab4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata.str1.4 00000244  30006c2c  30006c2c  0000ec2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000004  30006e80  30006e80  0000ee80  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00016e0c  30006ea0  30006ea0  0000ee84  2**2
                  ALLOC
  5 .ARM.attributes 00000026  00000000  00000000  0000ee84  2**0
                  CONTENTS, READONLY
  6 .comment      00000018  00000000  00000000  0000eeaa  2**0
                  CONTENTS, READONLY
  7 .debug_line   00001e5f  00000000  00000000  0000eec2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00005c7b  00000000  00000000  00010d21  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000116e  00000000  00000000  0001699c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000260  00000000  00000000  00017b10  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000013a0  00000000  00000000  00017d70  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000049e1  00000000  00000000  00019110  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00000fa8  00000000  00000000  0001daf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000014e4  00000000  00000000  0001ea99  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000578  00000000  00000000  0001ff7d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

30000000 <_start>:
.extern	__vector_irq
.extern	__vector_fiq

_start:
	
	ldr	pc,_vector_reset
30000000:	e59ff018 	ldr	pc, [pc, #24]	; 30000020 <_vector_reset>
	ldr pc,_vector_undefined
30000004:	e59ff018 	ldr	pc, [pc, #24]	; 30000024 <_vector_undefined>
	ldr pc,_vector_swi
30000008:	e59ff018 	ldr	pc, [pc, #24]	; 30000028 <_vector_swi>
	ldr pc,_vector_prefetch_abort
3000000c:	e59ff018 	ldr	pc, [pc, #24]	; 3000002c <_vector_prefetch_abort>
	ldr pc,_vector_data_abort
30000010:	e59ff018 	ldr	pc, [pc, #24]	; 30000030 <_vector_data_abort>
	ldr pc,_vector_reserved
30000014:	e59ff018 	ldr	pc, [pc, #24]	; 30000034 <_vector_reserved>
	ldr pc,_vector_irq
30000018:	e59ff018 	ldr	pc, [pc, #24]	; 30000038 <_vector_irq>
	ldr pc,_vector_fiq
3000001c:	e59ff018 	ldr	pc, [pc, #24]	; 3000003c <_vector_fiq>

30000020 <_vector_reset>:
30000020:	30000040 	andcc	r0, r0, r0, asr #32

30000024 <_vector_undefined>:
30000024:	300001d8 	ldrdcc	r0, [r0], -r8

30000028 <_vector_swi>:
30000028:	300001dc 	ldrdcc	r0, [r0], -ip

3000002c <_vector_prefetch_abort>:
3000002c:	300001e0 	andcc	r0, r0, r0, ror #3

30000030 <_vector_data_abort>:
30000030:	300001e4 	andcc	r0, r0, r4, ror #3

30000034 <_vector_reserved>:
30000034:	300001e8 	andcc	r0, r0, r8, ror #3

30000038 <_vector_irq>:
30000038:	300001ec 	andcc	r0, r0, ip, ror #3

3000003c <_vector_fiq>:
3000003c:	3000025c 	andcc	r0, r0, ip, asr r2

30000040 <__vector_reset>:
.extern plat_boot
.extern __bss_start__
.extern __bss_end__

__vector_reset:
        msr cpsr_c,#(DISABLE_IRQ|DISABLE_FIQ|IRQ_MOD)
30000040:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
	ldr	sp,=_IRQ_STACK
30000044:	e59fd04c 	ldr	sp, [pc, #76]	; 30000098 <_bss_end_+0x4>
	msr cpsr_c,#(DISABLE_IRQ|DISABLE_FIQ|FIQ_MOD)
30000048:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
	ldr	sp,=_FIQ_STACK
3000004c:	e59fd048 	ldr	sp, [pc, #72]	; 3000009c <_bss_end_+0x8>
	msr cpsr_c,#(DISABLE_IRQ|DISABLE_FIQ|ABT_MOD)
30000050:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
	ldr	sp,=_ABT_STACK
30000054:	e59fd044 	ldr	sp, [pc, #68]	; 300000a0 <_bss_end_+0xc>
	msr cpsr_c,#(DISABLE_IRQ|DISABLE_FIQ|UND_MOD)
30000058:	e321f0db 	msr	CPSR_c, #219	; 0xdb
	ldr	sp,=_UND_STACK
3000005c:	e59fd040 	ldr	sp, [pc, #64]	; 300000a4 <_bss_end_+0x10>
	msr cpsr_c,#(DISABLE_IRQ|DISABLE_FIQ|SYS_MOD)
30000060:	e321f0df 	msr	CPSR_c, #223	; 0xdf
	ldr	sp,=_SYS_STACK
30000064:	e59fd03c 	ldr	sp, [pc, #60]	; 300000a8 <_bss_end_+0x14>
        msr cpsr_c,#(DISABLE_IRQ|DISABLE_FIQ|SVC_MOD)
30000068:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
	ldr	sp,=_SVC_STACK
3000006c:	e59fd038 	ldr	sp, [pc, #56]	; 300000ac <_bss_end_+0x18>

30000070 <_clear_bss>:
	
_clear_bss:
	ldr r1,_bss_start_
30000070:	e59f1018 	ldr	r1, [pc, #24]	; 30000090 <_bss_start_>
	ldr r3,_bss_end_
30000074:	e59f3018 	ldr	r3, [pc, #24]	; 30000094 <_bss_end_>
	mov r2,#0x0
30000078:	e3a02000 	mov	r2, #0
1:
	cmp r1,r3
3000007c:	e1510003 	cmp	r1, r3
	beq _main
30000080:	0a000001 	beq	3000008c <_main>
	str r2,[r1],#0x4
30000084:	e4812004 	str	r2, [r1], #4
	b	1b
30000088:	eafffffb 	b	3000007c <_clear_bss+0xc>

3000008c <_main>:

_main:
	b plat_boot
3000008c:	ea000036 	b	3000016c <plat_boot>

30000090 <_bss_start_>:
30000090:	30006ea0 	andcc	r6, r0, r0, lsr #29

30000094 <_bss_end_>:
30000094:	3001dcac 	andcc	sp, r1, ip, lsr #25
30000098:	307feffc 	ldrshtcc	lr, [pc, #-252]	; 2fffffa4 <MEM_SIZE+0x2f7fffa4>
3000009c:	307fdffc 	ldrshtcc	sp, [pc, #-252]	; 2fffffa8 <MEM_SIZE+0x2f7fffa8>
300000a0:	307fcffc 	ldrshtcc	ip, [pc, #-252]	; 2fffffac <MEM_SIZE+0x2f7fffac>
300000a4:	307fbffc 	ldrshtcc	fp, [pc, #-252]	; 2fffffb0 <MEM_SIZE+0x2f7fffb0>
300000a8:	307faffc 	ldrshtcc	sl, [pc, #-252]	; 2fffffb4 <MEM_SIZE+0x2f7fffb4>
300000ac:	307ffffc 	ldrshtcc	pc, [pc, #-252]	; 2fffffb8 <MEM_SIZE+0x2f7fffb8>

300000b0 <helloworld>:

typedef void (*init_func)(void);

#define UFCON0	((volatile unsigned int *)(0x50000020))

void helloworld(void){
300000b0:	e59f2018 	ldr	r2, [pc, #24]	; 300000d0 <helloworld+0x20>
300000b4:	e3a03068 	mov	r3, #104	; 0x68
	const char *p="helloworld\n";
	while(*p){
		*UFCON0=*p++;
300000b8:	e3a01205 	mov	r1, #1342177280	; 0x50000000
300000bc:	e5813020 	str	r3, [r1, #32]

#define UFCON0	((volatile unsigned int *)(0x50000020))

void helloworld(void){
	const char *p="helloworld\n";
	while(*p){
300000c0:	e5f23001 	ldrb	r3, [r2, #1]!
300000c4:	e3530000 	cmp	r3, #0
300000c8:	1afffffb 	bne	300000bc <helloworld+0xc>
		*UFCON0=*p++;
	};
}
300000cc:	e12fff1e 	bx	lr
300000d0:	30006c2c 	andcc	r6, r0, ip, lsr #24

300000d4 <test_mmu>:

void test_mmu(void){
300000d4:	e59f2018 	ldr	r2, [pc, #24]	; 300000f4 <test_mmu+0x20>
300000d8:	e3a03074 	mov	r3, #116	; 0x74
	const char *p="test_mmu\n";
	while(*p){
		*(volatile unsigned int *)0xd0000020=*p++;
300000dc:	e3a0120d 	mov	r1, #-805306368	; 0xd0000000
300000e0:	e5813020 	str	r3, [r1, #32]
	};
}

void test_mmu(void){
	const char *p="test_mmu\n";
	while(*p){
300000e4:	e5f23001 	ldrb	r3, [r2, #1]!
300000e8:	e3530000 	cmp	r3, #0
300000ec:	1afffffb 	bne	300000e0 <test_mmu+0xc>
		*(volatile unsigned int *)0xd0000020=*p++;
	};
}
300000f0:	e12fff1e 	bx	lr
300000f4:	30006c38 	andcc	r6, r0, r8, lsr ip

300000f8 <raise>:
	helloworld,
	0,
};

void raise(int sig)
{}
300000f8:	e12fff1e 	bx	lr

300000fc <timer_init>:
#define TIMER_BASE  (0xd1000000)
#define TCFG0   ((volatile unsigned int *)(TIMER_BASE+0x0))
#define TCFG1   ((volatile unsigned int *)(TIMER_BASE+0x4))
#define TCON    ((volatile unsigned int *)(TIMER_BASE+0x8))
#define TCONB4  ((volatile unsigned int *)(TIMER_BASE+0x3c))
	*TCFG0|=0x800;
300000fc:	e3a034d1 	mov	r3, #-788529152	; 0xd1000000
30000100:	e5932000 	ldr	r2, [r3]
};

void raise(int sig)
{}

void timer_init(void){
30000104:	e92d4010 	push	{r4, lr}
#define TIMER_BASE  (0xd1000000)
#define TCFG0   ((volatile unsigned int *)(TIMER_BASE+0x0))
#define TCFG1   ((volatile unsigned int *)(TIMER_BASE+0x4))
#define TCON    ((volatile unsigned int *)(TIMER_BASE+0x8))
#define TCONB4  ((volatile unsigned int *)(TIMER_BASE+0x3c))
	*TCFG0|=0x800;
30000108:	e3822b02 	orr	r2, r2, #2048	; 0x800
3000010c:	e5832000 	str	r2, [r3]
	*TCON&=(~(7<<20));
30000110:	e5932008 	ldr	r2, [r3, #8]
	*TCONB4=10000;

	*TCON|=(1<<20);
	*TCON&=~(1<<21);

	umask_int(14);
30000114:	e3a0000e 	mov	r0, #14
#define TCFG0   ((volatile unsigned int *)(TIMER_BASE+0x0))
#define TCFG1   ((volatile unsigned int *)(TIMER_BASE+0x4))
#define TCON    ((volatile unsigned int *)(TIMER_BASE+0x8))
#define TCONB4  ((volatile unsigned int *)(TIMER_BASE+0x3c))
	*TCFG0|=0x800;
	*TCON&=(~(7<<20));
30000118:	e3c22607 	bic	r2, r2, #7340032	; 0x700000
3000011c:	e5832008 	str	r2, [r3, #8]
	*TCON|=(1<<22);
30000120:	e5932008 	ldr	r2, [r3, #8]
30000124:	e3822501 	orr	r2, r2, #4194304	; 0x400000
30000128:	e5832008 	str	r2, [r3, #8]
	*TCON|=(1<<21);
3000012c:	e5932008 	ldr	r2, [r3, #8]
30000130:	e3822602 	orr	r2, r2, #2097152	; 0x200000
30000134:	e5832008 	str	r2, [r3, #8]

	*TCONB4=10000;
30000138:	e59f2028 	ldr	r2, [pc, #40]	; 30000168 <timer_init+0x6c>
3000013c:	e583203c 	str	r2, [r3, #60]	; 0x3c

	*TCON|=(1<<20);
30000140:	e5932008 	ldr	r2, [r3, #8]
30000144:	e3822601 	orr	r2, r2, #1048576	; 0x100000
30000148:	e5832008 	str	r2, [r3, #8]
	*TCON&=~(1<<21);
3000014c:	e5932008 	ldr	r2, [r3, #8]
30000150:	e3c22602 	bic	r2, r2, #2097152	; 0x200000
30000154:	e5832008 	str	r2, [r3, #8]

	umask_int(14);
30000158:	eb00021e 	bl	300009d8 <umask_int>
	disable_irq();
3000015c:	eb000217 	bl	300009c0 <disable_irq>
}
30000160:	e8bd4010 	pop	{r4, lr}
30000164:	e12fff1e 	bx	lr
30000168:	00002710 	andeq	r2, r0, r0, lsl r7

3000016c <plat_boot>:

int test_switch = 0;

void plat_boot(void){
3000016c:	e92d4010 	push	{r4, lr}
	int i;
	for(i=0;init[i];i++){
30000170:	e59f3054 	ldr	r3, [pc, #84]	; 300001cc <plat_boot+0x60>
30000174:	e59f4054 	ldr	r4, [pc, #84]	; 300001d0 <plat_boot+0x64>
		init[i]();
30000178:	e1a0e00f 	mov	lr, pc
3000017c:	e12fff13 	bx	r3

int test_switch = 0;

void plat_boot(void){
	int i;
	for(i=0;init[i];i++){
30000180:	e5b43004 	ldr	r3, [r4, #4]!
30000184:	e3530000 	cmp	r3, #0
30000188:	1afffffa 	bne	30000178 <plat_boot+0xc>
		init[i]();
	}
	init_sys_mmu();
3000018c:	eb000079 	bl	30000378 <init_sys_mmu>
	start_mmu();
30000190:	eb000063 	bl	30000324 <start_mmu>
30000194:	e59f2038 	ldr	r2, [pc, #56]	; 300001d4 <plat_boot+0x68>
30000198:	e3a03074 	mov	r3, #116	; 0x74
}

void test_mmu(void){
	const char *p="test_mmu\n";
	while(*p){
		*(volatile unsigned int *)0xd0000020=*p++;
3000019c:	e3a0120d 	mov	r1, #-805306368	; 0xd0000000
300001a0:	e5813020 	str	r3, [r1, #32]
	};
}

void test_mmu(void){
	const char *p="test_mmu\n";
	while(*p){
300001a4:	e5f23001 	ldrb	r3, [r2, #1]!
300001a8:	e3530000 	cmp	r3, #0
300001ac:	1afffffb 	bne	300001a0 <plat_boot+0x34>
		init[i]();
	}
	init_sys_mmu();
	start_mmu();
	test_mmu();
	test_printk();
300001b0:	eb0001e8 	bl	30000958 <test_printk>
	timer_init();
300001b4:	ebffffd0 	bl	300000fc <timer_init>

	OSInit();
300001b8:	eb001743 	bl	30005ecc <OSInit>

	//test_mbox();
	//test_tmr();
	//test_q();

	test_m();
300001bc:	eb00197b 	bl	300067b0 <test_m>

	OSStart();
300001c0:	eb0016dd 	bl	30005d3c <OSStart>

}
300001c4:	e8bd4010 	pop	{r4, lr}
300001c8:	e12fff1e 	bx	lr
300001cc:	300000b0 	strhcc	r0, [r0], -r0
300001d0:	30006ab4 	undefined instruction 0x30006ab4
300001d4:	30006c38 	andcc	r6, r0, r8, lsr ip

300001d8 <__vector_undefined>:
.extern common_irq_handler
.extern raw_finish_int


__vector_undefined:
	nop
300001d8:	e1a00000 	nop			; (mov r0, r0)

300001dc <__vector_swi>:

__vector_swi:
	nop
300001dc:	e1a00000 	nop			; (mov r0, r0)

300001e0 <__vector_prefetch_abort>:

__vector_prefetch_abort:	
	nop
300001e0:	e1a00000 	nop			; (mov r0, r0)

300001e4 <__vector_data_abort>:

__vector_data_abort:
	nop
300001e4:	e1a00000 	nop			; (mov r0, r0)

300001e8 <__vector_reserved>:

__vector_reserved:
	nop
300001e8:	e1a00000 	nop			; (mov r0, r0)

300001ec <__vector_irq>:

__vector_irq:

       STMFD   SP!, {R1-R3}                    @ We will use R1-R3 as temporary registers
300001ec:	e92d000e 	push	{r1, r2, r3}
@----------------------------------------------------------------------------
@   R1--SP
@       R2--PC
@   R3--SPSR
@------------------------------------------------------------------------
        MOV     R1, SP
300001f0:	e1a0100d 	mov	r1, sp
        ADD     SP, SP, #12             @Adjust IRQ stack pointer
300001f4:	e28dd00c 	add	sp, sp, #12
        SUB     R2, LR, #4             @Adjust PC for return address to task
300001f8:	e24e2004 	sub	r2, lr, #4

        MRS     R3, SPSR                                @ Copy SPSR (Task CPSR)
300001fc:	e14f3000 	mrs	r3, SPSR



        MSR     CPSR_cxsf, #0x13|0xc0   @Change to SVC mode
30000200:	e32ff0d3 	msr	CPSR_fsxc, #211	; 0xd3

                                                                        @ SAVE TASK''S CONTEXT ONTO OLD TASK''S STACK

        STMFD   SP!, {R2}                               @ Push task''s PC
30000204:	e92d0004 	push	{r2}
        STMFD   SP!, {R4-R12, LR}               @ Push task''s LR,R12-R4
30000208:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

        LDMFD   R1!, {R4-R6}                    @Load Task''s R1-R3 from IRQ stack
3000020c:	e8b10070 	ldm	r1!, {r4, r5, r6}
        STMFD   SP!, {R4-R6}                    @ Push Task''s R1-R3 to SVC stack
30000210:	e92d0070 	push	{r4, r5, r6}
        STMFD   SP!, {R0}                           @ Push Task''s R0 to SVC stack
30000214:	e92d0001 	push	{r0}

        STMFD   SP!, {R3}                               @ Push task''s CPSR
30000218:	e92d0008 	push	{r3}

        LDR     R0,=OSIntNesting        @raw_int_nesting++
3000021c:	e59f0040 	ldr	r0, [pc, #64]	; 30000264 <__vector_fiq+0x8>
        LDRB    R1,[R0]
30000220:	e5d01000 	ldrb	r1, [r0]
        ADD     R1,R1,#1
30000224:	e2811001 	add	r1, r1, #1
        STRB    R1,[R0]
30000228:	e5c01000 	strb	r1, [r0]

        CMP     R1,#1                   @if(raw_int_nesting==1){
3000022c:	e3510001 	cmp	r1, #1
        BNE     1f
30000230:	1a000002 	bne	30000240 <__vector_irq+0x54>
        LDR     R4,=OSTCBCur            @high_ready_obj->task_stack=SP;
30000234:	e59f402c 	ldr	r4, [pc, #44]	; 30000268 <__vector_fiq+0xc>
        LDR     R5,[R4]
30000238:	e5945000 	ldr	r5, [r4]
        STR     SP,[R5]                 @}
3000023c:	e585d000 	str	sp, [r5]

1:
        MSR    CPSR_c,#0x12|0xc0    @Change to IRQ mode to use IRQ stack to handle interrupt
30000240:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
	
	BL     common_irq_handler
30000244:	eb0001e9 	bl	300009f0 <common_irq_handler>

    	MSR         CPSR_c,#0x13|0xc0   @Change to SVC mode
30000248:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    	BL          OSIntExit          @Call raw_finish_int
3000024c:	eb0016de 	bl	30005dcc <OSIntExit>

    	LDMFD   SP!,{R4}               @POP the task''s CPSR
30000250:	e8bd0010 	pop	{r4}
    	MSR         SPSR_cxsf,R4
30000254:	e16ff004 	msr	SPSR_fsxc, r4
    	LDMFD   SP!,{R0-R12,LR,PC}^    @POP new Task''s context
30000258:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

3000025c <__vector_fiq>:


__vector_fiq:

	b __vector_irq
3000025c:	eaffffe2 	b	300001ec <__vector_irq>

	nop
30000260:	e1a00000 	nop			; (mov r0, r0)
30000264:	3001d094 	mulcc	r1, r4, r0
30000268:	3001d098 	mulcc	r1, r8, r0

3000026c <OS_CPU_SR_Save>:
#define MODEMASK        0x1f
#define NOINT           0xc0


OS_CPU_SR_Save:
        MRS     R0, CPSR                                @ Set IRQ and FIQ bits in CPSR to disable all interrupts
3000026c:	e10f0000 	mrs	r0, CPSR
        ORR     R1, R0, #0xC0
30000270:	e38010c0 	orr	r1, r0, #192	; 0xc0
        MSR     CPSR_c, R1
30000274:	e121f001 	msr	CPSR_c, r1
        MRS     R1, CPSR                                @Confirm that CPSR contains the proper interrupt disable flags
30000278:	e10f1000 	mrs	r1, CPSR
        AND     R1, R1, #0xC0
3000027c:	e20110c0 	and	r1, r1, #192	; 0xc0
        CMP     R1, #0xC0
30000280:	e35100c0 	cmp	r1, #192	; 0xc0
        BNE     OS_CPU_SR_Save                          @ Not properly disabled (try again)
30000284:	1afffff8 	bne	3000026c <OS_CPU_SR_Save>
        MOV     PC, LR                                  @ Disabled, return the original CPSR contents in R0
30000288:	e1a0f00e 	mov	pc, lr

3000028c <OS_CPU_SR_Restore>:


OS_CPU_SR_Restore:
        MSR     CPSR_c, R0
3000028c:	e121f000 	msr	CPSR_c, r0
        MOV     PC, LR
30000290:	e1a0f00e 	mov	pc, lr

30000294 <OSStartHighRdy>:



OSStartHighRdy:
        MSR             CPSR_cxsf,#0x13|0xc0     @Switch to SVC mode with IRQ&FIQ disable
30000294:	e32ff0d3 	msr	CPSR_fsxc, #211	; 0xd3

	LDR     R0, =OSRunning
30000298:	e59f0070 	ldr	r0, [pc, #112]	; 30000310 <raw_int_switch+0x38>
	MOV     R1, #1
3000029c:	e3a01001 	mov	r1, #1
	STRB    R1, [R0]
300002a0:	e5c01000 	strb	r1, [r0]

        @----------------------------------------------------------------------------------
        @               SP = raw_task_active->task_stack;
        @----------------------------------------------------------------------------------
        LDR     R0, =OSTCBCur
300002a4:	e59f0068 	ldr	r0, [pc, #104]	; 30000314 <raw_int_switch+0x3c>
        LDR     R0, [R0]
300002a8:	e5900000 	ldr	r0, [r0]
        LDR     SP, [R0]
300002ac:	e590d000 	ldr	sp, [r0]

        @----------------------------------------------------------------------------------
        @ Prepare to return to proper mode
        @----------------------------------------------------------------------------------
        LDMFD   SP!, {R0}
300002b0:	e8bd0001 	pop	{r0}
        MSR     SPSR_cxsf, R0
300002b4:	e16ff000 	msr	SPSR_fsxc, r0
        LDMFD   SP!, {R0-R12, LR, PC}^
300002b8:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

300002bc <port_task_switch>:


port_task_switch:
        STMFD   SP!, {LR}           @PC
300002bc:	e92d4000 	push	{lr}
        STMFD   SP!, {R0-R12, LR}   @R0-R12 LR
300002c0:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
        MRS     R0,  CPSR       @Push CPSR
300002c4:	e10f0000 	mrs	r0, CPSR
        STMFD   SP!, {R0}
300002c8:	e92d0001 	push	{r0}

        @----------------------------------------------------------------------------------
        @               raw_task_active->task_stack = SP
        @----------------------------------------------------------------------------------
        LDR             R0, =OSTCBCur
300002cc:	e59f0040 	ldr	r0, [pc, #64]	; 30000314 <raw_int_switch+0x3c>
        LDR             R0, [R0]
300002d0:	e5900000 	ldr	r0, [r0]
        STR             SP, [R0]
300002d4:	e580d000 	str	sp, [r0]

300002d8 <raw_int_switch>:
raw_int_switch:

        @----------------------------------------------------------------------------------
        @ raw_task_active= high_ready_obj;
        @----------------------------------------------------------------------------------
        LDR             R0, =OSPrioHighRdy
300002d8:	e59f0038 	ldr	r0, [pc, #56]	; 30000318 <raw_int_switch+0x40>
        LDR             R1, =OSPrioCur
300002dc:	e59f1038 	ldr	r1, [pc, #56]	; 3000031c <raw_int_switch+0x44>
        LDRB            R0, [R0]
300002e0:	e5d00000 	ldrb	r0, [r0]
        STRB            R0, [R1]
300002e4:	e5c10000 	strb	r0, [r1]


        @----------------------------------------------------------------------------------
        @ raw_task_active= high_ready_obj;
        @----------------------------------------------------------------------------------
        LDR             R0, =OSTCBHighRdy
300002e8:	e59f0030 	ldr	r0, [pc, #48]	; 30000320 <raw_int_switch+0x48>
        LDR             R1, =OSTCBCur
300002ec:	e59f1020 	ldr	r1, [pc, #32]	; 30000314 <raw_int_switch+0x3c>
        LDR             R0, [R0]
300002f0:	e5900000 	ldr	r0, [r0]
        STR             R0, [R1]
300002f4:	e5810000 	str	r0, [r1]


        @----------------------------------------------------------------------------------
        @  high_ready_obj->task_stack;
        @----------------------------------------------------------------------------------
        LDR             R0, =OSTCBHighRdy
300002f8:	e59f0020 	ldr	r0, [pc, #32]	; 30000320 <raw_int_switch+0x48>
        LDR             R0, [R0]
300002fc:	e5900000 	ldr	r0, [r0]
        LDR             SP, [R0]
30000300:	e590d000 	ldr	sp, [r0]

        @----------------------------------------------------------------------------------
        @Restore New task context
        @----------------------------------------------------------------------------------
        LDMFD   SP!, {R0}               @POP CPSR
30000304:	e8bd0001 	pop	{r0}
        MSR     SPSR_cxsf, R0
30000308:	e16ff000 	msr	SPSR_fsxc, r0
        LDMFD   SP!, {R0-R12, LR, PC}^
3000030c:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^
30000310:	3001c76c 	andcc	ip, r1, ip, ror #14
30000314:	3001d098 	mulcc	r1, r8, r0
30000318:	3001c776 	andcc	ip, r1, r6, ror r7
3000031c:	3001cb44 	andcc	ip, r1, r4, asr #22
30000320:	3001ce7c 	andcc	ip, r1, ip, ror lr

30000324 <start_mmu>:
#define PHYSICAL_VECTOR_ADDR		0x30000000

void start_mmu(void){
	unsigned int ttb=L1_PTR_BASE_ADDR;

	asm (
30000324:	e59f3020 	ldr	r3, [pc, #32]	; 3000034c <start_mmu+0x28>
30000328:	ee023f10 	mcr	15, 0, r3, cr2, cr0, {0}
3000032c:	e3e00000 	mvn	r0, #0
30000330:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
30000334:	e3a00001 	mov	r0, #1
30000338:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
3000033c:	e1a00000 	nop			; (mov r0, r0)
30000340:	e1a00000 	nop			; (mov r0, r0)
30000344:	e1a00000 	nop			; (mov r0, r0)
		"mov r0,r0\n"
		:
		: "r" (ttb)
		:"r0"
	);
}
30000348:	e12fff1e 	bx	lr
3000034c:	30700000 	rsbscc	r0, r0, r0

30000350 <gen_l1_pte>:

unsigned int gen_l1_pte(unsigned int paddr){
30000350:	e1a00a20 	lsr	r0, r0, #20
30000354:	e1a00a00 	lsl	r0, r0, #20
	return (paddr&PTE_L1_SECTION_PADDR_BASE_MASK)|\
										PTE_BITS_L1_SECTION;
}
30000358:	e3800002 	orr	r0, r0, #2
3000035c:	e12fff1e 	bx	lr

30000360 <gen_l1_pte_addr>:

unsigned int gen_l1_pte_addr(unsigned int baddr,\
										unsigned int vaddr){
30000360:	e3c00dff 	bic	r0, r0, #16320	; 0x3fc0
30000364:	e1a01a21 	lsr	r1, r1, #20
30000368:	e1a01a01 	lsl	r1, r1, #20
3000036c:	e3c0003f 	bic	r0, r0, #63	; 0x3f
	return (baddr&PAGE_TABLE_L1_BASE_ADDR_MASK)|\
								VIRT_TO_PTE_L1_INDEX(vaddr);
}
30000370:	e1800921 	orr	r0, r0, r1, lsr #18
30000374:	e12fff1e 	bx	lr

30000378 <init_sys_mmu>:

void init_sys_mmu(void){
30000378:	e3a03000 	mov	r3, #0
	unsigned int pte;
	unsigned int pte_addr;
	int j;

	for(j=0;j<MEM_MAP_SIZE>>20;j++){
		pte=gen_l1_pte(PHYSICAL_VECTOR_ADDR+(j<<20));
3000037c:	e1a01a03 	lsl	r1, r3, #20
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
30000380:	e1a02921 	lsr	r2, r1, #18
	unsigned int pte_addr;
	int j;

	for(j=0;j<MEM_MAP_SIZE>>20;j++){
		pte=gen_l1_pte(PHYSICAL_VECTOR_ADDR+(j<<20));
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
30000384:	e2811203 	add	r1, r1, #805306368	; 0x30000000
30000388:	e3811b01 	orr	r1, r1, #1024	; 0x400
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
3000038c:	e38225c1 	orr	r2, r2, #809500672	; 0x30400000
void init_sys_mmu(void){
	unsigned int pte;
	unsigned int pte_addr;
	int j;

	for(j=0;j<MEM_MAP_SIZE>>20;j++){
30000390:	e2833001 	add	r3, r3, #1
		pte=gen_l1_pte(PHYSICAL_VECTOR_ADDR+(j<<20));
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
30000394:	e3811002 	orr	r1, r1, #2
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
30000398:	e3822603 	orr	r2, r2, #3145728	; 0x300000
void init_sys_mmu(void){
	unsigned int pte;
	unsigned int pte_addr;
	int j;

	for(j=0;j<MEM_MAP_SIZE>>20;j++){
3000039c:	e3530008 	cmp	r3, #8
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003a0:	e5821000 	str	r1, [r2]
void init_sys_mmu(void){
	unsigned int pte;
	unsigned int pte_addr;
	int j;

	for(j=0;j<MEM_MAP_SIZE>>20;j++){
300003a4:	1afffff4 	bne	3000037c <init_sys_mmu+0x4>
300003a8:	e3a03000 	mov	r3, #0
		:"r0"
	);
}

unsigned int gen_l1_pte(unsigned int paddr){
	return (paddr&PTE_L1_SECTION_PADDR_BASE_MASK)|\
300003ac:	e1a01a03 	lsl	r1, r3, #20
300003b0:	e2811203 	add	r1, r1, #805306368	; 0x30000000
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003b4:	e1a02921 	lsr	r2, r1, #18
300003b8:	e38225c1 	orr	r2, r2, #809500672	; 0x30400000
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<MEM_MAP_SIZE>>20;j++){
300003bc:	e2833001 	add	r3, r3, #1
		pte=gen_l1_pte(PHYSICAL_MEM_ADDR+(j<<20));
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
300003c0:	e3811b01 	orr	r1, r1, #1024	; 0x400
300003c4:	e3811002 	orr	r1, r1, #2
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003c8:	e3822603 	orr	r2, r2, #3145728	; 0x300000
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<MEM_MAP_SIZE>>20;j++){
300003cc:	e3530008 	cmp	r3, #8
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003d0:	e5821000 	str	r1, [r2]
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_VECTOR_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<MEM_MAP_SIZE>>20;j++){
300003d4:	1afffff4 	bne	300003ac <init_sys_mmu+0x34>
300003d8:	e3a03000 	mov	r3, #0
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<IO_MAP_SIZE>>20;j++){
		pte=gen_l1_pte(PHYSICAL_IO_ADDR+(j<<20));
300003dc:	e1a01a03 	lsl	r1, r3, #20
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_IO_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003e0:	e2812332 	add	r2, r1, #-939524096	; 0xc8000000
300003e4:	e1a02922 	lsr	r2, r2, #18
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<IO_MAP_SIZE>>20;j++){
		pte=gen_l1_pte(PHYSICAL_IO_ADDR+(j<<20));
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
300003e8:	e2811312 	add	r1, r1, #1207959552	; 0x48000000
300003ec:	e3811b01 	orr	r1, r1, #1024	; 0x400
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_IO_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003f0:	e38225c1 	orr	r2, r2, #809500672	; 0x30400000
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<IO_MAP_SIZE>>20;j++){
300003f4:	e2833001 	add	r3, r3, #1
		pte=gen_l1_pte(PHYSICAL_IO_ADDR+(j<<20));
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
300003f8:	e3811002 	orr	r1, r1, #2
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_IO_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
300003fc:	e3822603 	orr	r2, r2, #3145728	; 0x300000
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<IO_MAP_SIZE>>20;j++){
30000400:	e3530d06 	cmp	r3, #384	; 0x180
		pte|=PTE_ALL_AP_L1_SECTION_DEFAULT;
		pte|=PTE_L1_SECTION_NO_CACHE_AND_WB;
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_IO_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
30000404:	e5821000 	str	r1, [r2]
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_MEM_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
	for(j=0;j<IO_MAP_SIZE>>20;j++){
30000408:	1afffff3 	bne	300003dc <init_sys_mmu+0x64>
		pte|=PTE_L1_SECTION_DOMAIN_DEFAULT;
		pte_addr=gen_l1_pte_addr(L1_PTR_BASE_ADDR,\
								VIRTUAL_IO_ADDR+(j<<20));
		*(volatile unsigned int *)pte_addr=pte;
	}
}
3000040c:	e12fff1e 	bx	lr

30000410 <memcpy>:


void * memcpy(void * dest,const void *src,unsigned int count)
{
	char *tmp = (char *) dest, *s = (char *) src;
	while (count--)
30000410:	e3520000 	cmp	r2, #0
30000414:	012fff1e 	bxeq	lr
30000418:	e3a03000 	mov	r3, #0
		*tmp++ = *s++;
3000041c:	e7d1c003 	ldrb	ip, [r1, r3]
30000420:	e7c0c003 	strb	ip, [r0, r3]
30000424:	e2833001 	add	r3, r3, #1


void * memcpy(void * dest,const void *src,unsigned int count)
{
	char *tmp = (char *) dest, *s = (char *) src;
	while (count--)
30000428:	e1530002 	cmp	r3, r2
3000042c:	1afffffa 	bne	3000041c <memcpy+0xc>
		*tmp++ = *s++;
	return dest;
}
30000430:	e12fff1e 	bx	lr

30000434 <number>:

char *number(char *str, int num,int base,unsigned int flags){
30000434:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
30000438:	e1a06003 	mov	r6, r3
	int i=0;
	int sign=0;
	char numbers[68];
	
	if(FORMAT_SIGNED(flags)&&(signed int)num<0){
3000043c:	e1a03fa1 	lsr	r3, r1, #31
30000440:	e0133426 	ands	r3, r3, r6, lsr #8
	while (count--)
		*tmp++ = *s++;
	return dest;
}

char *number(char *str, int num,int base,unsigned int flags){
30000444:	e24dd054 	sub	sp, sp, #84	; 0x54
	int i=0;
	int sign=0;
	char numbers[68];
	
	if(FORMAT_SIGNED(flags)&&(signed int)num<0){
30000448:	058d3004 	streq	r3, [sp, #4]
		sign=1;
		num=~num+1;
3000044c:	e59f3120 	ldr	r3, [pc, #288]	; 30000574 <number+0x140>
	while (count--)
		*tmp++ = *s++;
	return dest;
}

char *number(char *str, int num,int base,unsigned int flags){
30000450:	e1a04001 	mov	r4, r1
	int sign=0;
	char numbers[68];
	
	if(FORMAT_SIGNED(flags)&&(signed int)num<0){
		sign=1;
		num=~num+1;
30000454:	e593b000 	ldr	fp, [r3]
30000458:	12614000 	rsbne	r4, r1, #0
3000045c:	13a01001 	movne	r1, #1
	while (count--)
		*tmp++ = *s++;
	return dest;
}

char *number(char *str, int num,int base,unsigned int flags){
30000460:	e1a05000 	mov	r5, r0
30000464:	e1a0a002 	mov	sl, r2
	int sign=0;
	char numbers[68];
	
	if(FORMAT_SIGNED(flags)&&(signed int)num<0){
		sign=1;
		num=~num+1;
30000468:	158d1004 	strne	r1, [sp, #4]
3000046c:	e3a07000 	mov	r7, #0
30000470:	e28d900c 	add	r9, sp, #12
	}

	do{
		numbers[i++]=digits[do_div(num,base)];
30000474:	e1a00004 	mov	r0, r4
30000478:	e1a0100a 	mov	r1, sl
3000047c:	eb001942 	bl	3000698c <__aeabi_uidiv>
30000480:	e1a08004 	mov	r8, r4
30000484:	e1a0100a 	mov	r1, sl
30000488:	e1a04000 	mov	r4, r0
3000048c:	e1a00008 	mov	r0, r8
30000490:	eb00197c 	bl	30006a88 <__aeabi_uidivmod>
30000494:	e7db3001 	ldrb	r3, [fp, r1]
	}while(num!=0);
30000498:	e3540000 	cmp	r4, #0
		sign=1;
		num=~num+1;
	}

	do{
		numbers[i++]=digits[do_div(num,base)];
3000049c:	e7c93007 	strb	r3, [r9, r7]
300004a0:	e2877001 	add	r7, r7, #1
	}while(num!=0);
300004a4:	1afffff2 	bne	30000474 <number+0x40>
	

	if(FORMAT_BASE(flags)==FORMAT_BASE_O){
300004a8:	e20660ff 	and	r6, r6, #255	; 0xff
300004ac:	e3560008 	cmp	r6, #8
300004b0:	0a000015 	beq	3000050c <number+0xd8>
		numbers[i++]='0';
	}else if(FORMAT_BASE(flags)==FORMAT_BASE_X){
300004b4:	e3560010 	cmp	r6, #16
300004b8:	0a000019 	beq	30000524 <number+0xf0>
		numbers[i++]='x';
		numbers[i++]='0';
	}else if(FORMAT_BASE(flags)==FORMAT_BASE_B){
300004bc:	e3560002 	cmp	r6, #2
300004c0:	0a000021 	beq	3000054c <number+0x118>
		numbers[i++]='b';
		numbers[i++]='0';
	}
	if(sign)
300004c4:	e59d3004 	ldr	r3, [sp, #4]
	while (count--)
		*tmp++ = *s++;
	return dest;
}

char *number(char *str, int num,int base,unsigned int flags){
300004c8:	e3a00000 	mov	r0, #0
		numbers[i++]='0';
	}else if(FORMAT_BASE(flags)==FORMAT_BASE_B){
		numbers[i++]='b';
		numbers[i++]='0';
	}
	if(sign)
300004cc:	e3530000 	cmp	r3, #0
		numbers[i++]='-';
300004d0:	128d1050 	addne	r1, sp, #80	; 0x50
300004d4:	10813007 	addne	r3, r1, r7
300004d8:	13a0202d 	movne	r2, #45	; 0x2d
300004dc:	12877001 	addne	r7, r7, #1
300004e0:	15432044 	strbne	r2, [r3, #-68]	; 0x44
300004e4:	e0899007 	add	r9, r9, r7

	while (i-- > 0)
			*str++ = numbers[i];
300004e8:	e5793001 	ldrb	r3, [r9, #-1]!
300004ec:	e7c53000 	strb	r3, [r5, r0]
300004f0:	e2800001 	add	r0, r0, #1
		numbers[i++]='0';
	}
	if(sign)
		numbers[i++]='-';

	while (i-- > 0)
300004f4:	e1500007 	cmp	r0, r7
300004f8:	1afffffa 	bne	300004e8 <number+0xb4>
			*str++ = numbers[i];
	return str;
}
300004fc:	e0850000 	add	r0, r5, r0
30000500:	e28dd054 	add	sp, sp, #84	; 0x54
30000504:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
30000508:	e12fff1e 	bx	lr
		numbers[i++]=digits[do_div(num,base)];
	}while(num!=0);
	

	if(FORMAT_BASE(flags)==FORMAT_BASE_O){
		numbers[i++]='0';
3000050c:	e28d2050 	add	r2, sp, #80	; 0x50
30000510:	e0823007 	add	r3, r2, r7
30000514:	e3a02030 	mov	r2, #48	; 0x30
30000518:	e5432044 	strb	r2, [r3, #-68]	; 0x44
3000051c:	e2877001 	add	r7, r7, #1
30000520:	eaffffe7 	b	300004c4 <number+0x90>
	}else if(FORMAT_BASE(flags)==FORMAT_BASE_X){
		numbers[i++]='x';
30000524:	e2873001 	add	r3, r7, #1
30000528:	e28d1050 	add	r1, sp, #80	; 0x50
3000052c:	e0817007 	add	r7, r1, r7
		numbers[i++]='0';
30000530:	e0812003 	add	r2, r1, r3
	

	if(FORMAT_BASE(flags)==FORMAT_BASE_O){
		numbers[i++]='0';
	}else if(FORMAT_BASE(flags)==FORMAT_BASE_X){
		numbers[i++]='x';
30000534:	e3a01078 	mov	r1, #120	; 0x78
30000538:	e5471044 	strb	r1, [r7, #-68]	; 0x44
		numbers[i++]='0';
3000053c:	e3a01030 	mov	r1, #48	; 0x30
30000540:	e5421044 	strb	r1, [r2, #-68]	; 0x44
30000544:	e2837001 	add	r7, r3, #1
30000548:	eaffffdd 	b	300004c4 <number+0x90>
	}else if(FORMAT_BASE(flags)==FORMAT_BASE_B){
		numbers[i++]='b';
3000054c:	e28d2050 	add	r2, sp, #80	; 0x50
30000550:	e2873001 	add	r3, r7, #1
30000554:	e3a01062 	mov	r1, #98	; 0x62
30000558:	e0827007 	add	r7, r2, r7
3000055c:	e5471044 	strb	r1, [r7, #-68]	; 0x44
		numbers[i++]='0';
30000560:	e0822003 	add	r2, r2, r3
30000564:	e3a01030 	mov	r1, #48	; 0x30
30000568:	e5421044 	strb	r1, [r2, #-68]	; 0x44
3000056c:	e2837001 	add	r7, r3, #1
30000570:	eaffffd3 	b	300004c4 <number+0x90>
30000574:	30006e80 	andcc	r6, r0, r0, lsl #29

30000578 <format_decode>:
}

int format_decode(const char *fmt,unsigned int *flags){
	const char *start = fmt;

	*flags &= ~FORMAT_TYPE_MASK;
30000578:	e5913000 	ldr	r3, [r1]
3000057c:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
	*flags |= FORMAT_TYPE_NONE;
30000580:	e5813000 	str	r3, [r1]
	for (; *fmt ; ++fmt) {
30000584:	e5d02000 	ldrb	r2, [r0]
30000588:	e3520000 	cmp	r2, #0
3000058c:	0a00003b 	beq	30000680 <format_decode+0x108>
		if (*fmt == '%')
30000590:	e3520025 	cmp	r2, #37	; 0x25
30000594:	11a0c000 	movne	ip, r0
30000598:	1a000002 	bne	300005a8 <format_decode+0x30>
3000059c:	ea000008 	b	300005c4 <format_decode+0x4c>
300005a0:	e3520025 	cmp	r2, #37	; 0x25
300005a4:	0a000002 	beq	300005b4 <format_decode+0x3c>
int format_decode(const char *fmt,unsigned int *flags){
	const char *start = fmt;

	*flags &= ~FORMAT_TYPE_MASK;
	*flags |= FORMAT_TYPE_NONE;
	for (; *fmt ; ++fmt) {
300005a8:	e5fc2001 	ldrb	r2, [ip, #1]!
300005ac:	e3520000 	cmp	r2, #0
300005b0:	1afffffa 	bne	300005a0 <format_decode+0x28>
		if (*fmt == '%')
		break;
	}

	if (fmt != start || !*fmt)
300005b4:	e15c0000 	cmp	ip, r0
300005b8:	0a000001 	beq	300005c4 <format_decode+0x4c>
		return fmt - start;
300005bc:	e060000c 	rsb	r0, r0, ip
300005c0:	e12fff1e 	bx	lr
	for (; *fmt ; ++fmt) {
		if (*fmt == '%')
		break;
	}

	if (fmt != start || !*fmt)
300005c4:	e3520000 	cmp	r2, #0
300005c8:	0a00002c 	beq	30000680 <format_decode+0x108>
		return fmt - start;

	do{
		fmt++;
		switch(*fmt){
300005cc:	e5d02001 	ldrb	r2, [r0, #1]
300005d0:	e352006c 	cmp	r2, #108	; 0x6c
			case 'l':
				SET_FORMAT_FLAG(*flags,FORMAT_FLAG_WIDTH);
300005d4:	03833601 	orreq	r3, r3, #1048576	; 0x100000
300005d8:	05813000 	streq	r3, [r1]
			default:
				break;
		}
	}while(0);
	
	SET_FORMAT_BASE(*flags,FORMAT_BASE_D);
300005dc:	e3c330ff 	bic	r3, r3, #255	; 0xff
300005e0:	e383200a 	orr	r2, r3, #10
300005e4:	e5812000 	str	r2, [r1]
	switch (*fmt) {
300005e8:	e5d03001 	ldrb	r3, [r0, #1]
300005ec:	e2433058 	sub	r3, r3, #88	; 0x58
300005f0:	e3530020 	cmp	r3, #32
300005f4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
300005f8:	ea000025 	b	30000694 <format_decode+0x11c>
300005fc:	30000704 	andcc	r0, r0, r4, lsl #14
30000600:	30000694 	mulcc	r0, r4, r6
30000604:	30000694 	mulcc	r0, r4, r6
30000608:	30000694 	mulcc	r0, r4, r6
3000060c:	30000694 	mulcc	r0, r4, r6
30000610:	30000694 	mulcc	r0, r4, r6
30000614:	30000694 	mulcc	r0, r4, r6
30000618:	30000694 	mulcc	r0, r4, r6
3000061c:	30000694 	mulcc	r0, r4, r6
30000620:	30000694 	mulcc	r0, r4, r6
30000624:	30000694 	mulcc	r0, r4, r6
30000628:	30000688 	andcc	r0, r0, r8, lsl #13
3000062c:	300006e8 	andcc	r0, r0, r8, ror #13
30000630:	30000694 	mulcc	r0, r4, r6
30000634:	30000694 	mulcc	r0, r4, r6
30000638:	30000694 	mulcc	r0, r4, r6
3000063c:	30000694 	mulcc	r0, r4, r6
30000640:	300006e8 	andcc	r0, r0, r8, ror #13
30000644:	30000694 	mulcc	r0, r4, r6
30000648:	30000694 	mulcc	r0, r4, r6
3000064c:	30000694 	mulcc	r0, r4, r6
30000650:	30000694 	mulcc	r0, r4, r6
30000654:	30000694 	mulcc	r0, r4, r6
30000658:	300006cc 	andcc	r0, r0, ip, asr #13
3000065c:	30000694 	mulcc	r0, r4, r6
30000660:	30000694 	mulcc	r0, r4, r6
30000664:	30000694 	mulcc	r0, r4, r6
30000668:	300006b8 	undefined instruction 0x300006b8
3000066c:	30000694 	mulcc	r0, r4, r6
30000670:	3000069c 	mulcc	r0, ip, r6
30000674:	30000694 	mulcc	r0, r4, r6
30000678:	30000694 	mulcc	r0, r4, r6
3000067c:	30000704 	andcc	r0, r0, r4, lsl #14
	for (; *fmt ; ++fmt) {
		if (*fmt == '%')
		break;
	}

	if (fmt != start || !*fmt)
30000680:	e1a0c000 	mov	ip, r0
30000684:	eaffffcc 	b	300005bc <format_decode+0x44>
	}while(0);
	
	SET_FORMAT_BASE(*flags,FORMAT_BASE_D);
	switch (*fmt) {
		case 'c':
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_CHAR);
30000688:	e3c23cff 	bic	r3, r2, #65280	; 0xff00
3000068c:	e3833c01 	orr	r3, r3, #256	; 0x100
30000690:	e5813000 	str	r3, [r1]
30000694:	e3a00002 	mov	r0, #2
			break;
30000698:	e12fff1e 	bx	lr
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_INT);
			SET_FORMAT_BASE(*flags,FORMAT_BASE_D);
			break;
		case 'u':
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_UINT);
			SET_FORMAT_BASE(*flags,FORMAT_BASE_D);
3000069c:	e3c23cff 	bic	r3, r2, #65280	; 0xff00
300006a0:	e3833c06 	orr	r3, r3, #1536	; 0x600
300006a4:	e3c330ff 	bic	r3, r3, #255	; 0xff
300006a8:	e383300a 	orr	r3, r3, #10
300006ac:	e5813000 	str	r3, [r1]
300006b0:	e3a00002 	mov	r0, #2

	default:
		break;
	}
	return ++fmt-start;
}
300006b4:	e12fff1e 	bx	lr
		case 'c':
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_CHAR);
			break;

		case 's':
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_STR);
300006b8:	e3c23cff 	bic	r3, r2, #65280	; 0xff00
300006bc:	e3833c0d 	orr	r3, r3, #3328	; 0xd00
300006c0:	e5813000 	str	r3, [r1]
300006c4:	e3a00002 	mov	r0, #2
			break;
300006c8:	e12fff1e 	bx	lr

		case 'o':
			SET_FORMAT_BASE(*flags,FORMAT_BASE_O);
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_UINT);
300006cc:	e3c230ff 	bic	r3, r2, #255	; 0xff
300006d0:	e3833008 	orr	r3, r3, #8
300006d4:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
300006d8:	e3833c06 	orr	r3, r3, #1536	; 0x600
300006dc:	e5813000 	str	r3, [r1]
300006e0:	e3a00002 	mov	r0, #2
			break;
300006e4:	e12fff1e 	bx	lr
			break;

		case 'd':
		case 'i':
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_INT);
			SET_FORMAT_BASE(*flags,FORMAT_BASE_D);
300006e8:	e3c23cff 	bic	r3, r2, #65280	; 0xff00
300006ec:	e3833c05 	orr	r3, r3, #1280	; 0x500
300006f0:	e3c330ff 	bic	r3, r3, #255	; 0xff
300006f4:	e383300a 	orr	r3, r3, #10
300006f8:	e5813000 	str	r3, [r1]
300006fc:	e3a00002 	mov	r0, #2
			break;
30000700:	e12fff1e 	bx	lr
			break;

		case 'x':
		case 'X':
			SET_FORMAT_BASE(*flags,FORMAT_BASE_X);
			SET_FORMAT_TYPE(*flags,FORMAT_TYPE_UINT);
30000704:	e3c230ff 	bic	r3, r2, #255	; 0xff
30000708:	e3833010 	orr	r3, r3, #16
3000070c:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
30000710:	e3833c06 	orr	r3, r3, #1536	; 0x600
30000714:	e5813000 	str	r3, [r1]
30000718:	e3a00002 	mov	r0, #2
			break;
3000071c:	e12fff1e 	bx	lr

30000720 <vsnprintf>:
	char *str, *end, c,*s;
	int read;
	unsigned int spec=0;

	str = buf;
	end = buf + size;
30000720:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
30000724:	e24dd00c 	sub	sp, sp, #12
30000728:	e1a08003 	mov	r8, r3

int vsnprintf(char *buf, int size, const char *fmt, va_list args){
	int num;
	char *str, *end, c,*s;
	int read;
	unsigned int spec=0;
3000072c:	e28d7008 	add	r7, sp, #8
30000730:	e3a03000 	mov	r3, #0

	str = buf;
	end = buf + size;
30000734:	e1a04002 	mov	r4, r2

int vsnprintf(char *buf, int size, const char *fmt, va_list args){
	int num;
	char *str, *end, c,*s;
	int read;
	unsigned int spec=0;
30000738:	e5273004 	str	r3, [r7, #-4]!
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
	}

	while (*fmt) {
3000073c:	e5d43000 	ldrb	r3, [r4]
	unsigned int spec=0;

	str = buf;
	end = buf + size;

	if (end < buf) {
30000740:	e0906001 	adds	r6, r0, r1
	char *str, *end, c,*s;
	int read;
	unsigned int spec=0;

	str = buf;
	end = buf + size;
30000744:	e1a0b001 	mov	fp, r1

	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
30000748:	23e06000 	mvncs	r6, #0
3000074c:	21e0b000 	mvncs	fp, r0
	}

	while (*fmt) {
30000750:	e3530000 	cmp	r3, #0
	char *str, *end, c,*s;
	int read;
	unsigned int spec=0;

	str = buf;
	end = buf + size;
30000754:	e1a0a000 	mov	sl, r0

int vsnprintf(char *buf, int size, const char *fmt, va_list args){
	int num;
	char *str, *end, c,*s;
	int read;
	unsigned int spec=0;
30000758:	e1a09000 	mov	r9, r0
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
	}

	while (*fmt) {
3000075c:	0a000019 	beq	300007c8 <vsnprintf+0xa8>
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);
30000760:	e1a00004 	mov	r0, r4
30000764:	e1a01007 	mov	r1, r7
30000768:	ebffff82 	bl	30000578 <format_decode>
		fmt += read;

		if((FORMAT_TYPE(spec))==FORMAT_TYPE_NONE){
3000076c:	e59d3004 	ldr	r3, [sp, #4]
	}

	while (*fmt) {
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);
30000770:	e1a05000 	mov	r5, r0
		fmt += read;

		if((FORMAT_TYPE(spec))==FORMAT_TYPE_NONE){
30000774:	e2132cff 	ands	r2, r3, #65280	; 0xff00
30000778:	1a00001b 	bne	300007ec <vsnprintf+0xcc>
			int copy = read;
			if (str < end) {
3000077c:	e1590006 	cmp	r9, r6
30000780:	2a00000b 	bcs	300007b4 <vsnprintf+0x94>
				if (copy > end - str)
					copy = end - str;
					memcpy(str, old_fmt, copy);
30000784:	e0691006 	rsb	r1, r9, r6
30000788:	e1500001 	cmp	r0, r1
3000078c:	b1a01000 	movlt	r1, r0
30000790:	a1a01001 	movge	r1, r1


void * memcpy(void * dest,const void *src,unsigned int count)
{
	char *tmp = (char *) dest, *s = (char *) src;
	while (count--)
30000794:	e3510000 	cmp	r1, #0
30000798:	0a000005 	beq	300007b4 <vsnprintf+0x94>
3000079c:	e1a03002 	mov	r3, r2
		*tmp++ = *s++;
300007a0:	e7d42003 	ldrb	r2, [r4, r3]
300007a4:	e7c92003 	strb	r2, [r9, r3]
300007a8:	e2833001 	add	r3, r3, #1


void * memcpy(void * dest,const void *src,unsigned int count)
{
	char *tmp = (char *) dest, *s = (char *) src;
	while (count--)
300007ac:	e1510003 	cmp	r1, r3
300007b0:	1afffffa 	bne	300007a0 <vsnprintf+0x80>
			if (str < end) {
				if (copy > end - str)
					copy = end - str;
					memcpy(str, old_fmt, copy);
			}
			str += read;
300007b4:	e0899005 	add	r9, r9, r5

	while (*fmt) {
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);
		fmt += read;
300007b8:	e0844005 	add	r4, r4, r5
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
	}

	while (*fmt) {
300007bc:	e5d43000 	ldrb	r3, [r4]
300007c0:	e3530000 	cmp	r3, #0
300007c4:	1affffe5 	bne	30000760 <vsnprintf+0x40>
				num = va_arg(args, unsigned int);
			}
				str=number(str,num,spec&FORMAT_BASE_MASK,spec);
		}
	}
	if (size > 0) {
300007c8:	e35b0000 	cmp	fp, #0
300007cc:	da000002 	ble	300007dc <vsnprintf+0xbc>
		if (str < end)
300007d0:	e1590006 	cmp	r9, r6
			*str = '\0';
300007d4:	35c93000 	strbcc	r3, [r9]
		else
			end[-1] = '\0';
300007d8:	25463001 	strbcs	r3, [r6, #-1]
	}
	return str-buf;
}
300007dc:	e06a0009 	rsb	r0, sl, r9
300007e0:	e28dd00c 	add	sp, sp, #12
300007e4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
300007e8:	e12fff1e 	bx	lr
					copy = end - str;
					memcpy(str, old_fmt, copy);
			}
			str += read;

		}else if(spec&FORMAT_FLAG_WIDTH){
300007ec:	e3130601 	tst	r3, #1048576	; 0x100000
300007f0:	1afffff0 	bne	300007b8 <vsnprintf+0x98>
			//do nothing
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_CHAR){
300007f4:	e3520c01 	cmp	r2, #256	; 0x100
300007f8:	0a000014 	beq	30000850 <vsnprintf+0x130>
			c = (unsigned char) va_arg(args, int);
			if (str < end)
				*str = c;
			++str;
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_STR){
300007fc:	e3520c0d 	cmp	r2, #3328	; 0xd00
30000800:	0a000018 	beq	30000868 <vsnprintf+0x148>
			s = (char *) va_arg(args, char *);
			while(str<end&&*s!='\0'){
				*str++=*s++;
			}
		}else{
			if(FORMAT_TYPE(spec)==FORMAT_TYPE_INT){
30000804:	e3520c05 	cmp	r2, #1280	; 0x500
30000808:	0a000009 	beq	30000834 <vsnprintf+0x114>
				num = va_arg(args, int);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_ULONG){
3000080c:	e3520b02 	cmp	r2, #2048	; 0x800
30000810:	0a000007 	beq	30000834 <vsnprintf+0x114>
				num = va_arg(args, unsigned long);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_LONG){
30000814:	e3520c07 	cmp	r2, #1792	; 0x700
30000818:	0a000005 	beq	30000834 <vsnprintf+0x114>
				num = va_arg(args, long);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_SIZE_T){
3000081c:	e3520c0b 	cmp	r2, #2816	; 0xb00
30000820:	0a000003 	beq	30000834 <vsnprintf+0x114>
				num = va_arg(args, int);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_USHORT){
30000824:	e3520b01 	cmp	r2, #1024	; 0x400
30000828:	0a000021 	beq	300008b4 <vsnprintf+0x194>
				num = (unsigned short) va_arg(args, int);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_SHORT){
3000082c:	e3520c03 	cmp	r2, #768	; 0x300
30000830:	0a00001b 	beq	300008a4 <vsnprintf+0x184>
				num = (short) va_arg(args, int);
			}else{
				num = va_arg(args, unsigned int);
30000834:	e4981004 	ldr	r1, [r8], #4
			}
				str=number(str,num,spec&FORMAT_BASE_MASK,spec);
30000838:	e1a00009 	mov	r0, r9
3000083c:	e20320ff 	and	r2, r3, #255	; 0xff
30000840:	ebfffefb 	bl	30000434 <number>

	while (*fmt) {
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);
		fmt += read;
30000844:	e0844005 	add	r4, r4, r5
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_SHORT){
				num = (short) va_arg(args, int);
			}else{
				num = va_arg(args, unsigned int);
			}
				str=number(str,num,spec&FORMAT_BASE_MASK,spec);
30000848:	e1a09000 	mov	r9, r0
3000084c:	eaffffda 	b	300007bc <vsnprintf+0x9c>
			str += read;

		}else if(spec&FORMAT_FLAG_WIDTH){
			//do nothing
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_CHAR){
			c = (unsigned char) va_arg(args, int);
30000850:	e4983004 	ldr	r3, [r8], #4
			if (str < end)
30000854:	e1590006 	cmp	r9, r6
				*str = c;
30000858:	35c93000 	strbcc	r3, [r9]

	while (*fmt) {
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);
		fmt += read;
3000085c:	e0844005 	add	r4, r4, r5
			//do nothing
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_CHAR){
			c = (unsigned char) va_arg(args, int);
			if (str < end)
				*str = c;
			++str;
30000860:	e2899001 	add	r9, r9, #1
30000864:	eaffffd4 	b	300007bc <vsnprintf+0x9c>
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_STR){
			s = (char *) va_arg(args, char *);
			while(str<end&&*s!='\0'){
30000868:	e1590006 	cmp	r9, r6
			c = (unsigned char) va_arg(args, int);
			if (str < end)
				*str = c;
			++str;
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_STR){
			s = (char *) va_arg(args, char *);
3000086c:	e4982004 	ldr	r2, [r8], #4
			while(str<end&&*s!='\0'){
30000870:	2affffd0 	bcs	300007b8 <vsnprintf+0x98>
30000874:	e5d23000 	ldrb	r3, [r2]
30000878:	e3530000 	cmp	r3, #0
3000087c:	1a000003 	bne	30000890 <vsnprintf+0x170>
30000880:	eaffffcc 	b	300007b8 <vsnprintf+0x98>
30000884:	e5f23001 	ldrb	r3, [r2, #1]!
30000888:	e3530000 	cmp	r3, #0
3000088c:	0affffc9 	beq	300007b8 <vsnprintf+0x98>
				*str++=*s++;
30000890:	e4c93001 	strb	r3, [r9], #1
			if (str < end)
				*str = c;
			++str;
		}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_STR){
			s = (char *) va_arg(args, char *);
			while(str<end&&*s!='\0'){
30000894:	e1590006 	cmp	r9, r6
30000898:	3afffff9 	bcc	30000884 <vsnprintf+0x164>

	while (*fmt) {
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);
		fmt += read;
3000089c:	e0844005 	add	r4, r4, r5
300008a0:	eaffffc5 	b	300007bc <vsnprintf+0x9c>
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_SIZE_T){
				num = va_arg(args, int);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_USHORT){
				num = (unsigned short) va_arg(args, int);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_SHORT){
				num = (short) va_arg(args, int);
300008a4:	e4981004 	ldr	r1, [r8], #4
300008a8:	e1a01801 	lsl	r1, r1, #16
300008ac:	e1a01841 	asr	r1, r1, #16
300008b0:	eaffffe0 	b	30000838 <vsnprintf+0x118>
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_LONG){
				num = va_arg(args, long);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_SIZE_T){
				num = va_arg(args, int);
			}else if(FORMAT_TYPE(spec)==FORMAT_TYPE_USHORT){
				num = (unsigned short) va_arg(args, int);
300008b4:	e4981004 	ldr	r1, [r8], #4
300008b8:	e1a01801 	lsl	r1, r1, #16
300008bc:	e1a01821 	lsr	r1, r1, #16
300008c0:	eaffffdc 	b	30000838 <vsnprintf+0x118>

300008c4 <__put_char>:
	__res = ((unsigned int) n) % (unsigned int) base; \
	n = ((unsigned int) n) / (unsigned int) base; \
	__res; })


void __put_char(char *p,int num){
300008c4:	e92d4070 	push	{r4, r5, r6, lr}
300008c8:	e1a04000 	mov	r4, r0
300008cc:	e1a05001 	mov	r5, r1

	OS_CPU_SR cpu_sr;

	OS_ENTER_CRITICAL();
300008d0:	ebfffe65 	bl	3000026c <OS_CPU_SR_Save>

	while(*p&&num--){
300008d4:	e5d43000 	ldrb	r3, [r4]
300008d8:	e3530000 	cmp	r3, #0
300008dc:	0a00000a 	beq	3000090c <__put_char+0x48>
300008e0:	e3550000 	cmp	r5, #0
300008e4:	0a000008 	beq	3000090c <__put_char+0x48>
		*(volatile unsigned int *)0xd0000020=*p++;
300008e8:	e3a0220d 	mov	r2, #-805306368	; 0xd0000000
300008ec:	ea000001 	b	300008f8 <__put_char+0x34>

	OS_CPU_SR cpu_sr;

	OS_ENTER_CRITICAL();

	while(*p&&num--){
300008f0:	e2555001 	subs	r5, r5, #1
300008f4:	0a000004 	beq	3000090c <__put_char+0x48>
		*(volatile unsigned int *)0xd0000020=*p++;
300008f8:	e5823020 	str	r3, [r2, #32]

	OS_CPU_SR cpu_sr;

	OS_ENTER_CRITICAL();

	while(*p&&num--){
300008fc:	e5d43001 	ldrb	r3, [r4, #1]
30000900:	e2844001 	add	r4, r4, #1
30000904:	e3530000 	cmp	r3, #0
30000908:	1afffff8 	bne	300008f0 <__put_char+0x2c>
		*(volatile unsigned int *)0xd0000020=*p++;
	};

	OS_EXIT_CRITICAL();
3000090c:	ebfffe5e 	bl	3000028c <OS_CPU_SR_Restore>

}
30000910:	e8bd4070 	pop	{r4, r5, r6, lr}
30000914:	e12fff1e 	bx	lr

30000918 <printk>:
	}
	return str-buf;
}

void printk(const char *fmt, ...)
{
30000918:	e92d000f 	push	{r0, r1, r2, r3}
3000091c:	e92d4010 	push	{r4, lr}
30000920:	e24ddc01 	sub	sp, sp, #256	; 0x100
	
	va_list args;
	unsigned int i;

	va_start (args, fmt);
	i = vsnprintf (print_buf, sizeof(print_buf),fmt, args);
30000924:	e1a0000d 	mov	r0, sp
30000928:	e3a01c01 	mov	r1, #256	; 0x100
3000092c:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
30000930:	e28d3f43 	add	r3, sp, #268	; 0x10c
30000934:	ebffff79 	bl	30000720 <vsnprintf>
30000938:	e1a01000 	mov	r1, r0
	va_end (args);

	__put_char (print_buf,i);
3000093c:	e1a0000d 	mov	r0, sp
	
	va_list args;
	unsigned int i;

	va_start (args, fmt);
	i = vsnprintf (print_buf, sizeof(print_buf),fmt, args);
30000940:	e1a0400d 	mov	r4, sp
	va_end (args);

	__put_char (print_buf,i);
30000944:	ebffffde 	bl	300008c4 <__put_char>
}
30000948:	e28ddc01 	add	sp, sp, #256	; 0x100
3000094c:	e8bd4010 	pop	{r4, lr}
30000950:	e28dd010 	add	sp, sp, #16
30000954:	e12fff1e 	bx	lr

30000958 <test_printk>:


void test_printk(void){
30000958:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	char *p="this is %s test";
	char c='H';
	int d=-256;
	int k=0;
	printk("testing printk\n");
3000095c:	e59f0038 	ldr	r0, [pc, #56]	; 3000099c <test_printk+0x44>

	__put_char (print_buf,i);
}


void test_printk(void){
30000960:	e24dd014 	sub	sp, sp, #20
	char *p="this is %s test";
	char c='H';
	int d=-256;
	int k=0;
	printk("testing printk\n");
30000964:	ebffffeb 	bl	30000918 <printk>
	printk("test string :::	%s\ntest char ::: %c\ntest digit ::: %d\ntest X ::: %x\ntest unsigned ::: %u\ntest zero ::: %d\n",p,c,d,d,d,k);
30000968:	e3e0c0ff 	mvn	ip, #255	; 0xff
3000096c:	e3a0e000 	mov	lr, #0
30000970:	e1a0300c 	mov	r3, ip
30000974:	e59f0024 	ldr	r0, [pc, #36]	; 300009a0 <test_printk+0x48>
30000978:	e59f1024 	ldr	r1, [pc, #36]	; 300009a4 <test_printk+0x4c>
3000097c:	e3a02048 	mov	r2, #72	; 0x48
30000980:	e58de008 	str	lr, [sp, #8]
30000984:	e58dc000 	str	ip, [sp]
30000988:	e58dc004 	str	ip, [sp, #4]
3000098c:	ebffffe1 	bl	30000918 <printk>
}
30000990:	e28dd014 	add	sp, sp, #20
30000994:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000998:	e12fff1e 	bx	lr
3000099c:	30006c44 	andcc	r6, r0, r4, asr #24
300009a0:	30006c54 	andcc	r6, r0, r4, asr ip
300009a4:	30006cc0 	andcc	r6, r0, r0, asr #25

300009a8 <enable_irq>:
#define INTMSK		(INT_BASE+0x8)
#define INTOFFSET	(INT_BASE+0x14)
#define INTPND		(INT_BASE+0x10)
#define SRCPND		(INT_BASE+0x0)

void enable_irq(void){
300009a8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
	asm volatile (
300009ac:	e10f4000 	mrs	r4, CPSR
300009b0:	e3c440c0 	bic	r4, r4, #192	; 0xc0
300009b4:	e129f004 	msr	CPSR_fc, r4
		"mrs r4,cpsr\n\t"
		"bic r4,r4,#0xc0\n\t"
		"msr cpsr,r4\n\t"
		:::"r4"
	);
}
300009b8:	e8bd0010 	pop	{r4}
300009bc:	e12fff1e 	bx	lr

300009c0 <disable_irq>:

void disable_irq(void){
300009c0:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
	asm volatile (
300009c4:	e10f4000 	mrs	r4, CPSR
300009c8:	e38440c0 	orr	r4, r4, #192	; 0xc0
300009cc:	e129f004 	msr	CPSR_fc, r4
		"mrs r4,cpsr\n\t"
		"orr r4,r4,#0xc0\n\t"
		"msr cpsr,r4\n\t"
		:::"r4"
	);
}
300009d0:	e8bd0010 	pop	{r4}
300009d4:	e12fff1e 	bx	lr

300009d8 <umask_int>:

void umask_int(unsigned int offset){
	*(volatile unsigned int *)INTMSK&=~(1<<offset);
300009d8:	e3a034ca 	mov	r3, #-905969664	; 0xca000000
300009dc:	e5932008 	ldr	r2, [r3, #8]
300009e0:	e3a01001 	mov	r1, #1
300009e4:	e1c22011 	bic	r2, r2, r1, lsl r0
300009e8:	e5832008 	str	r2, [r3, #8]
}
300009ec:	e12fff1e 	bx	lr

300009f0 <common_irq_handler>:

void common_irq_handler(void){
	unsigned int tmp=(1<<(*(volatile unsigned int *)INTOFFSET));
300009f0:	e3a034ca 	mov	r3, #-905969664	; 0xca000000
300009f4:	e5932014 	ldr	r2, [r3, #20]
300009f8:	e3a01001 	mov	r1, #1
300009fc:	e1a02211 	lsl	r2, r1, r2
	*(volatile unsigned int *)SRCPND|=tmp;
30000a00:	e5931000 	ldr	r1, [r3]

void umask_int(unsigned int offset){
	*(volatile unsigned int *)INTMSK&=~(1<<offset);
}

void common_irq_handler(void){
30000a04:	e92d4010 	push	{r4, lr}
	unsigned int tmp=(1<<(*(volatile unsigned int *)INTOFFSET));
	*(volatile unsigned int *)SRCPND|=tmp;
30000a08:	e1821001 	orr	r1, r2, r1
30000a0c:	e5831000 	str	r1, [r3]
	*(volatile unsigned int *)INTPND|=tmp;
30000a10:	e5931010 	ldr	r1, [r3, #16]
30000a14:	e1822001 	orr	r2, r2, r1
30000a18:	e5832010 	str	r2, [r3, #16]

	// tick process
	OSTimeTick();
30000a1c:	eb001481 	bl	30005c28 <OSTimeTick>

	// signal timer task
	OSTmrSignal();
30000a20:	eb000b57 	bl	30003784 <OSTmrSignal>
}
30000a24:	e8bd4010 	pop	{r4, lr}
30000a28:	e12fff1e 	bx	lr

30000a2c <OSIntEnter>:
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
    if (OSRunning == OS_TRUE) {
30000a2c:	e59f3020 	ldr	r3, [pc, #32]	; 30000a54 <OSIntEnter+0x28>
30000a30:	e5d33000 	ldrb	r3, [r3]
30000a34:	e3530001 	cmp	r3, #1
30000a38:	112fff1e 	bxne	lr
        if (OSIntNesting < 255u) {
30000a3c:	e59f3014 	ldr	r3, [pc, #20]	; 30000a58 <OSIntEnter+0x2c>
30000a40:	e5d32000 	ldrb	r2, [r3]
30000a44:	e35200ff 	cmp	r2, #255	; 0xff
            OSIntNesting++;                      /* Increment ISR nesting level                        */
30000a48:	12822001 	addne	r2, r2, #1
30000a4c:	15c32000 	strbne	r2, [r3]
30000a50:	e12fff1e 	bx	lr
30000a54:	3001c76c 	andcc	ip, r1, ip, ror #14
30000a58:	3001d094 	mulcc	r1, r4, r0

30000a5c <OSVersion>:
*/

INT16U  OSVersion (void)
{
    return (OS_VERSION);
}
30000a5c:	e59f0000 	ldr	r0, [pc, #0]	; 30000a64 <OSVersion+0x8>
30000a60:	e12fff1e 	bx	lr
30000a64:	0000011b 	andeq	r0, r0, fp, lsl r1

30000a68 <OS_Dummy>:
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
}
30000a68:	e12fff1e 	bx	lr

30000a6c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
30000a6c:	e92d05f0 	push	{r4, r5, r6, r7, r8, sl}
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
30000a70:	e59f40a4 	ldr	r4, [pc, #164]	; 30000b1c <OS_EventTaskRdy+0xb0>
30000a74:	e5d0500a 	ldrb	r5, [r0, #10]
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
30000a78:	e1a0c000 	mov	ip, r0
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
30000a7c:	e7d43005 	ldrb	r3, [r4, r5]
    bity  = (INT8U)(1 << y);
30000a80:	e3a00001 	mov	r0, #1
    x     = OSUnMapTbl[pevent->OSEventTbl[y]];
30000a84:	e08c6003 	add	r6, ip, r3
30000a88:	e2866008 	add	r6, r6, #8
30000a8c:	e5d67003 	ldrb	r7, [r6, #3]
#endif


#if OS_LOWEST_PRIO <= 63
    y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
    bity  = (INT8U)(1 << y);
30000a90:	e1a08310 	lsl	r8, r0, r3
    x     = OSUnMapTbl[pevent->OSEventTbl[y]];
30000a94:	e7d44007 	ldrb	r4, [r4, r7]
#endif


#if OS_LOWEST_PRIO <= 63
    y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
    bity  = (INT8U)(1 << y);
30000a98:	e20880ff 	and	r8, r8, #255	; 0xff
    x     = OSUnMapTbl[pevent->OSEventTbl[y]];
    bitx  = (INT8U)(1 << x);
30000a9c:	e1a00410 	lsl	r0, r0, r4
30000aa0:	e200a0ff 	and	sl, r0, #255	; 0xff
    }
    bitx = (INT16U)(1 << x);
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
30000aa4:	e1c7700a 	bic	r7, r7, sl
    if (pevent->OSEventTbl[y] == 0) {
30000aa8:	e3570000 	cmp	r7, #0
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
30000aac:	01c55008 	biceq	r5, r5, r8
30000ab0:	05cc500a 	strbeq	r5, [ip, #10]
#if OS_LOWEST_PRIO <= 63
    y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
    bity  = (INT8U)(1 << y);
    x     = OSUnMapTbl[pevent->OSEventTbl[y]];
    bitx  = (INT8U)(1 << x);
    prio  = (INT8U)((y << 3) + x);                      /* Find priority of task getting the msg       */
30000ab4:	e0844183 	add	r4, r4, r3, lsl #3

    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    if (pevent->OSEventTbl[y] == 0) {
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
30000ab8:	e59fc060 	ldr	ip, [pc, #96]	; 30000b20 <OS_EventTaskRdy+0xb4>
    }
    bitx = (INT16U)(1 << x);
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
30000abc:	e5c67003 	strb	r7, [r6, #3]
#if OS_LOWEST_PRIO <= 63
    y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
    bity  = (INT8U)(1 << y);
    x     = OSUnMapTbl[pevent->OSEventTbl[y]];
    bitx  = (INT8U)(1 << x);
    prio  = (INT8U)((y << 3) + x);                      /* Find priority of task getting the msg       */
30000ac0:	e20400ff 	and	r0, r4, #255	; 0xff

    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    if (pevent->OSEventTbl[y] == 0) {
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
30000ac4:	e79cc100 	ldr	ip, [ip, r0, lsl #2]
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
30000ac8:	e3a05000 	mov	r5, #0
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
30000acc:	e5dc602c 	ldrb	r6, [ip, #44]	; 0x2c
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    if (pevent->OSEventTbl[y] == 0) {
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
30000ad0:	e1a04005 	mov	r4, r5
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
30000ad4:	e1c62002 	bic	r2, r6, r2
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
30000ad8:	e1520005 	cmp	r2, r5
    if (pevent->OSEventTbl[y] == 0) {
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
    ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
30000adc:	e58c501c 	str	r5, [ip, #28]
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
30000ae0:	e58c1020 	str	r1, [ip, #32]
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
30000ae4:	e5cc502d 	strb	r5, [ip, #45]	; 0x2d
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
30000ae8:	e5cc202c 	strb	r2, [ip, #44]	; 0x2c
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    if (pevent->OSEventTbl[y] == 0) {
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
30000aec:	e1cc52ba 	strh	r5, [ip, #42]	; 0x2a
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
30000af0:	1a000007 	bne	30000b14 <OS_EventTaskRdy+0xa8>
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
30000af4:	e59f2028 	ldr	r2, [pc, #40]	; 30000b24 <OS_EventTaskRdy+0xb8>
        OSRdyTbl[y]     |=  bitx;
30000af8:	e59f1028 	ldr	r1, [pc, #40]	; 30000b28 <OS_EventTaskRdy+0xbc>
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
30000afc:	e5d24000 	ldrb	r4, [r2]
        OSRdyTbl[y]     |=  bitx;
30000b00:	e7d1c003 	ldrb	ip, [r1, r3]
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
30000b04:	e1888004 	orr	r8, r8, r4
        OSRdyTbl[y]     |=  bitx;
30000b08:	e18aa00c 	orr	sl, sl, ip
30000b0c:	e7c1a003 	strb	sl, [r1, r3]
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = OS_FALSE;                    /* Cancel 'any' timeout because of post        */
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
30000b10:	e5c28000 	strb	r8, [r2]
        OSRdyTbl[y]     |=  bitx;
    }
    return (prio);
}
30000b14:	e8bd05f0 	pop	{r4, r5, r6, r7, r8, sl}
30000b18:	e12fff1e 	bx	lr
30000b1c:	30006abc 	undefined instruction 0x30006abc
30000b20:	3001dba8 	andcc	sp, r1, r8, lsr #23
30000b24:	3001ce84 	andcc	ip, r1, r4, lsl #29
30000b28:	3001ce88 	andcc	ip, r1, r8, lsl #29

30000b2c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTaskWait (OS_EVENT *pevent)
{
30000b2c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
30000b30:	e59f3068 	ldr	r3, [pc, #104]	; 30000ba0 <OS_EventTaskWait+0x74>
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30000b34:	e59f1068 	ldr	r1, [pc, #104]	; 30000ba4 <OS_EventTaskWait+0x78>
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
30000b38:	e5933000 	ldr	r3, [r3]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30000b3c:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
30000b40:	e583001c 	str	r0, [r3, #28]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30000b44:	e7d1c002 	ldrb	ip, [r1, r2]
30000b48:	e5d34031 	ldrb	r4, [r3, #49]	; 0x31
30000b4c:	e1ccc004 	bic	ip, ip, r4
    if (OSRdyTbl[y] == 0) {
30000b50:	e35c0000 	cmp	ip, #0
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30000b54:	e7c1c002 	strb	ip, [r1, r2]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
30000b58:	059f2048 	ldreq	r2, [pc, #72]	; 30000ba8 <OS_EventTaskWait+0x7c>
30000b5c:	05d3c032 	ldrbeq	ip, [r3, #50]	; 0x32
30000b60:	05d21000 	ldrbeq	r1, [r2]
30000b64:	01c1100c 	biceq	r1, r1, ip
30000b68:	05c21000 	strbeq	r1, [r2]
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30000b6c:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30000b70:	e5d3c031 	ldrb	ip, [r3, #49]	; 0x31
30000b74:	e0802002 	add	r2, r0, r2
30000b78:	e2822008 	add	r2, r2, #8
30000b7c:	e5d24003 	ldrb	r4, [r2, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30000b80:	e5d0100a 	ldrb	r1, [r0, #10]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30000b84:	e184c00c 	orr	ip, r4, ip
30000b88:	e5c2c003 	strb	ip, [r2, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30000b8c:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
30000b90:	e1833001 	orr	r3, r3, r1
30000b94:	e5c0300a 	strb	r3, [r0, #10]
}
30000b98:	e8bd0010 	pop	{r4}
30000b9c:	e12fff1e 	bx	lr
30000ba0:	3001d098 	mulcc	r1, r8, r0
30000ba4:	3001ce88 	andcc	ip, r1, r8, lsl #29
30000ba8:	3001ce84 	andcc	ip, r1, r4, lsl #29

30000bac <OS_EventTO>:
void  OS_EventTO (OS_EVENT *pevent)
{
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
30000bac:	e59f3044 	ldr	r3, [pc, #68]	; 30000bf8 <OS_EventTO+0x4c>
30000bb0:	e5933000 	ldr	r3, [r3]
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
30000bb4:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30000bb8:	e5d3c031 	ldrb	ip, [r3, #49]	; 0x31
30000bbc:	e0802002 	add	r2, r0, r2
30000bc0:	e2822008 	add	r2, r2, #8
30000bc4:	e5d21003 	ldrb	r1, [r2, #3]
30000bc8:	e1c1100c 	bic	r1, r1, ip
30000bcc:	e5c21003 	strb	r1, [r2, #3]
    if (pevent->OSEventTbl[y] == 0x00) {
30000bd0:	e3510000 	cmp	r1, #0
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
30000bd4:	05d0200a 	ldrbeq	r2, [r0, #10]
30000bd8:	05d31032 	ldrbeq	r1, [r3, #50]	; 0x32
30000bdc:	01c22001 	biceq	r2, r2, r1
30000be0:	05c0200a 	strbeq	r2, [r0, #10]
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30000be4:	e3a02000 	mov	r2, #0
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
30000be8:	e583201c 	str	r2, [r3, #28]
    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    if (pevent->OSEventTbl[y] == 0x00) {
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30000bec:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
30000bf0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
}
30000bf4:	e12fff1e 	bx	lr
30000bf8:	3001d098 	mulcc	r1, r8, r0

30000bfc <OS_EventWaitListInit>:
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
30000bfc:	e3a03000 	mov	r3, #0
30000c00:	e5c0300a 	strb	r3, [r0, #10]
    ptbl               = &pevent->OSEventTbl[0];
30000c04:	e1a02003 	mov	r2, r3
30000c08:	e280000b 	add	r0, r0, #11

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0;
30000c0c:	e7c03002 	strb	r3, [r0, r2]
30000c10:	e2822001 	add	r2, r2, #1


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30000c14:	e3520008 	cmp	r2, #8
30000c18:	1afffffb 	bne	30000c0c <OS_EventWaitListInit+0x10>
        *ptbl++ = 0;
    }
}
30000c1c:	e12fff1e 	bx	lr

30000c20 <OS_MemClr>:
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30000c20:	e3510000 	cmp	r1, #0
30000c24:	012fff1e 	bxeq	lr
*              3) The clear is done one byte at a time since this will work on any processor irrespective
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
30000c28:	e2411001 	sub	r1, r1, #1
30000c2c:	e1a01801 	lsl	r1, r1, #16
30000c30:	e1a01821 	lsr	r1, r1, #16
30000c34:	e3a03000 	mov	r3, #0
30000c38:	e2811001 	add	r1, r1, #1
{
    while (size > 0) {
        *pdest++ = (INT8U)0;
30000c3c:	e1a02003 	mov	r2, r3
30000c40:	e7c02003 	strb	r2, [r0, r3]
30000c44:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30000c48:	e1530001 	cmp	r3, r1
30000c4c:	1afffffb 	bne	30000c40 <OS_MemClr+0x20>
30000c50:	e12fff1e 	bx	lr

30000c54 <OS_MemCopy>:
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
30000c54:	e3520000 	cmp	r2, #0
30000c58:	012fff1e 	bxeq	lr
*              3) The copy is done one byte at a time since this will work on any processor irrespective
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
30000c5c:	e242c001 	sub	ip, r2, #1
30000c60:	e1a0c80c 	lsl	ip, ip, #16
30000c64:	e1a0c82c 	lsr	ip, ip, #16
30000c68:	e28cc001 	add	ip, ip, #1
30000c6c:	e3a03000 	mov	r3, #0
{
    while (size > 0) {
        *pdest++ = *psrc++;
30000c70:	e7d12003 	ldrb	r2, [r1, r3]
30000c74:	e7c02003 	strb	r2, [r0, r3]
30000c78:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
30000c7c:	e153000c 	cmp	r3, ip
30000c80:	1afffffa 	bne	30000c70 <OS_MemCopy+0x1c>
30000c84:	e12fff1e 	bx	lr

30000c88 <OS_StrCopy>:
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000c88:	e5d13000 	ldrb	r3, [r1]
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
30000c8c:	e1a02000 	mov	r2, r0
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000c90:	e3530000 	cmp	r3, #0
30000c94:	01a00003 	moveq	r0, r3
30000c98:	0a000006 	beq	30000cb8 <OS_StrCopy+0x30>
30000c9c:	e3a00000 	mov	r0, #0
        *pdest++ = *psrc++;
30000ca0:	e4c23001 	strb	r3, [r2], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000ca4:	e5f13001 	ldrb	r3, [r1, #1]!
        *pdest++ = *psrc++;
        len++;
30000ca8:	e2800001 	add	r0, r0, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000cac:	e3530000 	cmp	r3, #0
        *pdest++ = *psrc++;
        len++;
30000cb0:	e20000ff 	and	r0, r0, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000cb4:	1afffff9 	bne	30000ca0 <OS_StrCopy+0x18>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30000cb8:	e3a03000 	mov	r3, #0
30000cbc:	e5c23000 	strb	r3, [r2]
    return (len);
}
30000cc0:	e12fff1e 	bx	lr

30000cc4 <OS_StrLen>:
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000cc4:	e5d03000 	ldrb	r3, [r0]
30000cc8:	e3530000 	cmp	r3, #0
30000ccc:	01a00003 	moveq	r0, r3
30000cd0:	012fff1e 	bxeq	lr
30000cd4:	e1a03000 	mov	r3, r0
30000cd8:	e3a00000 	mov	r0, #0
30000cdc:	e5f32001 	ldrb	r2, [r3, #1]!
        psrc++;
        len++;
30000ce0:	e2800001 	add	r0, r0, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000ce4:	e3520000 	cmp	r2, #0
        psrc++;
        len++;
30000ce8:	e20000ff 	and	r0, r0, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30000cec:	1afffffa 	bne	30000cdc <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
}
30000cf0:	e12fff1e 	bx	lr

30000cf4 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
30000cf4:	e92d0070 	push	{r4, r5, r6}
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
30000cf8:	e59fc084 	ldr	ip, [pc, #132]	; 30000d84 <OS_FlagBlock+0x90>
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
30000cfc:	e1dd40bc 	ldrh	r4, [sp, #12]
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
30000d00:	e59cc000 	ldr	ip, [ip]
    OSTCBCur->OSTCBPendTO     = OS_FALSE;
30000d04:	e3a05000 	mov	r5, #0
{
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
30000d08:	e5dc602c 	ldrb	r6, [ip, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO     = OS_FALSE;
30000d0c:	e5cc502d 	strb	r5, [ip, #45]	; 0x2d
{
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
30000d10:	e3866020 	orr	r6, r6, #32
30000d14:	e5cc602c 	strb	r6, [ip, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO     = OS_FALSE;
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
30000d18:	e1cc42ba 	strh	r4, [ip, #42]	; 0x2a
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
30000d1c:	e581c008 	str	ip, [r1, #8]


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
    OSTCBCur->OSTCBPendTO     = OS_FALSE;
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
30000d20:	e58c501c 	str	r5, [ip, #28]
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
30000d24:	e58c1024 	str	r1, [ip, #36]	; 0x24
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
30000d28:	e5c13012 	strb	r3, [r1, #18]
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
30000d2c:	e5903004 	ldr	r3, [r0, #4]
    pnode->OSFlagNodePrev     = (void *)0;
30000d30:	e8810028 	stm	r1, {r3, r5}
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
30000d34:	e581000c 	str	r0, [r1, #12]
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
30000d38:	e5903004 	ldr	r3, [r0, #4]
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
30000d3c:	e1c121b0 	strh	r2, [r1, #16]
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
    pnode->OSFlagNodePrev     = (void *)0;
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
30000d40:	e1530005 	cmp	r3, r5
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
30000d44:	15831004 	strne	r1, [r3, #4]
    }
    pgrp->OSFlagWaitList = (void *)pnode;
30000d48:	e5801004 	str	r1, [r0, #4]

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
30000d4c:	e5dc3030 	ldrb	r3, [ip, #48]	; 0x30
30000d50:	e59f2030 	ldr	r2, [pc, #48]	; 30000d88 <OS_FlagBlock+0x94>
30000d54:	e5dc0031 	ldrb	r0, [ip, #49]	; 0x31
30000d58:	e7d21003 	ldrb	r1, [r2, r3]
30000d5c:	e1c11000 	bic	r1, r1, r0
    if (OSRdyTbl[y] == 0x00) {
30000d60:	e3510000 	cmp	r1, #0
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
    }
    pgrp->OSFlagWaitList = (void *)pnode;

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
30000d64:	e7c21003 	strb	r1, [r2, r3]
    if (OSRdyTbl[y] == 0x00) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
30000d68:	059f301c 	ldreq	r3, [pc, #28]	; 30000d8c <OS_FlagBlock+0x98>
30000d6c:	05dc1032 	ldrbeq	r1, [ip, #50]	; 0x32
30000d70:	05d32000 	ldrbeq	r2, [r3]
30000d74:	01c22001 	biceq	r2, r2, r1
30000d78:	05c32000 	strbeq	r2, [r3]
    }
}
30000d7c:	e8bd0070 	pop	{r4, r5, r6}
30000d80:	e12fff1e 	bx	lr
30000d84:	3001d098 	mulcc	r1, r8, r0
30000d88:	3001ce88 	andcc	ip, r1, r8, lsl #29
30000d8c:	3001ce84 	andcc	ip, r1, r4, lsl #29

30000d90 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
30000d90:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30000d94:	e3a03000 	mov	r3, #0
30000d98:	e59f2064 	ldr	r2, [pc, #100]	; 30000e04 <OS_FlagInit+0x74>
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
        *pdest++ = (INT8U)0;
30000d9c:	e1a01003 	mov	r1, r3
30000da0:	e7c21003 	strb	r1, [r2, r3]
30000da4:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30000da8:	e353008c 	cmp	r3, #140	; 0x8c
30000dac:	1afffffb 	bne	30000da0 <OS_FlagInit+0x10>
*
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
30000db0:	e59f0050 	ldr	r0, [pc, #80]	; 30000e08 <OS_FlagInit+0x78>

    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
30000db4:	e3a04000 	mov	r4, #0
*
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
30000db8:	e2403070 	sub	r3, r0, #112	; 0x70
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        pgrp1->OSFlagWaitList = (void *)pgrp2;
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
30000dbc:	e3a0c03f 	mov	ip, #63	; 0x3f

    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
30000dc0:	e3a01000 	mov	r1, #0
30000dc4:	e543401c 	strb	r4, [r3, #-28]
        pgrp1->OSFlagWaitList = (void *)pgrp2;
30000dc8:	e5033018 	str	r3, [r3, #-24]
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
30000dcc:	e543c012 	strb	ip, [r3, #-18]
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
30000dd0:	e5431011 	strb	r1, [r3, #-17]
#endif
        pgrp1++;
        pgrp2++;
30000dd4:	e283301c 	add	r3, r3, #28


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
30000dd8:	e1530000 	cmp	r3, r0
30000ddc:	1afffff7 	bne	30000dc0 <OS_FlagInit+0x30>
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    pgrp1->OSFlagWaitList = (void *)0;
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
30000de0:	e3a0303f 	mov	r3, #63	; 0x3f
30000de4:	e5c2307a 	strb	r3, [r2, #122]	; 0x7a
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
30000de8:	e59f301c 	ldr	r3, [pc, #28]	; 30000e0c <OS_FlagInit+0x7c>
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    pgrp1->OSFlagWaitList = (void *)0;
30000dec:	e5821074 	str	r1, [r2, #116]	; 0x74
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
30000df0:	e5832000 	str	r2, [r3]
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    pgrp1->OSFlagWaitList = (void *)0;
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
30000df4:	e5c2107b 	strb	r1, [r2, #123]	; 0x7b
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
30000df8:	e5c21070 	strb	r1, [r2, #112]	; 0x70
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
#endif
}
30000dfc:	e8bd0010 	pop	{r4}
30000e00:	e12fff1e 	bx	lr
30000e04:	3001c778 	andcc	ip, r1, r8, ror r7
30000e08:	3001c804 	andcc	ip, r1, r4, lsl #16
30000e0c:	3001dba0 	andcc	sp, r1, r0, lsr #23

30000e10 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
30000e10:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
30000e14:	e5903008 	ldr	r3, [r0, #8]
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
30000e18:	e1a02000 	mov	r2, r0


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    ptcb->OSTCBDly      = 0;
    ptcb->OSTCBFlagsRdy = flags_rdy;
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
30000e1c:	e5d3c02c 	ldrb	ip, [r3, #44]	; 0x2c
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    ptcb->OSTCBDly      = 0;
30000e20:	e3a00000 	mov	r0, #0
    ptcb->OSTCBFlagsRdy = flags_rdy;
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
30000e24:	e20cc0df 	and	ip, ip, #223	; 0xdf
    ptcb->OSTCBPendTO   = OS_FALSE;
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
30000e28:	e35c0000 	cmp	ip, #0

    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    ptcb->OSTCBDly      = 0;
    ptcb->OSTCBFlagsRdy = flags_rdy;
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
    ptcb->OSTCBPendTO   = OS_FALSE;
30000e2c:	e5c3002d 	strb	r0, [r3, #45]	; 0x2d
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    ptcb->OSTCBDly      = 0;
30000e30:	e1c302ba 	strh	r0, [r3, #42]	; 0x2a
    ptcb->OSTCBFlagsRdy = flags_rdy;
30000e34:	e1c312b8 	strh	r1, [r3, #40]	; 0x28
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
30000e38:	e5c3c02c 	strb	ip, [r3, #44]	; 0x2c
    ptcb->OSTCBPendTO   = OS_FALSE;
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
30000e3c:	13a00000 	movne	r0, #0
30000e40:	1a00000b 	bne	30000e74 <OS_FlagTaskRdy+0x64>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
30000e44:	e59f1070 	ldr	r1, [pc, #112]	; 30000ebc <OS_FlagTaskRdy+0xac>
30000e48:	e5d30032 	ldrb	r0, [r3, #50]	; 0x32
30000e4c:	e5d14000 	ldrb	r4, [r1]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30000e50:	e59fc068 	ldr	ip, [pc, #104]	; 30000ec0 <OS_FlagTaskRdy+0xb0>
    ptcb->OSTCBDly      = 0;
    ptcb->OSTCBFlagsRdy = flags_rdy;
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
    ptcb->OSTCBPendTO   = OS_FALSE;
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
30000e54:	e1840000 	orr	r0, r4, r0
30000e58:	e5c10000 	strb	r0, [r1]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30000e5c:	e5d31030 	ldrb	r1, [r3, #48]	; 0x30
30000e60:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
30000e64:	e7dc4001 	ldrb	r4, [ip, r1]
30000e68:	e3a00001 	mov	r0, #1
30000e6c:	e1843003 	orr	r3, r4, r3
30000e70:	e7cc3001 	strb	r3, [ip, r1]
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
30000e74:	e5921004 	ldr	r1, [r2, #4]
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
30000e78:	e5923000 	ldr	r3, [r2]
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
30000e7c:	e3510000 	cmp	r1, #0
30000e80:	0a000008 	beq	30000ea8 <OS_FlagTaskRdy+0x98>
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
30000e84:	e3530000 	cmp	r3, #0
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
30000e88:	e5813000 	str	r3, [r1]
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
30000e8c:	0a000000 	beq	30000e94 <OS_FlagTaskRdy+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
30000e90:	e5831004 	str	r1, [r3, #4]
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
30000e94:	e5923008 	ldr	r3, [r2, #8]
30000e98:	e3a02000 	mov	r2, #0
30000e9c:	e5832024 	str	r2, [r3, #36]	; 0x24
    } else {
        sched                   = OS_FALSE;
    }
    OS_FlagUnlink(pnode);
    return (sched);
}
30000ea0:	e8bd0010 	pop	{r4}
30000ea4:	e12fff1e 	bx	lr

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30000ea8:	e592c00c 	ldr	ip, [r2, #12]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30000eac:	e3530000 	cmp	r3, #0

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30000eb0:	e58c3004 	str	r3, [ip, #4]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30000eb4:	1afffff5 	bne	30000e90 <OS_FlagTaskRdy+0x80>
30000eb8:	eafffff5 	b	30000e94 <OS_FlagTaskRdy+0x84>
30000ebc:	3001ce84 	andcc	ip, r1, r4, lsl #29
30000ec0:	3001ce88 	andcc	ip, r1, r8, lsl #29

30000ec4 <OS_FlagUnlink>:
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
30000ec4:	e5902004 	ldr	r2, [r0, #4]
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
30000ec8:	e5903000 	ldr	r3, [r0]
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
30000ecc:	e3520000 	cmp	r2, #0
30000ed0:	0a000007 	beq	30000ef4 <OS_FlagUnlink+0x30>
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
30000ed4:	e3530000 	cmp	r3, #0
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
30000ed8:	e5823000 	str	r3, [r2]
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
30000edc:	0a000000 	beq	30000ee4 <OS_FlagUnlink+0x20>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
30000ee0:	e5832004 	str	r2, [r3, #4]
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
30000ee4:	e5903008 	ldr	r3, [r0, #8]
30000ee8:	e3a02000 	mov	r2, #0
30000eec:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
}
30000ef0:	e12fff1e 	bx	lr

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30000ef4:	e590100c 	ldr	r1, [r0, #12]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30000ef8:	e3530000 	cmp	r3, #0

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30000efc:	e5813004 	str	r3, [r1, #4]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30000f00:	1afffff6 	bne	30000ee0 <OS_FlagUnlink+0x1c>
30000f04:	eafffff6 	b	30000ee4 <OS_FlagUnlink+0x20>

30000f08 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
30000f08:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30000f0c:	e3a03000 	mov	r3, #0
30000f10:	e59f205c 	ldr	r2, [pc, #92]	; 30000f74 <OS_MemInit+0x6c>
        *pdest++ = (INT8U)0;
30000f14:	e1a01003 	mov	r1, r3
30000f18:	e7c21003 	strb	r1, [r2, r3]
30000f1c:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30000f20:	e35300b4 	cmp	r3, #180	; 0xb4
30000f24:	1afffffb 	bne	30000f18 <OS_MemInit+0x10>
30000f28:	e59f3048 	ldr	r3, [pc, #72]	; 30000f78 <OS_MemInit+0x70>
    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
30000f2c:	e3a0403f 	mov	r4, #63	; 0x3f
*
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
30000f30:	e283c090 	add	ip, r3, #144	; 0x90
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
30000f34:	e3a00000 	mov	r0, #0


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
30000f38:	e5033020 	str	r3, [r3, #-32]
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
30000f3c:	e5434010 	strb	r4, [r3, #-16]
        pmem->OSMemName[1]  = OS_ASCII_NUL;
30000f40:	e543000f 	strb	r0, [r3, #-15]
30000f44:	e2833024 	add	r3, r3, #36	; 0x24
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
30000f48:	e153000c 	cmp	r3, ip
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
30000f4c:	e3a01000 	mov	r1, #0
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
30000f50:	1afffff8 	bne	30000f38 <OS_MemInit+0x30>
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
30000f54:	e3a0303f 	mov	r3, #63	; 0x3f
30000f58:	e5c230a4 	strb	r3, [r2, #164]	; 0xa4
    pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
30000f5c:	e59f3018 	ldr	r3, [pc, #24]	; 30000f7c <OS_MemInit+0x74>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
30000f60:	e5821094 	str	r1, [r2, #148]	; 0x94
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
    pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
30000f64:	e5832000 	str	r2, [r3]
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
    pmem->OSMemName[1]  = OS_ASCII_NUL;
30000f68:	e5c210a5 	strb	r1, [r2, #165]	; 0xa5
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
#endif
}
30000f6c:	e8bd0010 	pop	{r4}
30000f70:	e12fff1e 	bx	lr
30000f74:	3001cb50 	andcc	ip, r1, r0, asr fp
30000f78:	3001cb74 	andcc	ip, r1, r4, ror fp
30000f7c:	3001ce18 	andcc	ip, r1, r8, lsl lr

30000f80 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
30000f80:	e3a03000 	mov	r3, #0
30000f84:	e59f0040 	ldr	r0, [pc, #64]	; 30000fcc <OS_QInit+0x4c>
        *pdest++ = (INT8U)0;
30000f88:	e1a01003 	mov	r1, r3
30000f8c:	e7c01003 	strb	r1, [r0, r3]
30000f90:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30000f94:	e3530060 	cmp	r3, #96	; 0x60
        *pdest++ = (INT8U)0;
30000f98:	e59f202c 	ldr	r2, [pc, #44]	; 30000fcc <OS_QInit+0x4c>
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30000f9c:	1afffffa 	bne	30000f8c <OS_QInit+0xc>

    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
30000fa0:	e1a03002 	mov	r3, r2
30000fa4:	e2821018 	add	r1, r2, #24
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    OSQFreeList = &OSQTbl[0];
30000fa8:	e59f0020 	ldr	r0, [pc, #32]	; 30000fd0 <OS_QInit+0x50>

    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
30000fac:	e4831030 	str	r1, [r3], #48	; 0x30
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    OSQFreeList = &OSQTbl[0];
30000fb0:	e5802000 	str	r2, [r0]

    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
30000fb4:	e2821048 	add	r1, r2, #72	; 0x48
30000fb8:	e5823018 	str	r3, [r2, #24]
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
30000fbc:	e3a03000 	mov	r3, #0

    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
30000fc0:	e5821030 	str	r1, [r2, #48]	; 0x30
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
30000fc4:	e5823048 	str	r3, [r2, #72]	; 0x48
    OSQFreeList = &OSQTbl[0];
#endif
}
30000fc8:	e12fff1e 	bx	lr
30000fcc:	3001ce1c 	andcc	ip, r1, ip, lsl lr
30000fd0:	3001ce80 	andcc	ip, r1, r0, lsl #29

30000fd4 <OS_TaskStkClr>:
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
30000fd4:	e3120001 	tst	r2, #1
30000fd8:	012fff1e 	bxeq	lr
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
30000fdc:	e3120002 	tst	r2, #2
30000fe0:	012fff1e 	bxeq	lr
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
30000fe4:	e3510000 	cmp	r1, #0
30000fe8:	012fff1e 	bxeq	lr
30000fec:	e3a03000 	mov	r3, #0
                size--;
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
30000ff0:	e1a02003 	mov	r2, r3
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
30000ff4:	e2511001 	subs	r1, r1, #1
                size--;
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
30000ff8:	e7802003 	str	r2, [r0, r3]
30000ffc:	e2833004 	add	r3, r3, #4
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
30001000:	1afffffb 	bne	30000ff4 <OS_TaskStkClr+0x20>
30001004:	e12fff1e 	bx	lr

30001008 <OSTmr_Link>:
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
30001008:	e3a03003 	mov	r3, #3
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
3000100c:	e3510001 	cmp	r1, #1
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
30001010:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
30001014:	e5c03031 	strb	r3, [r0, #49]	; 0x31
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
30001018:	0a000002 	beq	30001028 <OSTmr_Link+0x20>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
    } else {
        if (ptmr->OSTmrDly == 0) {
3000101c:	e5903018 	ldr	r3, [r0, #24]
30001020:	e3530000 	cmp	r3, #0
30001024:	1a000017 	bne	30001088 <OSTmr_Link+0x80>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
30001028:	e59f206c 	ldr	r2, [pc, #108]	; 3000109c <OSTmr_Link+0x94>
3000102c:	e590301c 	ldr	r3, [r0, #28]
30001030:	e5922000 	ldr	r2, [r2]
30001034:	e0822003 	add	r2, r2, r3
30001038:	e5802014 	str	r2, [r0, #20]
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
        }
    }
    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];
3000103c:	e59f305c 	ldr	r3, [pc, #92]	; 300010a0 <OSTmr_Link+0x98>
30001040:	e2022007 	and	r2, r2, #7

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
30001044:	e7931182 	ldr	r1, [r3, r2, lsl #3]
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
        }
    }
    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];
30001048:	e083c182 	add	ip, r3, r2, lsl #3

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
3000104c:	e3510000 	cmp	r1, #0
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (void *)ptmr1;
        ptmr1->OSTmrPrev     = (void *)ptmr;
        pspoke->OSTmrEntries++;
30001050:	11dc40b4 	ldrhne	r4, [ip, #4]
    }
    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
        pspoke->OSTmrFirst   = ptmr;
30001054:	07830182 	streq	r0, [r3, r2, lsl #3]
        ptmr->OSTmrNext      = (OS_TMR *)0;
        pspoke->OSTmrEntries = 1;
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
30001058:	17830182 	strne	r0, [r3, r2, lsl #3]
    pspoke = &OSTmrWheelTbl[spoke];

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (OS_TMR *)0;
        pspoke->OSTmrEntries = 1;
3000105c:	03a03001 	moveq	r3, #1
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (void *)ptmr1;
        ptmr1->OSTmrPrev     = (void *)ptmr;
        pspoke->OSTmrEntries++;
30001060:	12843001 	addne	r3, r4, #1
    pspoke = &OSTmrWheelTbl[spoke];

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (OS_TMR *)0;
        pspoke->OSTmrEntries = 1;
30001064:	01cc30b4 	strheq	r3, [ip, #4]
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (void *)ptmr1;
        ptmr1->OSTmrPrev     = (void *)ptmr;
        pspoke->OSTmrEntries++;
30001068:	11cc30b4 	strhne	r3, [ip, #4]
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
3000106c:	e3a03000 	mov	r3, #0
        pspoke->OSTmrEntries = 1;
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (void *)ptmr1;
        ptmr1->OSTmrPrev     = (void *)ptmr;
30001070:	15810010 	strne	r0, [r1, #16]
    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (OS_TMR *)0;
30001074:	0580100c 	streq	r1, [r0, #12]
        pspoke->OSTmrEntries = 1;
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (void *)ptmr1;
30001078:	1580100c 	strne	r1, [r0, #12]
        ptmr1->OSTmrPrev     = (void *)ptmr;
        pspoke->OSTmrEntries++;
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
3000107c:	e5803010 	str	r3, [r0, #16]
}
30001080:	e8bd0010 	pop	{r4}
30001084:	e12fff1e 	bx	lr
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
    } else {
        if (ptmr->OSTmrDly == 0) {
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
30001088:	e59f200c 	ldr	r2, [pc, #12]	; 3000109c <OSTmr_Link+0x94>
3000108c:	e5922000 	ldr	r2, [r2]
30001090:	e0832002 	add	r2, r3, r2
30001094:	e5802014 	str	r2, [r0, #20]
30001098:	eaffffe7 	b	3000103c <OSTmr_Link+0x34>
3000109c:	3001d09c 	mulcc	r1, ip, r0
300010a0:	3001c724 	andcc	ip, r1, r4, lsr #14

300010a4 <OSTmr_Unlink>:
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];
300010a4:	e5902014 	ldr	r2, [r0, #20]
300010a8:	e59f3060 	ldr	r3, [pc, #96]	; 30001110 <OSTmr_Unlink+0x6c>
300010ac:	e2022007 	and	r2, r2, #7

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
300010b0:	e793c182 	ldr	ip, [r3, r2, lsl #3]
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];
300010b4:	e0831182 	add	r1, r3, r2, lsl #3

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
300010b8:	e15c0000 	cmp	ip, r0
300010bc:	0a00000d 	beq	300010f8 <OSTmr_Unlink+0x54>
        if (ptmr1 != (OS_TMR *)0) {
            ptmr1->OSTmrPrev = (void *)0;
        }
    } else {
        ptmr1            = ptmr->OSTmrPrev;                 /* Remove timer from somewhere in the list                */
        ptmr2            = ptmr->OSTmrNext;
300010c0:	e590300c 	ldr	r3, [r0, #12]
        pspoke->OSTmrFirst = ptmr1;
        if (ptmr1 != (OS_TMR *)0) {
            ptmr1->OSTmrPrev = (void *)0;
        }
    } else {
        ptmr1            = ptmr->OSTmrPrev;                 /* Remove timer from somewhere in the list                */
300010c4:	e5902010 	ldr	r2, [r0, #16]
        ptmr2            = ptmr->OSTmrNext;
        ptmr1->OSTmrNext = ptmr2;
        if (ptmr2 != (OS_TMR *)0) {
300010c8:	e3530000 	cmp	r3, #0
            ptmr1->OSTmrPrev = (void *)0;
        }
    } else {
        ptmr1            = ptmr->OSTmrPrev;                 /* Remove timer from somewhere in the list                */
        ptmr2            = ptmr->OSTmrNext;
        ptmr1->OSTmrNext = ptmr2;
300010cc:	e582300c 	str	r3, [r2, #12]
        if (ptmr2 != (OS_TMR *)0) {
            ptmr2->OSTmrPrev = ptmr1;
300010d0:	15832010 	strne	r2, [r3, #16]
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
300010d4:	e3a03001 	mov	r3, #1
300010d8:	e5c03031 	strb	r3, [r0, #49]	; 0x31
    ptmr->OSTmrNext  = (void *)0;
    ptmr->OSTmrPrev  = (void *)0;
    pspoke->OSTmrEntries--;
300010dc:	e1d120b4 	ldrh	r2, [r1, #4]
        if (ptmr2 != (OS_TMR *)0) {
            ptmr2->OSTmrPrev = ptmr1;
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
    ptmr->OSTmrNext  = (void *)0;
300010e0:	e3a03000 	mov	r3, #0
    ptmr->OSTmrPrev  = (void *)0;
    pspoke->OSTmrEntries--;
300010e4:	e2422001 	sub	r2, r2, #1
            ptmr2->OSTmrPrev = ptmr1;
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
    ptmr->OSTmrNext  = (void *)0;
    ptmr->OSTmrPrev  = (void *)0;
300010e8:	e5803010 	str	r3, [r0, #16]
    pspoke->OSTmrEntries--;
300010ec:	e1c120b4 	strh	r2, [r1, #4]
        if (ptmr2 != (OS_TMR *)0) {
            ptmr2->OSTmrPrev = ptmr1;
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
    ptmr->OSTmrNext  = (void *)0;
300010f0:	e580300c 	str	r3, [r0, #12]
    ptmr->OSTmrPrev  = (void *)0;
    pspoke->OSTmrEntries--;
}
300010f4:	e12fff1e 	bx	lr

    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
300010f8:	e590c00c 	ldr	ip, [r0, #12]
        pspoke->OSTmrFirst = ptmr1;
        if (ptmr1 != (OS_TMR *)0) {
300010fc:	e35c0000 	cmp	ip, #0
    spoke  = ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE;
    pspoke = &OSTmrWheelTbl[spoke];

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
        pspoke->OSTmrFirst = ptmr1;
30001100:	e783c182 	str	ip, [r3, r2, lsl #3]
        if (ptmr1 != (OS_TMR *)0) {
            ptmr1->OSTmrPrev = (void *)0;
30001104:	13a03000 	movne	r3, #0
30001108:	158c3010 	strne	r3, [ip, #16]
3000110c:	eafffff0 	b	300010d4 <OSTmr_Unlink+0x30>
30001110:	3001c724 	andcc	ip, r1, r4, lsr #14

30001114 <OSDebugInit>:
    ptemp = (void *)&OSVersionNbr;

    ptemp = (void *)&OSDataSize;

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
30001114:	e12fff1e 	bx	lr

30001118 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
30001118:	e92d4010 	push	{r4, lr}
3000111c:	e1a04000 	mov	r4, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30001120:	ebfffc51 	bl	3000026c <OS_CPU_SR_Save>
    OSTime = ticks;
30001124:	e59f300c 	ldr	r3, [pc, #12]	; 30001138 <OSTimeSet+0x20>
30001128:	e5834000 	str	r4, [r3]
    OS_EXIT_CRITICAL();
3000112c:	ebfffc56 	bl	3000028c <OS_CPU_SR_Restore>
}
30001130:	e8bd4010 	pop	{r4, lr}
30001134:	e12fff1e 	bx	lr
30001138:	3001d0a0 	andcc	sp, r1, r0, lsr #1

3000113c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
3000113c:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30001140:	ebfffc49 	bl	3000026c <OS_CPU_SR_Save>
    ticks = OSTime;
30001144:	e59f3010 	ldr	r3, [pc, #16]	; 3000115c <OSTimeGet+0x20>
30001148:	e5934000 	ldr	r4, [r3]
    OS_EXIT_CRITICAL();
3000114c:	ebfffc4e 	bl	3000028c <OS_CPU_SR_Restore>
    return (ticks);
}
30001150:	e1a00004 	mov	r0, r4
30001154:	e8bd4010 	pop	{r4, lr}
30001158:	e12fff1e 	bx	lr
3000115c:	3001d0a0 	andcc	sp, r1, r0, lsr #1

30001160 <OSTaskQuery>:
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
30001160:	e350003f 	cmp	r0, #63	; 0x3f
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
30001164:	e92d4070 	push	{r4, r5, r6, lr}
30001168:	e1a04000 	mov	r4, r0
3000116c:	e1a05001 	mov	r5, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
30001170:	9a000004 	bls	30001188 <OSTaskQuery+0x28>
        if (prio != OS_PRIO_SELF) {
30001174:	e35000ff 	cmp	r0, #255	; 0xff
30001178:	13a0002a 	movne	r0, #42	; 0x2a
3000117c:	0a000001 	beq	30001188 <OSTaskQuery+0x28>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30001180:	e8bd4070 	pop	{r4, r5, r6, lr}
30001184:	e12fff1e 	bx	lr
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
        if (prio != OS_PRIO_SELF) {
            return (OS_PRIO_INVALID);
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
30001188:	e3550000 	cmp	r5, #0
3000118c:	03a00009 	moveq	r0, #9
30001190:	0afffffa 	beq	30001180 <OSTaskQuery+0x20>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    OS_ENTER_CRITICAL();
30001194:	ebfffc34 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
30001198:	e35400ff 	cmp	r4, #255	; 0xff
        prio = OSTCBCur->OSTCBPrio;
3000119c:	059f3058 	ldreq	r3, [pc, #88]	; 300011fc <OSTaskQuery+0x9c>
300011a0:	05933000 	ldreq	r3, [r3]
300011a4:	05d3402e 	ldrbeq	r4, [r3, #46]	; 0x2e
    }
    ptcb = OSTCBPrioTbl[prio];
300011a8:	e59f3050 	ldr	r3, [pc, #80]	; 30001200 <OSTaskQuery+0xa0>
300011ac:	e7931104 	ldr	r1, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
300011b0:	e3510000 	cmp	r1, #0
300011b4:	0a00000a 	beq	300011e4 <OSTaskQuery+0x84>
        OS_EXIT_CRITICAL();
        return (OS_PRIO_ERR);
    }
    if (ptcb == (OS_TCB *)1) {                   /* Task to query must not be assigned to a Mutex      */
300011b8:	e3510001 	cmp	r1, #1
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
300011bc:	13a03000 	movne	r3, #0
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
        OS_EXIT_CRITICAL();
        return (OS_PRIO_ERR);
    }
    if (ptcb == (OS_TCB *)1) {                   /* Task to query must not be assigned to a Mutex      */
300011c0:	0a00000a 	beq	300011f0 <OSTaskQuery+0x90>
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
        *pdest++ = *psrc++;
300011c4:	e7d12003 	ldrb	r2, [r1, r3]
300011c8:	e7c52003 	strb	r2, [r5, r3]
300011cc:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
300011d0:	e3530058 	cmp	r3, #88	; 0x58
300011d4:	1afffffa 	bne	300011c4 <OSTaskQuery+0x64>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
    OS_EXIT_CRITICAL();
300011d8:	ebfffc2b 	bl	3000028c <OS_CPU_SR_Restore>
300011dc:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
300011e0:	eaffffe6 	b	30001180 <OSTaskQuery+0x20>
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
        prio = OSTCBCur->OSTCBPrio;
    }
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
        OS_EXIT_CRITICAL();
300011e4:	ebfffc28 	bl	3000028c <OS_CPU_SR_Restore>
300011e8:	e3a00029 	mov	r0, #41	; 0x29
        return (OS_PRIO_ERR);
300011ec:	eaffffe3 	b	30001180 <OSTaskQuery+0x20>
    }
    if (ptcb == (OS_TCB *)1) {                   /* Task to query must not be assigned to a Mutex      */
        OS_EXIT_CRITICAL();
300011f0:	ebfffc25 	bl	3000028c <OS_CPU_SR_Restore>
300011f4:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);
300011f8:	eaffffe0 	b	30001180 <OSTaskQuery+0x20>
300011fc:	3001d098 	mulcc	r1, r8, r0
30001200:	3001dba8 	andcc	sp, r1, r8, lsr #23

30001204 <OSTaskStkChk>:
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
30001204:	e350003f 	cmp	r0, #63	; 0x3f
*              OS_ERR_PDATA_NULL   if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
30001208:	e92d4070 	push	{r4, r5, r6, lr}
3000120c:	e1a04000 	mov	r4, r0
30001210:	e1a05001 	mov	r5, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
30001214:	9a000004 	bls	3000122c <OSTaskStkChk+0x28>
        if (prio != OS_PRIO_SELF) {
30001218:	e35000ff 	cmp	r0, #255	; 0xff
3000121c:	13a0002a 	movne	r0, #42	; 0x2a
30001220:	0a000001 	beq	3000122c <OSTaskStkChk+0x28>
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
    return (OS_NO_ERR);
}
30001224:	e8bd4070 	pop	{r4, r5, r6, lr}
30001228:	e12fff1e 	bx	lr
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
        if (prio != OS_PRIO_SELF) {
            return (OS_PRIO_INVALID);
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
3000122c:	e3550000 	cmp	r5, #0
30001230:	03a00009 	moveq	r0, #9
30001234:	0afffffa 	beq	30001224 <OSTaskStkChk+0x20>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
30001238:	e3a03000 	mov	r3, #0
    p_stk_data->OSUsed = 0;
3000123c:	e5853004 	str	r3, [r5, #4]
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
30001240:	e5853000 	str	r3, [r5]
    p_stk_data->OSUsed = 0;
    OS_ENTER_CRITICAL();
30001244:	ebfffc08 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
30001248:	e35400ff 	cmp	r4, #255	; 0xff
        prio = OSTCBCur->OSTCBPrio;
3000124c:	059f3088 	ldreq	r3, [pc, #136]	; 300012dc <OSTaskStkChk+0xd8>
30001250:	05933000 	ldreq	r3, [r3]
30001254:	05d3402e 	ldrbeq	r4, [r3, #46]	; 0x2e
    }
    ptcb = OSTCBPrioTbl[prio];
30001258:	e59f3080 	ldr	r3, [pc, #128]	; 300012e0 <OSTaskStkChk+0xdc>
3000125c:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
30001260:	e3530000 	cmp	r3, #0
30001264:	0a000007 	beq	30001288 <OSTaskStkChk+0x84>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    if (ptcb == (OS_TCB *)1) {
30001268:	e3530001 	cmp	r3, #1
3000126c:	0a000005 	beq	30001288 <OSTaskStkChk+0x84>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
30001270:	e1d321b0 	ldrh	r2, [r3, #16]
30001274:	e3120001 	tst	r2, #1
30001278:	1a000005 	bne	30001294 <OSTaskStkChk+0x90>
        OS_EXIT_CRITICAL();
3000127c:	ebfffc02 	bl	3000028c <OS_CPU_SR_Restore>
30001280:	e3a00082 	mov	r0, #130	; 0x82
        return (OS_TASK_OPT_ERR);
30001284:	eaffffe6 	b	30001224 <OSTaskStkChk+0x20>
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    if (ptcb == (OS_TCB *)1) {
        OS_EXIT_CRITICAL();
30001288:	ebfffbff 	bl	3000028c <OS_CPU_SR_Restore>
3000128c:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);
30001290:	eaffffe3 	b	30001224 <OSTaskStkChk+0x20>
        OS_EXIT_CRITICAL();
        return (OS_TASK_OPT_ERR);
    }
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
30001294:	e5934008 	ldr	r4, [r3, #8]
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
        OS_EXIT_CRITICAL();
        return (OS_TASK_OPT_ERR);
    }
    free = 0;
    size = ptcb->OSTCBStkSize;
30001298:	e593600c 	ldr	r6, [r3, #12]
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
3000129c:	ebfffbfa 	bl	3000028c <OS_CPU_SR_Restore>
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
300012a0:	e5943000 	ldr	r3, [r4]
300012a4:	e3530000 	cmp	r3, #0
300012a8:	13a01000 	movne	r1, #0
300012ac:	11a03001 	movne	r3, r1
300012b0:	1a000004 	bne	300012c8 <OSTaskStkChk+0xc4>
        free++;
300012b4:	e2833001 	add	r3, r3, #1
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
300012b8:	e7942103 	ldr	r2, [r4, r3, lsl #2]
300012bc:	e1a01103 	lsl	r1, r3, #2
300012c0:	e3520000 	cmp	r2, #0
300012c4:	0afffffa 	beq	300012b4 <OSTaskStkChk+0xb0>
    while (*pchk-- == (OS_STK)0) {
        free++;
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
300012c8:	e0633006 	rsb	r3, r3, r6
300012cc:	e1a03103 	lsl	r3, r3, #2
300012d0:	e885000a 	stm	r5, {r1, r3}
300012d4:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
300012d8:	eaffffd1 	b	30001224 <OSTaskStkChk+0x20>
300012dc:	3001d098 	mulcc	r1, r8, r0
300012e0:	3001dba8 	andcc	sp, r1, r8, lsr #23

300012e4 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
300012e4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
300012e8:	e3a05000 	mov	r5, #0
300012ec:	e24dd00c 	sub	sp, sp, #12


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
        err = OSTaskStkChk(prio, &stk_data);
        if (err == OS_NO_ERR) {
            ptcb = OSTCBPrioTbl[prio];
300012f0:	e59f7064 	ldr	r7, [pc, #100]	; 3000135c <OS_TaskStatStkChk+0x78>
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
300012f4:	e1a04005 	mov	r4, r5
300012f8:	e1a0600d 	mov	r6, sp
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
        err = OSTaskStkChk(prio, &stk_data);
300012fc:	e1a00004 	mov	r0, r4
30001300:	e1a0100d 	mov	r1, sp
30001304:	ebffffbe 	bl	30001204 <OSTaskStkChk>
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
30001308:	e2844001 	add	r4, r4, #1
        err = OSTaskStkChk(prio, &stk_data);
        if (err == OS_NO_ERR) {
3000130c:	e3500000 	cmp	r0, #0
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
30001310:	e20440ff 	and	r4, r4, #255	; 0xff
        err = OSTaskStkChk(prio, &stk_data);
        if (err == OS_NO_ERR) {
30001314:	1a00000a 	bne	30001344 <OS_TaskStatStkChk+0x60>
            ptcb = OSTCBPrioTbl[prio];
30001318:	e7973005 	ldr	r3, [r7, r5]
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
3000131c:	e3530000 	cmp	r3, #0
30001320:	0a000007 	beq	30001344 <OS_TaskStatStkChk+0x60>
                if (ptcb != (OS_TCB *)1) {                           /* ... still valid.               */
30001324:	e3530001 	cmp	r3, #1
30001328:	0a000005 	beq	30001344 <OS_TaskStatStkChk+0x60>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
3000132c:	e593100c 	ldr	r1, [r3, #12]
30001330:	e5932008 	ldr	r2, [r3, #8]
30001334:	e0822101 	add	r2, r2, r1, lsl #2
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
30001338:	e59d1004 	ldr	r1, [sp, #4]
            ptcb = OSTCBPrioTbl[prio];
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
                if (ptcb != (OS_TCB *)1) {                           /* ... still valid.               */
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
3000133c:	e5832040 	str	r2, [r3, #64]	; 0x40
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
30001340:	e5831044 	str	r1, [r3, #68]	; 0x44
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
30001344:	e3540040 	cmp	r4, #64	; 0x40
30001348:	e2855004 	add	r5, r5, #4
3000134c:	1affffea 	bne	300012fc <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
30001350:	e28dd00c 	add	sp, sp, #12
30001354:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
30001358:	e12fff1e 	bx	lr
3000135c:	3001dba8 	andcc	sp, r1, r8, lsr #23

30001360 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *err)
{
30001360:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                         /* Validate 'err'                                 */
30001364:	e2525000 	subs	r5, r2, #0
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *err)
{
30001368:	e1a04000 	mov	r4, r0
3000136c:	e1a06001 	mov	r6, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                         /* Validate 'err'                                 */
30001370:	0a000005 	beq	3000138c <OSTaskNameSet+0x2c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
30001374:	e350003f 	cmp	r0, #63	; 0x3f
30001378:	9a000005 	bls	30001394 <OSTaskNameSet+0x34>
        if (prio != OS_PRIO_SELF) {
3000137c:	e35000ff 	cmp	r0, #255	; 0xff
            *err = OS_PRIO_INVALID;                  /* No                                             */
30001380:	13a0302a 	movne	r3, #42	; 0x2a
30001384:	15c53000 	strbne	r3, [r5]
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                         /* Validate 'err'                                 */
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
        if (prio != OS_PRIO_SELF) {
30001388:	0a000001 	beq	30001394 <OSTaskNameSet+0x34>
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
}
3000138c:	e8bd4070 	pop	{r4, r5, r6, lr}
30001390:	e12fff1e 	bx	lr
        if (prio != OS_PRIO_SELF) {
            *err = OS_PRIO_INVALID;                  /* No                                             */
            return;
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
30001394:	e3560000 	cmp	r6, #0
        *err = OS_ERR_PNAME_NULL;                    /* Yes                                            */
30001398:	03a0300f 	moveq	r3, #15
3000139c:	05c53000 	strbeq	r3, [r5]
        if (prio != OS_PRIO_SELF) {
            *err = OS_PRIO_INVALID;                  /* No                                             */
            return;
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
300013a0:	0afffff9 	beq	3000138c <OSTaskNameSet+0x2c>
        *err = OS_ERR_PNAME_NULL;                    /* Yes                                            */
        return;
    }
#endif
    OS_ENTER_CRITICAL();
300013a4:	ebfffbb0 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
300013a8:	e35400ff 	cmp	r4, #255	; 0xff
        prio = OSTCBCur->OSTCBPrio;
300013ac:	059f309c 	ldreq	r3, [pc, #156]	; 30001450 <OSTaskNameSet+0xf0>
300013b0:	05933000 	ldreq	r3, [r3]
300013b4:	05d3402e 	ldrbeq	r4, [r3, #46]	; 0x2e
    }
    ptcb = OSTCBPrioTbl[prio];
300013b8:	e59f3094 	ldr	r3, [pc, #148]	; 30001454 <OSTaskNameSet+0xf4>
300013bc:	e793e104 	ldr	lr, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
300013c0:	e35e0000 	cmp	lr, #0
300013c4:	0a00001b 	beq	30001438 <OSTaskNameSet+0xd8>
        OS_EXIT_CRITICAL();                          /* No                                             */
        *err = OS_TASK_NOT_EXIST;
        return;
    }
    if (ptcb == (OS_TCB *)1) {                       /* Task assigned to a Mutex?                      */
300013c8:	e35e0001 	cmp	lr, #1
300013cc:	0a000019 	beq	30001438 <OSTaskNameSet+0xd8>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300013d0:	e5d63000 	ldrb	r3, [r6]
300013d4:	e3530000 	cmp	r3, #0
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *err = OS_TASK_NOT_EXIST;
        return;
300013d8:	11a01006 	movne	r1, r6
300013dc:	13a02000 	movne	r2, #0
300013e0:	0a000018 	beq	30001448 <OSTaskNameSet+0xe8>
300013e4:	e5f1c001 	ldrb	ip, [r1, #1]!
        psrc++;
        len++;
300013e8:	e2822001 	add	r2, r2, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300013ec:	e35c0000 	cmp	ip, #0
        psrc++;
        len++;
300013f0:	e20220ff 	and	r2, r2, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300013f4:	1afffffa 	bne	300013e4 <OSTaskNameSet+0x84>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
300013f8:	e352000f 	cmp	r2, #15
        OS_EXIT_CRITICAL();
        *err = OS_ERR_TASK_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
300013fc:	928e2048 	addls	r2, lr, #72	; 0x48
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *err = OS_TASK_NOT_EXIST;
        return;
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
30001400:	8a000008 	bhi	30001428 <OSTaskNameSet+0xc8>
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
        *pdest++ = *psrc++;
30001404:	e4c23001 	strb	r3, [r2], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001408:	e5f63001 	ldrb	r3, [r6, #1]!
3000140c:	e3530000 	cmp	r3, #0
30001410:	1afffffb 	bne	30001404 <OSTaskNameSet+0xa4>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30001414:	e3a04000 	mov	r4, #0
30001418:	e5c24000 	strb	r4, [r2]
        OS_EXIT_CRITICAL();
        *err = OS_ERR_TASK_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
3000141c:	ebfffb9a 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30001420:	e5c54000 	strb	r4, [r5]
30001424:	eaffffd8 	b	3000138c <OSTaskNameSet+0x2c>
        *err = OS_TASK_NOT_EXIST;
        return;
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
        OS_EXIT_CRITICAL();
30001428:	ebfffb97 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_TASK_NAME_TOO_LONG;
3000142c:	e3a0300e 	mov	r3, #14
30001430:	e5c53000 	strb	r3, [r5]
        return;
30001434:	eaffffd4 	b	3000138c <OSTaskNameSet+0x2c>
        OS_EXIT_CRITICAL();                          /* No                                             */
        *err = OS_TASK_NOT_EXIST;
        return;
    }
    if (ptcb == (OS_TCB *)1) {                       /* Task assigned to a Mutex?                      */
        OS_EXIT_CRITICAL();                          /* Yes                                            */
30001438:	ebfffb93 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TASK_NOT_EXIST;
3000143c:	e3a0300b 	mov	r3, #11
30001440:	e5c53000 	strb	r3, [r5]
        return;
30001444:	eaffffd0 	b	3000138c <OSTaskNameSet+0x2c>
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
        OS_EXIT_CRITICAL();
        *err = OS_ERR_TASK_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
30001448:	e28e2048 	add	r2, lr, #72	; 0x48
3000144c:	eafffff0 	b	30001414 <OSTaskNameSet+0xb4>
30001450:	3001d098 	mulcc	r1, r8, r0
30001454:	3001dba8 	andcc	sp, r1, r8, lsr #23

30001458 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *err)
{
30001458:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                             /* Validate 'err'                             */
3000145c:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *err)
{
30001460:	e1a04000 	mov	r4, r0
30001464:	e1a06001 	mov	r6, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                             /* Validate 'err'                             */
30001468:	01a04005 	moveq	r4, r5
3000146c:	0a000006 	beq	3000148c <OSTaskNameGet+0x34>
        return (0);
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
30001470:	e354003f 	cmp	r4, #63	; 0x3f
30001474:	9a000007 	bls	30001498 <OSTaskNameGet+0x40>
        if (prio != OS_PRIO_SELF) {
30001478:	e35400ff 	cmp	r4, #255	; 0xff
            *err = OS_PRIO_INVALID;                      /* No                                         */
3000147c:	13a0302a 	movne	r3, #42	; 0x2a
30001480:	15c53000 	strbne	r3, [r5]
30001484:	13a04000 	movne	r4, #0
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                             /* Validate 'err'                             */
        return (0);
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
        if (prio != OS_PRIO_SELF) {
30001488:	0a000002 	beq	30001498 <OSTaskNameGet+0x40>
    }
    len  = OS_StrCopy(pname, ptcb->OSTCBTaskName);       /* Yes, copy name from TCB                    */
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
    return (len);
}
3000148c:	e1a00004 	mov	r0, r4
30001490:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30001494:	e12fff1e 	bx	lr
        if (prio != OS_PRIO_SELF) {
            *err = OS_PRIO_INVALID;                      /* No                                         */
            return (0);
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
30001498:	e3560000 	cmp	r6, #0
        *err = OS_ERR_PNAME_NULL;                        /* Yes                                        */
3000149c:	03a0300f 	moveq	r3, #15
300014a0:	05c53000 	strbeq	r3, [r5]
300014a4:	01a04006 	moveq	r4, r6
        if (prio != OS_PRIO_SELF) {
            *err = OS_PRIO_INVALID;                      /* No                                         */
            return (0);
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
300014a8:	0afffff7 	beq	3000148c <OSTaskNameGet+0x34>
        *err = OS_ERR_PNAME_NULL;                        /* Yes                                        */
        return (0);
    }
#endif
    OS_ENTER_CRITICAL();
300014ac:	ebfffb6e 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
300014b0:	e35400ff 	cmp	r4, #255	; 0xff
        prio = OSTCBCur->OSTCBPrio;
300014b4:	059f3084 	ldreq	r3, [pc, #132]	; 30001540 <OSTaskNameGet+0xe8>
300014b8:	05933000 	ldreq	r3, [r3]
300014bc:	05d3402e 	ldrbeq	r4, [r3, #46]	; 0x2e
    }
    ptcb = OSTCBPrioTbl[prio];
300014c0:	e59f307c 	ldr	r3, [pc, #124]	; 30001544 <OSTaskNameGet+0xec>
300014c4:	e7934104 	ldr	r4, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
300014c8:	e3540000 	cmp	r4, #0
300014cc:	0a000012 	beq	3000151c <OSTaskNameGet+0xc4>
        OS_EXIT_CRITICAL();                              /* No                                         */
        *err = OS_TASK_NOT_EXIST;
        return (0);
    }
    if (ptcb == (OS_TCB *)1) {                           /* Task assigned to a Mutex?                  */
300014d0:	e3540001 	cmp	r4, #1
300014d4:	0a000014 	beq	3000152c <OSTaskNameGet+0xd4>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300014d8:	e5d43048 	ldrb	r3, [r4, #72]	; 0x48
300014dc:	e3530000 	cmp	r3, #0
300014e0:	01a04003 	moveq	r4, r3
300014e4:	0a000007 	beq	30001508 <OSTaskNameGet+0xb0>
300014e8:	e2842048 	add	r2, r4, #72	; 0x48
300014ec:	e3a04000 	mov	r4, #0
        *pdest++ = *psrc++;
300014f0:	e4c63001 	strb	r3, [r6], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300014f4:	e5f23001 	ldrb	r3, [r2, #1]!
        *pdest++ = *psrc++;
        len++;
300014f8:	e2844001 	add	r4, r4, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300014fc:	e3530000 	cmp	r3, #0
        *pdest++ = *psrc++;
        len++;
30001500:	e20440ff 	and	r4, r4, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001504:	1afffff9 	bne	300014f0 <OSTaskNameGet+0x98>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30001508:	e3a07000 	mov	r7, #0
3000150c:	e5c67000 	strb	r7, [r6]
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *err = OS_TASK_NOT_EXIST;
        return (0);
    }
    len  = OS_StrCopy(pname, ptcb->OSTCBTaskName);       /* Yes, copy name from TCB                    */
    OS_EXIT_CRITICAL();
30001510:	ebfffb5d 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30001514:	e5c57000 	strb	r7, [r5]
    return (len);
30001518:	eaffffdb 	b	3000148c <OSTaskNameGet+0x34>
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
        prio = OSTCBCur->OSTCBPrio;
    }
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
        OS_EXIT_CRITICAL();                              /* No                                         */
3000151c:	ebfffb5a 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TASK_NOT_EXIST;
30001520:	e3a0300b 	mov	r3, #11
30001524:	e5c53000 	strb	r3, [r5]
        return (0);
30001528:	eaffffd7 	b	3000148c <OSTaskNameGet+0x34>
    }
    if (ptcb == (OS_TCB *)1) {                           /* Task assigned to a Mutex?                  */
        OS_EXIT_CRITICAL();                              /* Yes                                        */
3000152c:	ebfffb56 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TASK_NOT_EXIST;
30001530:	e3a0300b 	mov	r3, #11
30001534:	e5c53000 	strb	r3, [r5]
30001538:	e3a04000 	mov	r4, #0
        return (0);
3000153c:	eaffffd2 	b	3000148c <OSTaskNameGet+0x34>
30001540:	3001d098 	mulcc	r1, r8, r0
30001544:	3001dba8 	andcc	sp, r1, r8, lsr #23

30001548 <OSTaskDelReq>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
30001548:	e350003f 	cmp	r0, #63	; 0x3f
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
3000154c:	e92d4010 	push	{r4, lr}
30001550:	e1a04000 	mov	r4, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
30001554:	03a0403d 	moveq	r4, #61	; 0x3d
30001558:	0a000004 	beq	30001570 <OSTaskDelReq+0x28>
        return (OS_TASK_DEL_IDLE);
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
3000155c:	e354003e 	cmp	r4, #62	; 0x3e
30001560:	9a000005 	bls	3000157c <OSTaskDelReq+0x34>
        if (prio != OS_PRIO_SELF) {
30001564:	e35400ff 	cmp	r4, #255	; 0xff
30001568:	13a0402a 	movne	r4, #42	; 0x2a
3000156c:	0a00000e 	beq	300015ac <OSTaskDelReq+0x64>
        return (OS_TASK_DEL_ERR);
    }
    ptcb->OSTCBDelReq = OS_TASK_DEL_REQ;                        /* Set flag indicating task to be DEL. */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30001570:	e1a00004 	mov	r0, r4
30001574:	e8bd4010 	pop	{r4, lr}
30001578:	e12fff1e 	bx	lr
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
        OS_EXIT_CRITICAL();
        return (stat);
    }
    OS_ENTER_CRITICAL();
3000157c:	ebfffb3a 	bl	3000026c <OS_CPU_SR_Save>
    ptcb = OSTCBPrioTbl[prio];
30001580:	e59f3054 	ldr	r3, [pc, #84]	; 300015dc <OSTaskDelReq+0x94>
30001584:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
30001588:	e3530000 	cmp	r3, #0
3000158c:	0a00000f 	beq	300015d0 <OSTaskDelReq+0x88>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);                             /* Task must already be deleted        */
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Must NOT be assigned to a Mutex     */
30001590:	e3530001 	cmp	r3, #1
30001594:	0a00000a 	beq	300015c4 <OSTaskDelReq+0x7c>
        OS_EXIT_CRITICAL();
        return (OS_TASK_DEL_ERR);
    }
    ptcb->OSTCBDelReq = OS_TASK_DEL_REQ;                        /* Set flag indicating task to be DEL. */
30001598:	e3a0203e 	mov	r2, #62	; 0x3e
3000159c:	e5c32033 	strb	r2, [r3, #51]	; 0x33
    OS_EXIT_CRITICAL();
300015a0:	ebfffb39 	bl	3000028c <OS_CPU_SR_Restore>
300015a4:	e3a04000 	mov	r4, #0
    return (OS_NO_ERR);
300015a8:	eafffff0 	b	30001570 <OSTaskDelReq+0x28>
            return (OS_PRIO_INVALID);
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
300015ac:	ebfffb2e 	bl	3000026c <OS_CPU_SR_Save>
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
300015b0:	e59f3028 	ldr	r3, [pc, #40]	; 300015e0 <OSTaskDelReq+0x98>
300015b4:	e5933000 	ldr	r3, [r3]
300015b8:	e5d34033 	ldrb	r4, [r3, #51]	; 0x33
        OS_EXIT_CRITICAL();
300015bc:	ebfffb32 	bl	3000028c <OS_CPU_SR_Restore>
        return (stat);
300015c0:	eaffffea 	b	30001570 <OSTaskDelReq+0x28>
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);                             /* Task must already be deleted        */
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Must NOT be assigned to a Mutex     */
        OS_EXIT_CRITICAL();
300015c4:	ebfffb30 	bl	3000028c <OS_CPU_SR_Restore>
300015c8:	e3a0403c 	mov	r4, #60	; 0x3c
        return (OS_TASK_DEL_ERR);
300015cc:	eaffffe7 	b	30001570 <OSTaskDelReq+0x28>
        return (stat);
    }
    OS_ENTER_CRITICAL();
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
        OS_EXIT_CRITICAL();
300015d0:	ebfffb2d 	bl	3000028c <OS_CPU_SR_Restore>
300015d4:	e3a0400b 	mov	r4, #11
        return (OS_TASK_NOT_EXIST);                             /* Task must already be deleted        */
300015d8:	eaffffe4 	b	30001570 <OSTaskDelReq+0x28>
300015dc:	3001dba8 	andcc	sp, r1, r8, lsr #23
300015e0:	3001d098 	mulcc	r1, r8, r0

300015e4 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *err)
{
300015e4:	e92d4030 	push	{r4, r5, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
300015e8:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *err)
{
300015ec:	e24dd00c 	sub	sp, sp, #12
300015f0:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
300015f4:	0a000008 	beq	3000161c <OSSemSet+0x38>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300015f8:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
300015fc:	03a03004 	moveq	r3, #4
30001600:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30001604:	0a000004 	beq	3000161c <OSSemSet+0x38>
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
30001608:	e5d03000 	ldrb	r3, [r0]
3000160c:	e3530003 	cmp	r3, #3
        *err = OS_ERR_EVENT_TYPE;
30001610:	13a03001 	movne	r3, #1
30001614:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
30001618:	0a000002 	beq	30001628 <OSSemSet+0x44>
        } else {
            *err               = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
3000161c:	e28dd00c 	add	sp, sp, #12
30001620:	e8bd4030 	pop	{r4, r5, lr}
30001624:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        *err = OS_ERR_EVENT_TYPE;
        return;
    }
    OS_ENTER_CRITICAL();
30001628:	e58d1004 	str	r1, [sp, #4]
3000162c:	ebfffb0e 	bl	3000026c <OS_CPU_SR_Save>
    *err = OS_NO_ERR;
30001630:	e3a03000 	mov	r3, #0
30001634:	e5c53000 	strb	r3, [r5]
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
30001638:	e1d430b8 	ldrh	r3, [r4, #8]
3000163c:	e59d1004 	ldr	r1, [sp, #4]
30001640:	e3530000 	cmp	r3, #0
30001644:	1a000004 	bne	3000165c <OSSemSet+0x78>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
30001648:	e5d4300a 	ldrb	r3, [r4, #10]
3000164c:	e3530000 	cmp	r3, #0
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
        } else {
            *err               = OS_ERR_TASK_WAITING;
30001650:	13a03008 	movne	r3, #8
30001654:	15c53000 	strbne	r3, [r5]
    OS_ENTER_CRITICAL();
    *err = OS_NO_ERR;
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
30001658:	1a000000 	bne	30001660 <OSSemSet+0x7c>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
3000165c:	e1c410b8 	strh	r1, [r4, #8]
        } else {
            *err               = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
30001660:	ebfffb09 	bl	3000028c <OS_CPU_SR_Restore>
30001664:	eaffffec 	b	3000161c <OSSemSet+0x38>

30001668 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
30001668:	e92d4010 	push	{r4, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
3000166c:	e2504000 	subs	r4, r0, #0
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
30001670:	e24dd008 	sub	sp, sp, #8
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30001674:	03a00004 	moveq	r0, #4
30001678:	0a000006 	beq	30001698 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
3000167c:	e3510000 	cmp	r1, #0
30001680:	03a00009 	moveq	r0, #9
30001684:	0a000003 	beq	30001698 <OSSemQuery+0x30>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
30001688:	e5d43000 	ldrb	r3, [r4]
3000168c:	e3530003 	cmp	r3, #3
30001690:	13a00001 	movne	r0, #1
30001694:	0a000002 	beq	300016a4 <OSSemQuery+0x3c>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30001698:	e28dd008 	add	sp, sp, #8
3000169c:	e8bd4010 	pop	{r4, lr}
300016a0:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
300016a4:	e58d1004 	str	r1, [sp, #4]
300016a8:	ebfffaef 	bl	3000026c <OS_CPU_SR_Save>
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
300016ac:	e5d4300a 	ldrb	r3, [r4, #10]
300016b0:	e59d1004 	ldr	r1, [sp, #4]
    psrc                   = &pevent->OSEventTbl[0];
300016b4:	e284e00b 	add	lr, r4, #11
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
300016b8:	e5c1300a 	strb	r3, [r1, #10]
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
300016bc:	e281c002 	add	ip, r1, #2
300016c0:	e3a03000 	mov	r3, #0
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
300016c4:	e7de2003 	ldrb	r2, [lr, r3]
300016c8:	e7cc2003 	strb	r2, [ip, r3]
300016cc:	e2833001 	add	r3, r3, #1
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
300016d0:	e3530008 	cmp	r3, #8
300016d4:	1afffffa 	bne	300016c4 <OSSemQuery+0x5c>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
300016d8:	e1d440b8 	ldrh	r4, [r4, #8]
300016dc:	e1c140b0 	strh	r4, [r1]
    OS_EXIT_CRITICAL();
300016e0:	ebfffae9 	bl	3000028c <OS_CPU_SR_Restore>
300016e4:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
300016e8:	eaffffea 	b	30001698 <OSSemQuery+0x30>

300016ec <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
300016ec:	e92d4070 	push	{r4, r5, r6, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300016f0:	e59f3084 	ldr	r3, [pc, #132]	; 3000177c <OSSemCreate+0x90>
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
300016f4:	e1a06000 	mov	r6, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300016f8:	e5d35000 	ldrb	r5, [r3]
300016fc:	e3550000 	cmp	r5, #0
30001700:	13a04000 	movne	r4, #0
30001704:	0a000002 	beq	30001714 <OSSemCreate+0x28>
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
    }
    return (pevent);
}
30001708:	e1a00004 	mov	r0, r4
3000170c:	e8bd4070 	pop	{r4, r5, r6, lr}
30001710:	e12fff1e 	bx	lr


    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    }
    OS_ENTER_CRITICAL();
30001714:	ebfffad4 	bl	3000026c <OS_CPU_SR_Save>
    pevent = OSEventFreeList;                              /* Get next free event control block        */
30001718:	e59f3060 	ldr	r3, [pc, #96]	; 30001780 <OSSemCreate+0x94>
3000171c:	e5934000 	ldr	r4, [r3]
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
30001720:	e3540000 	cmp	r4, #0
30001724:	0a000012 	beq	30001774 <OSSemCreate+0x88>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
30001728:	e5942004 	ldr	r2, [r4, #4]
3000172c:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
30001730:	ebfffad5 	bl	3000028c <OS_CPU_SR_Restore>
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
30001734:	e3a02003 	mov	r2, #3
30001738:	e5c42000 	strb	r2, [r4]
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
3000173c:	e3a0203f 	mov	r2, #63	; 0x3f
30001740:	e5c42013 	strb	r2, [r4, #19]
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];
30001744:	e1a03005 	mov	r3, r5
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
30001748:	e1c460b8 	strh	r6, [r4, #8]
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
3000174c:	e5845004 	str	r5, [r4, #4]
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
        pevent->OSEventName[1] = OS_ASCII_NUL;
30001750:	e5c45014 	strb	r5, [r4, #20]
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
30001754:	e5c4500a 	strb	r5, [r4, #10]
    ptbl               = &pevent->OSEventTbl[0];
30001758:	e284100b 	add	r1, r4, #11

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0;
3000175c:	e1a02005 	mov	r2, r5
30001760:	e7c12003 	strb	r2, [r1, r3]
30001764:	e2833001 	add	r3, r3, #1


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30001768:	e3530008 	cmp	r3, #8
3000176c:	1afffffb 	bne	30001760 <OSSemCreate+0x74>
30001770:	eaffffe4 	b	30001708 <OSSemCreate+0x1c>
    OS_ENTER_CRITICAL();
    pevent = OSEventFreeList;                              /* Get next free event control block        */
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
30001774:	ebfffac4 	bl	3000028c <OS_CPU_SR_Restore>
30001778:	eaffffe2 	b	30001708 <OSSemCreate+0x1c>
3000177c:	3001d094 	mulcc	r1, r4, r0
30001780:	3001d090 	mulcc	r1, r0, r0

30001784 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
30001784:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30001788:	e2505000 	subs	r5, r0, #0
3000178c:	0a000002 	beq	3000179c <OSSemAccept+0x18>
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
30001790:	e5d53000 	ldrb	r3, [r5]
30001794:	e3530003 	cmp	r3, #3
30001798:	0a000003 	beq	300017ac <OSSemAccept+0x28>
    cnt = pevent->OSEventCnt;
    if (cnt > 0) {                                    /* See if resource is available                  */
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
3000179c:	e3a04000 	mov	r4, #0
}
300017a0:	e1a00004 	mov	r0, r4
300017a4:	e8bd4070 	pop	{r4, r5, r6, lr}
300017a8:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        return (0);
    }
    OS_ENTER_CRITICAL();
300017ac:	ebfffaae 	bl	3000026c <OS_CPU_SR_Save>
    cnt = pevent->OSEventCnt;
300017b0:	e1d540b8 	ldrh	r4, [r5, #8]
    if (cnt > 0) {                                    /* See if resource is available                  */
300017b4:	e3540000 	cmp	r4, #0
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
300017b8:	12443001 	subne	r3, r4, #1
300017bc:	11c530b8 	strhne	r3, [r5, #8]
    }
    OS_EXIT_CRITICAL();
300017c0:	ebfffab1 	bl	3000028c <OS_CPU_SR_Restore>
    return (cnt);                                     /* Return semaphore count                        */
300017c4:	eafffff5 	b	300017a0 <OSSemAccept+0x1c>

300017c8 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
300017c8:	e92d4010 	push	{r4, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
300017cc:	e2504000 	subs	r4, r0, #0
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
300017d0:	e24dd008 	sub	sp, sp, #8
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
300017d4:	03a00004 	moveq	r0, #4
300017d8:	0a000006 	beq	300017f8 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
300017dc:	e3510000 	cmp	r1, #0
300017e0:	03a00009 	moveq	r0, #9
300017e4:	0a000003 	beq	300017f8 <OSQQuery+0x30>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
300017e8:	e5d43000 	ldrb	r3, [r4]
300017ec:	e3530002 	cmp	r3, #2
300017f0:	13a00001 	movne	r0, #1
300017f4:	0a000002 	beq	30001804 <OSQQuery+0x3c>
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
    p_q_data->OSQSize = pq->OSQSize;
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
300017f8:	e28dd008 	add	sp, sp, #8
300017fc:	e8bd4010 	pop	{r4, lr}
30001800:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30001804:	e58d1004 	str	r1, [sp, #4]
30001808:	ebfffa97 	bl	3000026c <OS_CPU_SR_Save>
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
3000180c:	e5d4300a 	ldrb	r3, [r4, #10]
30001810:	e59d1004 	ldr	r1, [sp, #4]
    psrc                 = &pevent->OSEventTbl[0];
30001814:	e284e00b 	add	lr, r4, #11
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
30001818:	e5c13010 	strb	r3, [r1, #16]
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
3000181c:	e281c008 	add	ip, r1, #8
30001820:	e3a03000 	mov	r3, #0
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
30001824:	e7de2003 	ldrb	r2, [lr, r3]
30001828:	e7cc2003 	strb	r2, [ip, r3]
3000182c:	e2833001 	add	r3, r3, #1
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30001830:	e3530008 	cmp	r3, #8
30001834:	1afffffa 	bne	30001824 <OSQQuery+0x5c>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
30001838:	e5943004 	ldr	r3, [r4, #4]
    if (pq->OSQEntries > 0) {
3000183c:	e1d321b6 	ldrh	r2, [r3, #22]
30001840:	e3520000 	cmp	r2, #0
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
30001844:	1593c010 	ldrne	ip, [r3, #16]
    } else {
        p_q_data->OSMsg = (void *)0;
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
30001848:	e1c120b4 	strh	r2, [r1, #4]
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
    if (pq->OSQEntries > 0) {
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
3000184c:	159cc000 	ldrne	ip, [ip]
    } else {
        p_q_data->OSMsg = (void *)0;
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
    p_q_data->OSQSize = pq->OSQSize;
30001850:	e1d331b4 	ldrh	r3, [r3, #20]
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
    if (pq->OSQEntries > 0) {
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
30001854:	1581c000 	strne	ip, [r1]
    } else {
        p_q_data->OSMsg = (void *)0;
30001858:	05812000 	streq	r2, [r1]
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
    p_q_data->OSQSize = pq->OSQSize;
3000185c:	e1c130b6 	strh	r3, [r1, #6]
    OS_EXIT_CRITICAL();
30001860:	ebfffa89 	bl	3000028c <OS_CPU_SR_Restore>
30001864:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30001868:	eaffffe2 	b	300017f8 <OSQQuery+0x30>

3000186c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
3000186c:	e92d4010 	push	{r4, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30001870:	e2504000 	subs	r4, r0, #0
30001874:	03a00004 	moveq	r0, #4
30001878:	0a000003 	beq	3000188c <OSQFlush+0x20>
        return (OS_ERR_PEVENT_NULL);
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
3000187c:	e5d43000 	ldrb	r3, [r4]
30001880:	e3530002 	cmp	r3, #2
30001884:	13a00001 	movne	r0, #1
30001888:	0a000001 	beq	30001894 <OSQFlush+0x28>
    pq->OSQIn      = pq->OSQStart;
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0;
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
3000188c:	e8bd4010 	pop	{r4, lr}
30001890:	e12fff1e 	bx	lr
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
30001894:	ebfffa74 	bl	3000026c <OS_CPU_SR_Save>
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
30001898:	e5943004 	ldr	r3, [r4, #4]
    pq->OSQIn      = pq->OSQStart;
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0;
3000189c:	e3a01000 	mov	r1, #0
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    pq->OSQIn      = pq->OSQStart;
300018a0:	e5932004 	ldr	r2, [r3, #4]
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0;
300018a4:	e1c311b6 	strh	r1, [r3, #22]
    }
#endif
    OS_ENTER_CRITICAL();
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    pq->OSQIn      = pq->OSQStart;
    pq->OSQOut     = pq->OSQStart;
300018a8:	e5832010 	str	r2, [r3, #16]
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    pq->OSQIn      = pq->OSQStart;
300018ac:	e583200c 	str	r2, [r3, #12]
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0;
    OS_EXIT_CRITICAL();
300018b0:	ebfffa75 	bl	3000028c <OS_CPU_SR_Restore>
300018b4:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
300018b8:	eafffff3 	b	3000188c <OSQFlush+0x20>

300018bc <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
300018bc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
300018c0:	e59f30dc 	ldr	r3, [pc, #220]	; 300019a4 <OSQCreate+0xe8>
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
300018c4:	e1a05000 	mov	r5, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
300018c8:	e5d34000 	ldrb	r4, [r3]
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
300018cc:	e1a08001 	mov	r8, r1
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
300018d0:	e3540000 	cmp	r4, #0
300018d4:	13a06000 	movne	r6, #0
300018d8:	0a000002 	beq	300018e8 <OSQCreate+0x2c>
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
        }
    }
    return (pevent);
}
300018dc:	e1a00006 	mov	r0, r6
300018e0:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
300018e4:	e12fff1e 	bx	lr

    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    }
    OS_ENTER_CRITICAL();
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
300018e8:	e59fa0b8 	ldr	sl, [pc, #184]	; 300019a8 <OSQCreate+0xec>


    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    }
    OS_ENTER_CRITICAL();
300018ec:	ebfffa5e 	bl	3000026c <OS_CPU_SR_Save>
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
300018f0:	e59a6000 	ldr	r6, [sl]
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
300018f4:	e3560000 	cmp	r6, #0
300018f8:	0a000021 	beq	30001984 <OSQCreate+0xc8>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
300018fc:	e5963004 	ldr	r3, [r6, #4]
30001900:	e58a3000 	str	r3, [sl]
    }
    OS_EXIT_CRITICAL();
30001904:	ebfffa60 	bl	3000028c <OS_CPU_SR_Restore>
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
        OS_ENTER_CRITICAL();
30001908:	ebfffa57 	bl	3000026c <OS_CPU_SR_Save>
        pq = OSQFreeList;                        /* Get a free queue control block                     */
3000190c:	e59f3098 	ldr	r3, [pc, #152]	; 300019ac <OSQCreate+0xf0>
30001910:	e5937000 	ldr	r7, [r3]
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
30001914:	e3570000 	cmp	r7, #0
30001918:	0a00001b 	beq	3000198c <OSQCreate+0xd0>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
3000191c:	e5972000 	ldr	r2, [r7]
30001920:	e5832000 	str	r2, [r3]
            OS_EXIT_CRITICAL();
30001924:	ebfffa58 	bl	3000028c <OS_CPU_SR_Restore>
            pq->OSQStart           = start;               /*      Initialize the queue                 */
            pq->OSQEnd             = &start[size];
30001928:	e0851108 	add	r1, r5, r8, lsl #2
3000192c:	e5871008 	str	r1, [r7, #8]
            pq->OSQIn              = start;
            pq->OSQOut             = start;
            pq->OSQSize            = size;
            pq->OSQEntries         = 0;
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
30001930:	e3a01002 	mov	r1, #2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
            pq->OSQEnd             = &start[size];
            pq->OSQIn              = start;
            pq->OSQOut             = start;
            pq->OSQSize            = size;
30001934:	e1c781b4 	strh	r8, [r7, #20]
            pq->OSQEntries         = 0;
30001938:	e1c741b6 	strh	r4, [r7, #22]
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
            pq->OSQEnd             = &start[size];
            pq->OSQIn              = start;
            pq->OSQOut             = start;
3000193c:	e5875010 	str	r5, [r7, #16]
        OS_ENTER_CRITICAL();
        pq = OSQFreeList;                        /* Get a free queue control block                     */
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
30001940:	e5875004 	str	r5, [r7, #4]
            pq->OSQEnd             = &start[size];
            pq->OSQIn              = start;
30001944:	e587500c 	str	r5, [r7, #12]
            pq->OSQOut             = start;
            pq->OSQSize            = size;
            pq->OSQEntries         = 0;
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
30001948:	e5c61000 	strb	r1, [r6]
            pevent->OSEventCnt     = 0;
            pevent->OSEventPtr     = pq;
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
3000194c:	e3a0103f 	mov	r1, #63	; 0x3f
30001950:	e5c61013 	strb	r1, [r6, #19]
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];
30001954:	e1a03004 	mov	r3, r4
            pq->OSQOut             = start;
            pq->OSQSize            = size;
            pq->OSQEntries         = 0;
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
            pevent->OSEventCnt     = 0;
            pevent->OSEventPtr     = pq;
30001958:	e5867004 	str	r7, [r6, #4]
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
3000195c:	e5c6400a 	strb	r4, [r6, #10]
            pq->OSQIn              = start;
            pq->OSQOut             = start;
            pq->OSQSize            = size;
            pq->OSQEntries         = 0;
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
            pevent->OSEventCnt     = 0;
30001960:	e1c640b8 	strh	r4, [r6, #8]
            pevent->OSEventPtr     = pq;
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
30001964:	e5c64014 	strb	r4, [r6, #20]
    ptbl               = &pevent->OSEventTbl[0];
30001968:	e286100b 	add	r1, r6, #11

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0;
3000196c:	e1a02004 	mov	r2, r4
30001970:	e7c12003 	strb	r2, [r1, r3]
30001974:	e2833001 	add	r3, r3, #1


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30001978:	e3530008 	cmp	r3, #8
3000197c:	1afffffb 	bne	30001970 <OSQCreate+0xb4>
30001980:	eaffffd5 	b	300018dc <OSQCreate+0x20>
    OS_ENTER_CRITICAL();
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
30001984:	ebfffa40 	bl	3000028c <OS_CPU_SR_Restore>
30001988:	eaffffd3 	b	300018dc <OSQCreate+0x20>
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
3000198c:	e59a3000 	ldr	r3, [sl]
            OSEventFreeList    = pevent;
30001990:	e58a6000 	str	r6, [sl]
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
30001994:	e5863004 	str	r3, [r6, #4]
            OSEventFreeList    = pevent;
            OS_EXIT_CRITICAL();
30001998:	ebfffa3b 	bl	3000028c <OS_CPU_SR_Restore>
3000199c:	e1a06007 	mov	r6, r7
300019a0:	eaffffcd 	b	300018dc <OSQCreate+0x20>
300019a4:	3001d094 	mulcc	r1, r4, r0
300019a8:	3001d090 	mulcc	r1, r0, r0
300019ac:	3001ce80 	andcc	ip, r1, r0, lsl #29

300019b0 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
300019b0:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
300019b4:	e2515000 	subs	r5, r1, #0
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
300019b8:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
300019bc:	01a04005 	moveq	r4, r5
300019c0:	0a000012 	beq	30001a10 <OSQAccept+0x60>
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
300019c4:	e3540000 	cmp	r4, #0
        *err = OS_ERR_PEVENT_NULL;
300019c8:	03a03004 	moveq	r3, #4
300019cc:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
300019d0:	0a00000e 	beq	30001a10 <OSQAccept+0x60>
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
300019d4:	e5d43000 	ldrb	r3, [r4]
300019d8:	e3530002 	cmp	r3, #2
        *err = OS_ERR_EVENT_TYPE;
300019dc:	13a03001 	movne	r3, #1
300019e0:	15c53000 	strbne	r3, [r5]
300019e4:	13a04000 	movne	r4, #0
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
300019e8:	1a000008 	bne	30001a10 <OSQAccept+0x60>
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
300019ec:	ebfffa1e 	bl	3000026c <OS_CPU_SR_Save>
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
300019f0:	e5943004 	ldr	r3, [r4, #4]
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
300019f4:	e1d321b6 	ldrh	r2, [r3, #22]
300019f8:	e3520000 	cmp	r2, #0
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
            pq->OSQOut = pq->OSQStart;
        }
        *err = OS_NO_ERR;
    } else {
        *err = OS_Q_EMPTY;
300019fc:	03a0301f 	moveq	r3, #31
30001a00:	05c53000 	strbeq	r3, [r5]
30001a04:	01a04002 	moveq	r4, r2
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
30001a08:	1a000003 	bne	30001a1c <OSQAccept+0x6c>
        *err = OS_NO_ERR;
    } else {
        *err = OS_Q_EMPTY;
        msg  = (void *)0;                        /* Queue is empty                                     */
    }
    OS_EXIT_CRITICAL();
30001a0c:	ebfffa1e 	bl	3000028c <OS_CPU_SR_Restore>
    return (msg);                                /* Return message received (or NULL)                  */
}
30001a10:	e1a00004 	mov	r0, r4
30001a14:	e8bd4070 	pop	{r4, r5, r6, lr}
30001a18:	e12fff1e 	bx	lr
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
30001a1c:	e5931010 	ldr	r1, [r3, #16]
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
30001a20:	e593c008 	ldr	ip, [r3, #8]
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
30001a24:	e4914004 	ldr	r4, [r1], #4
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
30001a28:	e2422001 	sub	r2, r2, #1
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
30001a2c:	e151000c 	cmp	r1, ip
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
30001a30:	e1c321b6 	strh	r2, [r3, #22]
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
            pq->OSQOut = pq->OSQStart;
30001a34:	05932004 	ldreq	r2, [r3, #4]
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
30001a38:	e5831010 	str	r1, [r3, #16]
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
            pq->OSQOut = pq->OSQStart;
30001a3c:	05832010 	streq	r2, [r3, #16]
        }
        *err = OS_NO_ERR;
30001a40:	e3a03000 	mov	r3, #0
30001a44:	e5c53000 	strb	r3, [r5]
30001a48:	eaffffef 	b	30001a0c <OSQAccept+0x5c>

30001a4c <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
30001a4c:	e92d4030 	push	{r4, r5, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30001a50:	e59f30a8 	ldr	r3, [pc, #168]	; 30001b00 <OSMutexQuery+0xb4>
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
30001a54:	e1a04000 	mov	r4, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30001a58:	e5d35000 	ldrb	r5, [r3]
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
30001a5c:	e24dd00c 	sub	sp, sp, #12
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30001a60:	e3550000 	cmp	r5, #0
30001a64:	13a00006 	movne	r0, #6
30001a68:	1a000009 	bne	30001a94 <OSMutexQuery+0x48>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30001a6c:	e3540000 	cmp	r4, #0
30001a70:	03a00004 	moveq	r0, #4
30001a74:	0a000006 	beq	30001a94 <OSMutexQuery+0x48>
        return (OS_ERR_PEVENT_NULL);
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
30001a78:	e3510000 	cmp	r1, #0
30001a7c:	03a00009 	moveq	r0, #9
30001a80:	0a000003 	beq	30001a94 <OSMutexQuery+0x48>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
30001a84:	e5d43000 	ldrb	r3, [r4]
30001a88:	e3530004 	cmp	r3, #4
30001a8c:	13a00001 	movne	r0, #1
30001a90:	0a000002 	beq	30001aa0 <OSMutexQuery+0x54>
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30001a94:	e28dd00c 	add	sp, sp, #12
30001a98:	e8bd4030 	pop	{r4, r5, lr}
30001a9c:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30001aa0:	e58d1004 	str	r1, [sp, #4]
30001aa4:	ebfff9f0 	bl	3000026c <OS_CPU_SR_Save>
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
30001aa8:	e1d430b8 	ldrh	r3, [r4, #8]
30001aac:	e59d1004 	ldr	r1, [sp, #4]
30001ab0:	e1a03423 	lsr	r3, r3, #8
30001ab4:	e5c1300b 	strb	r3, [r1, #11]
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
30001ab8:	e5d43008 	ldrb	r3, [r4, #8]
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
30001abc:	e35300ff 	cmp	r3, #255	; 0xff
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
30001ac0:	e5c1300a 	strb	r3, [r1, #10]
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
        p_mutex_data->OSValue = 1;
30001ac4:	03a03001 	moveq	r3, #1
30001ac8:	05c13009 	strbeq	r3, [r1, #9]
    } else {
        p_mutex_data->OSValue = 0;
30001acc:	15c15009 	strbne	r5, [r1, #9]
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
30001ad0:	e5d4300a 	ldrb	r3, [r4, #10]
    psrc                      = &pevent->OSEventTbl[0];
30001ad4:	e284400b 	add	r4, r4, #11
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
        p_mutex_data->OSValue = 1;
    } else {
        p_mutex_data->OSValue = 0;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
30001ad8:	e5c13008 	strb	r3, [r1, #8]
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
30001adc:	e3a03000 	mov	r3, #0
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
30001ae0:	e7d42003 	ldrb	r2, [r4, r3]
30001ae4:	e7c12003 	strb	r2, [r1, r3]
30001ae8:	e2833001 	add	r3, r3, #1
        p_mutex_data->OSValue = 0;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30001aec:	e3530008 	cmp	r3, #8
30001af0:	1afffffa 	bne	30001ae0 <OSMutexQuery+0x94>
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
30001af4:	ebfff9e4 	bl	3000028c <OS_CPU_SR_Restore>
30001af8:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30001afc:	eaffffe4 	b	30001a94 <OSMutexQuery+0x48>
30001b00:	3001d094 	mulcc	r1, r4, r0

30001b04 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *err)
{
30001b04:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30001b08:	e2517000 	subs	r7, r1, #0
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *err)
{
30001b0c:	e1a05000 	mov	r5, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30001b10:	01a04007 	moveq	r4, r7
30001b14:	0a00002c 	beq	30001bcc <OSMutexCreate+0xc8>
        return ((OS_EVENT *)0);
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
30001b18:	e350003e 	cmp	r0, #62	; 0x3e
        *err = OS_PRIO_INVALID;
30001b1c:	83a0302a 	movhi	r3, #42	; 0x2a
30001b20:	85c73000 	strbhi	r3, [r7]
30001b24:	83a04000 	movhi	r4, #0

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return ((OS_EVENT *)0);
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
30001b28:	8a000027 	bhi	30001bcc <OSMutexCreate+0xc8>
        *err = OS_PRIO_INVALID;
        return ((OS_EVENT *)0);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30001b2c:	e59f30c8 	ldr	r3, [pc, #200]	; 30001bfc <OSMutexCreate+0xf8>
30001b30:	e5d34000 	ldrb	r4, [r3]
30001b34:	e3540000 	cmp	r4, #0
        *err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE mutex from an ISR       */
30001b38:	13e03072 	mvnne	r3, #114	; 0x72
30001b3c:	15c73000 	strbne	r3, [r7]
30001b40:	13a04000 	movne	r4, #0
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
        *err = OS_PRIO_INVALID;
        return ((OS_EVENT *)0);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30001b44:	1a000020 	bne	30001bcc <OSMutexCreate+0xc8>
        *err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE mutex from an ISR       */
        return ((OS_EVENT *)0);
    }
    OS_ENTER_CRITICAL();
30001b48:	ebfff9c7 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
30001b4c:	e59f30ac 	ldr	r3, [pc, #172]	; 30001c00 <OSMutexCreate+0xfc>
30001b50:	e7936105 	ldr	r6, [r3, r5, lsl #2]
30001b54:	e3560000 	cmp	r6, #0
30001b58:	1a000023 	bne	30001bec <OSMutexCreate+0xe8>
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *err = OS_PRIO_EXIST;                              /* ... inheritance priority                 */
        return ((OS_EVENT *)0);
    }
    OSTCBPrioTbl[prio] = (OS_TCB *)1;                      /* Reserve the table entry                  */
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
30001b5c:	e59f20a0 	ldr	r2, [pc, #160]	; 30001c04 <OSMutexCreate+0x100>
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *err = OS_PRIO_EXIST;                              /* ... inheritance priority                 */
        return ((OS_EVENT *)0);
    }
    OSTCBPrioTbl[prio] = (OS_TCB *)1;                      /* Reserve the table entry                  */
30001b60:	e3a01001 	mov	r1, #1
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
30001b64:	e5924000 	ldr	r4, [r2]
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *err = OS_PRIO_EXIST;                              /* ... inheritance priority                 */
        return ((OS_EVENT *)0);
    }
    OSTCBPrioTbl[prio] = (OS_TCB *)1;                      /* Reserve the table entry                  */
30001b68:	e7831105 	str	r1, [r3, r5, lsl #2]
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
30001b6c:	e3540000 	cmp	r4, #0
30001b70:	0a000018 	beq	30001bd8 <OSMutexCreate+0xd4>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
        OS_EXIT_CRITICAL();
        *err               = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
        return (pevent);
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
30001b74:	e5943004 	ldr	r3, [r4, #4]
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
30001b78:	e1a05405 	lsl	r5, r5, #8
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
        OS_EXIT_CRITICAL();
        *err               = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
        return (pevent);
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
30001b7c:	e5823000 	str	r3, [r2]
    OS_EXIT_CRITICAL();
30001b80:	ebfff9c1 	bl	3000028c <OS_CPU_SR_Restore>
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
30001b84:	e3a02004 	mov	r2, #4
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
30001b88:	e38550ff 	orr	r5, r5, #255	; 0xff
        *err               = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
        return (pevent);
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
30001b8c:	e5c42000 	strb	r2, [r4]
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
30001b90:	e3a0203f 	mov	r2, #63	; 0x3f
30001b94:	e5c42013 	strb	r2, [r4, #19]
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];
30001b98:	e1a03006 	mov	r3, r6
        return (pevent);
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
30001b9c:	e1c450b8 	strh	r5, [r4, #8]
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
30001ba0:	e5846004 	str	r6, [r4, #4]
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
    pevent->OSEventName[1] = OS_ASCII_NUL;
30001ba4:	e5c46014 	strb	r6, [r4, #20]
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
30001ba8:	e5c4600a 	strb	r6, [r4, #10]
    ptbl               = &pevent->OSEventTbl[0];
30001bac:	e284100b 	add	r1, r4, #11

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0;
30001bb0:	e1a02006 	mov	r2, r6
30001bb4:	e7c12003 	strb	r2, [r1, r3]
30001bb8:	e2833001 	add	r3, r3, #1


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30001bbc:	e3530008 	cmp	r3, #8
30001bc0:	1afffffb 	bne	30001bb4 <OSMutexCreate+0xb0>
#endif
    OS_EventWaitListInit(pevent);
    *err                   = OS_NO_ERR;
30001bc4:	e3a03000 	mov	r3, #0
30001bc8:	e5c73000 	strb	r3, [r7]
    return (pevent);
}
30001bcc:	e1a00004 	mov	r0, r4
30001bd0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30001bd4:	e12fff1e 	bx	lr
        return ((OS_EVENT *)0);
    }
    OSTCBPrioTbl[prio] = (OS_TCB *)1;                      /* Reserve the table entry                  */
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
30001bd8:	e7834105 	str	r4, [r3, r5, lsl #2]
        OS_EXIT_CRITICAL();
30001bdc:	ebfff9aa 	bl	3000028c <OS_CPU_SR_Restore>
        *err               = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
30001be0:	e3a03004 	mov	r3, #4
30001be4:	e5c73000 	strb	r3, [r7]
        return (pevent);
30001be8:	eafffff7 	b	30001bcc <OSMutexCreate+0xc8>
        *err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE mutex from an ISR       */
        return ((OS_EVENT *)0);
    }
    OS_ENTER_CRITICAL();
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
30001bec:	ebfff9a6 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_PRIO_EXIST;                              /* ... inheritance priority                 */
30001bf0:	e3a03028 	mov	r3, #40	; 0x28
30001bf4:	e5c73000 	strb	r3, [r7]
        return ((OS_EVENT *)0);
30001bf8:	eafffff3 	b	30001bcc <OSMutexCreate+0xc8>
30001bfc:	3001d094 	mulcc	r1, r4, r0
30001c00:	3001dba8 	andcc	sp, r1, r8, lsr #23
30001c04:	3001d090 	mulcc	r1, r0, r0

30001c08 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
INT8U  OSMutexAccept (OS_EVENT *pevent, INT8U *err)
{
30001c08:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                           /* Validate 'err'                               */
30001c0c:	e2515000 	subs	r5, r1, #0
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
INT8U  OSMutexAccept (OS_EVENT *pevent, INT8U *err)
{
30001c10:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                           /* Validate 'err'                               */
30001c14:	01a00005 	moveq	r0, r5
30001c18:	0a00000a 	beq	30001c48 <OSMutexAccept+0x40>
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
30001c1c:	e3540000 	cmp	r4, #0
        *err = OS_ERR_PEVENT_NULL;
30001c20:	03a03004 	moveq	r3, #4
30001c24:	05c53000 	strbeq	r3, [r5]
30001c28:	01a00004 	moveq	r0, r4

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                           /* Validate 'err'                               */
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
30001c2c:	0a000005 	beq	30001c48 <OSMutexAccept+0x40>
        *err = OS_ERR_PEVENT_NULL;
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
30001c30:	e5d43000 	ldrb	r3, [r4]
30001c34:	e3530004 	cmp	r3, #4
        *err = OS_ERR_EVENT_TYPE;
30001c38:	13a03001 	movne	r3, #1
30001c3c:	15c53000 	strbne	r3, [r5]
30001c40:	13a00000 	movne	r0, #0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        *err = OS_ERR_PEVENT_NULL;
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
30001c44:	0a000001 	beq	30001c50 <OSMutexAccept+0x48>
        return (1);
    }
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
    return (0);
}
30001c48:	e8bd4070 	pop	{r4, r5, r6, lr}
30001c4c:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
        *err = OS_ERR_EVENT_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
30001c50:	e59f3088 	ldr	r3, [pc, #136]	; 30001ce0 <OSMutexAccept+0xd8>
30001c54:	e5d36000 	ldrb	r6, [r3]
30001c58:	e3560000 	cmp	r6, #0
        *err = OS_ERR_PEND_ISR;
30001c5c:	13a03002 	movne	r3, #2
30001c60:	15c53000 	strbne	r3, [r5]
30001c64:	13a00000 	movne	r0, #0
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
        *err = OS_ERR_EVENT_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
30001c68:	1afffff6 	bne	30001c48 <OSMutexAccept+0x40>
        *err = OS_ERR_PEND_ISR;
        return (0);
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
30001c6c:	ebfff97e 	bl	3000026c <OS_CPU_SR_Save>
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
30001c70:	e1d430b8 	ldrh	r3, [r4, #8]
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
30001c74:	e20320ff 	and	r2, r3, #255	; 0xff
30001c78:	e35200ff 	cmp	r2, #255	; 0xff
30001c7c:	1a00000f 	bne	30001cc0 <OSMutexAccept+0xb8>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
30001c80:	e59f205c 	ldr	r2, [pc, #92]	; 30001ce4 <OSMutexAccept+0xdc>
        return (0);
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
30001c84:	e2031cff 	and	r1, r3, #65280	; 0xff00
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
30001c88:	e5922000 	ldr	r2, [r2]
        return (0);
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
30001c8c:	e1c410b8 	strh	r1, [r4, #8]
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
30001c90:	e5d2c02e 	ldrb	ip, [r2, #46]	; 0x2e
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
30001c94:	e5842004 	str	r2, [r4, #4]
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
30001c98:	e181100c 	orr	r1, r1, ip
30001c9c:	e1c410b8 	strh	r1, [r4, #8]
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
30001ca0:	e5d2202e 	ldrb	r2, [r2, #46]	; 0x2e
30001ca4:	e1520423 	cmp	r2, r3, lsr #8
30001ca8:	8a000008 	bhi	30001cd0 <OSMutexAccept+0xc8>
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
30001cac:	ebfff976 	bl	3000028c <OS_CPU_SR_Restore>
            *err  = OS_ERR_PIP_LOWER;
30001cb0:	e3e0305f 	mvn	r3, #95	; 0x5f
30001cb4:	e5c53000 	strb	r3, [r5]
30001cb8:	e3a00001 	mov	r0, #1
30001cbc:	eaffffe1 	b	30001c48 <OSMutexAccept+0x40>
            OS_EXIT_CRITICAL();
            *err  = OS_NO_ERR;
        }
        return (1);
    }
    OS_EXIT_CRITICAL();
30001cc0:	ebfff971 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30001cc4:	e5c56000 	strb	r6, [r5]
30001cc8:	e1a00006 	mov	r0, r6
    return (0);
30001ccc:	eaffffdd 	b	30001c48 <OSMutexAccept+0x40>
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *err  = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
30001cd0:	ebfff96d 	bl	3000028c <OS_CPU_SR_Restore>
            *err  = OS_NO_ERR;
30001cd4:	e5c56000 	strb	r6, [r5]
30001cd8:	e3a00001 	mov	r0, #1
30001cdc:	eaffffd9 	b	30001c48 <OSMutexAccept+0x40>
30001ce0:	3001d094 	mulcc	r1, r4, r0
30001ce4:	3001d098 	mulcc	r1, r8, r0

30001ce8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
30001ce8:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
30001cec:	e2504000 	subs	r4, r0, #0
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
30001cf0:	e1a05001 	mov	r5, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
30001cf4:	03a00074 	moveq	r0, #116	; 0x74
30001cf8:	0a000013 	beq	30001d4c <OSMemQuery+0x64>
        return (OS_MEM_INVALID_PMEM);
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
30001cfc:	e3510000 	cmp	r1, #0
30001d00:	03a00075 	moveq	r0, #117	; 0x75
30001d04:	0a000010 	beq	30001d4c <OSMemQuery+0x64>
        return (OS_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
30001d08:	ebfff957 	bl	3000026c <OS_CPU_SR_Save>
    p_mem_data->OSAddr     = pmem->OSMemAddr;
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
30001d0c:	e5943008 	ldr	r3, [r4, #8]
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
        return (OS_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
30001d10:	e5942000 	ldr	r2, [r4]
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
30001d14:	e5853008 	str	r3, [r5, #8]
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
30001d18:	e594300c 	ldr	r3, [r4, #12]
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
        return (OS_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
30001d1c:	e5852000 	str	r2, [r5]
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
30001d20:	e585300c 	str	r3, [r5, #12]
    p_mem_data->OSNFree    = pmem->OSMemNFree;
30001d24:	e5942010 	ldr	r2, [r4, #16]
        return (OS_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
30001d28:	e5943004 	ldr	r3, [r4, #4]
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
    p_mem_data->OSNFree    = pmem->OSMemNFree;
30001d2c:	e5852010 	str	r2, [r5, #16]
        return (OS_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
30001d30:	e5853004 	str	r3, [r5, #4]
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
    p_mem_data->OSNFree    = pmem->OSMemNFree;
    OS_EXIT_CRITICAL();
30001d34:	ebfff954 	bl	3000028c <OS_CPU_SR_Restore>
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
30001d38:	e595200c 	ldr	r2, [r5, #12]
30001d3c:	e5953010 	ldr	r3, [r5, #16]
30001d40:	e3a00000 	mov	r0, #0
30001d44:	e0633002 	rsb	r3, r3, r2
30001d48:	e5853014 	str	r3, [r5, #20]
    return (OS_NO_ERR);
}
30001d4c:	e8bd4070 	pop	{r4, r5, r6, lr}
30001d50:	e12fff1e 	bx	lr

30001d54 <OSMemPut>:
*               OS_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
30001d54:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
30001d58:	e2504000 	subs	r4, r0, #0
*               OS_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
30001d5c:	e1a05001 	mov	r5, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
30001d60:	03a00074 	moveq	r0, #116	; 0x74
30001d64:	0a000009 	beq	30001d90 <OSMemPut+0x3c>
        return (OS_MEM_INVALID_PMEM);
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
30001d68:	e3510000 	cmp	r1, #0
30001d6c:	03a00073 	moveq	r0, #115	; 0x73
30001d70:	0a000006 	beq	30001d90 <OSMemPut+0x3c>
        return (OS_MEM_INVALID_PBLK);
    }
#endif
    OS_ENTER_CRITICAL();
30001d74:	ebfff93c 	bl	3000026c <OS_CPU_SR_Save>
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
30001d78:	e5943010 	ldr	r3, [r4, #16]
30001d7c:	e594200c 	ldr	r2, [r4, #12]
30001d80:	e1530002 	cmp	r3, r2
30001d84:	3a000003 	bcc	30001d98 <OSMemPut+0x44>
        OS_EXIT_CRITICAL();
30001d88:	ebfff93f 	bl	3000028c <OS_CPU_SR_Restore>
30001d8c:	e3a00072 	mov	r0, #114	; 0x72
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);                          /* Notify caller that memory block was released       */
}
30001d90:	e8bd4070 	pop	{r4, r5, r6, lr}
30001d94:	e12fff1e 	bx	lr
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
        OS_EXIT_CRITICAL();
        return (OS_MEM_FULL);
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
30001d98:	e5942004 	ldr	r2, [r4, #4]
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
30001d9c:	e2833001 	add	r3, r3, #1
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
        OS_EXIT_CRITICAL();
        return (OS_MEM_FULL);
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
30001da0:	e5852000 	str	r2, [r5]
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
30001da4:	e5843010 	str	r3, [r4, #16]
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
        OS_EXIT_CRITICAL();
        return (OS_MEM_FULL);
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
    pmem->OSMemFreeList = pblk;
30001da8:	e5845004 	str	r5, [r4, #4]
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
    OS_EXIT_CRITICAL();
30001dac:	ebfff936 	bl	3000028c <OS_CPU_SR_Restore>
30001db0:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);                          /* Notify caller that memory block was released       */
30001db4:	eafffff5 	b	30001d90 <OSMemPut+0x3c>

30001db8 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *err)
{
30001db8:	e92d4070 	push	{r4, r5, r6, lr}
30001dbc:	e1a04002 	mov	r4, r2
30001dc0:	e1a05000 	mov	r5, r0
30001dc4:	e1a06001 	mov	r6, r1
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30001dc8:	ebfff927 	bl	3000026c <OS_CPU_SR_Save>
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30001dcc:	e3540000 	cmp	r4, #0
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30001dd0:	e1a03000 	mov	r3, r0
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30001dd4:	0a000022 	beq	30001e64 <OSMemNameSet+0xac>
        OS_EXIT_CRITICAL();
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
30001dd8:	e3550000 	cmp	r5, #0
30001ddc:	0a000022 	beq	30001e6c <OSMemNameSet+0xb4>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_MEM_INVALID_PMEM;
        return;
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
30001de0:	e3560000 	cmp	r6, #0
30001de4:	0a000024 	beq	30001e7c <OSMemNameSet+0xc4>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001de8:	e5d62000 	ldrb	r2, [r6]
30001dec:	e3520000 	cmp	r2, #0
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_ERR_PNAME_NULL;
        return;
30001df0:	11a00006 	movne	r0, r6
30001df4:	13a01000 	movne	r1, #0
30001df8:	0a000017 	beq	30001e5c <OSMemNameSet+0xa4>
30001dfc:	e5f0c001 	ldrb	ip, [r0, #1]!
        psrc++;
        len++;
30001e00:	e2811001 	add	r1, r1, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001e04:	e35c0000 	cmp	ip, #0
        psrc++;
        len++;
30001e08:	e20110ff 	and	r1, r1, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001e0c:	1afffffa 	bne	30001dfc <OSMemNameSet+0x44>
    }
#endif
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
30001e10:	e351000f 	cmp	r1, #15
        OS_EXIT_CRITICAL();
        *err = OS_MEM_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
30001e14:	92855014 	addls	r5, r5, #20
        *err = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
30001e18:	8a00000a 	bhi	30001e48 <OSMemNameSet+0x90>
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
        *pdest++ = *psrc++;
30001e1c:	e4c52001 	strb	r2, [r5], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001e20:	e5f62001 	ldrb	r2, [r6, #1]!
30001e24:	e3520000 	cmp	r2, #0
30001e28:	1afffffb 	bne	30001e1c <OSMemNameSet+0x64>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30001e2c:	e3a06000 	mov	r6, #0
30001e30:	e5c56000 	strb	r6, [r5]
        OS_EXIT_CRITICAL();
        *err = OS_MEM_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
30001e34:	e1a00003 	mov	r0, r3
30001e38:	ebfff913 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30001e3c:	e5c46000 	strb	r6, [r4]
}
30001e40:	e8bd4070 	pop	{r4, r5, r6, lr}
30001e44:	e12fff1e 	bx	lr
        return;
    }
#endif
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
        OS_EXIT_CRITICAL();
30001e48:	e1a00003 	mov	r0, r3
30001e4c:	ebfff90e 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_MEM_NAME_TOO_LONG;
30001e50:	e3a03077 	mov	r3, #119	; 0x77
30001e54:	e5c43000 	strb	r3, [r4]
        return;
30001e58:	eafffff8 	b	30001e40 <OSMemNameSet+0x88>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
30001e5c:	e2855014 	add	r5, r5, #20
30001e60:	eafffff1 	b	30001e2c <OSMemNameSet+0x74>


    OS_ENTER_CRITICAL();
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        OS_EXIT_CRITICAL();
30001e64:	ebfff908 	bl	3000028c <OS_CPU_SR_Restore>
        return;
30001e68:	eafffff4 	b	30001e40 <OSMemNameSet+0x88>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
30001e6c:	ebfff906 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_MEM_INVALID_PMEM;
30001e70:	e3a03074 	mov	r3, #116	; 0x74
30001e74:	e5c43000 	strb	r3, [r4]
        return;
30001e78:	eafffff0 	b	30001e40 <OSMemNameSet+0x88>
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
30001e7c:	ebfff902 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_PNAME_NULL;
30001e80:	e3a0300f 	mov	r3, #15
30001e84:	e5c43000 	strb	r3, [r4]
        return;
30001e88:	eaffffec 	b	30001e40 <OSMemNameSet+0x88>

30001e8c <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *err)
{
30001e8c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
30001e90:	e1a05002 	mov	r5, r2
30001e94:	e1a04000 	mov	r4, r0
30001e98:	e1a06001 	mov	r6, r1
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30001e9c:	ebfff8f2 	bl	3000026c <OS_CPU_SR_Save>
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30001ea0:	e3550000 	cmp	r5, #0
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30001ea4:	e1a03000 	mov	r3, r0
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30001ea8:	0a000017 	beq	30001f0c <OSMemNameGet+0x80>
        OS_EXIT_CRITICAL();
        return (0);
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
30001eac:	e3540000 	cmp	r4, #0
30001eb0:	0a000018 	beq	30001f18 <OSMemNameGet+0x8c>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_MEM_INVALID_PMEM;
        return (0);
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
30001eb4:	e3560000 	cmp	r6, #0
30001eb8:	0a00001a 	beq	30001f28 <OSMemNameGet+0x9c>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001ebc:	e5d42014 	ldrb	r2, [r4, #20]
30001ec0:	e3520000 	cmp	r2, #0
30001ec4:	01a04002 	moveq	r4, r2
30001ec8:	0a000007 	beq	30001eec <OSMemNameGet+0x60>
30001ecc:	e2841014 	add	r1, r4, #20
30001ed0:	e3a04000 	mov	r4, #0
        *pdest++ = *psrc++;
30001ed4:	e4c62001 	strb	r2, [r6], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001ed8:	e5f12001 	ldrb	r2, [r1, #1]!
        *pdest++ = *psrc++;
        len++;
30001edc:	e2844001 	add	r4, r4, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001ee0:	e3520000 	cmp	r2, #0
        *pdest++ = *psrc++;
        len++;
30001ee4:	e20440ff 	and	r4, r4, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30001ee8:	1afffff9 	bne	30001ed4 <OSMemNameGet+0x48>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30001eec:	e3a07000 	mov	r7, #0
30001ef0:	e5c67000 	strb	r7, [r6]
        *err = OS_ERR_PNAME_NULL;
        return (0);
    }
#endif
    len  = OS_StrCopy(pname, pmem->OSMemName);   /* Copy name from OS_MEM                              */
    OS_EXIT_CRITICAL();
30001ef4:	e1a00003 	mov	r0, r3
30001ef8:	ebfff8e3 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30001efc:	e5c57000 	strb	r7, [r5]
    return (len);
}
30001f00:	e1a00004 	mov	r0, r4
30001f04:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30001f08:	e12fff1e 	bx	lr


    OS_ENTER_CRITICAL();
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        OS_EXIT_CRITICAL();
30001f0c:	e1a04005 	mov	r4, r5
30001f10:	ebfff8dd 	bl	3000028c <OS_CPU_SR_Restore>
        return (0);
30001f14:	eafffff9 	b	30001f00 <OSMemNameGet+0x74>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
30001f18:	ebfff8db 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_MEM_INVALID_PMEM;
30001f1c:	e3a03074 	mov	r3, #116	; 0x74
30001f20:	e5c53000 	strb	r3, [r5]
        return (0);
30001f24:	eafffff5 	b	30001f00 <OSMemNameGet+0x74>
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
30001f28:	ebfff8d7 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_PNAME_NULL;
30001f2c:	e3a0300f 	mov	r3, #15
30001f30:	e5c53000 	strb	r3, [r5]
30001f34:	e1a04006 	mov	r4, r6
        return (0);
30001f38:	eafffff0 	b	30001f00 <OSMemNameGet+0x74>

30001f3c <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *err)
{
30001f3c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
30001f40:	e2517000 	subs	r7, r1, #0
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *err)
{
30001f44:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
30001f48:	01a05007 	moveq	r5, r7
30001f4c:	0a000010 	beq	30001f94 <OSMemGet+0x58>
        return ((void *)0);
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
30001f50:	e3500000 	cmp	r0, #0
        *err = OS_MEM_INVALID_PMEM;
30001f54:	03a03074 	moveq	r3, #116	; 0x74
30001f58:	05c73000 	strbeq	r3, [r7]
30001f5c:	01a05000 	moveq	r5, r0

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
        return ((void *)0);
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
30001f60:	0a00000b 	beq	30001f94 <OSMemGet+0x58>
        *err = OS_MEM_INVALID_PMEM;
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
30001f64:	ebfff8c0 	bl	3000026c <OS_CPU_SR_Save>
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
30001f68:	e5946010 	ldr	r6, [r4, #16]
30001f6c:	e3560000 	cmp	r6, #0
30001f70:	0a00000a 	beq	30001fa0 <OSMemGet+0x64>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
30001f74:	e5945004 	ldr	r5, [r4, #4]
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
30001f78:	e2466001 	sub	r6, r6, #1
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
30001f7c:	e5953000 	ldr	r3, [r5]
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
30001f80:	e5846010 	str	r6, [r4, #16]
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
30001f84:	e5843004 	str	r3, [r4, #4]
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
        OS_EXIT_CRITICAL();
30001f88:	ebfff8bf 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_NO_ERR;                             /*      No error                                 */
30001f8c:	e3a03000 	mov	r3, #0
30001f90:	e5c73000 	strb	r3, [r7]
        return (pblk);                                /*      Return memory block to caller            */
    }
    OS_EXIT_CRITICAL();
    *err = OS_MEM_NO_FREE_BLKS;                       /* No,  Notify caller of empty memory partition  */
    return ((void *)0);                               /*      Return NULL pointer to caller            */
}
30001f94:	e1a00005 	mov	r0, r5
30001f98:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30001f9c:	e12fff1e 	bx	lr
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
        OS_EXIT_CRITICAL();
        *err = OS_NO_ERR;                             /*      No error                                 */
        return (pblk);                                /*      Return memory block to caller            */
    }
    OS_EXIT_CRITICAL();
30001fa0:	ebfff8b9 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_MEM_NO_FREE_BLKS;                       /* No,  Notify caller of empty memory partition  */
30001fa4:	e3a03071 	mov	r3, #113	; 0x71
30001fa8:	e5c73000 	strb	r3, [r7]
30001fac:	e1a05006 	mov	r5, r6
    return ((void *)0);                               /*      Return NULL pointer to caller            */
30001fb0:	eafffff7 	b	30001f94 <OSMemGet+0x58>

30001fb4 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *err)
{
30001fb4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
#endif



#if OS_ARG_CHK_EN > 0              
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
30001fb8:	e2535000 	subs	r5, r3, #0
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *err)
{
30001fbc:	e1a04000 	mov	r4, r0
30001fc0:	e1a06001 	mov	r6, r1
30001fc4:	e1a07002 	mov	r7, r2
#endif



#if OS_ARG_CHK_EN > 0              
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
30001fc8:	01a08005 	moveq	r8, r5
30001fcc:	0a00002a 	beq	3000207c <OSMemCreate+0xc8>
        return ((OS_MEM *)0);
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
30001fd0:	e3500000 	cmp	r0, #0
        *err = OS_MEM_INVALID_ADDR;
30001fd4:	03a03076 	moveq	r3, #118	; 0x76
30001fd8:	05c53000 	strbeq	r3, [r5]
30001fdc:	01a08000 	moveq	r8, r0

#if OS_ARG_CHK_EN > 0              
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
        return ((OS_MEM *)0);
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
30001fe0:	0a000025 	beq	3000207c <OSMemCreate+0xc8>
        *err = OS_MEM_INVALID_ADDR;
        return ((OS_MEM *)0);
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
30001fe4:	e2108003 	ands	r8, r0, #3
        *err = OS_MEM_INVALID_ADDR;
30001fe8:	13a03076 	movne	r3, #118	; 0x76
30001fec:	15c53000 	strbne	r3, [r5]
30001ff0:	13a08000 	movne	r8, #0
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
        *err = OS_MEM_INVALID_ADDR;
        return ((OS_MEM *)0);
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
30001ff4:	1a000020 	bne	3000207c <OSMemCreate+0xc8>
        *err = OS_MEM_INVALID_ADDR;
        return ((OS_MEM *)0);
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
30001ff8:	e3510001 	cmp	r1, #1
        *err = OS_MEM_INVALID_BLKS;
30001ffc:	93a0306f 	movls	r3, #111	; 0x6f
30002000:	95c53000 	strbls	r3, [r5]
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
        *err = OS_MEM_INVALID_ADDR;
        return ((OS_MEM *)0);
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
30002004:	9a00001c 	bls	3000207c <OSMemCreate+0xc8>
        *err = OS_MEM_INVALID_BLKS;
        return ((OS_MEM *)0);
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
30002008:	e3520003 	cmp	r2, #3
3000200c:	9a00001d 	bls	30002088 <OSMemCreate+0xd4>
        *err = OS_MEM_INVALID_SIZE;
        return ((OS_MEM *)0);
    }
    if ((blksize % sizeof(void *)) != 0) {            /* Must contain space for an integral number ... */
30002010:	e212a003 	ands	sl, r2, #3
30002014:	1a00001b 	bne	30002088 <OSMemCreate+0xd4>
        *err = OS_MEM_INVALID_SIZE;                   /* ... of pointer sized items                    */
        return ((OS_MEM *)0);
    }
#endif
    OS_ENTER_CRITICAL();
30002018:	ebfff893 	bl	3000026c <OS_CPU_SR_Save>
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
3000201c:	e59f3080 	ldr	r3, [pc, #128]	; 300020a4 <OSMemCreate+0xf0>
30002020:	e5938000 	ldr	r8, [r3]
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
30002024:	e3580000 	cmp	r8, #0
30002028:	0a000019 	beq	30002094 <OSMemCreate+0xe0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
3000202c:	e5982004 	ldr	r2, [r8, #4]
30002030:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
30002034:	ebfff894 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
30002038:	e2561001 	subs	r1, r6, #1
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
        *err = OS_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
3000203c:	e1a02004 	mov	r2, r4
    pblk  = (INT8U *)((INT32U)addr + blksize);
30002040:	10873004 	addne	r3, r7, r4
    for (i = 0; i < (nblks - 1); i++) {
30002044:	0a000005 	beq	30002060 <OSMemCreate+0xac>
30002048:	e28aa001 	add	sl, sl, #1
3000204c:	e15a0001 	cmp	sl, r1
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
30002050:	e5823000 	str	r3, [r2]
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
30002054:	e1a02003 	mov	r2, r3
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
30002058:	e0833007 	add	r3, r3, r7
        *err = OS_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
3000205c:	3afffff9 	bcc	30002048 <OSMemCreate+0x94>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
30002060:	e3a03000 	mov	r3, #0
30002064:	e5823000 	str	r3, [r2]
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
    pmem->OSMemNBlks    = nblks;
30002068:	e588600c 	str	r6, [r8, #12]
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
3000206c:	e9880090 	stmib	r8, {r4, r7}
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
30002070:	e5884000 	str	r4, [r8]
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
30002074:	e5886010 	str	r6, [r8, #16]
    pmem->OSMemNBlks    = nblks;
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
    *err                = OS_NO_ERR;
30002078:	e5c53000 	strb	r3, [r5]
    return (pmem);
}
3000207c:	e1a00008 	mov	r0, r8
30002080:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
30002084:	e12fff1e 	bx	lr
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
        *err = OS_MEM_INVALID_SIZE;
        return ((OS_MEM *)0);
    }
    if ((blksize % sizeof(void *)) != 0) {            /* Must contain space for an integral number ... */
        *err = OS_MEM_INVALID_SIZE;                   /* ... of pointer sized items                    */
30002088:	e3a03070 	mov	r3, #112	; 0x70
3000208c:	e5c53000 	strb	r3, [r5]
        return ((OS_MEM *)0);
30002090:	eafffff9 	b	3000207c <OSMemCreate+0xc8>
    OS_ENTER_CRITICAL();
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
    }
    OS_EXIT_CRITICAL();
30002094:	ebfff87c 	bl	3000028c <OS_CPU_SR_Restore>
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
        *err = OS_MEM_INVALID_PART;
30002098:	e3a0306e 	mov	r3, #110	; 0x6e
3000209c:	e5c53000 	strb	r3, [r5]
        return ((OS_MEM *)0);
300020a0:	eafffff5 	b	3000207c <OSMemCreate+0xc8>
300020a4:	3001ce18 	andcc	ip, r1, r8, lsl lr

300020a8 <OSMboxQuery>:
*********************************************************************************************************
*/

#if OS_MBOX_QUERY_EN > 0
INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
{
300020a8:	e92d4010 	push	{r4, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
300020ac:	e2504000 	subs	r4, r0, #0
*********************************************************************************************************
*/

#if OS_MBOX_QUERY_EN > 0
INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
{
300020b0:	e24dd008 	sub	sp, sp, #8
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
300020b4:	03a00004 	moveq	r0, #4
300020b8:	0a000006 	beq	300020d8 <OSMboxQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
    }
    if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
300020bc:	e3510000 	cmp	r1, #0
300020c0:	03a00009 	moveq	r0, #9
300020c4:	0a000003 	beq	300020d8 <OSMboxQuery+0x30>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
300020c8:	e5d43000 	ldrb	r3, [r4]
300020cc:	e3530001 	cmp	r3, #1
300020d0:	13a00001 	movne	r0, #1
300020d4:	0a000002 	beq	300020e4 <OSMboxQuery+0x3c>
        *pdest++ = *psrc++;
    }
    p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
300020d8:	e28dd008 	add	sp, sp, #8
300020dc:	e8bd4010 	pop	{r4, lr}
300020e0:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
300020e4:	e58d1004 	str	r1, [sp, #4]
300020e8:	ebfff85f 	bl	3000026c <OS_CPU_SR_Save>
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
300020ec:	e5d4300a 	ldrb	r3, [r4, #10]
300020f0:	e59d1004 	ldr	r1, [sp, #4]
    psrc                    = &pevent->OSEventTbl[0];
300020f4:	e284e00b 	add	lr, r4, #11
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
300020f8:	e5c1300c 	strb	r3, [r1, #12]
    psrc                    = &pevent->OSEventTbl[0];
    pdest                   = &p_mbox_data->OSEventTbl[0];
300020fc:	e281c004 	add	ip, r1, #4
30002100:	e3a03000 	mov	r3, #0
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
30002104:	e7de2003 	ldrb	r2, [lr, r3]
30002108:	e7cc2003 	strb	r2, [ip, r3]
3000210c:	e2833001 	add	r3, r3, #1
    }
    OS_ENTER_CRITICAL();
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
    psrc                    = &pevent->OSEventTbl[0];
    pdest                   = &p_mbox_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
30002110:	e3530008 	cmp	r3, #8
30002114:	1afffffa 	bne	30002104 <OSMboxQuery+0x5c>
        *pdest++ = *psrc++;
    }
    p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
30002118:	e5943004 	ldr	r3, [r4, #4]
3000211c:	e5813000 	str	r3, [r1]
    OS_EXIT_CRITICAL();
30002120:	ebfff859 	bl	3000028c <OS_CPU_SR_Restore>
30002124:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30002128:	eaffffea 	b	300020d8 <OSMboxQuery+0x30>

3000212c <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
3000212c:	e92d4070 	push	{r4, r5, r6, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
30002130:	e59f3084 	ldr	r3, [pc, #132]	; 300021bc <OSMboxCreate+0x90>
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
30002134:	e1a06000 	mov	r6, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
30002138:	e5d35000 	ldrb	r5, [r3]
3000213c:	e3550000 	cmp	r5, #0
30002140:	13a04000 	movne	r4, #0
30002144:	0a000002 	beq	30002154 <OSMboxCreate+0x28>
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);
    }
    return (pevent);                             /* Return pointer to event control block              */
}
30002148:	e1a00004 	mov	r0, r4
3000214c:	e8bd4070 	pop	{r4, r5, r6, lr}
30002150:	e12fff1e 	bx	lr


    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    }
    OS_ENTER_CRITICAL();
30002154:	ebfff844 	bl	3000026c <OS_CPU_SR_Save>
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
30002158:	e59f3060 	ldr	r3, [pc, #96]	; 300021c0 <OSMboxCreate+0x94>
3000215c:	e5934000 	ldr	r4, [r3]
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
30002160:	e3540000 	cmp	r4, #0
30002164:	0a000012 	beq	300021b4 <OSMboxCreate+0x88>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
30002168:	e5942004 	ldr	r2, [r4, #4]
3000216c:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
30002170:	ebfff845 	bl	3000028c <OS_CPU_SR_Restore>
    if (pevent != (OS_EVENT *)0) {
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
30002174:	e3a02001 	mov	r2, #1
30002178:	e5c42000 	strb	r2, [r4]
        pevent->OSEventCnt     = 0;
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
3000217c:	e3a0203f 	mov	r2, #63	; 0x3f
30002180:	e5c42013 	strb	r2, [r4, #19]
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];
30002184:	e1a03005 	mov	r3, r5
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
        pevent->OSEventCnt     = 0;
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
30002188:	e5846004 	str	r6, [r4, #4]
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
        pevent->OSEventCnt     = 0;
3000218c:	e1c450b8 	strh	r5, [r4, #8]
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
        pevent->OSEventName[1] = OS_ASCII_NUL;
30002190:	e5c45014 	strb	r5, [r4, #20]
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
30002194:	e5c4500a 	strb	r5, [r4, #10]
    ptbl               = &pevent->OSEventTbl[0];
30002198:	e284100b 	add	r1, r4, #11

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0;
3000219c:	e1a02005 	mov	r2, r5
300021a0:	e7c12003 	strb	r2, [r1, r3]
300021a4:	e2833001 	add	r3, r3, #1


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
300021a8:	e3530008 	cmp	r3, #8
300021ac:	1afffffb 	bne	300021a0 <OSMboxCreate+0x74>
300021b0:	eaffffe4 	b	30002148 <OSMboxCreate+0x1c>
    OS_ENTER_CRITICAL();
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
300021b4:	ebfff834 	bl	3000028c <OS_CPU_SR_Restore>
300021b8:	eaffffe2 	b	30002148 <OSMboxCreate+0x1c>
300021bc:	3001d094 	mulcc	r1, r4, r0
300021c0:	3001d090 	mulcc	r1, r0, r0

300021c4 <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
300021c4:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
300021c8:	e2505000 	subs	r5, r0, #0
300021cc:	1a000003 	bne	300021e0 <OSMboxAccept+0x1c>
    }
    OS_ENTER_CRITICAL();
    msg                = pevent->OSEventPtr;
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    OS_EXIT_CRITICAL();
    return (msg);                                         /* Return the message received (or NULL)     */
300021d0:	e3a04000 	mov	r4, #0
}
300021d4:	e1a00004 	mov	r0, r4
300021d8:	e8bd4070 	pop	{r4, r5, r6, lr}
300021dc:	e12fff1e 	bx	lr
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
300021e0:	e5d53000 	ldrb	r3, [r5]
300021e4:	e3530001 	cmp	r3, #1
300021e8:	1afffff8 	bne	300021d0 <OSMboxAccept+0xc>
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
300021ec:	ebfff81e 	bl	3000026c <OS_CPU_SR_Save>
    msg                = pevent->OSEventPtr;
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
300021f0:	e3a03000 	mov	r3, #0
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    msg                = pevent->OSEventPtr;
300021f4:	e5954004 	ldr	r4, [r5, #4]
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
300021f8:	e5853004 	str	r3, [r5, #4]
    OS_EXIT_CRITICAL();
300021fc:	ebfff822 	bl	3000028c <OS_CPU_SR_Restore>
    return (msg);                                         /* Return the message received (or NULL)     */
30002200:	eafffff3 	b	300021d4 <OSMboxAccept+0x10>

30002204 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *err)
{
30002204:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                      /* Validate 'err'                                    */
30002208:	e2515000 	subs	r5, r1, #0
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *err)
{
3000220c:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                      /* Validate 'err'                                    */
30002210:	01a04005 	moveq	r4, r5
30002214:	0a000009 	beq	30002240 <OSFlagQuery+0x3c>
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
30002218:	e3540000 	cmp	r4, #0
        *err = OS_FLAG_INVALID_PGRP;
3000221c:	03e03069 	mvneq	r3, #105	; 0x69
30002220:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                      /* Validate 'err'                                    */
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
30002224:	0a000005 	beq	30002240 <OSFlagQuery+0x3c>
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
30002228:	e5d43000 	ldrb	r3, [r4]
3000222c:	e3530005 	cmp	r3, #5
        *err = OS_ERR_EVENT_TYPE;
30002230:	13a03001 	movne	r3, #1
30002234:	15c53000 	strbne	r3, [r5]
30002238:	13a04000 	movne	r4, #0
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
3000223c:	0a000002 	beq	3000224c <OSFlagQuery+0x48>
    OS_ENTER_CRITICAL();
    flags = pgrp->OSFlagFlags;
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
    return (flags);                               /* Return the current value of the event flags       */
}
30002240:	e1a00004 	mov	r0, r4
30002244:	e8bd4070 	pop	{r4, r5, r6, lr}
30002248:	e12fff1e 	bx	lr
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
    OS_ENTER_CRITICAL();
3000224c:	ebfff806 	bl	3000026c <OS_CPU_SR_Save>
    flags = pgrp->OSFlagFlags;
30002250:	e1d440b8 	ldrh	r4, [r4, #8]
    OS_EXIT_CRITICAL();
30002254:	ebfff80c 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30002258:	e3a03000 	mov	r3, #0
3000225c:	e5c53000 	strb	r3, [r5]
    return (flags);                               /* Return the current value of the event flags       */
30002260:	eafffff6 	b	30002240 <OSFlagQuery+0x3c>

30002264 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
30002264:	e92d4010 	push	{r4, lr}
    OS_CPU_SR     cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30002268:	ebfff7ff 	bl	3000026c <OS_CPU_SR_Save>
    flags = OSTCBCur->OSTCBFlagsRdy;
3000226c:	e59f3014 	ldr	r3, [pc, #20]	; 30002288 <OSFlagPendGetFlagsRdy+0x24>
30002270:	e5933000 	ldr	r3, [r3]
30002274:	e1d342b8 	ldrh	r4, [r3, #40]	; 0x28
    OS_EXIT_CRITICAL();
30002278:	ebfff803 	bl	3000028c <OS_CPU_SR_Restore>
    return (flags);
}
3000227c:	e1a00004 	mov	r0, r4
30002280:	e8bd4010 	pop	{r4, lr}
30002284:	e12fff1e 	bx	lr
30002288:	3001d098 	mulcc	r1, r8, r0

3000228c <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *err)
{
3000228c:	e92d4070 	push	{r4, r5, r6, lr}
30002290:	e1a05002 	mov	r5, r2
30002294:	e1a04000 	mov	r4, r0
30002298:	e1a06001 	mov	r6, r1
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
3000229c:	ebfff7f2 	bl	3000026c <OS_CPU_SR_Save>
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
300022a0:	e3550000 	cmp	r5, #0
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
300022a4:	e1a02000 	mov	r2, r0
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
300022a8:	0a000029 	beq	30002354 <OSFlagNameSet+0xc8>
        OS_EXIT_CRITICAL();
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
300022ac:	e3540000 	cmp	r4, #0
300022b0:	0a000029 	beq	3000235c <OSFlagNameSet+0xd0>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_FLAG_INVALID_PGRP;
        return;
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
300022b4:	e3560000 	cmp	r6, #0
300022b8:	0a00002b 	beq	3000236c <OSFlagNameSet+0xe0>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
300022bc:	e5d43000 	ldrb	r3, [r4]
300022c0:	e3530005 	cmp	r3, #5
300022c4:	1a000017 	bne	30002328 <OSFlagNameSet+0x9c>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300022c8:	e5d63000 	ldrb	r3, [r6]
300022cc:	e3530000 	cmp	r3, #0
        OS_EXIT_CRITICAL();
        *err = OS_ERR_EVENT_TYPE;
        return;
300022d0:	11a00006 	movne	r0, r6
300022d4:	13a01000 	movne	r1, #0
300022d8:	0a00001b 	beq	3000234c <OSFlagNameSet+0xc0>
300022dc:	e5f0c001 	ldrb	ip, [r0, #1]!
        psrc++;
        len++;
300022e0:	e2811001 	add	r1, r1, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300022e4:	e35c0000 	cmp	ip, #0
        psrc++;
        len++;
300022e8:	e20110ff 	and	r1, r1, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300022ec:	1afffffa 	bne	300022dc <OSFlagNameSet+0x50>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
300022f0:	e351000f 	cmp	r1, #15
        OS_EXIT_CRITICAL();
        *err = OS_ERR_FLAG_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
300022f4:	9284400a 	addls	r4, r4, #10
        OS_EXIT_CRITICAL();
        *err = OS_ERR_EVENT_TYPE;
        return;
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
300022f8:	8a00000e 	bhi	30002338 <OSFlagNameSet+0xac>
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
        *pdest++ = *psrc++;
300022fc:	e4c43001 	strb	r3, [r4], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30002300:	e5f63001 	ldrb	r3, [r6, #1]!
30002304:	e3530000 	cmp	r3, #0
30002308:	1afffffb 	bne	300022fc <OSFlagNameSet+0x70>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
3000230c:	e3a06000 	mov	r6, #0
30002310:	e5c46000 	strb	r6, [r4]
        OS_EXIT_CRITICAL();
        *err = OS_ERR_FLAG_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
30002314:	e1a00002 	mov	r0, r2
30002318:	ebfff7db 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
3000231c:	e5c56000 	strb	r6, [r5]
    return;
}
30002320:	e8bd4070 	pop	{r4, r5, r6, lr}
30002324:	e12fff1e 	bx	lr
        *err = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
        OS_EXIT_CRITICAL();
30002328:	ebfff7d7 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_EVENT_TYPE;
3000232c:	e3a03001 	mov	r3, #1
30002330:	e5c53000 	strb	r3, [r5]
        return;
30002334:	eafffff9 	b	30002320 <OSFlagNameSet+0x94>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
        OS_EXIT_CRITICAL();
30002338:	e1a00002 	mov	r0, r2
3000233c:	ebfff7d2 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_FLAG_NAME_TOO_LONG;
30002340:	e3a0300d 	mov	r3, #13
30002344:	e5c53000 	strb	r3, [r5]
        return;
30002348:	eafffff4 	b	30002320 <OSFlagNameSet+0x94>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
3000234c:	e284400a 	add	r4, r4, #10
30002350:	eaffffed 	b	3000230c <OSFlagNameSet+0x80>


    OS_ENTER_CRITICAL();
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        OS_EXIT_CRITICAL();
30002354:	ebfff7cc 	bl	3000028c <OS_CPU_SR_Restore>
        return;
30002358:	eafffff0 	b	30002320 <OSFlagNameSet+0x94>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
3000235c:	ebfff7ca 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_FLAG_INVALID_PGRP;
30002360:	e3e03069 	mvn	r3, #105	; 0x69
30002364:	e5c53000 	strb	r3, [r5]
        return;
30002368:	eaffffec 	b	30002320 <OSFlagNameSet+0x94>
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
3000236c:	ebfff7c6 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_PNAME_NULL;
30002370:	e3a0300f 	mov	r3, #15
30002374:	e5c53000 	strb	r3, [r5]
        return;
30002378:	eaffffe8 	b	30002320 <OSFlagNameSet+0x94>

3000237c <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *err)
{
3000237c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
30002380:	e1a05002 	mov	r5, r2
30002384:	e1a04000 	mov	r4, r0
30002388:	e1a06001 	mov	r6, r1
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
3000238c:	ebfff7b6 	bl	3000026c <OS_CPU_SR_Save>
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30002390:	e3550000 	cmp	r5, #0
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30002394:	e1a02000 	mov	r2, r0
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30002398:	0a00001f 	beq	3000241c <OSFlagNameGet+0xa0>
        OS_EXIT_CRITICAL();
        return (0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
3000239c:	e3540000 	cmp	r4, #0
300023a0:	0a000020 	beq	30002428 <OSFlagNameGet+0xac>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_FLAG_INVALID_PGRP;
        return (0);
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
300023a4:	e3560000 	cmp	r6, #0
300023a8:	0a000022 	beq	30002438 <OSFlagNameGet+0xbc>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
        *err = OS_ERR_PNAME_NULL;
        return (0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
300023ac:	e5d43000 	ldrb	r3, [r4]
300023b0:	e3530005 	cmp	r3, #5
300023b4:	1a000013 	bne	30002408 <OSFlagNameGet+0x8c>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300023b8:	e5d4300a 	ldrb	r3, [r4, #10]
300023bc:	e3530000 	cmp	r3, #0
300023c0:	01a04003 	moveq	r4, r3
300023c4:	0a000007 	beq	300023e8 <OSFlagNameGet+0x6c>
300023c8:	e284100a 	add	r1, r4, #10
300023cc:	e3a04000 	mov	r4, #0
        *pdest++ = *psrc++;
300023d0:	e4c63001 	strb	r3, [r6], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300023d4:	e5f13001 	ldrb	r3, [r1, #1]!
        *pdest++ = *psrc++;
        len++;
300023d8:	e2844001 	add	r4, r4, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300023dc:	e3530000 	cmp	r3, #0
        *pdest++ = *psrc++;
        len++;
300023e0:	e20440ff 	and	r4, r4, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300023e4:	1afffff9 	bne	300023d0 <OSFlagNameGet+0x54>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
300023e8:	e3a07000 	mov	r7, #0
300023ec:	e5c67000 	strb	r7, [r6]
        OS_EXIT_CRITICAL();
        *err = OS_ERR_EVENT_TYPE;
        return (0);
    }
    len  = OS_StrCopy(pname, pgrp->OSFlagName);  /* Copy name from OS_FLAG_GRP                         */
    OS_EXIT_CRITICAL();
300023f0:	e1a00002 	mov	r0, r2
300023f4:	ebfff7a4 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
300023f8:	e5c57000 	strb	r7, [r5]
    return (len);
}
300023fc:	e1a00004 	mov	r0, r4
30002400:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30002404:	e12fff1e 	bx	lr
        *err = OS_ERR_PNAME_NULL;
        return (0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
        OS_EXIT_CRITICAL();
30002408:	ebfff79f 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_EVENT_TYPE;
3000240c:	e3a03001 	mov	r3, #1
30002410:	e5c53000 	strb	r3, [r5]
30002414:	e3a04000 	mov	r4, #0
        return (0);
30002418:	eafffff7 	b	300023fc <OSFlagNameGet+0x80>


    OS_ENTER_CRITICAL();
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        OS_EXIT_CRITICAL();
3000241c:	e1a04005 	mov	r4, r5
30002420:	ebfff799 	bl	3000028c <OS_CPU_SR_Restore>
        return (0);
30002424:	eafffff4 	b	300023fc <OSFlagNameGet+0x80>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
30002428:	ebfff797 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_FLAG_INVALID_PGRP;
3000242c:	e3e03069 	mvn	r3, #105	; 0x69
30002430:	e5c53000 	strb	r3, [r5]
        return (0);
30002434:	eafffff0 	b	300023fc <OSFlagNameGet+0x80>
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
        OS_EXIT_CRITICAL();                      /* Yes                                                */
30002438:	ebfff793 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_PNAME_NULL;
3000243c:	e3a0300f 	mov	r3, #15
30002440:	e5c53000 	strb	r3, [r5]
30002444:	e1a04006 	mov	r4, r6
        return (0);
30002448:	eaffffeb 	b	300023fc <OSFlagNameGet+0x80>

3000244c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
3000244c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                        /* Validate 'err'                                  */
30002450:	e2516000 	subs	r6, r1, #0
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
30002454:	e1a07000 	mov	r7, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                        /* Validate 'err'                                  */
30002458:	01a04006 	moveq	r4, r6
3000245c:	0a000016 	beq	300024bc <OSFlagCreate+0x70>
        return ((OS_FLAG_GRP *)0);
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
30002460:	e59f3070 	ldr	r3, [pc, #112]	; 300024d8 <OSFlagCreate+0x8c>
30002464:	e5d35000 	ldrb	r5, [r3]
30002468:	e3550000 	cmp	r5, #0
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
3000246c:	13e03072 	mvnne	r3, #114	; 0x72
30002470:	15c63000 	strbne	r3, [r6]
30002474:	13a04000 	movne	r4, #0
#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                        /* Validate 'err'                                  */
        return ((OS_FLAG_GRP *)0);
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
30002478:	1a00000f 	bne	300024bc <OSFlagCreate+0x70>
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
        return ((OS_FLAG_GRP *)0);
    }
    OS_ENTER_CRITICAL();
3000247c:	ebfff77a 	bl	3000026c <OS_CPU_SR_Save>
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
30002480:	e59f3054 	ldr	r3, [pc, #84]	; 300024dc <OSFlagCreate+0x90>
30002484:	e5934000 	ldr	r4, [r3]
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
30002488:	e3540000 	cmp	r4, #0
3000248c:	0a00000d 	beq	300024c8 <OSFlagCreate+0x7c>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
30002490:	e5942004 	ldr	r2, [r4, #4]
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
30002494:	e1c470b8 	strh	r7, [r4, #8]
    }
    OS_ENTER_CRITICAL();
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
30002498:	e5832000 	str	r2, [r3]
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
3000249c:	e3a03005 	mov	r3, #5
300024a0:	e5c43000 	strb	r3, [r4]
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
300024a4:	e3a0303f 	mov	r3, #63	; 0x3f
300024a8:	e5c4300a 	strb	r3, [r4, #10]
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
300024ac:	e5845004 	str	r5, [r4, #4]
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
300024b0:	e5c4500b 	strb	r5, [r4, #11]
#endif
        OS_EXIT_CRITICAL();
300024b4:	ebfff774 	bl	3000028c <OS_CPU_SR_Restore>
        *err                 = OS_NO_ERR;
300024b8:	e5c65000 	strb	r5, [r6]
    } else {
        OS_EXIT_CRITICAL();
        *err                 = OS_FLAG_GRP_DEPLETED;
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
}
300024bc:	e1a00004 	mov	r0, r4
300024c0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
300024c4:	e12fff1e 	bx	lr
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        OS_EXIT_CRITICAL();
        *err                 = OS_NO_ERR;
    } else {
        OS_EXIT_CRITICAL();
300024c8:	ebfff76f 	bl	3000028c <OS_CPU_SR_Restore>
        *err                 = OS_FLAG_GRP_DEPLETED;
300024cc:	e3e03065 	mvn	r3, #101	; 0x65
300024d0:	e5c63000 	strb	r3, [r6]
300024d4:	eafffff8 	b	300024bc <OSFlagCreate+0x70>
300024d8:	3001d094 	mulcc	r1, r4, r0
300024dc:	3001dba0 	andcc	sp, r1, r0, lsr #23

300024e0 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
300024e0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
300024e4:	e2535000 	subs	r5, r3, #0
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
300024e8:	e1a07002 	mov	r7, r2
300024ec:	e1a04000 	mov	r4, r0
300024f0:	e1a06001 	mov	r6, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
300024f4:	01a07005 	moveq	r7, r5
300024f8:	0a00000a 	beq	30002528 <OSFlagAccept+0x48>
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
300024fc:	e3500000 	cmp	r0, #0
        *err = OS_FLAG_INVALID_PGRP;
30002500:	03e03069 	mvneq	r3, #105	; 0x69
30002504:	05c53000 	strbeq	r3, [r5]
30002508:	01a07000 	moveq	r7, r0

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
3000250c:	0a000005 	beq	30002528 <OSFlagAccept+0x48>
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
30002510:	e5d03000 	ldrb	r3, [r0]
30002514:	e3530005 	cmp	r3, #5
        *err = OS_ERR_EVENT_TYPE;
30002518:	13a03001 	movne	r3, #1
3000251c:	15c53000 	strbne	r3, [r5]
30002520:	13a07000 	movne	r7, #0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
30002524:	0a000002 	beq	30002534 <OSFlagAccept+0x54>
             flags_rdy = (OS_FLAGS)0;
             *err      = OS_FLAG_ERR_WAIT_TYPE;
             break;
    }
    return (flags_rdy);
}
30002528:	e1a00007 	mov	r0, r7
3000252c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30002530:	e12fff1e 	bx	lr
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
30002534:	e2178080 	ands	r8, r7, #128	; 0x80
        consume    = OS_TRUE;
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
30002538:	e3a03000 	mov	r3, #0
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
        wait_type &= ~OS_FLAG_CONSUME;
3000253c:	1207707f 	andne	r7, r7, #127	; 0x7f
        consume    = OS_TRUE;
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
30002540:	e5c53000 	strb	r3, [r5]
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
        wait_type &= ~OS_FLAG_CONSUME;
30002544:	13a08001 	movne	r8, #1
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
    OS_ENTER_CRITICAL();
30002548:	ebfff747 	bl	3000026c <OS_CPU_SR_Save>
    switch (wait_type) {
3000254c:	e3570003 	cmp	r7, #3
30002550:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
30002554:	ea00001c 	b	300025cc <OSFlagAccept+0xec>
30002558:	300025a8 	andcc	r2, r0, r8, lsr #11
3000255c:	300025e0 	andcc	r2, r0, r0, ror #11
30002560:	30002588 	andcc	r2, r0, r8, lsl #11
30002564:	30002568 	andcc	r2, r0, r8, ror #10
             }
             OS_EXIT_CRITICAL();
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
30002568:	e1d430b8 	ldrh	r3, [r4, #8]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
3000256c:	e0167003 	ands	r7, r6, r3
30002570:	0a000008 	beq	30002598 <OSFlagAccept+0xb8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
30002574:	e3580001 	cmp	r8, #1
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
30002578:	01c33007 	biceq	r3, r3, r7
3000257c:	01c430b8 	strheq	r3, [r4, #8]
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
30002580:	ebfff741 	bl	3000028c <OS_CPU_SR_Restore>
             break;
30002584:	eaffffe7 	b	30002528 <OSFlagAccept+0x48>
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
    OS_ENTER_CRITICAL();
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
30002588:	e1d430b8 	ldrh	r3, [r4, #8]
3000258c:	e0067003 	and	r7, r6, r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
30002590:	e1570006 	cmp	r7, r6
30002594:	0a000019 	beq	30002600 <OSFlagAccept+0x120>
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
30002598:	e3e03067 	mvn	r3, #103	; 0x67
3000259c:	e5c53000 	strb	r3, [r5]
             }
             OS_EXIT_CRITICAL();
300025a0:	ebfff739 	bl	3000028c <OS_CPU_SR_Restore>
300025a4:	eaffffdf 	b	30002528 <OSFlagAccept+0x48>
             OS_EXIT_CRITICAL();
             break;

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
300025a8:	e1d430b8 	ldrh	r3, [r4, #8]
300025ac:	e1c67003 	bic	r7, r6, r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
300025b0:	e1570006 	cmp	r7, r6
300025b4:	1afffff7 	bne	30002598 <OSFlagAccept+0xb8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
300025b8:	e3580001 	cmp	r8, #1
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
300025bc:	01833006 	orreq	r3, r3, r6
300025c0:	01c430b8 	strheq	r3, [r4, #8]
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
300025c4:	ebfff730 	bl	3000028c <OS_CPU_SR_Restore>
300025c8:	eaffffd6 	b	30002528 <OSFlagAccept+0x48>
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
300025cc:	ebfff72e 	bl	3000028c <OS_CPU_SR_Restore>
             flags_rdy = (OS_FLAGS)0;
             *err      = OS_FLAG_ERR_WAIT_TYPE;
300025d0:	e3e03068 	mvn	r3, #104	; 0x68
300025d4:	e5c53000 	strb	r3, [r5]
300025d8:	e3a07000 	mov	r7, #0
300025dc:	eaffffd1 	b	30002528 <OSFlagAccept+0x48>
             }
             OS_EXIT_CRITICAL();
             break;

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
300025e0:	e1d430b8 	ldrh	r3, [r4, #8]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
300025e4:	e1d67003 	bics	r7, r6, r3
300025e8:	0affffea 	beq	30002598 <OSFlagAccept+0xb8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
300025ec:	e3580001 	cmp	r8, #1
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
300025f0:	01873003 	orreq	r3, r7, r3
300025f4:	01c430b8 	strheq	r3, [r4, #8]
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
300025f8:	ebfff723 	bl	3000028c <OS_CPU_SR_Restore>
300025fc:	eaffffc9 	b	30002528 <OSFlagAccept+0x48>
    OS_ENTER_CRITICAL();
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
30002600:	e3580001 	cmp	r8, #1
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
30002604:	01c33006 	biceq	r3, r3, r6
30002608:	01c430b8 	strheq	r3, [r4, #8]
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
3000260c:	ebfff71e 	bl	3000028c <OS_CPU_SR_Restore>
30002610:	eaffffc4 	b	30002528 <OSFlagAccept+0x48>

30002614 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
30002614:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
30002618:	e59f3040 	ldr	r3, [pc, #64]	; 30002660 <OSSchedLock+0x4c>
3000261c:	e5d33000 	ldrb	r3, [r3]
30002620:	e3530001 	cmp	r3, #1
30002624:	0a000001 	beq	30002630 <OSSchedLock+0x1c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
            }
        }
        OS_EXIT_CRITICAL();
    }
}
30002628:	e8bd4010 	pop	{r4, lr}
3000262c:	e12fff1e 	bx	lr
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
        OS_ENTER_CRITICAL();
30002630:	ebfff70d 	bl	3000026c <OS_CPU_SR_Save>
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
30002634:	e59f3028 	ldr	r3, [pc, #40]	; 30002664 <OSSchedLock+0x50>
30002638:	e5d33000 	ldrb	r3, [r3]
3000263c:	e3530000 	cmp	r3, #0
30002640:	1a000004 	bne	30002658 <OSSchedLock+0x44>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
30002644:	e59f301c 	ldr	r3, [pc, #28]	; 30002668 <OSSchedLock+0x54>
30002648:	e5d32000 	ldrb	r2, [r3]
3000264c:	e35200ff 	cmp	r2, #255	; 0xff
                OSLockNesting++;                 /* Increment lock nesting level                       */
30002650:	12822001 	addne	r2, r2, #1
30002654:	15c32000 	strbne	r2, [r3]
            }
        }
        OS_EXIT_CRITICAL();
30002658:	ebfff70b 	bl	3000028c <OS_CPU_SR_Restore>
3000265c:	eafffff1 	b	30002628 <OSSchedLock+0x14>
30002660:	3001c76c 	andcc	ip, r1, ip, ror #14
30002664:	3001d094 	mulcc	r1, r4, r0
30002668:	3001c764 	andcc	ip, r1, r4, ror #14

3000266c <OSEventNameSet>:
*********************************************************************************************************
*/

#if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *err)
{
3000266c:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30002670:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *err)
{
30002674:	e1a04000 	mov	r4, r0
30002678:	e1a06001 	mov	r6, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
3000267c:	0a000023 	beq	30002710 <OSEventNameSet+0xa4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
30002680:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
30002684:	03a03004 	moveq	r3, #4
30002688:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
3000268c:	0a00001f 	beq	30002710 <OSEventNameSet+0xa4>
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
30002690:	e3510000 	cmp	r1, #0
        *err = OS_ERR_PNAME_NULL;
30002694:	03a0300f 	moveq	r3, #15
30002698:	05c53000 	strbeq	r3, [r5]
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
3000269c:	0a00001b 	beq	30002710 <OSEventNameSet+0xa4>
        *err = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    switch (pevent->OSEventType) {
300026a0:	e5d03000 	ldrb	r3, [r0]
300026a4:	e2433001 	sub	r3, r3, #1
300026a8:	e3530003 	cmp	r3, #3
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *err = OS_ERR_EVENT_TYPE;
300026ac:	83a03001 	movhi	r3, #1
300026b0:	85c53000 	strbhi	r3, [r5]
    if (pname == (INT8U *)0) {                    /* Is 'pname' a NULL pointer?                         */
        *err = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    switch (pevent->OSEventType) {
300026b4:	8a000015 	bhi	30002710 <OSEventNameSet+0xa4>

        default:
             *err = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
300026b8:	ebfff6eb 	bl	3000026c <OS_CPU_SR_Save>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300026bc:	e5d63000 	ldrb	r3, [r6]
300026c0:	e3530000 	cmp	r3, #0
300026c4:	0a000017 	beq	30002728 <OSEventNameSet+0xbc>
300026c8:	e1a01006 	mov	r1, r6
300026cc:	e3a02000 	mov	r2, #0
300026d0:	e5f1c001 	ldrb	ip, [r1, #1]!
        psrc++;
        len++;
300026d4:	e2822001 	add	r2, r2, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300026d8:	e35c0000 	cmp	ip, #0
        psrc++;
        len++;
300026dc:	e20220ff 	and	r2, r2, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300026e0:	1afffffa 	bne	300026d0 <OSEventNameSet+0x64>
             *err = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
300026e4:	e352000f 	cmp	r2, #15
        OS_EXIT_CRITICAL();
        *err = OS_ERR_EVENT_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
300026e8:	92844013 	addls	r4, r4, #19
             *err = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
300026ec:	8a000009 	bhi	30002718 <OSEventNameSet+0xac>
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
        *pdest++ = *psrc++;
300026f0:	e4c43001 	strb	r3, [r4], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300026f4:	e5f63001 	ldrb	r3, [r6, #1]!
300026f8:	e3530000 	cmp	r3, #0
300026fc:	1afffffb 	bne	300026f0 <OSEventNameSet+0x84>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30002700:	e3a06000 	mov	r6, #0
30002704:	e5c46000 	strb	r6, [r4]
        OS_EXIT_CRITICAL();
        *err = OS_ERR_EVENT_NAME_TOO_LONG;
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
30002708:	ebfff6df 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
3000270c:	e5c56000 	strb	r6, [r5]
}
30002710:	e8bd4070 	pop	{r4, r5, r6, lr}
30002714:	e12fff1e 	bx	lr
             return;
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
30002718:	ebfff6db 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_ERR_EVENT_NAME_TOO_LONG;
3000271c:	e3a0300c 	mov	r3, #12
30002720:	e5c53000 	strb	r3, [r5]
        return;
30002724:	eafffff9 	b	30002710 <OSEventNameSet+0xa4>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
30002728:	e2844013 	add	r4, r4, #19
3000272c:	eafffff3 	b	30002700 <OSEventNameSet+0x94>

30002730 <OSEventNameGet>:
*********************************************************************************************************
*/

#if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *err)
{
30002730:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30002734:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *err)
{
30002738:	e1a04000 	mov	r4, r0
3000273c:	e1a06001 	mov	r6, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30002740:	01a04005 	moveq	r4, r5
30002744:	0a000020 	beq	300027cc <OSEventNameGet+0x9c>
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
30002748:	e3540000 	cmp	r4, #0
        *err = OS_ERR_PEVENT_NULL;
3000274c:	03a03004 	moveq	r3, #4
30002750:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
30002754:	0a00001c 	beq	300027cc <OSEventNameGet+0x9c>
        *err = OS_ERR_PEVENT_NULL;
        return (0);
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
30002758:	e3510000 	cmp	r1, #0
        *err = OS_ERR_PNAME_NULL;
3000275c:	03a0300f 	moveq	r3, #15
30002760:	05c53000 	strbeq	r3, [r5]
30002764:	01a04001 	moveq	r4, r1
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
        *err = OS_ERR_PEVENT_NULL;
        return (0);
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
30002768:	0a000017 	beq	300027cc <OSEventNameGet+0x9c>
        *err = OS_ERR_PNAME_NULL;
        return (0);
    }
#endif
    switch (pevent->OSEventType) {
3000276c:	e5d43000 	ldrb	r3, [r4]
30002770:	e2433001 	sub	r3, r3, #1
30002774:	e3530003 	cmp	r3, #3
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *err = OS_ERR_EVENT_TYPE;
30002778:	83a03001 	movhi	r3, #1
3000277c:	85c53000 	strbhi	r3, [r5]
30002780:	83a04000 	movhi	r4, #0
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *err = OS_ERR_PNAME_NULL;
        return (0);
    }
#endif
    switch (pevent->OSEventType) {
30002784:	8a000010 	bhi	300027cc <OSEventNameGet+0x9c>

        default:
             *err = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
30002788:	ebfff6b7 	bl	3000026c <OS_CPU_SR_Save>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
3000278c:	e5d43013 	ldrb	r3, [r4, #19]
30002790:	e3530000 	cmp	r3, #0
30002794:	01a04003 	moveq	r4, r3
30002798:	0a000007 	beq	300027bc <OSEventNameGet+0x8c>
3000279c:	e2842013 	add	r2, r4, #19
300027a0:	e3a04000 	mov	r4, #0
        *pdest++ = *psrc++;
300027a4:	e4c63001 	strb	r3, [r6], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300027a8:	e5f23001 	ldrb	r3, [r2, #1]!
        *pdest++ = *psrc++;
        len++;
300027ac:	e2844001 	add	r4, r4, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300027b0:	e3530000 	cmp	r3, #0
        *pdest++ = *psrc++;
        len++;
300027b4:	e20440ff 	and	r4, r4, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300027b8:	1afffff9 	bne	300027a4 <OSEventNameGet+0x74>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
300027bc:	e3a07000 	mov	r7, #0
300027c0:	e5c67000 	strb	r7, [r6]
             *err = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
    len  = OS_StrCopy(pname, pevent->OSEventName);    /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
300027c4:	ebfff6b0 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
300027c8:	e5c57000 	strb	r7, [r5]
    return (len);
}
300027cc:	e1a00004 	mov	r0, r4
300027d0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
300027d4:	e12fff1e 	bx	lr

300027d8 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
300027d8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
300027dc:	e1a0a003 	mov	sl, r3
300027e0:	e1a04000 	mov	r4, r0
300027e4:	e1a05001 	mov	r5, r1
300027e8:	e1a06002 	mov	r6, r2
300027ec:	e1dd92b8 	ldrh	r9, [sp, #40]	; 0x28
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
300027f0:	ebfff69d 	bl	3000026c <OS_CPU_SR_Save>
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
300027f4:	e59f3128 	ldr	r3, [pc, #296]	; 30002924 <OS_TCBInit+0x14c>
300027f8:	e5937000 	ldr	r7, [r3]
    if (ptcb != (OS_TCB *)0) {
300027fc:	e3570000 	cmp	r7, #0
30002800:	0a000044 	beq	30002918 <OS_TCBInit+0x140>
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
30002804:	e5972014 	ldr	r2, [r7, #20]
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
30002808:	e3a08000 	mov	r8, #0


    OS_ENTER_CRITICAL();
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
3000280c:	e5832000 	str	r2, [r3]
        OS_EXIT_CRITICAL();
30002810:	ebfff69d 	bl	3000028c <OS_CPU_SR_Restore>
#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
30002814:	e1a021a4 	lsr	r2, r4, #3
        ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
30002818:	e2043007 	and	r3, r4, #7
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
        ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
3000281c:	e3a01001 	mov	r1, #1
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
        ptcb->OSTCBBitX      = (INT8U)(1 << ptcb->OSTCBX);
30002820:	e1a00311 	lsl	r0, r1, r3
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
        ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
30002824:	e1a01211 	lsl	r1, r1, r2
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
        ptcb->OSTCBPendTO    = OS_FALSE;                   /* Clear the Pend timeout flag              */
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
30002828:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    OS_ENTER_CRITICAL();
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
3000282c:	e8871020 	stm	r7, {r5, ip}
        ptcb->OSTCBPendTO    = OS_FALSE;                   /* Clear the Pend timeout flag              */
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
30002830:	e59dc020 	ldr	ip, [sp, #32]
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
        ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
30002834:	e5c71032 	strb	r1, [r7, #50]	; 0x32
        ptcb->OSTCBStkBase     = (OS_STK *)0;
        ptcb->OSTCBStkUsed     = 0L;
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
30002838:	e3a0103f 	mov	r1, #63	; 0x3f
        ptcb->OSTCBPendTO    = OS_FALSE;                   /* Clear the Pend timeout flag              */
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
3000283c:	e587c00c 	str	ip, [r7, #12]
        ptcb->OSTCBStkBase     = (OS_STK *)0;
        ptcb->OSTCBStkUsed     = 0L;
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
30002840:	e5c71048 	strb	r1, [r7, #72]	; 0x48
#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
30002844:	e5c72030 	strb	r2, [r7, #48]	; 0x30
        ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
30002848:	e5c7302f 	strb	r3, [r7, #47]	; 0x2f
        ptcb->OSTCBBitX      = (INT8U)(1 << ptcb->OSTCBX);
3000284c:	e5c70031 	strb	r0, [r7, #49]	; 0x31
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
30002850:	e5c7402e 	strb	r4, [r7, #46]	; 0x2e
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
30002854:	e1a00007 	mov	r0, r7
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
        ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
30002858:	e5876008 	str	r6, [r7, #8]
        ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
3000285c:	e1c791b0 	strh	r9, [r7, #16]
        ptcb->OSTCBId        = id;                         /* Store task ID                            */
30002860:	e1c7a1b2 	strh	sl, [r7, #18]
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
30002864:	e5c7802c 	strb	r8, [r7, #44]	; 0x2c
        ptcb->OSTCBPendTO    = OS_FALSE;                   /* Clear the Pend timeout flag              */
30002868:	e5c7802d 	strb	r8, [r7, #45]	; 0x2d
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
3000286c:	e1c782ba 	strh	r8, [r7, #42]	; 0x2a
        opt                  = opt;
        id                   = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
30002870:	e5c78033 	strb	r8, [r7, #51]	; 0x33
        ptcb->OSTCBX         = (INT8U)(prio & 0x0F);
        ptcb->OSTCBBitX      = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if OS_EVENT_EN
        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
30002874:	e587801c 	str	r8, [r7, #28]
#endif

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
30002878:	e5878024 	str	r8, [r7, #36]	; 0x24
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
3000287c:	e5878020 	str	r8, [r7, #32]
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
30002880:	e5878034 	str	r8, [r7, #52]	; 0x34
        ptcb->OSTCBCyclesStart = 0L;
30002884:	e587803c 	str	r8, [r7, #60]	; 0x3c
        ptcb->OSTCBCyclesTot   = 0L;
30002888:	e5878038 	str	r8, [r7, #56]	; 0x38
        ptcb->OSTCBStkBase     = (OS_STK *)0;
3000288c:	e5878040 	str	r8, [r7, #64]	; 0x40
        ptcb->OSTCBStkUsed     = 0L;
30002890:	e5878044 	str	r8, [r7, #68]	; 0x44
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
30002894:	e5c78049 	strb	r8, [r7, #73]	; 0x49
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
30002898:	eb001030 	bl	30006960 <OSTCBInitHook>
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
3000289c:	e1a00007 	mov	r0, r7
300028a0:	eb001033 	bl	30006974 <OSTaskCreateHook>

        OS_ENTER_CRITICAL();
300028a4:	ebfff670 	bl	3000026c <OS_CPU_SR_Save>
        OSTCBPrioTbl[prio] = ptcb;
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
300028a8:	e59f2078 	ldr	r2, [pc, #120]	; 30002928 <OS_TCBInit+0x150>
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
300028ac:	e59f1078 	ldr	r1, [pc, #120]	; 3000292c <OS_TCBInit+0x154>
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
300028b0:	e5923000 	ldr	r3, [r2]
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
300028b4:	e7817104 	str	r7, [r1, r4, lsl #2]
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
300028b8:	e1530008 	cmp	r3, r8
        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
300028bc:	e5878018 	str	r8, [r7, #24]

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
300028c0:	e5873014 	str	r3, [r7, #20]
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
300028c4:	15837018 	strne	r7, [r3, #24]
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
300028c8:	e59f3060 	ldr	r3, [pc, #96]	; 30002930 <OS_TCBInit+0x158>
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
300028cc:	e5827000 	str	r7, [r2]
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
300028d0:	e5d72032 	ldrb	r2, [r7, #50]	; 0x32
300028d4:	e5d3c000 	ldrb	ip, [r3]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
300028d8:	e59f1054 	ldr	r1, [pc, #84]	; 30002934 <OS_TCBInit+0x15c>
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
300028dc:	e18c2002 	orr	r2, ip, r2
300028e0:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
300028e4:	e5d72030 	ldrb	r2, [r7, #48]	; 0x30
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
300028e8:	e59f3048 	ldr	r3, [pc, #72]	; 30002938 <OS_TCBInit+0x160>
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
300028ec:	e5d7e031 	ldrb	lr, [r7, #49]	; 0x31
300028f0:	e7d14002 	ldrb	r4, [r1, r2]
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
300028f4:	e5d3c000 	ldrb	ip, [r3]
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
300028f8:	e184e00e 	orr	lr, r4, lr
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
300028fc:	e28cc001 	add	ip, ip, #1
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30002900:	e7c1e002 	strb	lr, [r1, r2]
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
30002904:	e5c3c000 	strb	ip, [r3]
        OS_EXIT_CRITICAL();
30002908:	ebfff65f 	bl	3000028c <OS_CPU_SR_Restore>
3000290c:	e3a00000 	mov	r0, #0
        return (OS_NO_ERR);
    }
    OS_EXIT_CRITICAL();
    return (OS_NO_MORE_TCB);
}
30002910:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
30002914:	e12fff1e 	bx	lr
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
        OS_EXIT_CRITICAL();
        return (OS_NO_ERR);
    }
    OS_EXIT_CRITICAL();
30002918:	ebfff65b 	bl	3000028c <OS_CPU_SR_Restore>
3000291c:	e3a00046 	mov	r0, #70	; 0x46
    return (OS_NO_MORE_TCB);
30002920:	eafffffa 	b	30002910 <OS_TCBInit+0x138>
30002924:	3001ce10 	andcc	ip, r1, r0, lsl lr
30002928:	3001cb48 	andcc	ip, r1, r8, asr #22
3000292c:	3001dba8 	andcc	sp, r1, r8, lsr #23
30002930:	3001ce84 	andcc	ip, r1, r4, lsl #29
30002934:	3001ce88 	andcc	ip, r1, r8, lsl #29
30002938:	3001ce15 	andcc	ip, r1, r5, lsl lr

3000293c <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
3000293c:	e92d4010 	push	{r4, lr}
30002940:	e59f4018 	ldr	r4, [pc, #24]	; 30002960 <OS_TaskIdle+0x24>



    (void)p_arg;                                 /* Prevent compiler warning for not using 'parg'      */
    for (;;) {
        OS_ENTER_CRITICAL();
30002944:	ebfff648 	bl	3000026c <OS_CPU_SR_Save>
        OSIdleCtr++;
30002948:	e5943000 	ldr	r3, [r4]
3000294c:	e2833001 	add	r3, r3, #1
30002950:	e5843000 	str	r3, [r4]
        OS_EXIT_CRITICAL();
30002954:	ebfff64c 	bl	3000028c <OS_CPU_SR_Restore>
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
30002958:	eb000ffe 	bl	30006958 <OSTaskIdleHook>
3000295c:	eafffff8 	b	30002944 <OS_TaskIdle+0x8>
30002960:	3001c770 	andcc	ip, r1, r0, ror r7

30002964 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
30002964:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30002968:	ebfff63f 	bl	3000026c <OS_CPU_SR_Save>
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
3000296c:	e59f3098 	ldr	r3, [pc, #152]	; 30002a0c <OS_Sched+0xa8>
    OS_CPU_SR  cpu_sr = 0;
#endif



    OS_ENTER_CRITICAL();
30002970:	e1a04000 	mov	r4, r0
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
30002974:	e5d33000 	ldrb	r3, [r3]
30002978:	e3530000 	cmp	r3, #0
3000297c:	1a00001e 	bne	300029fc <OS_Sched+0x98>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
30002980:	e59f3088 	ldr	r3, [pc, #136]	; 30002a10 <OS_Sched+0xac>
30002984:	e5d33000 	ldrb	r3, [r3]
30002988:	e3530000 	cmp	r3, #0
3000298c:	1a00001a 	bne	300029fc <OS_Sched+0x98>
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
30002990:	e59f307c 	ldr	r3, [pc, #124]	; 30002a14 <OS_Sched+0xb0>
30002994:	e59f207c 	ldr	r2, [pc, #124]	; 30002a18 <OS_Sched+0xb4>
30002998:	e5d33000 	ldrb	r3, [r3]
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
3000299c:	e59f1078 	ldr	r1, [pc, #120]	; 30002a1c <OS_Sched+0xb8>
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
300029a0:	e7d23003 	ldrb	r3, [r2, r3]
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
300029a4:	e7d10003 	ldrb	r0, [r1, r3]

    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
300029a8:	e59f1070 	ldr	r1, [pc, #112]	; 30002a20 <OS_Sched+0xbc>
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
300029ac:	e7d22000 	ldrb	r2, [r2, r0]

    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
300029b0:	e5d11000 	ldrb	r1, [r1]
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
300029b4:	e0823183 	add	r3, r2, r3, lsl #3
300029b8:	e20330ff 	and	r3, r3, #255	; 0xff
300029bc:	e59f2060 	ldr	r2, [pc, #96]	; 30002a24 <OS_Sched+0xc0>

    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
300029c0:	e1510003 	cmp	r1, r3
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
300029c4:	e5c23000 	strb	r3, [r2]

    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
300029c8:	0a00000b 	beq	300029fc <OS_Sched+0x98>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
300029cc:	e59f1054 	ldr	r1, [pc, #84]	; 30002a28 <OS_Sched+0xc4>

#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
300029d0:	e59f2054 	ldr	r2, [pc, #84]	; 30002a2c <OS_Sched+0xc8>
    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
300029d4:	e7913103 	ldr	r3, [r1, r3, lsl #2]

#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
300029d8:	e5921000 	ldr	r1, [r2]
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];

#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
300029dc:	e5930034 	ldr	r0, [r3, #52]	; 0x34
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
300029e0:	e2811001 	add	r1, r1, #1
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];

#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
300029e4:	e2800001 	add	r0, r0, #1
300029e8:	e5830034 	str	r0, [r3, #52]	; 0x34
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
300029ec:	e5821000 	str	r1, [r2]
    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
300029f0:	e59f2038 	ldr	r2, [pc, #56]	; 30002a30 <OS_Sched+0xcc>
300029f4:	e5823000 	str	r3, [r2]

#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
                OS_TASK_SW();                          /* Perform a context switch                     */
300029f8:	ebfff62f 	bl	300002bc <port_task_switch>
            }
        }
    }
    OS_EXIT_CRITICAL();
300029fc:	e1a00004 	mov	r0, r4
30002a00:	ebfff621 	bl	3000028c <OS_CPU_SR_Restore>
}
30002a04:	e8bd4010 	pop	{r4, lr}
30002a08:	e12fff1e 	bx	lr
30002a0c:	3001d094 	mulcc	r1, r4, r0
30002a10:	3001c764 	andcc	ip, r1, r4, ror #14
30002a14:	3001ce84 	andcc	ip, r1, r4, lsl #29
30002a18:	30006abc 	undefined instruction 0x30006abc
30002a1c:	3001ce88 	andcc	ip, r1, r8, lsl #29
30002a20:	3001cb44 	andcc	ip, r1, r4, asr #22
30002a24:	3001c776 	andcc	ip, r1, r6, ror r7
30002a28:	3001dba8 	andcc	sp, r1, r8, lsr #23
30002a2c:	3001ce04 	andcc	ip, r1, r4, lsl #28
30002a30:	3001ce7c 	andcc	ip, r1, ip, ror lr

30002a34 <OSTimeDlyResume>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (prio >= OS_LOWEST_PRIO) {
30002a34:	e350003e 	cmp	r0, #62	; 0x3e
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
30002a38:	e92d4010 	push	{r4, lr}
30002a3c:	e1a04000 	mov	r4, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (prio >= OS_LOWEST_PRIO) {
30002a40:	83a0002a 	movhi	r0, #42	; 0x2a
30002a44:	9a000001 	bls	30002a50 <OSTimeDlyResume+0x1c>
        OS_Sched();                                           /* See if this is new highest priority   */
    } else {
        OS_EXIT_CRITICAL();                                   /* Task may be suspended                 */
    }
    return (OS_NO_ERR);
}
30002a48:	e8bd4010 	pop	{r4, lr}
30002a4c:	e12fff1e 	bx	lr


    if (prio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
    OS_ENTER_CRITICAL();
30002a50:	ebfff605 	bl	3000026c <OS_CPU_SR_Save>
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
30002a54:	e59f30b0 	ldr	r3, [pc, #176]	; 30002b0c <OSTimeDlyResume+0xd8>


    if (prio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
    OS_ENTER_CRITICAL();
30002a58:	e1a01000 	mov	r1, r0
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
30002a5c:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {
30002a60:	e3530000 	cmp	r3, #0
30002a64:	0a000015 	beq	30002ac0 <OSTimeDlyResume+0x8c>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
    }
    if (ptcb == (OS_TCB *)1) {
30002a68:	e3530001 	cmp	r3, #1
30002a6c:	0a000013 	beq	30002ac0 <OSTimeDlyResume+0x8c>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
30002a70:	e1d322ba 	ldrh	r2, [r3, #42]	; 0x2a
30002a74:	e3520000 	cmp	r2, #0
30002a78:	0a00000d 	beq	30002ab4 <OSTimeDlyResume+0x80>
        OS_EXIT_CRITICAL();
        return (OS_TIME_NOT_DLY);                              /* Indicate that task was not delayed   */
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
30002a7c:	e5d3402c 	ldrb	r4, [r3, #44]	; 0x2c
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
        OS_EXIT_CRITICAL();
        return (OS_TIME_NOT_DLY);                              /* Indicate that task was not delayed   */
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
30002a80:	e3a02000 	mov	r2, #0
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
30002a84:	e3140037 	tst	r4, #55	; 0x37
        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag               */
30002a88:	120440c8 	andne	r4, r4, #200	; 0xc8
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
        OS_EXIT_CRITICAL();
        return (OS_TIME_NOT_DLY);                              /* Indicate that task was not delayed   */
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
30002a8c:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag               */
        ptcb->OSTCBPendTO  = OS_TRUE;                          /* Indicate PEND timeout                */
30002a90:	13a02001 	movne	r2, #1
30002a94:	15c3202d 	strbne	r2, [r3, #45]	; 0x2d
        return (OS_TIME_NOT_DLY);                              /* Indicate that task was not delayed   */
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag               */
30002a98:	15c3402c 	strbne	r4, [r3, #44]	; 0x2c
        ptcb->OSTCBPendTO  = OS_TRUE;                          /* Indicate PEND timeout                */
    } else {
        ptcb->OSTCBPendTO  = OS_FALSE;
30002a9c:	05c3202d 	strbeq	r2, [r3, #45]	; 0x2d
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
30002aa0:	e2144008 	ands	r4, r4, #8
30002aa4:	0a000008 	beq	30002acc <OSTimeDlyResume+0x98>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        OS_EXIT_CRITICAL();
        OS_Sched();                                           /* See if this is new highest priority   */
    } else {
        OS_EXIT_CRITICAL();                                   /* Task may be suspended                 */
30002aa8:	ebfff5f7 	bl	3000028c <OS_CPU_SR_Restore>
30002aac:	e3a00000 	mov	r0, #0
30002ab0:	eaffffe4 	b	30002a48 <OSTimeDlyResume+0x14>
    if (ptcb == (OS_TCB *)1) {
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
        OS_EXIT_CRITICAL();
30002ab4:	ebfff5f4 	bl	3000028c <OS_CPU_SR_Restore>
30002ab8:	e3a00050 	mov	r0, #80	; 0x50
        return (OS_TIME_NOT_DLY);                              /* Indicate that task was not delayed   */
30002abc:	eaffffe1 	b	30002a48 <OSTimeDlyResume+0x14>
    if (ptcb == (OS_TCB *)0) {
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
    }
    if (ptcb == (OS_TCB *)1) {
        OS_EXIT_CRITICAL();
30002ac0:	ebfff5f1 	bl	3000028c <OS_CPU_SR_Restore>
30002ac4:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
30002ac8:	eaffffde 	b	30002a48 <OSTimeDlyResume+0x14>
        ptcb->OSTCBPendTO  = OS_TRUE;                          /* Indicate PEND timeout                */
    } else {
        ptcb->OSTCBPendTO  = OS_FALSE;
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
30002acc:	e59f203c 	ldr	r2, [pc, #60]	; 30002b10 <OSTimeDlyResume+0xdc>
30002ad0:	e5d30032 	ldrb	r0, [r3, #50]	; 0x32
30002ad4:	e5d2e000 	ldrb	lr, [r2]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30002ad8:	e59fc034 	ldr	ip, [pc, #52]	; 30002b14 <OSTimeDlyResume+0xe0>
        ptcb->OSTCBPendTO  = OS_TRUE;                          /* Indicate PEND timeout                */
    } else {
        ptcb->OSTCBPendTO  = OS_FALSE;
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
30002adc:	e18e0000 	orr	r0, lr, r0
30002ae0:	e5c20000 	strb	r0, [r2]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30002ae4:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30002ae8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
30002aec:	e7dce002 	ldrb	lr, [ip, r2]
        OS_EXIT_CRITICAL();
30002af0:	e1a00001 	mov	r0, r1
    } else {
        ptcb->OSTCBPendTO  = OS_FALSE;
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30002af4:	e18e3003 	orr	r3, lr, r3
30002af8:	e7cc3002 	strb	r3, [ip, r2]
        OS_EXIT_CRITICAL();
30002afc:	ebfff5e2 	bl	3000028c <OS_CPU_SR_Restore>
        OS_Sched();                                           /* See if this is new highest priority   */
30002b00:	ebffff97 	bl	30002964 <OS_Sched>
30002b04:	e1a00004 	mov	r0, r4
30002b08:	eaffffce 	b	30002a48 <OSTimeDlyResume+0x14>
30002b0c:	3001dba8 	andcc	sp, r1, r8, lsr #23
30002b10:	3001ce84 	andcc	ip, r1, r4, lsl #29
30002b14:	3001ce88 	andcc	ip, r1, r8, lsl #29

30002b18 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
30002b18:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (ticks > 0) {                             /* 0 means no delay!                                  */
30002b1c:	e2504000 	subs	r4, r0, #0
30002b20:	1a000001 	bne	30002b2c <OSTimeDly+0x14>
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
30002b24:	e8bd4010 	pop	{r4, lr}
30002b28:	e12fff1e 	bx	lr
#endif



    if (ticks > 0) {                             /* 0 means no delay!                                  */
        OS_ENTER_CRITICAL();
30002b2c:	ebfff5ce 	bl	3000026c <OS_CPU_SR_Save>
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
30002b30:	e59f3040 	ldr	r3, [pc, #64]	; 30002b78 <OSTimeDly+0x60>
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
30002b34:	e59f1040 	ldr	r1, [pc, #64]	; 30002b7c <OSTimeDly+0x64>



    if (ticks > 0) {                             /* 0 means no delay!                                  */
        OS_ENTER_CRITICAL();
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
30002b38:	e5933000 	ldr	r3, [r3]
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
30002b3c:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30002b40:	e5d3e031 	ldrb	lr, [r3, #49]	; 0x31
30002b44:	e7d1c002 	ldrb	ip, [r1, r2]
30002b48:	e1ccc00e 	bic	ip, ip, lr
        if (OSRdyTbl[y] == 0) {
30002b4c:	e35c0000 	cmp	ip, #0


    if (ticks > 0) {                             /* 0 means no delay!                                  */
        OS_ENTER_CRITICAL();
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
30002b50:	e7c1c002 	strb	ip, [r1, r2]
        if (OSRdyTbl[y] == 0) {
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
30002b54:	059f2024 	ldreq	r2, [pc, #36]	; 30002b80 <OSTimeDly+0x68>
30002b58:	05d3c032 	ldrbeq	ip, [r3, #50]	; 0x32
30002b5c:	05d21000 	ldrbeq	r1, [r2]
30002b60:	01c1100c 	biceq	r1, r1, ip
30002b64:	05c21000 	strbeq	r1, [r2]
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
30002b68:	e1c342ba 	strh	r4, [r3, #42]	; 0x2a
        OS_EXIT_CRITICAL();
30002b6c:	ebfff5c6 	bl	3000028c <OS_CPU_SR_Restore>
        OS_Sched();                              /* Find next task to run!                             */
    }
}
30002b70:	e8bd4010 	pop	{r4, lr}
        if (OSRdyTbl[y] == 0) {
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
30002b74:	eaffff7a 	b	30002964 <OS_Sched>
30002b78:	3001d098 	mulcc	r1, r8, r0
30002b7c:	3001ce88 	andcc	ip, r1, r8, lsl #29
30002b80:	3001ce84 	andcc	ip, r1, r4, lsl #29

30002b84 <OSTimeDlyHMSM>:
    INT32U ticks;
    INT16U loops;


#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
30002b84:	e3500000 	cmp	r0, #0
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)
{
30002b88:	e92d4010 	push	{r4, lr}
    INT32U ticks;
    INT16U loops;


#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
30002b8c:	0a00000a 	beq	30002bbc <OSTimeDlyHMSM+0x38>
                    return (OS_TIME_ZERO_DLY);
                }
            }
        }
    }
    if (minutes > 59) {
30002b90:	e351003b 	cmp	r1, #59	; 0x3b
30002b94:	83a00051 	movhi	r0, #81	; 0x51
30002b98:	8a000005 	bhi	30002bb4 <OSTimeDlyHMSM+0x30>
        return (OS_TIME_INVALID_MINUTES);        /* Validate arguments to be within range              */
    }
    if (seconds > 59) {
30002b9c:	e352003b 	cmp	r2, #59	; 0x3b
30002ba0:	83a00052 	movhi	r0, #82	; 0x52
30002ba4:	8a000002 	bhi	30002bb4 <OSTimeDlyHMSM+0x30>
        return (OS_TIME_INVALID_SECONDS);
    }
    if (milli > 999) {
30002ba8:	e3530ffa 	cmp	r3, #1000	; 0x3e8
30002bac:	23a00053 	movcs	r0, #83	; 0x53
30002bb0:	3a000009 	bcc	30002bdc <OSTimeDlyHMSM+0x58>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_NO_ERR);
}
30002bb4:	e8bd4010 	pop	{r4, lr}
30002bb8:	e12fff1e 	bx	lr
    INT16U loops;


#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
        if (minutes == 0) {
30002bbc:	e3510000 	cmp	r1, #0
30002bc0:	1afffff2 	bne	30002b90 <OSTimeDlyHMSM+0xc>
            if (seconds == 0) {
30002bc4:	e3520000 	cmp	r2, #0
30002bc8:	1afffff3 	bne	30002b9c <OSTimeDlyHMSM+0x18>
                if (milli == 0) {
30002bcc:	e3530000 	cmp	r3, #0
30002bd0:	03a00054 	moveq	r0, #84	; 0x54
30002bd4:	1afffff3 	bne	30002ba8 <OSTimeDlyHMSM+0x24>
30002bd8:	eafffff5 	b	30002bb4 <OSTimeDlyHMSM+0x30>
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
30002bdc:	e1a0c301 	lsl	ip, r1, #6
30002be0:	e0833103 	add	r3, r3, r3, lsl #2
30002be4:	e04c1101 	sub	r1, ip, r1, lsl #2
30002be8:	e0833103 	add	r3, r3, r3, lsl #2
30002bec:	e060c180 	rsb	ip, r0, r0, lsl #3
30002bf0:	e0812002 	add	r2, r1, r2
30002bf4:	e1a03103 	lsl	r3, r3, #2
30002bf8:	e59f105c 	ldr	r1, [pc, #92]	; 30002c5c <OSTimeDlyHMSM+0xd8>
30002bfc:	e080028c 	add	r0, r0, ip, lsl #5
30002c00:	e2833f7d 	add	r3, r3, #500	; 0x1f4
30002c04:	e084c391 	umull	ip, r4, r1, r3
30002c08:	e0822200 	add	r2, r2, r0, lsl #4
30002c0c:	e0822102 	add	r2, r2, r2, lsl #2
30002c10:	e0822102 	add	r2, r2, r2, lsl #2
30002c14:	e1a02102 	lsl	r2, r2, #2
30002c18:	e0824324 	add	r4, r2, r4, lsr #6
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
30002c1c:	e1a00804 	lsl	r0, r4, #16
30002c20:	e1a00820 	lsr	r0, r0, #16
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
30002c24:	e1a04824 	lsr	r4, r4, #16
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
30002c28:	ebffffba 	bl	30002b18 <OSTimeDly>
    while (loops > 0) {
30002c2c:	e3540000 	cmp	r4, #0
30002c30:	0a000007 	beq	30002c54 <OSTimeDlyHMSM+0xd0>
        OSTimeDly((INT16U)32768u);
30002c34:	e3a00902 	mov	r0, #32768	; 0x8000
        OSTimeDly((INT16U)32768u);
        loops--;
30002c38:	e2444001 	sub	r4, r4, #1
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
        OSTimeDly((INT16U)32768u);
30002c3c:	ebffffb5 	bl	30002b18 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
        loops--;
30002c40:	e1a04804 	lsl	r4, r4, #16
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
30002c44:	e3a00902 	mov	r0, #32768	; 0x8000
30002c48:	ebffffb2 	bl	30002b18 <OSTimeDly>
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
30002c4c:	e1b04824 	lsrs	r4, r4, #16
30002c50:	1afffff7 	bne	30002c34 <OSTimeDlyHMSM+0xb0>
30002c54:	e3a00000 	mov	r0, #0
30002c58:	eaffffd5 	b	30002bb4 <OSTimeDlyHMSM+0x30>
30002c5c:	10624dd3 	ldrdne	r4, [r2], #-211	; 0xffffff2d

30002c60 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
30002c60:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif



    p_arg = p_arg;                               /* Prevent compiler warning for not using 'parg'      */
    while (OSStatRdy == OS_FALSE) {
30002c64:	e59f409c 	ldr	r4, [pc, #156]	; 30002d08 <OS_TaskStat+0xa8>
30002c68:	e5d43000 	ldrb	r3, [r4]
30002c6c:	e3530000 	cmp	r3, #0
30002c70:	1a000004 	bne	30002c88 <OS_TaskStat+0x28>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
30002c74:	e3a00014 	mov	r0, #20
30002c78:	ebffffa6 	bl	30002b18 <OSTimeDly>
#endif



    p_arg = p_arg;                               /* Prevent compiler warning for not using 'parg'      */
    while (OSStatRdy == OS_FALSE) {
30002c7c:	e5d43000 	ldrb	r3, [r4]
30002c80:	e3530000 	cmp	r3, #0
30002c84:	0afffffa 	beq	30002c74 <OS_TaskStat+0x14>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    max = OSIdleCtrMax / 100L;
30002c88:	e59fa07c 	ldr	sl, [pc, #124]	; 30002d0c <OS_TaskStat+0xac>
30002c8c:	e3a01064 	mov	r1, #100	; 0x64
30002c90:	e59a0000 	ldr	r0, [sl]
30002c94:	eb000f3c 	bl	3000698c <__aeabi_uidiv>
30002c98:	e59f5070 	ldr	r5, [pc, #112]	; 30002d10 <OS_TaskStat+0xb0>
30002c9c:	e59f8070 	ldr	r8, [pc, #112]	; 30002d14 <OS_TaskStat+0xb4>
30002ca0:	e59f7070 	ldr	r7, [pc, #112]	; 30002d18 <OS_TaskStat+0xb8>
            } else {
                OSCPUUsage = 0;
            }
        } else {
            OSCPUUsage = 0;
            max        = OSIdleCtrMax / 100L;
30002ca4:	e59f9070 	ldr	r9, [pc, #112]	; 30002d1c <OS_TaskStat+0xbc>

    p_arg = p_arg;                               /* Prevent compiler warning for not using 'parg'      */
    while (OSStatRdy == OS_FALSE) {
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    max = OSIdleCtrMax / 100L;
30002ca8:	e1a04000 	mov	r4, r0
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
        run          = OSIdleCtr;
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
30002cac:	e3a06000 	mov	r6, #0
30002cb0:	ea000006 	b	30002cd0 <OS_TaskStat+0x70>
        OS_EXIT_CRITICAL();
        if (max > 0L) {
            usage = (INT8S)(100L - run / max);
            if (usage >= 0) {                    /* Make sure we don't have a negative percentage      */
                OSCPUUsage = usage;
30002cb4:	eb000f34 	bl	3000698c <__aeabi_uidiv>
30002cb8:	e2600064 	rsb	r0, r0, #100	; 0x64
30002cbc:	e5c70000 	strb	r0, [r7]
            }
        } else {
            OSCPUUsage = 0;
            max        = OSIdleCtrMax / 100L;
        }
        OSTaskStatHook();                        /* Invoke user definable hook                         */
30002cc0:	eb000f29 	bl	3000696c <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
30002cc4:	ebfff986 	bl	300012e4 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
30002cc8:	e3a0000a 	mov	r0, #10
30002ccc:	ebffff91 	bl	30002b18 <OSTimeDly>
    while (OSStatRdy == OS_FALSE) {
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    max = OSIdleCtrMax / 100L;
    for (;;) {
        OS_ENTER_CRITICAL();
30002cd0:	ebfff565 	bl	3000026c <OS_CPU_SR_Save>
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
30002cd4:	e5953000 	ldr	r3, [r5]
        run          = OSIdleCtr;
30002cd8:	e595b000 	ldr	fp, [r5]
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    max = OSIdleCtrMax / 100L;
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
30002cdc:	e5883000 	str	r3, [r8]
        run          = OSIdleCtr;
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
30002ce0:	e5856000 	str	r6, [r5]
        OS_EXIT_CRITICAL();
30002ce4:	ebfff568 	bl	3000028c <OS_CPU_SR_Restore>
        if (max > 0L) {
30002ce8:	e2541000 	subs	r1, r4, #0
            usage = (INT8S)(100L - run / max);
            if (usage >= 0) {                    /* Make sure we don't have a negative percentage      */
                OSCPUUsage = usage;
30002cec:	e1a0000b 	mov	r0, fp
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
        run          = OSIdleCtr;
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
        OS_EXIT_CRITICAL();
        if (max > 0L) {
30002cf0:	1affffef 	bne	30002cb4 <OS_TaskStat+0x54>
            } else {
                OSCPUUsage = 0;
            }
        } else {
            OSCPUUsage = 0;
            max        = OSIdleCtrMax / 100L;
30002cf4:	e59a3000 	ldr	r3, [sl]
                OSCPUUsage = usage;
            } else {
                OSCPUUsage = 0;
            }
        } else {
            OSCPUUsage = 0;
30002cf8:	e5c74000 	strb	r4, [r7]
            max        = OSIdleCtrMax / 100L;
30002cfc:	e0842399 	umull	r2, r4, r9, r3
30002d00:	e1a042a4 	lsr	r4, r4, #5
30002d04:	eaffffed 	b	30002cc0 <OS_TaskStat+0x60>
30002d08:	3001dba4 	andcc	sp, r1, r4, lsr #23
30002d0c:	3001ce0c 	andcc	ip, r1, ip, lsl #28
30002d10:	3001c770 	andcc	ip, r1, r0, ror r7
30002d14:	3001dca8 	andcc	sp, r1, r8, lsr #25
30002d18:	3001ce14 	andcc	ip, r1, r4, lsl lr
30002d1c:	51eb851f 	mvnpl	r8, pc, lsl r5

30002d20 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
30002d20:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
30002d24:	e3a00002 	mov	r0, #2
    OS_ENTER_CRITICAL();
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
30002d28:	e59f4040 	ldr	r4, [pc, #64]	; 30002d70 <OSStatInit+0x50>
    OS_CPU_SR  cpu_sr = 0;
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
30002d2c:	ebffff79 	bl	30002b18 <OSTimeDly>
    OS_ENTER_CRITICAL();
30002d30:	ebfff54d 	bl	3000026c <OS_CPU_SR_Save>
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
30002d34:	e3a03000 	mov	r3, #0
30002d38:	e5843000 	str	r3, [r4]
    OS_EXIT_CRITICAL();
30002d3c:	ebfff552 	bl	3000028c <OS_CPU_SR_Restore>
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
30002d40:	e3a0000a 	mov	r0, #10
30002d44:	ebffff73 	bl	30002b18 <OSTimeDly>
    OS_ENTER_CRITICAL();
30002d48:	ebfff547 	bl	3000026c <OS_CPU_SR_Save>
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
30002d4c:	e5942000 	ldr	r2, [r4]
30002d50:	e59f301c 	ldr	r3, [pc, #28]	; 30002d74 <OSStatInit+0x54>
30002d54:	e5832000 	str	r2, [r3]
    OSStatRdy    = OS_TRUE;
30002d58:	e59f3018 	ldr	r3, [pc, #24]	; 30002d78 <OSStatInit+0x58>
30002d5c:	e3a02001 	mov	r2, #1
30002d60:	e5c32000 	strb	r2, [r3]
    OS_EXIT_CRITICAL();
30002d64:	ebfff548 	bl	3000028c <OS_CPU_SR_Restore>
}
30002d68:	e8bd4010 	pop	{r4, lr}
30002d6c:	e12fff1e 	bx	lr
30002d70:	3001c770 	andcc	ip, r1, r0, ror r7
30002d74:	3001ce0c 	andcc	ip, r1, ip, lsl #28
30002d78:	3001dba4 	andcc	sp, r1, r4, lsr #23

30002d7c <OSTaskSuspend>:
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
30002d7c:	e350003f 	cmp	r0, #63	; 0x3f
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
30002d80:	e92d4010 	push	{r4, lr}
30002d84:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
30002d88:	03a0005b 	moveq	r0, #91	; 0x5b
30002d8c:	0a000004 	beq	30002da4 <OSTaskSuspend+0x28>
        return (OS_TASK_SUSPEND_IDLE);
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
30002d90:	e354003e 	cmp	r4, #62	; 0x3e
30002d94:	9a000025 	bls	30002e30 <OSTaskSuspend+0xb4>
        if (prio != OS_PRIO_SELF) {
30002d98:	e35400ff 	cmp	r4, #255	; 0xff
30002d9c:	13a0002a 	movne	r0, #42	; 0x2a
30002da0:	0a000001 	beq	30002dac <OSTaskSuspend+0x30>
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
        OS_Sched();
    }
    return (OS_NO_ERR);
}
30002da4:	e8bd4010 	pop	{r4, lr}
30002da8:	e12fff1e 	bx	lr
        if (prio != OS_PRIO_SELF) {
            return (OS_PRIO_INVALID);
        }
    }
#endif
    OS_ENTER_CRITICAL();
30002dac:	ebfff52e 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
        prio = OSTCBCur->OSTCBPrio;
30002db0:	e59f30b4 	ldr	r3, [pc, #180]	; 30002e6c <OSTaskSuspend+0xf0>
30002db4:	e3a04001 	mov	r4, #1
30002db8:	e5933000 	ldr	r3, [r3]
30002dbc:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
        self = OS_TRUE;
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
    }
    ptcb = OSTCBPrioTbl[prio];
30002dc0:	e59f20a8 	ldr	r2, [pc, #168]	; 30002e70 <OSTaskSuspend+0xf4>
30002dc4:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
30002dc8:	e3530000 	cmp	r3, #0
30002dcc:	0a000020 	beq	30002e54 <OSTaskSuspend+0xd8>
        OS_EXIT_CRITICAL();
        return (OS_TASK_SUSPEND_PRIO);
    }
    if (ptcb == (OS_TCB *)1) {                                  /* See if assigned to Mutex            */
30002dd0:	e3530001 	cmp	r3, #1
30002dd4:	0a000021 	beq	30002e60 <OSTaskSuspend+0xe4>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    y            = ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
30002dd8:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30002ddc:	e59f1090 	ldr	r1, [pc, #144]	; 30002e74 <OSTaskSuspend+0xf8>
30002de0:	e5d3e031 	ldrb	lr, [r3, #49]	; 0x31
30002de4:	e7d1c002 	ldrb	ip, [r1, r2]
30002de8:	e1ccc00e 	bic	ip, ip, lr
    if (OSRdyTbl[y] == 0) {
30002dec:	e35c0000 	cmp	ip, #0
    if (ptcb == (OS_TCB *)1) {                                  /* See if assigned to Mutex            */
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    y            = ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
30002df0:	e7c1c002 	strb	ip, [r1, r2]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
30002df4:	059f207c 	ldreq	r2, [pc, #124]	; 30002e78 <OSTaskSuspend+0xfc>
30002df8:	05d3c032 	ldrbeq	ip, [r3, #50]	; 0x32
30002dfc:	05d21000 	ldrbeq	r1, [r2]
30002e00:	01c1100c 	biceq	r1, r1, ip
30002e04:	05c21000 	strbeq	r1, [r2]
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
30002e08:	e5d3202c 	ldrb	r2, [r3, #44]	; 0x2c
30002e0c:	e3822008 	orr	r2, r2, #8
30002e10:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OS_EXIT_CRITICAL();
30002e14:	ebfff51c 	bl	3000028c <OS_CPU_SR_Restore>
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
30002e18:	e3540001 	cmp	r4, #1
        OS_Sched();
30002e1c:	13a00000 	movne	r0, #0
30002e20:	1affffdf 	bne	30002da4 <OSTaskSuspend+0x28>
30002e24:	ebfffece 	bl	30002964 <OS_Sched>
30002e28:	e3a00000 	mov	r0, #0
30002e2c:	eaffffdc 	b	30002da4 <OSTaskSuspend+0x28>
        if (prio != OS_PRIO_SELF) {
            return (OS_PRIO_INVALID);
        }
    }
#endif
    OS_ENTER_CRITICAL();
30002e30:	ebfff50d 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
        prio = OSTCBCur->OSTCBPrio;
        self = OS_TRUE;
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
30002e34:	e59f3030 	ldr	r3, [pc, #48]	; 30002e6c <OSTaskSuspend+0xf0>
30002e38:	e5933000 	ldr	r3, [r3]
30002e3c:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
30002e40:	e1530004 	cmp	r3, r4
30002e44:	11a03004 	movne	r3, r4
30002e48:	03a04001 	moveq	r4, #1
30002e4c:	13a04000 	movne	r4, #0
30002e50:	eaffffda 	b	30002dc0 <OSTaskSuspend+0x44>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
    }
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
        OS_EXIT_CRITICAL();
30002e54:	ebfff50c 	bl	3000028c <OS_CPU_SR_Restore>
30002e58:	e3a0005a 	mov	r0, #90	; 0x5a
        return (OS_TASK_SUSPEND_PRIO);
30002e5c:	eaffffd0 	b	30002da4 <OSTaskSuspend+0x28>
    }
    if (ptcb == (OS_TCB *)1) {                                  /* See if assigned to Mutex            */
        OS_EXIT_CRITICAL();
30002e60:	ebfff509 	bl	3000028c <OS_CPU_SR_Restore>
30002e64:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);
30002e68:	eaffffcd 	b	30002da4 <OSTaskSuspend+0x28>
30002e6c:	3001d098 	mulcc	r1, r8, r0
30002e70:	3001dba8 	andcc	sp, r1, r8, lsr #23
30002e74:	3001ce88 	andcc	ip, r1, r8, lsl #29
30002e78:	3001ce84 	andcc	ip, r1, r4, lsl #29

30002e7c <OSTaskResume>:
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
30002e7c:	e350003e 	cmp	r0, #62	; 0x3e
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
30002e80:	e92d4070 	push	{r4, r5, r6, lr}
30002e84:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
30002e88:	83a0002a 	movhi	r0, #42	; 0x2a
30002e8c:	9a000001 	bls	30002e98 <OSTaskResume+0x1c>
        }
        return (OS_NO_ERR);
    }
    OS_EXIT_CRITICAL();
    return (OS_TASK_NOT_SUSPENDED);
}
30002e90:	e8bd4070 	pop	{r4, r5, r6, lr}
30002e94:	e12fff1e 	bx	lr
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
30002e98:	ebfff4f3 	bl	3000026c <OS_CPU_SR_Save>
    ptcb = OSTCBPrioTbl[prio];
30002e9c:	e59f30b0 	ldr	r3, [pc, #176]	; 30002f54 <OSTaskResume+0xd8>
30002ea0:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
30002ea4:	e3530000 	cmp	r3, #0
30002ea8:	0a000020 	beq	30002f30 <OSTaskResume+0xb4>
        OS_EXIT_CRITICAL();
        return (OS_TASK_RESUME_PRIO);
    }
    if (ptcb == (OS_TCB *)1) {                                /* See if assigned to Mutex              */
30002eac:	e3530001 	cmp	r3, #1
30002eb0:	0a000021 	beq	30002f3c <OSTaskResume+0xc0>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
30002eb4:	e5d3402c 	ldrb	r4, [r3, #44]	; 0x2c
30002eb8:	e3140008 	tst	r4, #8
30002ebc:	0a000015 	beq	30002f18 <OSTaskResume+0x9c>
        ptcb->OSTCBStat &= ~OS_STAT_SUSPEND;                  /* Remove suspension                     */
30002ec0:	e20440f7 	and	r4, r4, #247	; 0xf7
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
30002ec4:	e3540000 	cmp	r4, #0
    if (ptcb == (OS_TCB *)1) {                                /* See if assigned to Mutex              */
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
        ptcb->OSTCBStat &= ~OS_STAT_SUSPEND;                  /* Remove suspension                     */
30002ec8:	e5c3402c 	strb	r4, [r3, #44]	; 0x2c
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
30002ecc:	1a00001d 	bne	30002f48 <OSTaskResume+0xcc>
            if (ptcb->OSTCBDly == 0) {
30002ed0:	e1d352ba 	ldrh	r5, [r3, #42]	; 0x2a
30002ed4:	e3550000 	cmp	r5, #0
30002ed8:	1a000011 	bne	30002f24 <OSTaskResume+0xa8>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
30002edc:	e59f2074 	ldr	r2, [pc, #116]	; 30002f58 <OSTaskResume+0xdc>
30002ee0:	e5d3c032 	ldrb	ip, [r3, #50]	; 0x32
30002ee4:	e5d2e000 	ldrb	lr, [r2]
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30002ee8:	e59f106c 	ldr	r1, [pc, #108]	; 30002f5c <OSTaskResume+0xe0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
        ptcb->OSTCBStat &= ~OS_STAT_SUSPEND;                  /* Remove suspension                     */
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
            if (ptcb->OSTCBDly == 0) {
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
30002eec:	e18ec00c 	orr	ip, lr, ip
30002ef0:	e5c2c000 	strb	ip, [r2]
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30002ef4:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30002ef8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
30002efc:	e7d1c002 	ldrb	ip, [r1, r2]
30002f00:	e18c3003 	orr	r3, ip, r3
30002f04:	e7c13002 	strb	r3, [r1, r2]
                OS_EXIT_CRITICAL();
30002f08:	ebfff4df 	bl	3000028c <OS_CPU_SR_Restore>
                OS_Sched();
30002f0c:	ebfffe94 	bl	30002964 <OS_Sched>
30002f10:	e1a00005 	mov	r0, r5
30002f14:	eaffffdd 	b	30002e90 <OSTaskResume+0x14>
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_NO_ERR);
    }
    OS_EXIT_CRITICAL();
30002f18:	ebfff4db 	bl	3000028c <OS_CPU_SR_Restore>
30002f1c:	e3a00065 	mov	r0, #101	; 0x65
    return (OS_TASK_NOT_SUSPENDED);
30002f20:	eaffffda 	b	30002e90 <OSTaskResume+0x14>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                OS_EXIT_CRITICAL();
                OS_Sched();
            } else {
                OS_EXIT_CRITICAL();
30002f24:	ebfff4d8 	bl	3000028c <OS_CPU_SR_Restore>
30002f28:	e1a00004 	mov	r0, r4
30002f2c:	eaffffd7 	b	30002e90 <OSTaskResume+0x14>
    }
#endif
    OS_ENTER_CRITICAL();
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
        OS_EXIT_CRITICAL();
30002f30:	ebfff4d5 	bl	3000028c <OS_CPU_SR_Restore>
30002f34:	e3a00064 	mov	r0, #100	; 0x64
        return (OS_TASK_RESUME_PRIO);
30002f38:	eaffffd4 	b	30002e90 <OSTaskResume+0x14>
    }
    if (ptcb == (OS_TCB *)1) {                                /* See if assigned to Mutex              */
        OS_EXIT_CRITICAL();
30002f3c:	ebfff4d2 	bl	3000028c <OS_CPU_SR_Restore>
30002f40:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);
30002f44:	eaffffd1 	b	30002e90 <OSTaskResume+0x14>
                OS_Sched();
            } else {
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
30002f48:	ebfff4cf 	bl	3000028c <OS_CPU_SR_Restore>
30002f4c:	e3a00000 	mov	r0, #0
30002f50:	eaffffce 	b	30002e90 <OSTaskResume+0x14>
30002f54:	3001dba8 	andcc	sp, r1, r8, lsr #23
30002f58:	3001ce84 	andcc	ip, r1, r4, lsl #29
30002f5c:	3001ce88 	andcc	ip, r1, r8, lsl #29

30002f60 <OSTaskDel>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
30002f60:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    OS_CPU_SR     cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                     /* See if trying to delete from ISR    */
30002f64:	e59f31f4 	ldr	r3, [pc, #500]	; 30003160 <OSTaskDel+0x200>
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
30002f68:	e1a05000 	mov	r5, r0
    OS_CPU_SR     cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                     /* See if trying to delete from ISR    */
30002f6c:	e5d33000 	ldrb	r3, [r3]
30002f70:	e3530000 	cmp	r3, #0
30002f74:	13a0003f 	movne	r0, #63	; 0x3f
30002f78:	1a000007 	bne	30002f9c <OSTaskDel+0x3c>
        return (OS_TASK_DEL_ISR);
    }
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
30002f7c:	e355003f 	cmp	r5, #63	; 0x3f
30002f80:	03a0003d 	moveq	r0, #61	; 0x3d
30002f84:	0a000004 	beq	30002f9c <OSTaskDel+0x3c>
        return (OS_TASK_DEL_IDLE);
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
30002f88:	e355003e 	cmp	r5, #62	; 0x3e
30002f8c:	9a000066 	bls	3000312c <OSTaskDel+0x1cc>
        if (prio != OS_PRIO_SELF) {
30002f90:	e35500ff 	cmp	r5, #255	; 0xff
30002f94:	13a0002a 	movne	r0, #42	; 0x2a
30002f98:	0a000001 	beq	30002fa4 <OSTaskDel+0x44>
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OS_EXIT_CRITICAL();
    OS_Sched();                                                 /* Find new highest priority task      */
    return (OS_NO_ERR);
}
30002f9c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30002fa0:	e12fff1e 	bx	lr
            return (OS_PRIO_INVALID);
        }
    }
#endif

    OS_ENTER_CRITICAL();
30002fa4:	ebfff4b0 	bl	3000026c <OS_CPU_SR_Save>
    if (prio == OS_PRIO_SELF) {                                 /* See if requesting to delete self    */
        prio = OSTCBCur->OSTCBPrio;                             /* Set priority to delete to current   */
30002fa8:	e59f31b4 	ldr	r3, [pc, #436]	; 30003164 <OSTaskDel+0x204>
30002fac:	e5933000 	ldr	r3, [r3]
30002fb0:	e5d3502e 	ldrb	r5, [r3, #46]	; 0x2e
    }
    ptcb = OSTCBPrioTbl[prio];
30002fb4:	e59f71ac 	ldr	r7, [pc, #428]	; 30003168 <OSTaskDel+0x208>
30002fb8:	e7974105 	ldr	r4, [r7, r5, lsl #2]
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
30002fbc:	e3540000 	cmp	r4, #0
30002fc0:	0a00005b 	beq	30003134 <OSTaskDel+0x1d4>
        OS_EXIT_CRITICAL();
        return (OS_TASK_NOT_EXIST);
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Must not be assigned to Mutex       */
30002fc4:	e3540001 	cmp	r4, #1
30002fc8:	0a00005c 	beq	30003140 <OSTaskDel+0x1e0>
        OS_EXIT_CRITICAL();
        return (OS_TASK_DEL_ERR);
    }
    y            =  ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30002fcc:	e59f2198 	ldr	r2, [pc, #408]	; 3000316c <OSTaskDel+0x20c>
30002fd0:	e5d43030 	ldrb	r3, [r4, #48]	; 0x30
30002fd4:	e5d4c031 	ldrb	ip, [r4, #49]	; 0x31
30002fd8:	e7d21003 	ldrb	r1, [r2, r3]
30002fdc:	e1c1100c 	bic	r1, r1, ip
    if (OSRdyTbl[y] == 0) {                                     /* Make task not ready                 */
30002fe0:	e3510000 	cmp	r1, #0
    if (ptcb == (OS_TCB *)1) {                                  /* Must not be assigned to Mutex       */
        OS_EXIT_CRITICAL();
        return (OS_TASK_DEL_ERR);
    }
    y            =  ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30002fe4:	e7c21003 	strb	r1, [r2, r3]
    if (OSRdyTbl[y] == 0) {                                     /* Make task not ready                 */
        OSRdyGrp &= ~ptcb->OSTCBBitY;
30002fe8:	059f2180 	ldreq	r2, [pc, #384]	; 30003170 <OSTaskDel+0x210>
30002fec:	05d4c032 	ldrbeq	ip, [r4, #50]	; 0x32
30002ff0:	05d21000 	ldrbeq	r1, [r2]
30002ff4:	01c1100c 	biceq	r1, r1, ip
30002ff8:	05c21000 	strbeq	r1, [r2]
    }
    
#if OS_EVENT_EN
    pevent = ptcb->OSTCBEventPtr;
30002ffc:	e594201c 	ldr	r2, [r4, #28]
    if (pevent != (OS_EVENT *)0) {                              /* If task is waiting on event         */
30003000:	e3520000 	cmp	r2, #0
30003004:	0a00000a 	beq	30003034 <OSTaskDel+0xd4>
        pevent->OSEventTbl[y] &= ~ptcb->OSTCBBitX;
30003008:	e0823003 	add	r3, r2, r3
3000300c:	e2833008 	add	r3, r3, #8
30003010:	e5d31003 	ldrb	r1, [r3, #3]
30003014:	e5d4c031 	ldrb	ip, [r4, #49]	; 0x31
30003018:	e1c1100c 	bic	r1, r1, ip
        if (pevent->OSEventTbl[y] == 0) {                       /* ... remove task from ...            */
3000301c:	e3510000 	cmp	r1, #0
    }
    
#if OS_EVENT_EN
    pevent = ptcb->OSTCBEventPtr;
    if (pevent != (OS_EVENT *)0) {                              /* If task is waiting on event         */
        pevent->OSEventTbl[y] &= ~ptcb->OSTCBBitX;
30003020:	e5c31003 	strb	r1, [r3, #3]
        if (pevent->OSEventTbl[y] == 0) {                       /* ... remove task from ...            */
            pevent->OSEventGrp &= ~ptcb->OSTCBBitY;             /* ... event ctrl block                */
30003024:	05d41032 	ldrbeq	r1, [r4, #50]	; 0x32
30003028:	05d2300a 	ldrbeq	r3, [r2, #10]
3000302c:	01c33001 	biceq	r3, r3, r1
30003030:	05c2300a 	strbeq	r3, [r2, #10]
        }
    }
#endif

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
30003034:	e5943024 	ldr	r3, [r4, #36]	; 0x24
    if (pnode != (OS_FLAG_NODE *)0) {                           /* If task is waiting on event flag    */
30003038:	e3530000 	cmp	r3, #0
3000303c:	0a00000a 	beq	3000306c <OSTaskDel+0x10c>
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
30003040:	e5931004 	ldr	r1, [r3, #4]
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
30003044:	e5932000 	ldr	r2, [r3]
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
30003048:	e3510000 	cmp	r1, #0
3000304c:	0a00003e 	beq	3000314c <OSTaskDel+0x1ec>
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
30003050:	e3520000 	cmp	r2, #0
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
30003054:	e5812000 	str	r2, [r1]
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
30003058:	0a000000 	beq	30003060 <OSTaskDel+0x100>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
3000305c:	e5821004 	str	r1, [r2, #4]
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
30003060:	e5933008 	ldr	r3, [r3, #8]
30003064:	e3a02000 	mov	r2, #0
30003068:	e5832024 	str	r2, [r3, #36]	; 0x24
        OS_FlagUnlink(pnode);                                   /* Remove from wait list               */
    }
#endif

    ptcb->OSTCBDly    = 0;                                      /* Prevent OSTimeTick() from updating  */
3000306c:	e3a03000 	mov	r3, #0
    ptcb->OSTCBStat   = OS_STAT_RDY;                            /* Prevent task from being resumed     */
    ptcb->OSTCBPendTO = OS_FALSE;
    if (OSLockNesting < 255u) {                                 /* Make sure we don't context switch   */
30003070:	e59f60fc 	ldr	r6, [pc, #252]	; 30003174 <OSTaskDel+0x214>
        OS_FlagUnlink(pnode);                                   /* Remove from wait list               */
    }
#endif

    ptcb->OSTCBDly    = 0;                                      /* Prevent OSTimeTick() from updating  */
    ptcb->OSTCBStat   = OS_STAT_RDY;                            /* Prevent task from being resumed     */
30003074:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
    ptcb->OSTCBPendTO = OS_FALSE;
30003078:	e5c4302d 	strb	r3, [r4, #45]	; 0x2d
    if (OSLockNesting < 255u) {                                 /* Make sure we don't context switch   */
3000307c:	e5d62000 	ldrb	r2, [r6]
    if (pnode != (OS_FLAG_NODE *)0) {                           /* If task is waiting on event flag    */
        OS_FlagUnlink(pnode);                                   /* Remove from wait list               */
    }
#endif

    ptcb->OSTCBDly    = 0;                                      /* Prevent OSTimeTick() from updating  */
30003080:	e1c432ba 	strh	r3, [r4, #42]	; 0x2a
    ptcb->OSTCBStat   = OS_STAT_RDY;                            /* Prevent task from being resumed     */
    ptcb->OSTCBPendTO = OS_FALSE;
    if (OSLockNesting < 255u) {                                 /* Make sure we don't context switch   */
30003084:	e35200ff 	cmp	r2, #255	; 0xff
        OSLockNesting++;
30003088:	12822001 	addne	r2, r2, #1
3000308c:	15c62000 	strbne	r2, [r6]
    }
    OS_EXIT_CRITICAL();                                         /* Enabling INT. ignores next instruc. */
30003090:	ebfff47d 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Dummy();                                                 /* ... Dummy ensures that INTs will be */
    OS_ENTER_CRITICAL();                                        /* ... disabled HERE!                  */
30003094:	ebfff474 	bl	3000026c <OS_CPU_SR_Save>
    if (OSLockNesting > 0) {                                    /* Remove context switch lock          */
30003098:	e5d63000 	ldrb	r3, [r6]
    if (OSLockNesting < 255u) {                                 /* Make sure we don't context switch   */
        OSLockNesting++;
    }
    OS_EXIT_CRITICAL();                                         /* Enabling INT. ignores next instruc. */
    OS_Dummy();                                                 /* ... Dummy ensures that INTs will be */
    OS_ENTER_CRITICAL();                                        /* ... disabled HERE!                  */
3000309c:	e1a08000 	mov	r8, r0
    if (OSLockNesting > 0) {                                    /* Remove context switch lock          */
300030a0:	e3530000 	cmp	r3, #0
        OSLockNesting--;
300030a4:	159f20c8 	ldrne	r2, [pc, #200]	; 30003174 <OSTaskDel+0x214>
300030a8:	12433001 	subne	r3, r3, #1
300030ac:	15c23000 	strbne	r3, [r2]
    }
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
300030b0:	e1a00004 	mov	r0, r4
300030b4:	eb000e26 	bl	30006954 <OSTaskDelHook>
    OSTaskCtr--;                                                /* One less task being managed         */
300030b8:	e59f30b8 	ldr	r3, [pc, #184]	; 30003178 <OSTaskDel+0x218>
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
300030bc:	e3a01000 	mov	r1, #0
    OS_ENTER_CRITICAL();                                        /* ... disabled HERE!                  */
    if (OSLockNesting > 0) {                                    /* Remove context switch lock          */
        OSLockNesting--;
    }
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
300030c0:	e5d32000 	ldrb	r2, [r3]
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
300030c4:	e7871105 	str	r1, [r7, r5, lsl #2]
    OS_ENTER_CRITICAL();                                        /* ... disabled HERE!                  */
    if (OSLockNesting > 0) {                                    /* Remove context switch lock          */
        OSLockNesting--;
    }
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
300030c8:	e2422001 	sub	r2, r2, #1
300030cc:	e5c32000 	strb	r2, [r3]
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
300030d0:	e5943018 	ldr	r3, [r4, #24]
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                          /* Return TCB to free TCB list         */
    OSTCBFreeList     = ptcb;
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                               /* Unknown name                        */
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
300030d4:	e3a05000 	mov	r5, #0
        OSLockNesting--;
    }
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
300030d8:	e1530001 	cmp	r3, r1
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
        OSTCBList                  = ptcb->OSTCBNext;
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
300030dc:	15942014 	ldrne	r2, [r4, #20]
    }
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
300030e0:	05942014 	ldreq	r2, [r4, #20]
        OSTCBList                  = ptcb->OSTCBNext;
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
300030e4:	15832014 	strne	r2, [r3, #20]
    }
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
300030e8:	05823018 	streq	r3, [r2, #24]
        OSTCBList                  = ptcb->OSTCBNext;
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
300030ec:	15942014 	ldrne	r2, [r4, #20]
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
        OSTCBList                  = ptcb->OSTCBNext;
300030f0:	059f3084 	ldreq	r3, [pc, #132]	; 3000317c <OSTaskDel+0x21c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
300030f4:	15823018 	strne	r3, [r2, #24]
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
    OSTaskCtr--;                                                /* One less task being managed         */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
        OSTCBList                  = ptcb->OSTCBNext;
300030f8:	05832000 	streq	r2, [r3]
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                          /* Return TCB to free TCB list         */
300030fc:	e59f307c 	ldr	r3, [pc, #124]	; 30003180 <OSTaskDel+0x220>
    OSTCBFreeList     = ptcb;
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                               /* Unknown name                        */
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OS_EXIT_CRITICAL();
30003100:	e1a00008 	mov	r0, r8
        OSTCBList                  = ptcb->OSTCBNext;
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                          /* Return TCB to free TCB list         */
30003104:	e5932000 	ldr	r2, [r3]
30003108:	e5842014 	str	r2, [r4, #20]
    OSTCBFreeList     = ptcb;
3000310c:	e5834000 	str	r4, [r3]
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                               /* Unknown name                        */
30003110:	e3a0303f 	mov	r3, #63	; 0x3f
30003114:	e5c43048 	strb	r3, [r4, #72]	; 0x48
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
30003118:	e5c45049 	strb	r5, [r4, #73]	; 0x49
#endif
    OS_EXIT_CRITICAL();
3000311c:	ebfff45a 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Sched();                                                 /* Find new highest priority task      */
30003120:	ebfffe0f 	bl	30002964 <OS_Sched>
30003124:	e1a00005 	mov	r0, r5
    return (OS_NO_ERR);
30003128:	eaffff9b 	b	30002f9c <OSTaskDel+0x3c>
            return (OS_PRIO_INVALID);
        }
    }
#endif

    OS_ENTER_CRITICAL();
3000312c:	ebfff44e 	bl	3000026c <OS_CPU_SR_Save>
30003130:	eaffff9f 	b	30002fb4 <OSTaskDel+0x54>
    if (prio == OS_PRIO_SELF) {                                 /* See if requesting to delete self    */
        prio = OSTCBCur->OSTCBPrio;                             /* Set priority to delete to current   */
    }
    ptcb = OSTCBPrioTbl[prio];
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
        OS_EXIT_CRITICAL();
30003134:	ebfff454 	bl	3000028c <OS_CPU_SR_Restore>
30003138:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);
3000313c:	eaffff96 	b	30002f9c <OSTaskDel+0x3c>
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Must not be assigned to Mutex       */
        OS_EXIT_CRITICAL();
30003140:	ebfff451 	bl	3000028c <OS_CPU_SR_Restore>
30003144:	e3a0003c 	mov	r0, #60	; 0x3c
        return (OS_TASK_DEL_ERR);
30003148:	eaffff93 	b	30002f9c <OSTaskDel+0x3c>

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
3000314c:	e593c00c 	ldr	ip, [r3, #12]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30003150:	e3520000 	cmp	r2, #0

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30003154:	e58c2004 	str	r2, [ip, #4]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30003158:	1affffbf 	bne	3000305c <OSTaskDel+0xfc>
3000315c:	eaffffbf 	b	30003060 <OSTaskDel+0x100>
30003160:	3001d094 	mulcc	r1, r4, r0
30003164:	3001d098 	mulcc	r1, r8, r0
30003168:	3001dba8 	andcc	sp, r1, r8, lsr #23
3000316c:	3001ce88 	andcc	ip, r1, r8, lsl #29
30003170:	3001ce84 	andcc	ip, r1, r4, lsl #29
30003174:	3001c764 	andcc	ip, r1, r4, ror #14
30003178:	3001ce15 	andcc	ip, r1, r5, lsl lr
3000317c:	3001cb48 	andcc	ip, r1, r8, asr #22
30003180:	3001ce10 	andcc	ip, r1, r0, lsl lr

30003184 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
30003184:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
30003188:	e353003f 	cmp	r3, #63	; 0x3f
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
3000318c:	e24dd01c 	sub	sp, sp, #28
30003190:	e1dd55b0 	ldrh	r5, [sp, #80]	; 0x50
30003194:	e1a04003 	mov	r4, r3
30003198:	e1a0a000 	mov	sl, r0
3000319c:	e1a0b001 	mov	fp, r1
300031a0:	e1a09002 	mov	r9, r2
300031a4:	e59d8044 	ldr	r8, [sp, #68]	; 0x44
300031a8:	e1dd64b0 	ldrh	r6, [sp, #64]	; 0x40
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
300031ac:	83a0502a 	movhi	r5, #42	; 0x2a
300031b0:	9a000003 	bls	300031c4 <OSTaskCreateExt+0x40>
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_PRIO_EXIST);
}
300031b4:	e1a00005 	mov	r0, r5
300031b8:	e28dd01c 	add	sp, sp, #28
300031bc:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
300031c0:	e12fff1e 	bx	lr
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
300031c4:	ebfff428 	bl	3000026c <OS_CPU_SR_Save>
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
300031c8:	e59f30e4 	ldr	r3, [pc, #228]	; 300032b4 <OSTaskCreateExt+0x130>
300031cc:	e5d33000 	ldrb	r3, [r3]
300031d0:	e3530000 	cmp	r3, #0
300031d4:	1a000006 	bne	300031f4 <OSTaskCreateExt+0x70>
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
300031d8:	e59f70d8 	ldr	r7, [pc, #216]	; 300032b8 <OSTaskCreateExt+0x134>
300031dc:	e7973104 	ldr	r3, [r7, r4, lsl #2]
300031e0:	e3530000 	cmp	r3, #0
300031e4:	0a000005 	beq	30003200 <OSTaskCreateExt+0x7c>
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
300031e8:	ebfff427 	bl	3000028c <OS_CPU_SR_Restore>
300031ec:	e3a05028 	mov	r5, #40	; 0x28
    return (OS_PRIO_EXIST);
300031f0:	eaffffef 	b	300031b4 <OSTaskCreateExt+0x30>
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
        OS_EXIT_CRITICAL();
300031f4:	ebfff424 	bl	3000028c <OS_CPU_SR_Restore>
300031f8:	e3a05010 	mov	r5, #16
        return (OS_ERR_TASK_CREATE_ISR);
300031fc:	eaffffec 	b	300031b4 <OSTaskCreateExt+0x30>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
30003200:	e3a02001 	mov	r2, #1
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
30003204:	e58d3014 	str	r3, [sp, #20]
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
30003208:	e7872104 	str	r2, [r7, r4, lsl #2]
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
3000320c:	ebfff41e 	bl	3000028c <OS_CPU_SR_Restore>
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
30003210:	e3150001 	tst	r5, #1
30003214:	e59d3014 	ldr	r3, [sp, #20]
30003218:	0a000009 	beq	30003244 <OSTaskCreateExt+0xc0>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
3000321c:	e3150002 	tst	r5, #2
30003220:	0a000007 	beq	30003244 <OSTaskCreateExt+0xc0>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
30003224:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
30003228:	e3520000 	cmp	r2, #0
3000322c:	0a000004 	beq	30003244 <OSTaskCreateExt+0xc0>
                size--;
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
30003230:	e1a01003 	mov	r1, r3
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
30003234:	e2522001 	subs	r2, r2, #1
                size--;
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
30003238:	e7881003 	str	r1, [r8, r3]
3000323c:	e2833004 	add	r3, r3, #4
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
30003240:	1afffffb 	bne	30003234 <OSTaskCreateExt+0xb0>
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
30003244:	e1a03005 	mov	r3, r5
30003248:	e1a0100b 	mov	r1, fp
3000324c:	e1a02009 	mov	r2, r9
30003250:	e1a0000a 	mov	r0, sl
30003254:	eb000d8e 	bl	30006894 <OSTaskStkInit>
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
30003258:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
3000325c:	e1a01000 	mov	r1, r0
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
30003260:	e58dc000 	str	ip, [sp]
30003264:	e59dc04c 	ldr	ip, [sp, #76]	; 0x4c
30003268:	e1a02008 	mov	r2, r8
3000326c:	e1a03006 	mov	r3, r6
30003270:	e1a00004 	mov	r0, r4
30003274:	e58d5008 	str	r5, [sp, #8]
30003278:	e58dc004 	str	ip, [sp, #4]
3000327c:	ebfffd55 	bl	300027d8 <OS_TCBInit>
        if (err == OS_NO_ERR) {
30003280:	e2505000 	subs	r5, r0, #0
30003284:	1a000005 	bne	300032a0 <OSTaskCreateExt+0x11c>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
30003288:	e59f302c 	ldr	r3, [pc, #44]	; 300032bc <OSTaskCreateExt+0x138>
3000328c:	e5d33000 	ldrb	r3, [r3]
30003290:	e3530001 	cmp	r3, #1
30003294:	1affffc6 	bne	300031b4 <OSTaskCreateExt+0x30>
                OS_Sched();
30003298:	ebfffdb1 	bl	30002964 <OS_Sched>
3000329c:	eaffffc4 	b	300031b4 <OSTaskCreateExt+0x30>
            }
        } else {
            OS_ENTER_CRITICAL();
300032a0:	ebfff3f1 	bl	3000026c <OS_CPU_SR_Save>
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
300032a4:	e3a03000 	mov	r3, #0
300032a8:	e7873104 	str	r3, [r7, r4, lsl #2]
            OS_EXIT_CRITICAL();
300032ac:	ebfff3f6 	bl	3000028c <OS_CPU_SR_Restore>
300032b0:	eaffffbf 	b	300031b4 <OSTaskCreateExt+0x30>
300032b4:	3001d094 	mulcc	r1, r4, r0
300032b8:	3001dba8 	andcc	sp, r1, r8, lsr #23
300032bc:	3001c76c 	andcc	ip, r1, ip, ror #14

300032c0 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
300032c0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
300032c4:	e3a02000 	mov	r2, #0
300032c8:	e59f3140 	ldr	r3, [pc, #320]	; 30003410 <OSTmr_Init+0x150>
300032cc:	e24dd024 	sub	sp, sp, #36	; 0x24
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
        *pdest++ = (INT8U)0;
300032d0:	e1a01002 	mov	r1, r2
300032d4:	e7c31002 	strb	r1, [r3, r2]
300032d8:	e2822001 	add	r2, r2, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
300032dc:	e3520d0d 	cmp	r2, #832	; 0x340
300032e0:	1afffffb 	bne	300032d4 <OSTmr_Init+0x14>
300032e4:	e3a02000 	mov	r2, #0
300032e8:	e59f0124 	ldr	r0, [pc, #292]	; 30003414 <OSTmr_Init+0x154>
        *pdest++ = (INT8U)0;
300032ec:	e1a01002 	mov	r1, r2
300032f0:	e7c01002 	strb	r1, [r0, r2]
300032f4:	e2822001 	add	r2, r2, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
300032f8:	e3520040 	cmp	r2, #64	; 0x40
300032fc:	1afffffb 	bne	300032f0 <OSTmr_Init+0x30>
* Returns    : none
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
30003300:	e59f1110 	ldr	r1, [pc, #272]	; 30003418 <OSTmr_Init+0x158>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
30003304:	e3a0e064 	mov	lr, #100	; 0x64
* Returns    : none
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
30003308:	e2412fc3 	sub	r2, r1, #780	; 0x30c

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
3000330c:	e3a0c000 	mov	ip, #0
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
30003310:	e3a0003f 	mov	r0, #63	; 0x3f

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
30003314:	e3a04000 	mov	r4, #0
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
30003318:	e542e034 	strb	lr, [r2, #-52]	; 0x34
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
3000331c:	e542c003 	strb	ip, [r2, #-3]
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
30003320:	e5022028 	str	r2, [r2, #-40]	; 0x28
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
30003324:	e5420014 	strb	r0, [r2, #-20]
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
30003328:	e5424013 	strb	r4, [r2, #-19]
#endif
        ptmr1++;
        ptmr2++;
3000332c:	e2822034 	add	r2, r2, #52	; 0x34
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
30003330:	e1520001 	cmp	r2, r1
30003334:	1afffff6 	bne	30003314 <OSTmr_Init+0x54>
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
    OSTmrTime           = 0;
    OSTmrUsed           = 0;
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
30003338:	e59f20dc 	ldr	r2, [pc, #220]	; 3000341c <OSTmr_Init+0x15c>
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
    OSTmrTime           = 0;
    OSTmrUsed           = 0;
    OSTmrFree           = OS_TMR_CFG_MAX;
3000333c:	e3a01010 	mov	r1, #16
    OSTmrFreeList       = &OSTmrTbl[0];
30003340:	e5823000 	str	r3, [r2]
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
30003344:	e3a02064 	mov	r2, #100	; 0x64
30003348:	e5c3230c 	strb	r2, [r3, #780]	; 0x30c
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
3000334c:	e3a0203f 	mov	r2, #63	; 0x3f
30003350:	e5c3232c 	strb	r2, [r3, #812]	; 0x32c
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
    OSTmrTime           = 0;
30003354:	e59f20c4 	ldr	r2, [pc, #196]	; 30003420 <OSTmr_Init+0x160>
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
30003358:	e5834318 	str	r4, [r3, #792]	; 0x318
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
    OSTmrTime           = 0;
3000335c:	e5824000 	str	r4, [r2]
    OSTmrUsed           = 0;
30003360:	e59f20bc 	ldr	r2, [pc, #188]	; 30003424 <OSTmr_Init+0x164>
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
    OSTmrSem            = OSSemCreate(1);
30003364:	e3a00001 	mov	r0, #1
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
    OSTmrTime           = 0;
    OSTmrUsed           = 0;
30003368:	e1c240b0 	strh	r4, [r2]
    OSTmrFree           = OS_TMR_CFG_MAX;
3000336c:	e59f20b4 	ldr	r2, [pc, #180]	; 30003428 <OSTmr_Init+0x168>
    OSTmrFreeList       = &OSTmrTbl[0];
    OSTmrSem            = OSSemCreate(1);
30003370:	e59f70b4 	ldr	r7, [pc, #180]	; 3000342c <OSTmr_Init+0x16c>
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
    OSTmrTime           = 0;
    OSTmrUsed           = 0;
    OSTmrFree           = OS_TMR_CFG_MAX;
30003374:	e1c210b0 	strh	r1, [r2]
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
30003378:	e5c3433d 	strb	r4, [r3, #829]	; 0x33d
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
3000337c:	e5c3432d 	strb	r4, [r3, #813]	; 0x32d
#endif
    OSTmrTime           = 0;
    OSTmrUsed           = 0;
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
    OSTmrSem            = OSSemCreate(1);
30003380:	ebfff8d9 	bl	300016ec <OSSemCreate>
30003384:	e5870000 	str	r0, [r7]
    OSTmrSemSignal      = OSSemCreate(0);
30003388:	e1a00004 	mov	r0, r4
3000338c:	ebfff8d6 	bl	300016ec <OSSemCreate>
30003390:	e59f6098 	ldr	r6, [pc, #152]	; 30003430 <OSTmr_Init+0x170>

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
#else
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
30003394:	e28d501f 	add	r5, sp, #31
    OSTmrTime           = 0;
    OSTmrUsed           = 0;
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
    OSTmrSem            = OSSemCreate(1);
    OSTmrSemSignal      = OSSemCreate(0);
30003398:	e5860000 	str	r0, [r6]

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
#else
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
3000339c:	e1a02005 	mov	r2, r5
300033a0:	e5970000 	ldr	r0, [r7]
300033a4:	e59f1088 	ldr	r1, [pc, #136]	; 30003434 <OSTmr_Init+0x174>
300033a8:	ebfffcaf 	bl	3000266c <OSEventNameSet>

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
#else
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
300033ac:	e5960000 	ldr	r0, [r6]
300033b0:	e1a02005 	mov	r2, r5
300033b4:	e59f107c 	ldr	r1, [pc, #124]	; 30003438 <OSTmr_Init+0x178>
300033b8:	ebfffcab 	bl	3000266c <OSEventNameSet>
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
300033bc:	e59fe078 	ldr	lr, [pc, #120]	; 3000343c <OSTmr_Init+0x17c>
300033c0:	e59fc078 	ldr	ip, [pc, #120]	; 30003440 <OSTmr_Init+0x180>
300033c4:	e58de000 	str	lr, [sp]
300033c8:	e3a0e080 	mov	lr, #128	; 0x80
300033cc:	e1a01004 	mov	r1, r4
300033d0:	e28c2f7f 	add	r2, ip, #508	; 0x1fc
300033d4:	e58de008 	str	lr, [sp, #8]
300033d8:	e3a03028 	mov	r3, #40	; 0x28
300033dc:	e3a0e003 	mov	lr, #3
300033e0:	e59f005c 	ldr	r0, [pc, #92]	; 30003444 <OSTmr_Init+0x184>
300033e4:	e58de010 	str	lr, [sp, #16]
300033e8:	e58dc004 	str	ip, [sp, #4]
300033ec:	e58d400c 	str	r4, [sp, #12]
300033f0:	ebffff63 	bl	30003184 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
300033f4:	e3a00028 	mov	r0, #40	; 0x28
300033f8:	e59f1048 	ldr	r1, [pc, #72]	; 30003448 <OSTmr_Init+0x188>
300033fc:	e28d201e 	add	r2, sp, #30
30003400:	ebfff7d6 	bl	30001360 <OSTaskNameSet>
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
}
30003404:	e28dd024 	add	sp, sp, #36	; 0x24
30003408:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
3000340c:	e12fff1e 	bx	lr
30003410:	3001c804 	andcc	ip, r1, r4, lsl #16
30003414:	3001c724 	andcc	ip, r1, r4, lsr #14
30003418:	3001cb44 	andcc	ip, r1, r4, asr #22
3000341c:	3001c720 	andcc	ip, r1, r0, lsr #14
30003420:	3001d09c 	mulcc	r1, ip, r0
30003424:	3001c774 	andcc	ip, r1, r4, ror r7
30003428:	3001ce08 	andcc	ip, r1, r8, lsl #28
3000342c:	3001d0a4 	andcc	sp, r1, r4, lsr #1
30003430:	3001c768 	andcc	ip, r1, r8, ror #14
30003434:	30006ce4 	andcc	r6, r0, r4, ror #25
30003438:	30006cf0 	strdcc	r6, [r0], -r0
3000343c:	0000fffd 	strdeq	pc, [r0], -sp
30003440:	3001ce90 	mulcc	r1, r0, lr
30003444:	3000418c 	andcc	r4, r0, ip, lsl #3
30003448:	30006cfc 	strdcc	r6, [r0], -ip

3000344c <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
3000344c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
30003450:	e353003f 	cmp	r3, #63	; 0x3f
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
30003454:	e1a07000 	mov	r7, r0
30003458:	e24dd014 	sub	sp, sp, #20
3000345c:	e1a04003 	mov	r4, r3
30003460:	e1a0a001 	mov	sl, r1
30003464:	e1a08002 	mov	r8, r2
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
30003468:	83a0702a 	movhi	r7, #42	; 0x2a
3000346c:	9a000003 	bls	30003480 <OSTaskCreate+0x34>
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_PRIO_EXIST);
}
30003470:	e1a00007 	mov	r0, r7
30003474:	e28dd014 	add	sp, sp, #20
30003478:	e8bd45f0 	pop	{r4, r5, r6, r7, r8, sl, lr}
3000347c:	e12fff1e 	bx	lr
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
30003480:	ebfff379 	bl	3000026c <OS_CPU_SR_Save>
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
30003484:	e59f30a0 	ldr	r3, [pc, #160]	; 3000352c <OSTaskCreate+0xe0>
30003488:	e5d33000 	ldrb	r3, [r3]
3000348c:	e3530000 	cmp	r3, #0
30003490:	1a000006 	bne	300034b0 <OSTaskCreate+0x64>
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
30003494:	e59f6094 	ldr	r6, [pc, #148]	; 30003530 <OSTaskCreate+0xe4>
30003498:	e7965104 	ldr	r5, [r6, r4, lsl #2]
3000349c:	e3550000 	cmp	r5, #0
300034a0:	0a000005 	beq	300034bc <OSTaskCreate+0x70>
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
300034a4:	ebfff378 	bl	3000028c <OS_CPU_SR_Restore>
300034a8:	e3a07028 	mov	r7, #40	; 0x28
    return (OS_PRIO_EXIST);
300034ac:	eaffffef 	b	30003470 <OSTaskCreate+0x24>
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
        OS_EXIT_CRITICAL();
300034b0:	ebfff375 	bl	3000028c <OS_CPU_SR_Restore>
300034b4:	e3a07010 	mov	r7, #16
        return (OS_ERR_TASK_CREATE_ISR);
300034b8:	eaffffec 	b	30003470 <OSTaskCreate+0x24>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
300034bc:	e3a03001 	mov	r3, #1
300034c0:	e7863104 	str	r3, [r6, r4, lsl #2]
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
300034c4:	ebfff370 	bl	3000028c <OS_CPU_SR_Restore>
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
300034c8:	e1a00007 	mov	r0, r7
300034cc:	e1a0100a 	mov	r1, sl
300034d0:	e1a02008 	mov	r2, r8
300034d4:	e1a03005 	mov	r3, r5
300034d8:	eb000ced 	bl	30006894 <OSTaskStkInit>
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
300034dc:	e1a02005 	mov	r2, r5
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
300034e0:	e1a01000 	mov	r1, r0
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
300034e4:	e1a03005 	mov	r3, r5
300034e8:	e1a00004 	mov	r0, r4
300034ec:	e58d5000 	str	r5, [sp]
300034f0:	e58d5004 	str	r5, [sp, #4]
300034f4:	e58d5008 	str	r5, [sp, #8]
300034f8:	ebfffcb6 	bl	300027d8 <OS_TCBInit>
        if (err == OS_NO_ERR) {
300034fc:	e2507000 	subs	r7, r0, #0
30003500:	1a000005 	bne	3000351c <OSTaskCreate+0xd0>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
30003504:	e59f3028 	ldr	r3, [pc, #40]	; 30003534 <OSTaskCreate+0xe8>
30003508:	e5d33000 	ldrb	r3, [r3]
3000350c:	e3530001 	cmp	r3, #1
30003510:	1affffd6 	bne	30003470 <OSTaskCreate+0x24>
                OS_Sched();
30003514:	ebfffd12 	bl	30002964 <OS_Sched>
30003518:	eaffffd4 	b	30003470 <OSTaskCreate+0x24>
            }
        } else {
            OS_ENTER_CRITICAL();
3000351c:	ebfff352 	bl	3000026c <OS_CPU_SR_Save>
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
30003520:	e7865104 	str	r5, [r6, r4, lsl #2]
            OS_EXIT_CRITICAL();
30003524:	ebfff358 	bl	3000028c <OS_CPU_SR_Restore>
30003528:	eaffffd0 	b	30003470 <OSTaskCreate+0x24>
3000352c:	3001d094 	mulcc	r1, r4, r0
30003530:	3001dba8 	andcc	sp, r1, r8, lsr #23
30003534:	3001c76c 	andcc	ip, r1, ip, ror #14

30003538 <OSTaskChangePrio>:
#endif



#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
30003538:	e350003e 	cmp	r0, #62	; 0x3e
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
3000353c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
30003540:	e1a04000 	mov	r4, r0
30003544:	e1a05001 	mov	r5, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
30003548:	9a000004 	bls	30003560 <OSTaskChangePrio+0x28>
        if (oldprio != OS_PRIO_SELF) {
3000354c:	e35000ff 	cmp	r0, #255	; 0xff
30003550:	0a000002 	beq	30003560 <OSTaskChangePrio+0x28>
    ptcb->OSTCBX    = x;
    ptcb->OSTCBBitY = bity;
    ptcb->OSTCBBitX = bitx;
    OS_EXIT_CRITICAL();
    OS_Sched();                                                 /* Run highest priority task ready     */
    return (OS_NO_ERR);
30003554:	e3a0002a 	mov	r0, #42	; 0x2a
}
30003558:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
3000355c:	e12fff1e 	bx	lr
    if (oldprio >= OS_LOWEST_PRIO) {
        if (oldprio != OS_PRIO_SELF) {
            return (OS_PRIO_INVALID);
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
30003560:	e355003e 	cmp	r5, #62	; 0x3e
30003564:	8afffffa 	bhi	30003554 <OSTaskChangePrio+0x1c>
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
30003568:	ebfff33f 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
3000356c:	e59f315c 	ldr	r3, [pc, #348]	; 300036d0 <OSTaskChangePrio+0x198>
    }
    if (newprio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
30003570:	e1a01000 	mov	r1, r0
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
30003574:	e7932105 	ldr	r2, [r3, r5, lsl #2]
30003578:	e3520000 	cmp	r2, #0
3000357c:	0a000002 	beq	3000358c <OSTaskChangePrio+0x54>
        OS_EXIT_CRITICAL();
30003580:	ebfff341 	bl	3000028c <OS_CPU_SR_Restore>
30003584:	e3a00028 	mov	r0, #40	; 0x28
        return (OS_PRIO_EXIST);
30003588:	eafffff2 	b	30003558 <OSTaskChangePrio+0x20>
    }
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
3000358c:	e35400ff 	cmp	r4, #255	; 0xff
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
30003590:	059f213c 	ldreq	r2, [pc, #316]	; 300036d4 <OSTaskChangePrio+0x19c>
    }
    ptcb = OSTCBPrioTbl[oldprio];
30003594:	e59f0134 	ldr	r0, [pc, #308]	; 300036d0 <OSTaskChangePrio+0x198>
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
        OS_EXIT_CRITICAL();
        return (OS_PRIO_EXIST);
    }
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
30003598:	05922000 	ldreq	r2, [r2]
3000359c:	05d2402e 	ldrbeq	r4, [r2, #46]	; 0x2e
    }
    ptcb = OSTCBPrioTbl[oldprio];
300035a0:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
300035a4:	e3530000 	cmp	r3, #0
300035a8:	0a000040 	beq	300036b0 <OSTaskChangePrio+0x178>
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
        return (OS_PRIO_ERR);
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
300035ac:	e3530001 	cmp	r3, #1
300035b0:	0a000042 	beq	300036c0 <OSTaskChangePrio+0x188>
        return (OS_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y                     = (INT8U)(newprio >> 3);              /* Yes, compute new TCB fields         */
    x                     = (INT8U)(newprio & 0x07);
    bity                  = (INT8U)(1 << y);
300035b4:	e3a0e001 	mov	lr, #1
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
        return (OS_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y                     = (INT8U)(newprio >> 3);              /* Yes, compute new TCB fields         */
300035b8:	e1a021a5 	lsr	r2, r5, #3
    x                     = (INT8U)(newprio & 0x07);
300035bc:	e205c007 	and	ip, r5, #7
    bity                  = (INT8U)(1 << y);
    bitx                  = (INT8U)(1 << x);
300035c0:	e1a0ac1e 	lsl	sl, lr, ip
        return (OS_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y                     = (INT8U)(newprio >> 3);              /* Yes, compute new TCB fields         */
    x                     = (INT8U)(newprio & 0x07);
    bity                  = (INT8U)(1 << y);
300035c4:	e1a0e21e 	lsl	lr, lr, r2
    x                     = (INT8U)( newprio & 0x0F);
    bity                  = (INT16U)(1 << y);
    bitx                  = (INT16U)(1 << x);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
300035c8:	e3a06000 	mov	r6, #0
300035cc:	e7806104 	str	r6, [r0, r4, lsl #2]
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
300035d0:	e7803105 	str	r3, [r0, r5, lsl #2]
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
300035d4:	e5d37030 	ldrb	r7, [r3, #48]	; 0x30
300035d8:	e59f00f8 	ldr	r0, [pc, #248]	; 300036d8 <OSTaskChangePrio+0x1a0>
300035dc:	e5d36031 	ldrb	r6, [r3, #49]	; 0x31
300035e0:	e7d08007 	ldrb	r8, [r0, r7]
        return (OS_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y                     = (INT8U)(newprio >> 3);              /* Yes, compute new TCB fields         */
    x                     = (INT8U)(newprio & 0x07);
    bity                  = (INT8U)(1 << y);
300035e4:	e20ee0ff 	and	lr, lr, #255	; 0xff
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
300035e8:	e1180006 	tst	r8, r6
    }
#if OS_LOWEST_PRIO <= 63
    y                     = (INT8U)(newprio >> 3);              /* Yes, compute new TCB fields         */
    x                     = (INT8U)(newprio & 0x07);
    bity                  = (INT8U)(1 << y);
    bitx                  = (INT8U)(1 << x);
300035ec:	e20a40ff 	and	r4, sl, #255	; 0xff
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
300035f0:	0a000018 	beq	30003658 <OSTaskChangePrio+0x120>
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
300035f4:	e1c86006 	bic	r6, r8, r6
        if (OSRdyTbl[y_old] == 0) {
300035f8:	e3560000 	cmp	r6, #0

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
300035fc:	e7c06007 	strb	r6, [r0, r7]
        if (OSRdyTbl[y_old] == 0) {
            OSRdyGrp &= ~ptcb->OSTCBBitY;
30003600:	059f60d4 	ldreq	r6, [pc, #212]	; 300036dc <OSTaskChangePrio+0x1a4>
30003604:	05d38032 	ldrbeq	r8, [r3, #50]	; 0x32
30003608:	05d67000 	ldrbeq	r7, [r6]
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
        if (OSRdyTbl[y_old] == 0) {
3000360c:	159f60c8 	ldrne	r6, [pc, #200]	; 300036dc <OSTaskChangePrio+0x1a4>
            OSRdyGrp &= ~ptcb->OSTCBBitY;
30003610:	01c77008 	biceq	r7, r7, r8
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
        if (OSRdyTbl[y_old] == 0) {
30003614:	15d67000 	ldrbne	r7, [r6]
            OSRdyGrp &= ~ptcb->OSTCBBitY;
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
        OSRdyTbl[y] |= bitx;
30003618:	e7d08002 	ldrb	r8, [r0, r2]
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    y_old                 = ptcb->OSTCBY;
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
        if (OSRdyTbl[y_old] == 0) {
            OSRdyGrp &= ~ptcb->OSTCBBitY;
3000361c:	05c67000 	strbeq	r7, [r6]
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
        OSRdyTbl[y] |= bitx;
30003620:	e1848008 	orr	r8, r4, r8
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0) {             /* If task is ready make it not        */
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
        if (OSRdyTbl[y_old] == 0) {
            OSRdyGrp &= ~ptcb->OSTCBBitY;
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
30003624:	e187700e 	orr	r7, r7, lr
30003628:	e5c67000 	strb	r7, [r6]
        OSRdyTbl[y] |= bitx;
3000362c:	e7c08002 	strb	r8, [r0, r2]
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
    ptcb->OSTCBY    = y;
    ptcb->OSTCBX    = x;
    ptcb->OSTCBBitY = bity;
    ptcb->OSTCBBitX = bitx;
30003630:	e5c34031 	strb	r4, [r3, #49]	; 0x31
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
            pevent->OSEventTbl[y] |= bitx;
        }
#endif
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
30003634:	e5c3502e 	strb	r5, [r3, #46]	; 0x2e
    ptcb->OSTCBY    = y;
30003638:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    ptcb->OSTCBX    = x;
3000363c:	e5c3c02f 	strb	ip, [r3, #47]	; 0x2f
    ptcb->OSTCBBitY = bity;
30003640:	e5c3e032 	strb	lr, [r3, #50]	; 0x32
    ptcb->OSTCBBitX = bitx;
    OS_EXIT_CRITICAL();
30003644:	e1a00001 	mov	r0, r1
30003648:	ebfff30f 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Sched();                                                 /* Run highest priority task ready     */
3000364c:	ebfffcc4 	bl	30002964 <OS_Sched>
30003650:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30003654:	eaffffbf 	b	30003558 <OSTaskChangePrio+0x20>
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
        OSRdyTbl[y] |= bitx;
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
30003658:	e593001c 	ldr	r0, [r3, #28]
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
3000365c:	e3500000 	cmp	r0, #0
30003660:	0afffff2 	beq	30003630 <OSTaskChangePrio+0xf8>
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
30003664:	e0807007 	add	r7, r0, r7
30003668:	e2877008 	add	r7, r7, #8
3000366c:	e5d78003 	ldrb	r8, [r7, #3]
30003670:	e1c86006 	bic	r6, r8, r6
30003674:	e5c76003 	strb	r6, [r7, #3]
            if (pevent->OSEventTbl[y_old] == 0) {
30003678:	e3560000 	cmp	r6, #0
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
3000367c:	05d37032 	ldrbeq	r7, [r3, #50]	; 0x32
30003680:	05d0600a 	ldrbeq	r6, [r0, #10]
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
            if (pevent->OSEventTbl[y_old] == 0) {
30003684:	15d0700a 	ldrbne	r7, [r0, #10]
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
30003688:	01c67007 	biceq	r7, r6, r7
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
            pevent->OSEventTbl[y] |= bitx;
3000368c:	e0806002 	add	r6, r0, r2
30003690:	e2866008 	add	r6, r6, #8
30003694:	e5d68003 	ldrb	r8, [r6, #3]
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
            if (pevent->OSEventTbl[y_old] == 0) {
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
30003698:	05c0700a 	strbeq	r7, [r0, #10]
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
            pevent->OSEventTbl[y] |= bitx;
3000369c:	e1848008 	orr	r8, r4, r8
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
            if (pevent->OSEventTbl[y_old] == 0) {
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
300036a0:	e187700e 	orr	r7, r7, lr
            pevent->OSEventTbl[y] |= bitx;
300036a4:	e5c68003 	strb	r8, [r6, #3]
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
            if (pevent->OSEventTbl[y_old] == 0) {
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
300036a8:	e5c0700a 	strb	r7, [r0, #10]
300036ac:	eaffffdf 	b	30003630 <OSTaskChangePrio+0xf8>
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
    }
    ptcb = OSTCBPrioTbl[oldprio];
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
300036b0:	e1a00001 	mov	r0, r1
300036b4:	ebfff2f4 	bl	3000028c <OS_CPU_SR_Restore>
300036b8:	e3a00029 	mov	r0, #41	; 0x29
        return (OS_PRIO_ERR);
300036bc:	eaffffa5 	b	30003558 <OSTaskChangePrio+0x20>
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
300036c0:	e1a00001 	mov	r0, r1
300036c4:	ebfff2f0 	bl	3000028c <OS_CPU_SR_Restore>
300036c8:	e3a0000b 	mov	r0, #11
        return (OS_TASK_NOT_EXIST);
300036cc:	eaffffa1 	b	30003558 <OSTaskChangePrio+0x20>
300036d0:	3001dba8 	andcc	sp, r1, r8, lsr #23
300036d4:	3001d098 	mulcc	r1, r8, r0
300036d8:	3001ce88 	andcc	ip, r1, r8, lsl #29
300036dc:	3001ce84 	andcc	ip, r1, r4, lsl #29

300036e0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
300036e0:	e92d4070 	push	{r4, r5, r6, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
300036e4:	e2505000 	subs	r5, r0, #0
300036e8:	03a00004 	moveq	r0, #4
300036ec:	0a000003 	beq	30003700 <OSSemPost+0x20>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
300036f0:	e5d53000 	ldrb	r3, [r5]
300036f4:	e3530003 	cmp	r3, #3
300036f8:	13a00001 	movne	r0, #1
300036fc:	0a000001 	beq	30003708 <OSSemPost+0x28>
        OS_EXIT_CRITICAL();
        return (OS_NO_ERR);
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_SEM_OVF);
}
30003700:	e8bd4070 	pop	{r4, r5, r6, lr}
30003704:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30003708:	ebfff2d7 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0) {                             /* See if any task waiting for semaphore*/
3000370c:	e5d5600a 	ldrb	r6, [r5, #10]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30003710:	e1a04000 	mov	r4, r0
    if (pevent->OSEventGrp != 0) {                             /* See if any task waiting for semaphore*/
30003714:	e3560000 	cmp	r6, #0
30003718:	1a00000b 	bne	3000374c <OSSemPost+0x6c>
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* Find HPT ready to run                */
        return (OS_NO_ERR);
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
3000371c:	e1d530b8 	ldrh	r3, [r5, #8]
30003720:	e59f2048 	ldr	r2, [pc, #72]	; 30003770 <OSSemPost+0x90>
30003724:	e1530002 	cmp	r3, r2
30003728:	0a000004 	beq	30003740 <OSSemPost+0x60>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
3000372c:	e2833001 	add	r3, r3, #1
30003730:	e1c530b8 	strh	r3, [r5, #8]
        OS_EXIT_CRITICAL();
30003734:	ebfff2d4 	bl	3000028c <OS_CPU_SR_Restore>
30003738:	e1a00006 	mov	r0, r6
        return (OS_NO_ERR);
3000373c:	eaffffef 	b	30003700 <OSSemPost+0x20>
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
30003740:	ebfff2d1 	bl	3000028c <OS_CPU_SR_Restore>
30003744:	e3a00032 	mov	r0, #50	; 0x32
    return (OS_SEM_OVF);
30003748:	eaffffec 	b	30003700 <OSSemPost+0x20>
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                             /* See if any task waiting for semaphore*/
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
3000374c:	e3a01000 	mov	r1, #0
30003750:	e3a02001 	mov	r2, #1
30003754:	e1a00005 	mov	r0, r5
30003758:	ebfff4c3 	bl	30000a6c <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
3000375c:	e1a00004 	mov	r0, r4
30003760:	ebfff2c9 	bl	3000028c <OS_CPU_SR_Restore>
        OS_Sched();                                            /* Find HPT ready to run                */
30003764:	ebfffc7e 	bl	30002964 <OS_Sched>
30003768:	e3a00000 	mov	r0, #0
        return (OS_NO_ERR);
3000376c:	eaffffe3 	b	30003700 <OSSemPost+0x20>
30003770:	0000ffff 	strdeq	pc, [r0], -pc

30003774 <OSTmr_Unlock>:


#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
    (void)OSSemPost(OSTmrSem);
30003774:	e59f3004 	ldr	r3, [pc, #4]	; 30003780 <OSTmr_Unlock+0xc>
30003778:	e5930000 	ldr	r0, [r3]
3000377c:	eaffffd7 	b	300036e0 <OSSemPost>
30003780:	3001d0a4 	andcc	sp, r1, r4, lsr #1

30003784 <OSTmrSignal>:
INT8U  OSTmrSignal (void)
{
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
30003784:	e59f3004 	ldr	r3, [pc, #4]	; 30003790 <OSTmrSignal+0xc>
30003788:	e5930000 	ldr	r0, [r3]
3000378c:	eaffffd3 	b	300036e0 <OSSemPost>
30003790:	3001c768 	andcc	ip, r1, r8, ror #14

30003794 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
30003794:	e92d40f0 	push	{r4, r5, r6, r7, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
30003798:	e2525000 	subs	r5, r2, #0
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
3000379c:	e24dd00c 	sub	sp, sp, #12
300037a0:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
300037a4:	0a000008 	beq	300037cc <OSSemPend+0x38>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300037a8:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
300037ac:	03a03004 	moveq	r3, #4
300037b0:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300037b4:	0a000004 	beq	300037cc <OSSemPend+0x38>
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
300037b8:	e5d03000 	ldrb	r3, [r0]
300037bc:	e3530003 	cmp	r3, #3
        *err = OS_ERR_EVENT_TYPE;
300037c0:	13a03001 	movne	r3, #1
300037c4:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
300037c8:	0a000002 	beq	300037d8 <OSSemPend+0x44>
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
}
300037cc:	e28dd00c 	add	sp, sp, #12
300037d0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
300037d4:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        *err = OS_ERR_EVENT_TYPE;
        return;
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
300037d8:	e59f3160 	ldr	r3, [pc, #352]	; 30003940 <OSSemPend+0x1ac>
300037dc:	e5d33000 	ldrb	r3, [r3]
300037e0:	e3530000 	cmp	r3, #0
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
300037e4:	13a03002 	movne	r3, #2
300037e8:	15c53000 	strbne	r3, [r5]
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        *err = OS_ERR_EVENT_TYPE;
        return;
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
300037ec:	1afffff6 	bne	300037cc <OSSemPend+0x38>
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
        return;
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
300037f0:	e59f314c 	ldr	r3, [pc, #332]	; 30003944 <OSSemPend+0x1b0>
300037f4:	e5d36000 	ldrb	r6, [r3]
300037f8:	e3560000 	cmp	r6, #0
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
300037fc:	13a03011 	movne	r3, #17
30003800:	15c53000 	strbne	r3, [r5]
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
        return;
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
30003804:	1afffff0 	bne	300037cc <OSSemPend+0x38>
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
        return;
    }
    OS_ENTER_CRITICAL();
30003808:	e58d1004 	str	r1, [sp, #4]
3000380c:	ebfff296 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
30003810:	e1d430b8 	ldrh	r3, [r4, #8]
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
        return;
    }
    OS_ENTER_CRITICAL();
30003814:	e1a02000 	mov	r2, r0
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
30003818:	e3530000 	cmp	r3, #0
3000381c:	e59d1004 	ldr	r1, [sp, #4]
30003820:	1a000041 	bne	3000392c <OSSemPend+0x198>
        OS_EXIT_CRITICAL();
        *err = OS_NO_ERR;
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
30003824:	e59f611c 	ldr	r6, [pc, #284]	; 30003948 <OSSemPend+0x1b4>
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30003828:	e59fe11c 	ldr	lr, [pc, #284]	; 3000394c <OSSemPend+0x1b8>
3000382c:	e5960000 	ldr	r0, [r6]
30003830:	e5d0702c 	ldrb	r7, [r0, #44]	; 0x2c
30003834:	e5d0c030 	ldrb	ip, [r0, #48]	; 0x30
30003838:	e3877001 	orr	r7, r7, #1
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
3000383c:	e1c012ba 	strh	r1, [r0, #42]	; 0x2a
        OS_EXIT_CRITICAL();
        *err = OS_NO_ERR;
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
30003840:	e5c0702c 	strb	r7, [r0, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
30003844:	e5c0302d 	strb	r3, [r0, #45]	; 0x2d
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
30003848:	e580401c 	str	r4, [r0, #28]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
3000384c:	e5d01031 	ldrb	r1, [r0, #49]	; 0x31
30003850:	e7de300c 	ldrb	r3, [lr, ip]
30003854:	e1c33001 	bic	r3, r3, r1
    if (OSRdyTbl[y] == 0) {
30003858:	e3530000 	cmp	r3, #0
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
3000385c:	e7ce300c 	strb	r3, [lr, ip]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
30003860:	059f30e8 	ldreq	r3, [pc, #232]	; 30003950 <OSSemPend+0x1bc>
30003864:	05d0c032 	ldrbeq	ip, [r0, #50]	; 0x32
30003868:	05d31000 	ldrbeq	r1, [r3]
3000386c:	01c1100c 	biceq	r1, r1, ip
30003870:	05c31000 	strbeq	r1, [r3]
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30003874:	e5d01030 	ldrb	r1, [r0, #48]	; 0x30
30003878:	e5d0c031 	ldrb	ip, [r0, #49]	; 0x31
3000387c:	e0841001 	add	r1, r4, r1
30003880:	e2811008 	add	r1, r1, #8
30003884:	e5d1e003 	ldrb	lr, [r1, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30003888:	e5d4300a 	ldrb	r3, [r4, #10]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
3000388c:	e18ec00c 	orr	ip, lr, ip
30003890:	e5c1c003 	strb	ip, [r1, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30003894:	e5d01032 	ldrb	r1, [r0, #50]	; 0x32
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    OS_EXIT_CRITICAL();
30003898:	e1a00002 	mov	r0, r2
3000389c:	e1813003 	orr	r3, r1, r3
300038a0:	e5c4300a 	strb	r3, [r4, #10]
300038a4:	ebfff278 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Sched();                                       /* Find next highest priority task ready         */
300038a8:	ebfffc2d 	bl	30002964 <OS_Sched>
    OS_ENTER_CRITICAL();
300038ac:	ebfff26e 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we timedout                            */
300038b0:	e5963000 	ldr	r3, [r6]
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
    OS_ENTER_CRITICAL();
300038b4:	e1a01000 	mov	r1, r0
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we timedout                            */
300038b8:	e5d3202d 	ldrb	r2, [r3, #45]	; 0x2d
300038bc:	e3520001 	cmp	r2, #1
300038c0:	0a000004 	beq	300038d8 <OSSemPend+0x144>
        OS_EventTO(pevent);
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
300038c4:	e3a04000 	mov	r4, #0
300038c8:	e583401c 	str	r4, [r3, #28]
    OS_EXIT_CRITICAL();
300038cc:	ebfff26e 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
300038d0:	e5c54000 	strb	r4, [r5]
300038d4:	eaffffbc 	b	300037cc <OSSemPend+0x38>
{
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
300038d8:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
300038dc:	e5d3c031 	ldrb	ip, [r3, #49]	; 0x31
300038e0:	e0842002 	add	r2, r4, r2
300038e4:	e2822008 	add	r2, r2, #8
300038e8:	e5d20003 	ldrb	r0, [r2, #3]
300038ec:	e1c0000c 	bic	r0, r0, ip
300038f0:	e5c20003 	strb	r0, [r2, #3]
    if (pevent->OSEventTbl[y] == 0x00) {
300038f4:	e3500000 	cmp	r0, #0
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
300038f8:	05d4200a 	ldrbeq	r2, [r4, #10]
300038fc:	05d30032 	ldrbeq	r0, [r3, #50]	; 0x32
30003900:	01c22000 	biceq	r2, r2, r0
30003904:	05c4200a 	strbeq	r2, [r4, #10]
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30003908:	e3a02000 	mov	r2, #0
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
3000390c:	e583201c 	str	r2, [r3, #28]
    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    if (pevent->OSEventTbl[y] == 0x00) {
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30003910:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
30003914:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we timedout                            */
        OS_EventTO(pevent);
        OS_EXIT_CRITICAL();
30003918:	e1a00001 	mov	r0, r1
3000391c:	ebfff25a 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
30003920:	e3a0300a 	mov	r3, #10
30003924:	e5c53000 	strb	r3, [r5]
        return;
30003928:	eaffffa7 	b	300037cc <OSSemPend+0x38>
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
        return;
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
3000392c:	e2433001 	sub	r3, r3, #1
30003930:	e1c430b8 	strh	r3, [r4, #8]
        OS_EXIT_CRITICAL();
30003934:	ebfff254 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_NO_ERR;
30003938:	e5c56000 	strb	r6, [r5]
        return;
3000393c:	eaffffa2 	b	300037cc <OSSemPend+0x38>
30003940:	3001d094 	mulcc	r1, r4, r0
30003944:	3001c764 	andcc	ip, r1, r4, ror #14
30003948:	3001d098 	mulcc	r1, r8, r0
3000394c:	3001ce88 	andcc	ip, r1, r8, lsl #29
30003950:	3001ce84 	andcc	ip, r1, r4, lsl #29

30003954 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
30003954:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
30003958:	e59f301c 	ldr	r3, [pc, #28]	; 3000397c <OSTmr_Lock+0x28>
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
3000395c:	e24dd00c 	sub	sp, sp, #12
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
30003960:	e3a01000 	mov	r1, #0
30003964:	e5930000 	ldr	r0, [r3]
30003968:	e28d2007 	add	r2, sp, #7
3000396c:	ebffff88 	bl	30003794 <OSSemPend>
    (void)err;
}
30003970:	e28dd00c 	add	sp, sp, #12
30003974:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003978:	e12fff1e 	bx	lr
3000397c:	3001d0a4 	andcc	sp, r1, r4, lsr #1

30003980 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
30003980:	e92d4070 	push	{r4, r5, r6, lr}
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
30003984:	e2535000 	subs	r5, r3, #0
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
30003988:	e1a04000 	mov	r4, r0
3000398c:	e24dd008 	sub	sp, sp, #8
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
30003990:	01a00005 	moveq	r0, r5
30003994:	0a00000a 	beq	300039c4 <OSTmrStop+0x44>
        return (OS_FALSE);
    }
    if (ptmr == (OS_TMR *)0) {
30003998:	e3540000 	cmp	r4, #0
        *perr = OS_ERR_TMR_INVALID;
3000399c:	03e0304d 	mvneq	r3, #77	; 0x4d
300039a0:	05c53000 	strbeq	r3, [r5]
300039a4:	01a00004 	moveq	r0, r4

#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
        return (OS_FALSE);
    }
    if (ptmr == (OS_TMR *)0) {
300039a8:	0a000005 	beq	300039c4 <OSTmrStop+0x44>
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
300039ac:	e5d43000 	ldrb	r3, [r4]
300039b0:	e3530064 	cmp	r3, #100	; 0x64
        *perr = OS_ERR_TMR_INVALID_TYPE;
300039b4:	13e0304e 	mvnne	r3, #78	; 0x4e
300039b8:	15c53000 	strbne	r3, [r5]
300039bc:	13a00000 	movne	r0, #0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
300039c0:	0a000002 	beq	300039d0 <OSTmrStop+0x50>
        default:
             OSTmr_Unlock();
             *perr = OS_ERR_TMR_INVALID_STATE;
             return (OS_FALSE);
    }
}
300039c4:	e28dd008 	add	sp, sp, #8
300039c8:	e8bd4070 	pop	{r4, r5, r6, lr}
300039cc:	e12fff1e 	bx	lr
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (OS_FALSE);
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
300039d0:	e59f3128 	ldr	r3, [pc, #296]	; 30003b00 <OSTmrStop+0x180>
300039d4:	e5d33000 	ldrb	r3, [r3]
300039d8:	e3530000 	cmp	r3, #0
        *perr  = OS_ERR_TMR_ISR;
300039dc:	13e0304c 	mvnne	r3, #76	; 0x4c
300039e0:	15c53000 	strbne	r3, [r5]
300039e4:	13a00000 	movne	r0, #0
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (OS_FALSE);
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
300039e8:	1afffff5 	bne	300039c4 <OSTmrStop+0x44>
        *perr  = OS_ERR_TMR_ISR;
        return (OS_FALSE);
    }
    OSTmr_Lock();
300039ec:	e58d1004 	str	r1, [sp, #4]
300039f0:	e58d2000 	str	r2, [sp]
300039f4:	ebffffd6 	bl	30003954 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
300039f8:	e5d43031 	ldrb	r3, [r4, #49]	; 0x31
300039fc:	e59d1004 	ldr	r1, [sp, #4]
30003a00:	e59d2000 	ldr	r2, [sp]
30003a04:	e3530003 	cmp	r3, #3
30003a08:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30003a0c:	ea000020 	b	30003a94 <OSTmrStop+0x114>
30003a10:	30003a80 	andcc	r3, r0, r0, lsl #21
30003a14:	30003a6c 	andcc	r3, r0, ip, ror #20
30003a18:	30003a6c 	andcc	r3, r0, ip, ror #20
30003a1c:	30003a20 	andcc	r3, r0, r0, lsr #20
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
30003a20:	e1a00004 	mov	r0, r4
30003a24:	e58d1004 	str	r1, [sp, #4]
30003a28:	e58d2000 	str	r2, [sp]
30003a2c:	ebfff59c 	bl	300010a4 <OSTmr_Unlink>
             *perr = OS_NO_ERR;
             switch (opt) {
30003a30:	e59d1004 	ldr	r1, [sp, #4]
    }
    OSTmr_Lock();
    switch (ptmr->OSTmrState) {
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
             *perr = OS_NO_ERR;
30003a34:	e3a06000 	mov	r6, #0
30003a38:	e5c56000 	strb	r6, [r5]
             switch (opt) {
30003a3c:	e3510003 	cmp	r1, #3
30003a40:	e59d2000 	ldr	r2, [sp]
30003a44:	0a000017 	beq	30003aa8 <OSTmrStop+0x128>
30003a48:	e3510004 	cmp	r1, #4
30003a4c:	0a00001f 	beq	30003ad0 <OSTmrStop+0x150>
30003a50:	e1510006 	cmp	r1, r6
30003a54:	0a00001a 	beq	30003ac4 <OSTmrStop+0x144>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     OSTmr_Unlock();
30003a58:	ebffff45 	bl	30003774 <OSTmr_Unlock>
                     *perr = OS_ERR_TMR_INVALID_OPT;
30003a5c:	e3e03053 	mvn	r3, #83	; 0x53
30003a60:	e5c53000 	strb	r3, [r5]
30003a64:	e1a00006 	mov	r0, r6
                     return (OS_FALSE);
30003a68:	eaffffd5 	b	300039c4 <OSTmrStop+0x44>
             OSTmr_Unlock();
             return (OS_TRUE);

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
30003a6c:	ebffff40 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
30003a70:	e3e03049 	mvn	r3, #73	; 0x49
30003a74:	e5c53000 	strb	r3, [r5]
30003a78:	e3a00001 	mov	r0, #1
             return (OS_TRUE);
30003a7c:	eaffffd0 	b	300039c4 <OSTmrStop+0x44>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
30003a80:	ebffff3b 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
30003a84:	e3e03050 	mvn	r3, #80	; 0x50
30003a88:	e5c53000 	strb	r3, [r5]
30003a8c:	e3a00000 	mov	r0, #0
             return (OS_FALSE);
30003a90:	eaffffcb 	b	300039c4 <OSTmrStop+0x44>

        default:
             OSTmr_Unlock();
30003a94:	ebffff36 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
30003a98:	e3e0304a 	mvn	r3, #74	; 0x4a
30003a9c:	e5c53000 	strb	r3, [r5]
30003aa0:	e3a00000 	mov	r0, #0
             return (OS_FALSE);
30003aa4:	eaffffc6 	b	300039c4 <OSTmrStop+0x44>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
             *perr = OS_NO_ERR;
             switch (opt) {
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
30003aa8:	e5943004 	ldr	r3, [r4, #4]
                      if (pfnct != (OS_TMR_CALLBACK)0) {
30003aac:	e3530000 	cmp	r3, #0
30003ab0:	0a00000e 	beq	30003af0 <OSTmrStop+0x170>
                          (*pfnct)(ptmr, ptmr->OSTmrCallbackArg); /* ... using the 'argument' specified @ creation    */
30003ab4:	e1a00004 	mov	r0, r4
30003ab8:	e5941008 	ldr	r1, [r4, #8]
30003abc:	e1a0e00f 	mov	lr, pc
30003ac0:	e12fff13 	bx	r3
                 default:
                     OSTmr_Unlock();
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     return (OS_FALSE);
             }
             OSTmr_Unlock();
30003ac4:	ebffff2a 	bl	30003774 <OSTmr_Unlock>
30003ac8:	e3a00001 	mov	r0, #1
             return (OS_TRUE);
30003acc:	eaffffbc 	b	300039c4 <OSTmrStop+0x44>
                          return (OS_FALSE);
                      }
                      break;

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
30003ad0:	e5943004 	ldr	r3, [r4, #4]
                      if (pfnct != (OS_TMR_CALLBACK)0) {
30003ad4:	e3530000 	cmp	r3, #0
30003ad8:	0a000004 	beq	30003af0 <OSTmrStop+0x170>
                          (*pfnct)(ptmr, callback_arg);           /* ... using the 'callback_arg' provided in call    */
30003adc:	e1a00004 	mov	r0, r4
30003ae0:	e1a01002 	mov	r1, r2
30003ae4:	e1a0e00f 	mov	lr, pc
30003ae8:	e12fff13 	bx	r3
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                          return (OS_FALSE);
                      }
                      break;
30003aec:	eafffff4 	b	30003ac4 <OSTmrStop+0x144>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)(ptmr, callback_arg);           /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
30003af0:	e3e02048 	mvn	r2, #72	; 0x48
30003af4:	e5c52000 	strb	r2, [r5]
30003af8:	e1a00003 	mov	r0, r3
                          return (OS_FALSE);
30003afc:	eaffffb0 	b	300039c4 <OSTmrStop+0x44>
30003b00:	3001d094 	mulcc	r1, r4, r0

30003b04 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
30003b04:	e92d4070 	push	{r4, r5, r6, lr}
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
30003b08:	e2514000 	subs	r4, r1, #0
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
30003b0c:	e1a05000 	mov	r5, r0
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
30003b10:	01a00004 	moveq	r0, r4
30003b14:	0a00000a 	beq	30003b44 <OSTmrStart+0x40>
        return (OS_FALSE);
    }
    if (ptmr == (OS_TMR *)0) {
30003b18:	e3550000 	cmp	r5, #0
        *perr = OS_ERR_TMR_INVALID;
30003b1c:	03e0304d 	mvneq	r3, #77	; 0x4d
30003b20:	05c43000 	strbeq	r3, [r4]
30003b24:	01a00005 	moveq	r0, r5
{
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
        return (OS_FALSE);
    }
    if (ptmr == (OS_TMR *)0) {
30003b28:	0a000005 	beq	30003b44 <OSTmrStart+0x40>
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
30003b2c:	e5d53000 	ldrb	r3, [r5]
30003b30:	e3530064 	cmp	r3, #100	; 0x64
        *perr = OS_ERR_TMR_INVALID_TYPE;
30003b34:	13e0304e 	mvnne	r3, #78	; 0x4e
30003b38:	15c43000 	strbne	r3, [r4]
30003b3c:	13a00000 	movne	r0, #0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
30003b40:	0a000001 	beq	30003b4c <OSTmrStart+0x48>
        default:
             OSTmr_Unlock();
             *perr = OS_ERR_TMR_INVALID_STATE;
             return (OS_FALSE);
    }
}
30003b44:	e8bd4070 	pop	{r4, r5, r6, lr}
30003b48:	e12fff1e 	bx	lr
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (OS_FALSE);
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
30003b4c:	e59f3088 	ldr	r3, [pc, #136]	; 30003bdc <OSTmrStart+0xd8>
30003b50:	e5d33000 	ldrb	r3, [r3]
30003b54:	e3530000 	cmp	r3, #0
        *perr  = OS_ERR_TMR_ISR;
30003b58:	13e0304c 	mvnne	r3, #76	; 0x4c
30003b5c:	15c43000 	strbne	r3, [r4]
30003b60:	13a00000 	movne	r0, #0
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (OS_FALSE);
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
30003b64:	1afffff6 	bne	30003b44 <OSTmrStart+0x40>
        *perr  = OS_ERR_TMR_ISR;
        return (OS_FALSE);
    }
    OSTmr_Lock();
30003b68:	ebffff79 	bl	30003954 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
30003b6c:	e5d53031 	ldrb	r3, [r5, #49]	; 0x31
30003b70:	e3530003 	cmp	r3, #3
30003b74:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30003b78:	ea000012 	b	30003bc8 <OSTmrStart+0xc4>
30003b7c:	30003bb4 	undefined instruction 0x30003bb4
30003b80:	30003b94 	mulcc	r0, r4, fp
30003b84:	30003b94 	mulcc	r0, r4, fp
30003b88:	30003b8c 	andcc	r3, r0, ip, lsl #23
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
30003b8c:	e1a00005 	mov	r0, r5
30003b90:	ebfff543 	bl	300010a4 <OSTmr_Unlink>
             *perr = OS_NO_ERR;
             return (OS_TRUE);

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
30003b94:	e1a00005 	mov	r0, r5
30003b98:	e3a01000 	mov	r1, #0
30003b9c:	ebfff519 	bl	30001008 <OSTmr_Link>
             OSTmr_Unlock();
30003ba0:	ebfffef3 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_NO_ERR;
30003ba4:	e3a03000 	mov	r3, #0
30003ba8:	e5c43000 	strb	r3, [r4]
30003bac:	e3a00001 	mov	r0, #1
             return (OS_TRUE);
30003bb0:	eaffffe3 	b	30003b44 <OSTmrStart+0x40>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
30003bb4:	ebfffeee 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
30003bb8:	e3e03050 	mvn	r3, #80	; 0x50
30003bbc:	e5c43000 	strb	r3, [r4]
30003bc0:	e3a00000 	mov	r0, #0
             return (OS_FALSE);
30003bc4:	eaffffde 	b	30003b44 <OSTmrStart+0x40>

        default:
             OSTmr_Unlock();
30003bc8:	ebfffee9 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
30003bcc:	e3e0304a 	mvn	r3, #74	; 0x4a
30003bd0:	e5c43000 	strb	r3, [r4]
30003bd4:	e3a00000 	mov	r0, #0
             return (OS_FALSE);
30003bd8:	eaffffd9 	b	30003b44 <OSTmrStart+0x40>
30003bdc:	3001d094 	mulcc	r1, r4, r0

30003be0 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
30003be0:	e92d4030 	push	{r4, r5, lr}
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
30003be4:	e2514000 	subs	r4, r1, #0
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
30003be8:	e24dd00c 	sub	sp, sp, #12
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
30003bec:	01a00004 	moveq	r0, r4
30003bf0:	0a000009 	beq	30003c1c <OSTmrStateGet+0x3c>
        return (0);
    }
    if (ptmr == (OS_TMR *)0) {
30003bf4:	e3500000 	cmp	r0, #0
        *perr = OS_ERR_TMR_INVALID;
30003bf8:	03e0304d 	mvneq	r3, #77	; 0x4d
30003bfc:	05c43000 	strbeq	r3, [r4]

#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
        return (0);
    }
    if (ptmr == (OS_TMR *)0) {
30003c00:	0a000005 	beq	30003c1c <OSTmrStateGet+0x3c>
        *perr = OS_ERR_TMR_INVALID;
        return (0);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
30003c04:	e5d03000 	ldrb	r3, [r0]
30003c08:	e3530064 	cmp	r3, #100	; 0x64
        *perr = OS_ERR_TMR_INVALID_TYPE;
30003c0c:	13e0304e 	mvnne	r3, #78	; 0x4e
30003c10:	15c43000 	strbne	r3, [r4]
30003c14:	13a00000 	movne	r0, #0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
30003c18:	0a000002 	beq	30003c28 <OSTmrStateGet+0x48>
             *perr = OS_ERR_TMR_INVALID_STATE;
             break;
    }
    OSTmr_Unlock();
    return (state);
}
30003c1c:	e28dd00c 	add	sp, sp, #12
30003c20:	e8bd4030 	pop	{r4, r5, lr}
30003c24:	e12fff1e 	bx	lr
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
30003c28:	e59f3044 	ldr	r3, [pc, #68]	; 30003c74 <OSTmrStateGet+0x94>
30003c2c:	e5d35000 	ldrb	r5, [r3]
30003c30:	e3550000 	cmp	r5, #0
        *perr = OS_ERR_TMR_ISR;
30003c34:	13e0304c 	mvnne	r3, #76	; 0x4c
30003c38:	15c43000 	strbne	r3, [r4]
30003c3c:	13a00000 	movne	r0, #0
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
30003c40:	1afffff5 	bne	30003c1c <OSTmrStateGet+0x3c>
        *perr = OS_ERR_TMR_ISR;
        return (0);
    }
    OSTmr_Lock();
30003c44:	e58d0004 	str	r0, [sp, #4]
30003c48:	ebffff41 	bl	30003954 <OSTmr_Lock>
    state = ptmr->OSTmrState;
30003c4c:	e59d0004 	ldr	r0, [sp, #4]
30003c50:	e5d00031 	ldrb	r0, [r0, #49]	; 0x31
    switch (state) {
30003c54:	e3500003 	cmp	r0, #3
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_NO_ERR;
             break;
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
30003c58:	83e0304a 	mvnhi	r3, #74	; 0x4a
    switch (state) {
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_NO_ERR;
30003c5c:	95c45000 	strbls	r5, [r4]
             break;
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
30003c60:	85c43000 	strbhi	r3, [r4]
             break;
    }
    OSTmr_Unlock();
30003c64:	e58d0004 	str	r0, [sp, #4]
30003c68:	ebfffec1 	bl	30003774 <OSTmr_Unlock>
30003c6c:	e59d0004 	ldr	r0, [sp, #4]
    return (state);
30003c70:	eaffffe9 	b	30003c1c <OSTmrStateGet+0x3c>
30003c74:	3001d094 	mulcc	r1, r4, r0

30003c78 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
30003c78:	e92d4030 	push	{r4, r5, lr}
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
30003c7c:	e2515000 	subs	r5, r1, #0
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
30003c80:	e24dd00c 	sub	sp, sp, #12
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
30003c84:	01a04005 	moveq	r4, r5
30003c88:	0a00000a 	beq	30003cb8 <OSTmrRemainGet+0x40>
        return (0);
    }
    if (ptmr == (OS_TMR *)0) {
30003c8c:	e3500000 	cmp	r0, #0
        *perr = OS_ERR_TMR_INVALID;
30003c90:	03e0304d 	mvneq	r3, #77	; 0x4d
30003c94:	05c53000 	strbeq	r3, [r5]
30003c98:	01a04000 	moveq	r4, r0

#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
        return (0);
    }
    if (ptmr == (OS_TMR *)0) {
30003c9c:	0a000005 	beq	30003cb8 <OSTmrRemainGet+0x40>
        *perr = OS_ERR_TMR_INVALID;
        return (0);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
30003ca0:	e5d03000 	ldrb	r3, [r0]
30003ca4:	e3530064 	cmp	r3, #100	; 0x64
        *perr = OS_ERR_TMR_INVALID_TYPE;
30003ca8:	13e0304e 	mvnne	r3, #78	; 0x4e
30003cac:	15c53000 	strbne	r3, [r5]
30003cb0:	13a04000 	movne	r4, #0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
30003cb4:	0a000003 	beq	30003cc8 <OSTmrRemainGet+0x50>
        default:
             OSTmr_Unlock();
             *perr  = OS_ERR_TMR_INVALID_STATE;
             return (0);
    }
}
30003cb8:	e1a00004 	mov	r0, r4
30003cbc:	e28dd00c 	add	sp, sp, #12
30003cc0:	e8bd4030 	pop	{r4, r5, lr}
30003cc4:	e12fff1e 	bx	lr
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
30003cc8:	e59f30d0 	ldr	r3, [pc, #208]	; 30003da0 <OSTmrRemainGet+0x128>
30003ccc:	e5d33000 	ldrb	r3, [r3]
30003cd0:	e3530000 	cmp	r3, #0
        *perr = OS_ERR_TMR_ISR;
30003cd4:	13e0304c 	mvnne	r3, #76	; 0x4c
30003cd8:	15c53000 	strbne	r3, [r5]
30003cdc:	13a04000 	movne	r4, #0
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
30003ce0:	1afffff4 	bne	30003cb8 <OSTmrRemainGet+0x40>
        *perr = OS_ERR_TMR_ISR;
        return (0);
    }
    OSTmr_Lock();
30003ce4:	e58d0004 	str	r0, [sp, #4]
30003ce8:	ebffff19 	bl	30003954 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
30003cec:	e59d0004 	ldr	r0, [sp, #4]
30003cf0:	e5d03031 	ldrb	r3, [r0, #49]	; 0x31
30003cf4:	e3530003 	cmp	r3, #3
30003cf8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30003cfc:	ea000020 	b	30003d84 <OSTmrRemainGet+0x10c>
30003d00:	30003d70 	andcc	r3, r0, r0, ror sp
30003d04:	30003d40 	andcc	r3, r0, r0, asr #26
30003d08:	30003d30 	andcc	r3, r0, r0, lsr sp
30003d0c:	30003d10 	andcc	r3, r0, r0, lsl sp
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
30003d10:	e59f308c 	ldr	r3, [pc, #140]	; 30003da4 <OSTmrRemainGet+0x12c>
30003d14:	e5904014 	ldr	r4, [r0, #20]
30003d18:	e5933000 	ldr	r3, [r3]
30003d1c:	e0634004 	rsb	r4, r3, r4
             OSTmr_Unlock();
30003d20:	ebfffe93 	bl	30003774 <OSTmr_Unlock>
             *perr  = OS_NO_ERR;
30003d24:	e3a03000 	mov	r3, #0
30003d28:	e5c53000 	strb	r3, [r5]
             return (remain);
30003d2c:	eaffffe1 	b	30003cb8 <OSTmrRemainGet+0x40>
             }
             return (remain);

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
             *perr  = OS_NO_ERR;
30003d30:	e3a04000 	mov	r4, #0
                      break;
             }
             return (remain);

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
30003d34:	ebfffe8e 	bl	30003774 <OSTmr_Unlock>
             *perr  = OS_NO_ERR;
30003d38:	e5c54000 	strb	r4, [r5]
             return (0);
30003d3c:	eaffffdd 	b	30003cb8 <OSTmrRemainGet+0x40>
             OSTmr_Unlock();
             *perr  = OS_NO_ERR;
             return (remain);

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
30003d40:	e5d03030 	ldrb	r3, [r0, #48]	; 0x30
30003d44:	e3530001 	cmp	r3, #1
30003d48:	0a000012 	beq	30003d98 <OSTmrRemainGet+0x120>
30003d4c:	e3530002 	cmp	r3, #2
30003d50:	1affffd8 	bne	30003cb8 <OSTmrRemainGet+0x40>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
30003d54:	e5904018 	ldr	r4, [r0, #24]
30003d58:	e3540000 	cmp	r4, #0
                          remain = ptmr->OSTmrPeriod;
30003d5c:	0590401c 	ldreq	r4, [r0, #28]
                      *perr  = OS_NO_ERR;
                      break;

                 case OS_TMR_OPT_ONE_SHOT:
                      remain = ptmr->OSTmrDly;
                      OSTmr_Unlock();
30003d60:	ebfffe83 	bl	30003774 <OSTmr_Unlock>
                      *perr  = OS_NO_ERR;
30003d64:	e3a03000 	mov	r3, #0
30003d68:	e5c53000 	strb	r3, [r5]
30003d6c:	eaffffd1 	b	30003cb8 <OSTmrRemainGet+0x40>
             OSTmr_Unlock();
             *perr  = OS_NO_ERR;
             return (0);

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
30003d70:	ebfffe7f 	bl	30003774 <OSTmr_Unlock>
             *perr  = OS_ERR_TMR_INACTIVE;
30003d74:	e3e03050 	mvn	r3, #80	; 0x50
30003d78:	e5c53000 	strb	r3, [r5]
30003d7c:	e3a04000 	mov	r4, #0
             return (0);
30003d80:	eaffffcc 	b	30003cb8 <OSTmrRemainGet+0x40>

        default:
             OSTmr_Unlock();
30003d84:	ebfffe7a 	bl	30003774 <OSTmr_Unlock>
             *perr  = OS_ERR_TMR_INVALID_STATE;
30003d88:	e3e0304a 	mvn	r3, #74	; 0x4a
30003d8c:	e5c53000 	strb	r3, [r5]
30003d90:	e3a04000 	mov	r4, #0
             return (0);
30003d94:	eaffffc7 	b	30003cb8 <OSTmrRemainGet+0x40>
                      OSTmr_Unlock();
                      *perr  = OS_NO_ERR;
                      break;

                 case OS_TMR_OPT_ONE_SHOT:
                      remain = ptmr->OSTmrDly;
30003d98:	e5904018 	ldr	r4, [r0, #24]
30003d9c:	eaffffef 	b	30003d60 <OSTmrRemainGet+0xe8>
30003da0:	3001d094 	mulcc	r1, r4, r0
30003da4:	3001d09c 	mulcc	r1, ip, r0

30003da8 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
30003da8:	e92d4070 	push	{r4, r5, r6, lr}
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
30003dac:	e2524000 	subs	r4, r2, #0

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
30003db0:	e24dd008 	sub	sp, sp, #8
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
30003db4:	01a00004 	moveq	r0, r4
30003db8:	0a00000e 	beq	30003df8 <OSTmrNameGet+0x50>
        return (0);
    }
    if (pdest == (INT8U *)0) {
30003dbc:	e3510000 	cmp	r1, #0
        *perr = OS_ERR_TMR_INVALID_DEST;
30003dc0:	03e0304f 	mvneq	r3, #79	; 0x4f
30003dc4:	05c43000 	strbeq	r3, [r4]
30003dc8:	01a00001 	moveq	r0, r1

#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
        return (0);
    }
    if (pdest == (INT8U *)0) {
30003dcc:	0a000009 	beq	30003df8 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
        return (0);
    }
    if (ptmr == (OS_TMR *)0) {
30003dd0:	e3500000 	cmp	r0, #0
        *perr = OS_ERR_TMR_INVALID;
30003dd4:	03e0304d 	mvneq	r3, #77	; 0x4d
30003dd8:	05c43000 	strbeq	r3, [r4]
    }
    if (pdest == (INT8U *)0) {
        *perr = OS_ERR_TMR_INVALID_DEST;
        return (0);
    }
    if (ptmr == (OS_TMR *)0) {
30003ddc:	0a000005 	beq	30003df8 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID;
        return (0);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
30003de0:	e5d03000 	ldrb	r3, [r0]
30003de4:	e3530064 	cmp	r3, #100	; 0x64
        *perr = OS_ERR_TMR_INVALID_TYPE;
30003de8:	13e0304e 	mvnne	r3, #78	; 0x4e
30003dec:	15c43000 	strbne	r3, [r4]
30003df0:	13a00000 	movne	r0, #0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
30003df4:	0a000002 	beq	30003e04 <OSTmrNameGet+0x5c>
        default:
             OSTmr_Unlock();
             *perr = OS_ERR_TMR_INVALID_STATE;
             return (0);
    }
}
30003df8:	e28dd008 	add	sp, sp, #8
30003dfc:	e8bd4070 	pop	{r4, r5, r6, lr}
30003e00:	e12fff1e 	bx	lr
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
30003e04:	e59f30a8 	ldr	r3, [pc, #168]	; 30003eb4 <OSTmrNameGet+0x10c>
30003e08:	e5d35000 	ldrb	r5, [r3]
30003e0c:	e3550000 	cmp	r5, #0
        *perr  = OS_ERR_TMR_ISR;
30003e10:	13e0304c 	mvnne	r3, #76	; 0x4c
30003e14:	15c43000 	strbne	r3, [r4]
30003e18:	13a00000 	movne	r0, #0
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (0);
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
30003e1c:	1afffff5 	bne	30003df8 <OSTmrNameGet+0x50>
        *perr  = OS_ERR_TMR_ISR;
        return (0);
    }
    OSTmr_Lock();
30003e20:	e88d0003 	stm	sp, {r0, r1}
30003e24:	ebfffeca 	bl	30003954 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
30003e28:	e89d0003 	ldm	sp, {r0, r1}
30003e2c:	e5d06031 	ldrb	r6, [r0, #49]	; 0x31
30003e30:	e3560000 	cmp	r6, #0
30003e34:	1a000004 	bne	30003e4c <OSTmrNameGet+0xa4>
             OSTmr_Unlock();
             *perr = OS_NO_ERR;
             return (len);

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
30003e38:	ebfffe4d 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
30003e3c:	e3e03050 	mvn	r3, #80	; 0x50
30003e40:	e5c43000 	strb	r3, [r4]
30003e44:	e1a00006 	mov	r0, r6
             return (0);
30003e48:	eaffffea 	b	30003df8 <OSTmrNameGet+0x50>
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
        *perr  = OS_ERR_TMR_ISR;
        return (0);
    }
    OSTmr_Lock();
    switch (ptmr->OSTmrState) {
30003e4c:	e3560003 	cmp	r6, #3
30003e50:	8a000012 	bhi	30003ea0 <OSTmrNameGet+0xf8>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30003e54:	e5d03020 	ldrb	r3, [r0, #32]
30003e58:	e3530000 	cmp	r3, #0
30003e5c:	01a00003 	moveq	r0, r3
30003e60:	0a000007 	beq	30003e84 <OSTmrNameGet+0xdc>
30003e64:	e2802020 	add	r2, r0, #32
30003e68:	e1a00005 	mov	r0, r5
        *pdest++ = *psrc++;
30003e6c:	e4c13001 	strb	r3, [r1], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30003e70:	e5f23001 	ldrb	r3, [r2, #1]!
        *pdest++ = *psrc++;
        len++;
30003e74:	e2800001 	add	r0, r0, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30003e78:	e3530000 	cmp	r3, #0
        *pdest++ = *psrc++;
        len++;
30003e7c:	e20000ff 	and	r0, r0, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
30003e80:	1afffff9 	bne	30003e6c <OSTmrNameGet+0xc4>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30003e84:	e3a05000 	mov	r5, #0
30003e88:	e5c15000 	strb	r5, [r1]
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
             OSTmr_Unlock();
30003e8c:	e58d0000 	str	r0, [sp]
30003e90:	ebfffe37 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_NO_ERR;
30003e94:	e5c45000 	strb	r5, [r4]
             return (len);
30003e98:	e59d0000 	ldr	r0, [sp]
30003e9c:	eaffffd5 	b	30003df8 <OSTmrNameGet+0x50>
             OSTmr_Unlock();
             *perr = OS_ERR_TMR_INACTIVE;
             return (0);

        default:
             OSTmr_Unlock();
30003ea0:	ebfffe33 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
30003ea4:	e3e0304a 	mvn	r3, #74	; 0x4a
30003ea8:	e5c43000 	strb	r3, [r4]
30003eac:	e1a00005 	mov	r0, r5
             return (0);
30003eb0:	eaffffd0 	b	30003df8 <OSTmrNameGet+0x50>
30003eb4:	3001d094 	mulcc	r1, r4, r0

30003eb8 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
30003eb8:	e92d4070 	push	{r4, r5, r6, lr}
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
30003ebc:	e2515000 	subs	r5, r1, #0
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
30003ec0:	e1a04000 	mov	r4, r0
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
30003ec4:	01a00005 	moveq	r0, r5
30003ec8:	0a00000a 	beq	30003ef8 <OSTmrDel+0x40>
        return (OS_FALSE);
    }
    if (ptmr == (OS_TMR *)0) {
30003ecc:	e3540000 	cmp	r4, #0
        *perr = OS_ERR_TMR_INVALID;
30003ed0:	03e0304d 	mvneq	r3, #77	; 0x4d
30003ed4:	05c53000 	strbeq	r3, [r5]
30003ed8:	01a00004 	moveq	r0, r4
{
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
        return (OS_FALSE);
    }
    if (ptmr == (OS_TMR *)0) {
30003edc:	0a000005 	beq	30003ef8 <OSTmrDel+0x40>
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
30003ee0:	e5d43000 	ldrb	r3, [r4]
30003ee4:	e3530064 	cmp	r3, #100	; 0x64
        *perr = OS_ERR_TMR_INVALID_TYPE;
30003ee8:	13e0304e 	mvnne	r3, #78	; 0x4e
30003eec:	15c53000 	strbne	r3, [r5]
30003ef0:	13a00000 	movne	r0, #0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
30003ef4:	0a000001 	beq	30003f00 <OSTmrDel+0x48>
        default:
             OSTmr_Unlock();
             *perr = OS_ERR_TMR_INVALID_STATE;
             return (OS_FALSE);
    }
}
30003ef8:	e8bd4070 	pop	{r4, r5, r6, lr}
30003efc:	e12fff1e 	bx	lr
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (OS_FALSE);
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
30003f00:	e59f30d4 	ldr	r3, [pc, #212]	; 30003fdc <OSTmrDel+0x124>
30003f04:	e5d33000 	ldrb	r3, [r3]
30003f08:	e3530000 	cmp	r3, #0
        *perr  = OS_ERR_TMR_ISR;
30003f0c:	13e0304c 	mvnne	r3, #76	; 0x4c
30003f10:	15c53000 	strbne	r3, [r5]
30003f14:	13a00000 	movne	r0, #0
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
        *perr = OS_ERR_TMR_INVALID_TYPE;
        return (OS_FALSE);
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
30003f18:	1afffff6 	bne	30003ef8 <OSTmrDel+0x40>
        *perr  = OS_ERR_TMR_ISR;
        return (OS_FALSE);
    }
    OSTmr_Lock();
30003f1c:	ebfffe8c 	bl	30003954 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
30003f20:	e5d43031 	ldrb	r3, [r4, #49]	; 0x31
30003f24:	e3530003 	cmp	r3, #3
30003f28:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30003f2c:	ea000025 	b	30003fc8 <OSTmrDel+0x110>
30003f30:	30003fb4 	undefined instruction 0x30003fb4
30003f34:	30003f48 	andcc	r3, r0, r8, asr #30
30003f38:	30003f48 	andcc	r3, r0, r8, asr #30
30003f3c:	30003f40 	andcc	r3, r0, r0, asr #30
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
30003f40:	e1a00004 	mov	r0, r4
30003f44:	ebfff456 	bl	300010a4 <OSTmr_Unlink>
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
30003f48:	e3a06000 	mov	r6, #0

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
30003f4c:	e59f208c 	ldr	r2, [pc, #140]	; 30003fe0 <OSTmrDel+0x128>
    OSTmrFree++;
30003f50:	e59f308c 	ldr	r3, [pc, #140]	; 30003fe4 <OSTmrDel+0x12c>
    ptmr->OSTmrPeriod      = 0;
    ptmr->OSTmrMatch       = 0;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
30003f54:	e3a0003f 	mov	r0, #63	; 0x3f
30003f58:	e5c40020 	strb	r0, [r4, #32]
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
30003f5c:	e5c46031 	strb	r6, [r4, #49]	; 0x31
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
30003f60:	e5c46030 	strb	r6, [r4, #48]	; 0x30
    ptmr->OSTmrMatch       = 0;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
30003f64:	e5c46021 	strb	r6, [r4, #33]	; 0x21
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
30003f68:	e59f1078 	ldr	r1, [pc, #120]	; 30003fe8 <OSTmrDel+0x130>
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
30003f6c:	e1d2c0b0 	ldrh	ip, [r2]
    OSTmrFree++;
30003f70:	e1d300b0 	ldrh	r0, [r3]
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
30003f74:	e591e000 	ldr	lr, [r1]
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
    OSTmrFree++;
30003f78:	e2800001 	add	r0, r0, #1

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
30003f7c:	e24cc001 	sub	ip, ip, #1
    OSTmrFree++;
30003f80:	e1c300b0 	strh	r0, [r3]
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
30003f84:	e584e00c 	str	lr, [r4, #12]
#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
    ptmr->OSTmrPeriod      = 0;
30003f88:	e584601c 	str	r6, [r4, #28]
    ptmr->OSTmrMatch       = 0;
30003f8c:	e5846014 	str	r6, [r4, #20]
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
30003f90:	e5846004 	str	r6, [r4, #4]
    ptmr->OSTmrCallbackArg = (void *)0;
30003f94:	e5846008 	str	r6, [r4, #8]
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
30003f98:	e5846010 	str	r6, [r4, #16]
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;
30003f9c:	e5814000 	str	r4, [r1]

    OSTmrUsed--;                                       /* Update timer object statistics                              */
30003fa0:	e1c2c0b0 	strh	ip, [r2]
             return (OS_TRUE);

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
             OSTmr_Unlock();
30003fa4:	ebfffdf2 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_NO_ERR;
30003fa8:	e5c56000 	strb	r6, [r5]
30003fac:	e3a00001 	mov	r0, #1
             return (OS_TRUE);
30003fb0:	eaffffd0 	b	30003ef8 <OSTmrDel+0x40>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
30003fb4:	ebfffdee 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
30003fb8:	e3e03050 	mvn	r3, #80	; 0x50
30003fbc:	e5c53000 	strb	r3, [r5]
30003fc0:	e3a00000 	mov	r0, #0
             return (OS_FALSE);
30003fc4:	eaffffcb 	b	30003ef8 <OSTmrDel+0x40>

        default:
             OSTmr_Unlock();
30003fc8:	ebfffde9 	bl	30003774 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
30003fcc:	e3e0304a 	mvn	r3, #74	; 0x4a
30003fd0:	e5c53000 	strb	r3, [r5]
30003fd4:	e3a00000 	mov	r0, #0
             return (OS_FALSE);
30003fd8:	eaffffc6 	b	30003ef8 <OSTmrDel+0x40>
30003fdc:	3001d094 	mulcc	r1, r4, r0
30003fe0:	3001c774 	andcc	ip, r1, r4, ror r7
30003fe4:	3001ce08 	andcc	ip, r1, r8, lsl #28
30003fe8:	3001c720 	andcc	ip, r1, r0, lsr #14

30003fec <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
30003fec:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
30003ff0:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
30003ff4:	e1a05000 	mov	r5, r0
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
30003ff8:	e3540000 	cmp	r4, #0
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
30003ffc:	e1a06001 	mov	r6, r1
30004000:	e1a07002 	mov	r7, r2
30004004:	e1a0b003 	mov	fp, r3
30004008:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
3000400c:	01a08004 	moveq	r8, r4
30004010:	0a000006 	beq	30004030 <OSTmrCreate+0x44>
        return ((OS_TMR *)0);
    }
    switch (opt) {
30004014:	e3520001 	cmp	r2, #1
30004018:	0a000044 	beq	30004130 <OSTmrCreate+0x144>
3000401c:	e3520002 	cmp	r2, #2
                 return ((OS_TMR *)0);
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
30004020:	13e03053 	mvnne	r3, #83	; 0x53
30004024:	15c43000 	strbne	r3, [r4]
30004028:	13a08000 	movne	r8, #0

#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
        return ((OS_TMR *)0);
    }
    switch (opt) {
3000402c:	0a000002 	beq	3000403c <OSTmrCreate+0x50>
    }
#endif
    OSTmr_Unlock();
    *perr = OS_NO_ERR;
    return (ptmr);
}
30004030:	e1a00008 	mov	r0, r8
30004034:	e8bd4ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
30004038:	e12fff1e 	bx	lr
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
        return ((OS_TMR *)0);
    }
    switch (opt) {
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
3000403c:	e3510000 	cmp	r1, #0
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
30004040:	03e03054 	mvneq	r3, #84	; 0x54
30004044:	05c43000 	strbeq	r3, [r4]
30004048:	01a08001 	moveq	r8, r1
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
        return ((OS_TMR *)0);
    }
    switch (opt) {
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
3000404c:	0afffff7 	beq	30004030 <OSTmrCreate+0x44>
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
30004050:	e59f3124 	ldr	r3, [pc, #292]	; 3000417c <OSTmrCreate+0x190>
30004054:	e5d3a000 	ldrb	sl, [r3]
30004058:	e35a0000 	cmp	sl, #0
        *perr  = OS_ERR_TMR_ISR;
3000405c:	13e0304c 	mvnne	r3, #76	; 0x4c
30004060:	15c43000 	strbne	r3, [r4]
30004064:	13a08000 	movne	r8, #0
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
30004068:	1afffff0 	bne	30004030 <OSTmrCreate+0x44>
        *perr  = OS_ERR_TMR_ISR;
        return ((OS_TMR *)0);
    }
    OSTmr_Lock();
3000406c:	ebfffe38 	bl	30003954 <OSTmr_Lock>
static  OS_TMR  *OSTmr_Alloc (void)
{
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
30004070:	e59f3108 	ldr	r3, [pc, #264]	; 30004180 <OSTmrCreate+0x194>
30004074:	e5938000 	ldr	r8, [r3]
30004078:	e3580000 	cmp	r8, #0
3000407c:	0a000038 	beq	30004164 <OSTmrCreate+0x178>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
30004080:	e59f10fc 	ldr	r1, [pc, #252]	; 30004184 <OSTmrCreate+0x198>
    OSTmrFree--;
30004084:	e59f20fc 	ldr	r2, [pc, #252]	; 30004188 <OSTmrCreate+0x19c>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
30004088:	e1d1c0b0 	ldrh	ip, [r1]
    OSTmrFree--;
3000408c:	e1d200b0 	ldrh	r0, [r2]

    if (OSTmrFreeList == (OS_TMR *)0) {
        return ((OS_TMR *)0);
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
30004090:	e598e00c 	ldr	lr, [r8, #12]
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
30004094:	e28cc001 	add	ip, ip, #1

    if (OSTmrFreeList == (OS_TMR *)0) {
        return ((OS_TMR *)0);
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
30004098:	e583e000 	str	lr, [r3]
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
    OSTmrFree--;
3000409c:	e2400001 	sub	r0, r0, #1
    if (ptmr == (OS_TMR *)0) {
        OSTmr_Unlock();
        *perr = OS_ERR_TMR_NON_AVAIL;
        return ((OS_TMR *)0);
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
300040a0:	e3a03001 	mov	r3, #1
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
300040a4:	e1c1c0b0 	strh	ip, [r1]
    OSTmrFree--;
300040a8:	e1c200b0 	strh	r0, [r2]
    if (ptmr == (OS_TMR *)0) {
        OSTmr_Unlock();
        *perr = OS_ERR_TMR_NON_AVAIL;
        return ((OS_TMR *)0);
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
300040ac:	e5c83031 	strb	r3, [r8, #49]	; 0x31
    ptmr->OSTmrDly         = dly;
    ptmr->OSTmrPeriod      = period;
    ptmr->OSTmrOpt         = opt;
300040b0:	e5c87030 	strb	r7, [r8, #48]	; 0x30
    ptmr->OSTmrCallback    = callback;
    ptmr->OSTmrCallbackArg = callback_arg;
300040b4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
300040b8:	e3590000 	cmp	r9, #0
        OSTmr_Unlock();
        *perr = OS_ERR_TMR_NON_AVAIL;
        return ((OS_TMR *)0);
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
    ptmr->OSTmrDly         = dly;
300040bc:	e5885018 	str	r5, [r8, #24]
    ptmr->OSTmrPeriod      = period;
300040c0:	e588601c 	str	r6, [r8, #28]
    ptmr->OSTmrOpt         = opt;
    ptmr->OSTmrCallback    = callback;
300040c4:	e588b004 	str	fp, [r8, #4]
    ptmr->OSTmrCallbackArg = callback_arg;
300040c8:	e5883008 	str	r3, [r8, #8]
    if (OSTmrFreeList == (OS_TMR *)0) {
        return ((OS_TMR *)0);
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
300040cc:	e588a00c 	str	sl, [r8, #12]
    ptmr->OSTmrPrev = (OS_TCB *)0;
300040d0:	e588a010 	str	sl, [r8, #16]
    ptmr->OSTmrPeriod      = period;
    ptmr->OSTmrOpt         = opt;
    ptmr->OSTmrCallback    = callback;
    ptmr->OSTmrCallbackArg = callback_arg;
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
300040d4:	0a000011 	beq	30004120 <OSTmrCreate+0x134>
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300040d8:	e5d93000 	ldrb	r3, [r9]
300040dc:	e3530000 	cmp	r3, #0
300040e0:	0a000023 	beq	30004174 <OSTmrCreate+0x188>
300040e4:	e1a02009 	mov	r2, r9
300040e8:	e5f21001 	ldrb	r1, [r2, #1]!
        psrc++;
        len++;
300040ec:	e28aa001 	add	sl, sl, #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300040f0:	e3510000 	cmp	r1, #0
        psrc++;
        len++;
300040f4:	e20aa0ff 	and	sl, sl, #255	; 0xff
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
300040f8:	1afffffa 	bne	300040e8 <OSTmrCreate+0xfc>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
        if (len < OS_TMR_CFG_NAME_SIZE) {
300040fc:	e35a000f 	cmp	sl, #15
30004100:	8a000010 	bhi	30004148 <OSTmrCreate+0x15c>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
30004104:	e2882020 	add	r2, r8, #32
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
        *pdest++ = *psrc++;
30004108:	e4c23001 	strb	r3, [r2], #1
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
3000410c:	e5f93001 	ldrb	r3, [r9, #1]!
30004110:	e3530000 	cmp	r3, #0
30004114:	1afffffb 	bne	30004108 <OSTmrCreate+0x11c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
30004118:	e3a03000 	mov	r3, #0
3000411c:	e5c23000 	strb	r3, [r2]
            OSTmr_Unlock();
            return (ptmr);
        }
    }
#endif
    OSTmr_Unlock();
30004120:	ebfffd93 	bl	30003774 <OSTmr_Unlock>
    *perr = OS_NO_ERR;
30004124:	e3a03000 	mov	r3, #0
30004128:	e5c43000 	strb	r3, [r4]
    return (ptmr);
3000412c:	eaffffbf 	b	30004030 <OSTmrCreate+0x44>
                 return ((OS_TMR *)0);
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
30004130:	e3500000 	cmp	r0, #0
                 *perr = OS_ERR_TMR_INVALID_DLY;
30004134:	03e03055 	mvneq	r3, #85	; 0x55
30004138:	05c43000 	strbeq	r3, [r4]
3000413c:	01a08000 	moveq	r8, r0
                 return ((OS_TMR *)0);
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
30004140:	1affffc2 	bne	30004050 <OSTmrCreate+0x64>
30004144:	eaffffb9 	b	30004030 <OSTmrCreate+0x44>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
        if (len < OS_TMR_CFG_NAME_SIZE) {
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
30004148:	e3a03023 	mov	r3, #35	; 0x23
3000414c:	e5c83020 	strb	r3, [r8, #32]
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
30004150:	e3e0304b 	mvn	r3, #75	; 0x4b
        if (len < OS_TMR_CFG_NAME_SIZE) {
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
30004154:	e5c81021 	strb	r1, [r8, #33]	; 0x21
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
30004158:	e5c43000 	strb	r3, [r4]
            OSTmr_Unlock();
3000415c:	ebfffd84 	bl	30003774 <OSTmr_Unlock>
            return (ptmr);
30004160:	eaffffb2 	b	30004030 <OSTmrCreate+0x44>
        return ((OS_TMR *)0);
    }
    OSTmr_Lock();
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
    if (ptmr == (OS_TMR *)0) {
        OSTmr_Unlock();
30004164:	ebfffd82 	bl	30003774 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
30004168:	e3e03051 	mvn	r3, #81	; 0x51
3000416c:	e5c43000 	strb	r3, [r4]
        return ((OS_TMR *)0);
30004170:	eaffffae 	b	30004030 <OSTmrCreate+0x44>
    ptmr->OSTmrCallbackArg = callback_arg;
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
        if (len < OS_TMR_CFG_NAME_SIZE) {
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
30004174:	e2882020 	add	r2, r8, #32
30004178:	eaffffe6 	b	30004118 <OSTmrCreate+0x12c>
3000417c:	3001d094 	mulcc	r1, r4, r0
30004180:	3001c720 	andcc	ip, r1, r0, lsr #14
30004184:	3001c774 	andcc	ip, r1, r4, ror r7
30004188:	3001ce08 	andcc	ip, r1, r8, lsl #28

3000418c <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
3000418c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
30004190:	e59f80b0 	ldr	r8, [pc, #176]	; 30004248 <OSTmr_Task+0xbc>
30004194:	e24dd008 	sub	sp, sp, #8
30004198:	e59f40ac 	ldr	r4, [pc, #172]	; 3000424c <OSTmr_Task+0xc0>
3000419c:	e59f70ac 	ldr	r7, [pc, #172]	; 30004250 <OSTmr_Task+0xc4>
300041a0:	e28d6007 	add	r6, sp, #7
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
300041a4:	e3a05002 	mov	r5, #2
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
300041a8:	e1a02006 	mov	r2, r6
300041ac:	e5980000 	ldr	r0, [r8]
300041b0:	e3a01000 	mov	r1, #0
300041b4:	ebfffd76 	bl	30003794 <OSSemPend>
        OSTmr_Lock();
300041b8:	ebfffde5 	bl	30003954 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
300041bc:	e5943000 	ldr	r3, [r4]
300041c0:	e2833001 	add	r3, r3, #1
        spoke  = OSTmrTime % OS_TMR_CFG_WHEEL_SIZE;              /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
300041c4:	e2032007 	and	r2, r3, #7
300041c8:	e797a182 	ldr	sl, [r7, r2, lsl #3]

    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
300041cc:	e5843000 	str	r3, [r4]
        spoke  = OSTmrTime % OS_TMR_CFG_WHEEL_SIZE;              /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
300041d0:	e35a0000 	cmp	sl, #0
300041d4:	1a000004 	bne	300041ec <OSTmr_Task+0x60>
300041d8:	ea000018 	b	30004240 <OSTmr_Task+0xb4>
300041dc:	e3590000 	cmp	r9, #0
300041e0:	0a000016 	beq	30004240 <OSTmr_Task+0xb4>
300041e4:	e5943000 	ldr	r3, [r4]
300041e8:	e1a0a009 	mov	sl, r9
            ptmr_next = ptmr->OSTmrNext;                         /* Point to next timer to update because current ... */
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
300041ec:	e59a2014 	ldr	r2, [sl, #20]
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = OSTmrTime % OS_TMR_CFG_WHEEL_SIZE;              /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
            ptmr_next = ptmr->OSTmrNext;                         /* Point to next timer to update because current ... */
300041f0:	e59a900c 	ldr	r9, [sl, #12]
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
300041f4:	e1520003 	cmp	r2, r3
300041f8:	1afffff7 	bne	300041dc <OSTmr_Task+0x50>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
300041fc:	e59a3004 	ldr	r3, [sl, #4]
                if (pfnct != (OS_TMR_CALLBACK)0) {
                    (*pfnct)(ptmr, ptmr->OSTmrCallbackArg);
30004200:	e1a0000a 	mov	r0, sl
        while (ptmr != (OS_TMR *)0) {
            ptmr_next = ptmr->OSTmrNext;                         /* Point to next timer to update because current ... */
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
                if (pfnct != (OS_TMR_CALLBACK)0) {
30004204:	e3530000 	cmp	r3, #0
                    (*pfnct)(ptmr, ptmr->OSTmrCallbackArg);
30004208:	159a1008 	ldrne	r1, [sl, #8]
3000420c:	11a0e00f 	movne	lr, pc
30004210:	112fff13 	bxne	r3
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
30004214:	e1a0000a 	mov	r0, sl
30004218:	ebfff3a1 	bl	300010a4 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
3000421c:	e5da3030 	ldrb	r3, [sl, #48]	; 0x30
30004220:	e3530002 	cmp	r3, #2
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
30004224:	15ca5031 	strbne	r5, [sl, #49]	; 0x31
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
                if (pfnct != (OS_TMR_CALLBACK)0) {
                    (*pfnct)(ptmr, ptmr->OSTmrCallbackArg);
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
30004228:	1affffeb 	bne	300041dc <OSTmr_Task+0x50>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
3000422c:	e1a0000a 	mov	r0, sl
30004230:	e3a01001 	mov	r1, #1
30004234:	ebfff373 	bl	30001008 <OSTmr_Link>
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = OSTmrTime % OS_TMR_CFG_WHEEL_SIZE;              /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
30004238:	e3590000 	cmp	r9, #0
3000423c:	1affffe8 	bne	300041e4 <OSTmr_Task+0x58>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
30004240:	ebfffd4b 	bl	30003774 <OSTmr_Unlock>
    }
30004244:	eaffffd7 	b	300041a8 <OSTmr_Task+0x1c>
30004248:	3001c768 	andcc	ip, r1, r8, ror #14
3000424c:	3001d09c 	mulcc	r1, ip, r0
30004250:	3001c724 	andcc	ip, r1, r4, lsr #14

30004254 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30004254:	e92d40f0 	push	{r4, r5, r6, r7, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004258:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
3000425c:	e24dd00c 	sub	sp, sp, #12
30004260:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004264:	0a000008 	beq	3000428c <OSSemDel+0x38>
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004268:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
3000426c:	03a03004 	moveq	r3, #4
30004270:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004274:	0a000004 	beq	3000428c <OSSemDel+0x38>
        *err = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
30004278:	e5d03000 	ldrb	r3, [r0]
3000427c:	e3530003 	cmp	r3, #3
        *err = OS_ERR_EVENT_TYPE;
30004280:	13a03001 	movne	r3, #1
30004284:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *err = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
30004288:	0a000003 	beq	3000429c <OSSemDel+0x48>
             *err                   = OS_ERR_INVALID_OPT;
             pevent_return          = pevent;
             break;
    }
    return (pevent_return);
}
3000428c:	e1a00004 	mov	r0, r4
30004290:	e28dd00c 	add	sp, sp, #12
30004294:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
30004298:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
3000429c:	e59f3108 	ldr	r3, [pc, #264]	; 300043ac <OSSemDel+0x158>
300042a0:	e5d33000 	ldrb	r3, [r3]
300042a4:	e3530000 	cmp	r3, #0
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
300042a8:	13e03073 	mvnne	r3, #115	; 0x73
300042ac:	15c53000 	strbne	r3, [r5]
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300042b0:	1afffff5 	bne	3000428c <OSSemDel+0x38>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
300042b4:	e58d1004 	str	r1, [sp, #4]
300042b8:	ebffefeb 	bl	3000026c <OS_CPU_SR_Save>
*                 will no longer be guarded by the semaphore.
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
300042bc:	e5d4600a 	ldrb	r6, [r4, #10]
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
300042c0:	e59d1004 	ldr	r1, [sp, #4]
*                 will no longer be guarded by the semaphore.
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
300042c4:	e2566000 	subs	r6, r6, #0
300042c8:	13a06001 	movne	r6, #1
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
300042cc:	e3510000 	cmp	r1, #0
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
300042d0:	e1a07000 	mov	r7, r0
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
300042d4:	1a00000e 	bne	30004314 <OSSemDel+0xc0>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
300042d8:	e3560000 	cmp	r6, #0
300042dc:	1a000012 	bne	3000432c <OSSemDel+0xd8>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
300042e0:	e59f30c8 	ldr	r3, [pc, #200]	; 300043b0 <OSSemDel+0x15c>
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
300042e4:	e3a0203f 	mov	r2, #63	; 0x3f
300042e8:	e5c42013 	strb	r2, [r4, #19]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
300042ec:	e5c46014 	strb	r6, [r4, #20]
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
300042f0:	e5c46000 	strb	r6, [r4]
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
300042f4:	e5932000 	ldr	r2, [r3]
                 pevent->OSEventCnt     = 0;
300042f8:	e1c460b8 	strh	r6, [r4, #8]
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
300042fc:	e5842004 	str	r2, [r4, #4]
                 pevent->OSEventCnt     = 0;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
30004300:	e5834000 	str	r4, [r3]
                 OS_EXIT_CRITICAL();
30004304:	ebffefe0 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                   = OS_NO_ERR;
30004308:	e1a04006 	mov	r4, r6
3000430c:	e5c56000 	strb	r6, [r5]
30004310:	eaffffdd 	b	3000428c <OSSemDel+0x38>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30004314:	e3510001 	cmp	r1, #1
30004318:	0a000007 	beq	3000433c <OSSemDel+0xe8>
             *err                   = OS_NO_ERR;
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
             break;

        default:
             OS_EXIT_CRITICAL();
3000431c:	ebffefda 	bl	3000028c <OS_CPU_SR_Restore>
             *err                   = OS_ERR_INVALID_OPT;
30004320:	e3a03007 	mov	r3, #7
30004324:	e5c53000 	strb	r3, [r5]
30004328:	eaffffd7 	b	3000428c <OSSemDel+0x38>
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
                 *err                   = OS_NO_ERR;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
3000432c:	ebffefd6 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                   = OS_ERR_TASK_WAITING;
30004330:	e3a03008 	mov	r3, #8
30004334:	e5c53000 	strb	r3, [r5]
30004338:	eaffffd3 	b	3000428c <OSSemDel+0x38>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
3000433c:	e3560000 	cmp	r6, #0
30004340:	0a000006 	beq	30004360 <OSSemDel+0x10c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM);
30004344:	e1a00004 	mov	r0, r4
30004348:	e3a01000 	mov	r1, #0
3000434c:	e3a02001 	mov	r2, #1
30004350:	ebfff1c5 	bl	30000a6c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
30004354:	e5d4300a 	ldrb	r3, [r4, #10]
30004358:	e3530000 	cmp	r3, #0
3000435c:	1afffff8 	bne	30004344 <OSSemDel+0xf0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
30004360:	e3a02000 	mov	r2, #0
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
30004364:	e59f3044 	ldr	r3, [pc, #68]	; 300043b0 <OSSemDel+0x15c>
        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
30004368:	e3a0103f 	mov	r1, #63	; 0x3f
3000436c:	e5c41013 	strb	r1, [r4, #19]
             pevent->OSEventName[1] = OS_ASCII_NUL;
30004370:	e5c42014 	strb	r2, [r4, #20]
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
30004374:	e5c42000 	strb	r2, [r4]
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
30004378:	e5931000 	ldr	r1, [r3]
             pevent->OSEventCnt     = 0;
3000437c:	e1c420b8 	strh	r2, [r4, #8]
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
30004380:	e5841004 	str	r1, [r4, #4]
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
30004384:	e1a00007 	mov	r0, r7
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
30004388:	e5834000 	str	r4, [r3]
             OS_EXIT_CRITICAL();
3000438c:	ebffefbe 	bl	3000028c <OS_CPU_SR_Restore>
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
30004390:	e3560001 	cmp	r6, #1
30004394:	0a000002 	beq	300043a4 <OSSemDel+0x150>
                 OS_Sched();                               /* Find highest priority task ready to run  */
             }
             *err                   = OS_NO_ERR;
30004398:	e3a04000 	mov	r4, #0
3000439c:	e5c54000 	strb	r4, [r5]
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
             break;
300043a0:	eaffffb9 	b	3000428c <OSSemDel+0x38>
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
                 OS_Sched();                               /* Find highest priority task ready to run  */
300043a4:	ebfff96e 	bl	30002964 <OS_Sched>
300043a8:	eafffffa 	b	30004398 <OSSemDel+0x144>
300043ac:	3001d094 	mulcc	r1, r4, r0
300043b0:	3001d090 	mulcc	r1, r0, r0

300043b4 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
300043b4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300043b8:	e2504000 	subs	r4, r0, #0
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
300043bc:	e1a05001 	mov	r5, r1
300043c0:	e1a06002 	mov	r6, r2
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300043c4:	03a00004 	moveq	r0, #4
300043c8:	0a000003 	beq	300043dc <OSQPostOpt+0x28>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
300043cc:	e5d43000 	ldrb	r3, [r4]
300043d0:	e3530002 	cmp	r3, #2
300043d4:	13a00001 	movne	r0, #1
300043d8:	0a000001 	beq	300043e4 <OSQPostOpt+0x30>
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
300043dc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
300043e0:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
300043e4:	ebffefa0 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
300043e8:	e5d4300a 	ldrb	r3, [r4, #10]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
300043ec:	e1a07000 	mov	r7, r0
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
300043f0:	e3530000 	cmp	r3, #0
300043f4:	0a00000e 	beq	30004434 <OSQPostOpt+0x80>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
300043f8:	e3160001 	tst	r6, #1
300043fc:	0a000027 	beq	300044a0 <OSQPostOpt+0xec>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
30004400:	e1a00004 	mov	r0, r4
30004404:	e1a01005 	mov	r1, r5
30004408:	e3a02004 	mov	r2, #4
3000440c:	ebfff196 	bl	30000a6c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
30004410:	e5d4300a 	ldrb	r3, [r4, #10]
30004414:	e3530000 	cmp	r3, #0
30004418:	1afffff8 	bne	30004400 <OSQPostOpt+0x4c>
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
        }
        OS_EXIT_CRITICAL();
3000441c:	e1a00007 	mov	r0, r7
30004420:	ebffef99 	bl	3000028c <OS_CPU_SR_Restore>
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {
30004424:	e2166004 	ands	r6, r6, #4
30004428:	0a000019 	beq	30004494 <OSQPostOpt+0xe0>
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
            pq->OSQIn = pq->OSQStart;
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
3000442c:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30004430:	eaffffe9 	b	300043dc <OSQPostOpt+0x28>
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {
            OS_Sched();                                     /* Find highest priority task ready to run */
        }
        return (OS_NO_ERR);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
30004434:	e5943004 	ldr	r3, [r4, #4]
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
30004438:	e1d321b6 	ldrh	r2, [r3, #22]
3000443c:	e1d311b4 	ldrh	r1, [r3, #20]
30004440:	e1520001 	cmp	r2, r1
30004444:	2a00000f 	bcs	30004488 <OSQPostOpt+0xd4>
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
30004448:	e3160002 	tst	r6, #2
3000444c:	0a000018 	beq	300044b4 <OSQPostOpt+0x100>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
30004450:	e5931010 	ldr	r1, [r3, #16]
30004454:	e5930004 	ldr	r0, [r3, #4]
30004458:	e1510000 	cmp	r1, r0
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
3000445c:	05931008 	ldreq	r1, [r3, #8]
        }
        pq->OSQOut--;
30004460:	e2410004 	sub	r0, r1, #4
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
30004464:	05831010 	streq	r1, [r3, #16]
        }
        pq->OSQOut--;
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
30004468:	e5015004 	str	r5, [r1, #-4]
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
        }
        pq->OSQOut--;
3000446c:	e5830010 	str	r0, [r3, #16]
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
            pq->OSQIn = pq->OSQStart;
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
30004470:	e2822001 	add	r2, r2, #1
30004474:	e1c321b6 	strh	r2, [r3, #22]
    OS_EXIT_CRITICAL();
30004478:	e1a00007 	mov	r0, r7
3000447c:	ebffef82 	bl	3000028c <OS_CPU_SR_Restore>
30004480:	e3a00000 	mov	r0, #0
30004484:	eaffffd4 	b	300043dc <OSQPostOpt+0x28>
        }
        return (OS_NO_ERR);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
        OS_EXIT_CRITICAL();
30004488:	ebffef7f 	bl	3000028c <OS_CPU_SR_Restore>
3000448c:	e3a0001e 	mov	r0, #30
        return (OS_Q_FULL);
30004490:	eaffffd1 	b	300043dc <OSQPostOpt+0x28>
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {
            OS_Sched();                                     /* Find highest priority task ready to run */
30004494:	ebfff932 	bl	30002964 <OS_Sched>
30004498:	e1a00006 	mov	r0, r6
3000449c:	eaffffce 	b	300043dc <OSQPostOpt+0x28>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
300044a0:	e1a00004 	mov	r0, r4
300044a4:	e1a01005 	mov	r1, r5
300044a8:	e3a02004 	mov	r2, #4
300044ac:	ebfff16e 	bl	30000a6c <OS_EventTaskRdy>
300044b0:	eaffffd9 	b	3000441c <OSQPostOpt+0x68>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
        }
        pq->OSQOut--;
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
300044b4:	e593100c 	ldr	r1, [r3, #12]
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
300044b8:	e5930008 	ldr	r0, [r3, #8]
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
        }
        pq->OSQOut--;
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
300044bc:	e4815004 	str	r5, [r1], #4
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
300044c0:	e1510000 	cmp	r1, r0
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
        }
        pq->OSQOut--;
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
300044c4:	e583100c 	str	r1, [r3, #12]
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
            pq->OSQIn = pq->OSQStart;
300044c8:	05931004 	ldreq	r1, [r3, #4]
300044cc:	0583100c 	streq	r1, [r3, #12]
300044d0:	eaffffe6 	b	30004470 <OSQPostOpt+0xbc>

300044d4 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
300044d4:	e92d4030 	push	{r4, r5, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300044d8:	e2505000 	subs	r5, r0, #0
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
300044dc:	e24dd00c 	sub	sp, sp, #12
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300044e0:	03a00004 	moveq	r0, #4
300044e4:	0a000003 	beq	300044f8 <OSQPostFront+0x24>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
300044e8:	e5d53000 	ldrb	r3, [r5]
300044ec:	e3530002 	cmp	r3, #2
300044f0:	13a00001 	movne	r0, #1
300044f4:	0a000002 	beq	30004504 <OSQPostFront+0x30>
    pq->OSQOut--;
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
300044f8:	e28dd00c 	add	sp, sp, #12
300044fc:	e8bd4030 	pop	{r4, r5, lr}
30004500:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30004504:	e58d1004 	str	r1, [sp, #4]
30004508:	ebffef57 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
3000450c:	e5d5300a 	ldrb	r3, [r5, #10]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30004510:	e1a04000 	mov	r4, r0
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
30004514:	e3530000 	cmp	r3, #0
30004518:	e59d1004 	ldr	r1, [sp, #4]
3000451c:	1a000015 	bne	30004578 <OSQPostFront+0xa4>
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
        return (OS_NO_ERR);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
30004520:	e5953004 	ldr	r3, [r5, #4]
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
30004524:	e1d321b6 	ldrh	r2, [r3, #22]
30004528:	e1d3c1b4 	ldrh	ip, [r3, #20]
3000452c:	e152000c 	cmp	r2, ip
30004530:	2a00000d 	bcs	3000456c <OSQPostFront+0x98>
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
30004534:	e5930010 	ldr	r0, [r3, #16]
30004538:	e593c004 	ldr	ip, [r3, #4]
        pq->OSQOut = pq->OSQEnd;
    }
    pq->OSQOut--;
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
3000453c:	e2822001 	add	r2, r2, #1
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
30004540:	e150000c 	cmp	r0, ip
        pq->OSQOut = pq->OSQEnd;
30004544:	05930008 	ldreq	r0, [r3, #8]
    }
    pq->OSQOut--;
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
30004548:	e1c321b6 	strh	r2, [r3, #22]
        return (OS_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
        pq->OSQOut = pq->OSQEnd;
    }
    pq->OSQOut--;
3000454c:	e240c004 	sub	ip, r0, #4
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
        pq->OSQOut = pq->OSQEnd;
30004550:	05830010 	streq	r0, [r3, #16]
    }
    pq->OSQOut--;
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
30004554:	e5001004 	str	r1, [r0, #-4]
        return (OS_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
        pq->OSQOut = pq->OSQEnd;
    }
    pq->OSQOut--;
30004558:	e583c010 	str	ip, [r3, #16]
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
3000455c:	e1a00004 	mov	r0, r4
30004560:	ebffef49 	bl	3000028c <OS_CPU_SR_Restore>
30004564:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30004568:	eaffffe2 	b	300044f8 <OSQPostFront+0x24>
        OS_Sched();                                   /* Find highest priority task ready to run       */
        return (OS_NO_ERR);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
        OS_EXIT_CRITICAL();
3000456c:	ebffef46 	bl	3000028c <OS_CPU_SR_Restore>
30004570:	e3a0001e 	mov	r0, #30
        return (OS_Q_FULL);
30004574:	eaffffdf 	b	300044f8 <OSQPostFront+0x24>
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
30004578:	e3a02004 	mov	r2, #4
3000457c:	e1a00005 	mov	r0, r5
30004580:	ebfff139 	bl	30000a6c <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
30004584:	e1a00004 	mov	r0, r4
30004588:	ebffef3f 	bl	3000028c <OS_CPU_SR_Restore>
        OS_Sched();                                   /* Find highest priority task ready to run       */
3000458c:	ebfff8f4 	bl	30002964 <OS_Sched>
30004590:	e3a00000 	mov	r0, #0
        return (OS_NO_ERR);
30004594:	eaffffd7 	b	300044f8 <OSQPostFront+0x24>

30004598 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
30004598:	e92d4030 	push	{r4, r5, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
3000459c:	e2505000 	subs	r5, r0, #0
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
300045a0:	e24dd00c 	sub	sp, sp, #12
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
300045a4:	03a00004 	moveq	r0, #4
300045a8:	0a000003 	beq	300045bc <OSQPost+0x24>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
300045ac:	e5d53000 	ldrb	r3, [r5]
300045b0:	e3530002 	cmp	r3, #2
300045b4:	13a00001 	movne	r0, #1
300045b8:	0a000002 	beq	300045c8 <OSQPost+0x30>
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
        pq->OSQIn = pq->OSQStart;
    }
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
300045bc:	e28dd00c 	add	sp, sp, #12
300045c0:	e8bd4030 	pop	{r4, r5, lr}
300045c4:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
300045c8:	e58d1004 	str	r1, [sp, #4]
300045cc:	ebffef26 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
300045d0:	e5d5300a 	ldrb	r3, [r5, #10]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
300045d4:	e1a04000 	mov	r4, r0
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
300045d8:	e3530000 	cmp	r3, #0
300045dc:	e59d1004 	ldr	r1, [sp, #4]
300045e0:	1a000014 	bne	30004638 <OSQPost+0xa0>
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
        return (OS_NO_ERR);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
300045e4:	e5953004 	ldr	r3, [r5, #4]
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
300045e8:	e1d321b6 	ldrh	r2, [r3, #22]
300045ec:	e1d3c1b4 	ldrh	ip, [r3, #20]
300045f0:	e152000c 	cmp	r2, ip
300045f4:	2a00000c 	bcs	3000462c <OSQPost+0x94>
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
300045f8:	e593000c 	ldr	r0, [r3, #12]
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
300045fc:	e593c008 	ldr	ip, [r3, #8]
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
30004600:	e4801004 	str	r1, [r0], #4
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
30004604:	e150000c 	cmp	r0, ip
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
30004608:	e2822001 	add	r2, r2, #1
3000460c:	e1c321b6 	strh	r2, [r3, #22]
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
        pq->OSQIn = pq->OSQStart;
30004610:	05932004 	ldreq	r2, [r3, #4]
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
        return (OS_Q_FULL);
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
30004614:	e583000c 	str	r0, [r3, #12]
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
        pq->OSQIn = pq->OSQStart;
30004618:	0583200c 	streq	r2, [r3, #12]
    }
    OS_EXIT_CRITICAL();
3000461c:	e1a00004 	mov	r0, r4
30004620:	ebffef19 	bl	3000028c <OS_CPU_SR_Restore>
30004624:	e3a00000 	mov	r0, #0
    return (OS_NO_ERR);
30004628:	eaffffe3 	b	300045bc <OSQPost+0x24>
        OS_Sched();                                    /* Find highest priority task ready to run      */
        return (OS_NO_ERR);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
3000462c:	ebffef16 	bl	3000028c <OS_CPU_SR_Restore>
30004630:	e3a0001e 	mov	r0, #30
        return (OS_Q_FULL);
30004634:	eaffffe0 	b	300045bc <OSQPost+0x24>
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
30004638:	e3a02004 	mov	r2, #4
3000463c:	e1a00005 	mov	r0, r5
30004640:	ebfff109 	bl	30000a6c <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
30004644:	e1a00004 	mov	r0, r4
30004648:	ebffef0f 	bl	3000028c <OS_CPU_SR_Restore>
        OS_Sched();                                    /* Find highest priority task ready to run      */
3000464c:	ebfff8c4 	bl	30002964 <OS_Sched>
30004650:	e3a00000 	mov	r0, #0
        return (OS_NO_ERR);
30004654:	eaffffd8 	b	300045bc <OSQPost+0x24>

30004658 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
30004658:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
3000465c:	e2525000 	subs	r5, r2, #0
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
30004660:	e1a04000 	mov	r4, r0
30004664:	e1a06001 	mov	r6, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
30004668:	01a04005 	moveq	r4, r5
3000466c:	0a000027 	beq	30004710 <OSQPend+0xb8>
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
30004670:	e3540000 	cmp	r4, #0
        *err = OS_ERR_PEVENT_NULL;
30004674:	03a03004 	moveq	r3, #4
30004678:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                     /* Validate 'err'                                     */
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
3000467c:	0a000023 	beq	30004710 <OSQPend+0xb8>
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
30004680:	e5d43000 	ldrb	r3, [r4]
30004684:	e3530002 	cmp	r3, #2
        *err = OS_ERR_EVENT_TYPE;
30004688:	13a03001 	movne	r3, #1
3000468c:	15c53000 	strbne	r3, [r5]
30004690:	13a04000 	movne	r4, #0
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
30004694:	1a00001d 	bne	30004710 <OSQPend+0xb8>
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
#endif
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
30004698:	e59f218c 	ldr	r2, [pc, #396]	; 3000482c <OSQPend+0x1d4>
3000469c:	e5d22000 	ldrb	r2, [r2]
300046a0:	e3520000 	cmp	r2, #0
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
300046a4:	15c53000 	strbne	r3, [r5]
300046a8:	13a04000 	movne	r4, #0
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
#endif
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
300046ac:	1a000017 	bne	30004710 <OSQPend+0xb8>
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
        return ((void *)0);
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
300046b0:	e59f3178 	ldr	r3, [pc, #376]	; 30004830 <OSQPend+0x1d8>
300046b4:	e5d33000 	ldrb	r3, [r3]
300046b8:	e3530000 	cmp	r3, #0
        *err = OS_ERR_PEND_LOCKED;               /* ... can't PEND when locked                         */
300046bc:	13a03011 	movne	r3, #17
300046c0:	15c53000 	strbne	r3, [r5]
300046c4:	11a04002 	movne	r4, r2
#endif
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
        return ((void *)0);
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
300046c8:	1a000010 	bne	30004710 <OSQPend+0xb8>
        *err = OS_ERR_PEND_LOCKED;               /* ... can't PEND when locked                         */
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
300046cc:	ebffeee6 	bl	3000026c <OS_CPU_SR_Save>
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
300046d0:	e5943004 	ldr	r3, [r4, #4]
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
300046d4:	e1d311b6 	ldrh	r1, [r3, #22]
300046d8:	e3510000 	cmp	r1, #0
300046dc:	0a00000e 	beq	3000471c <OSQPend+0xc4>
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
300046e0:	e5932010 	ldr	r2, [r3, #16]
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
300046e4:	e593c008 	ldr	ip, [r3, #8]
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
300046e8:	e4924004 	ldr	r4, [r2], #4
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
300046ec:	e2411001 	sub	r1, r1, #1
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
300046f0:	e152000c 	cmp	r2, ip
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
300046f4:	e5832010 	str	r2, [r3, #16]
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
            pq->OSQOut = pq->OSQStart;
300046f8:	05932004 	ldreq	r2, [r3, #4]
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
300046fc:	e1c311b6 	strh	r1, [r3, #22]
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
            pq->OSQOut = pq->OSQStart;
30004700:	05832010 	streq	r2, [r3, #16]
        }
        OS_EXIT_CRITICAL();
30004704:	ebffeee0 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_NO_ERR;
30004708:	e3a03000 	mov	r3, #0
3000470c:	e5c53000 	strb	r3, [r5]
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
    OS_EXIT_CRITICAL();
    *err                    = OS_NO_ERR;
    return (msg);                                /*     Return message received                        */
}
30004710:	e1a00004 	mov	r0, r4
30004714:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30004718:	e12fff1e 	bx	lr
        }
        OS_EXIT_CRITICAL();
        *err = OS_NO_ERR;
        return (msg);                            /* Return message received                            */
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_Q;          /* Task will have to pend for a message to be posted  */
3000471c:	e59f7110 	ldr	r7, [pc, #272]	; 30004834 <OSQPend+0x1dc>
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30004720:	e59fc110 	ldr	ip, [pc, #272]	; 30004838 <OSQPend+0x1e0>
30004724:	e5972000 	ldr	r2, [r7]
30004728:	e5d2e02c 	ldrb	lr, [r2, #44]	; 0x2c
3000472c:	e5d23030 	ldrb	r3, [r2, #48]	; 0x30
30004730:	e38ee004 	orr	lr, lr, #4
30004734:	e5c2e02c 	strb	lr, [r2, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
30004738:	e5c2102d 	strb	r1, [r2, #45]	; 0x2d
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
3000473c:	e1c262ba 	strh	r6, [r2, #42]	; 0x2a
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
30004740:	e582401c 	str	r4, [r2, #28]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30004744:	e7dc1003 	ldrb	r1, [ip, r3]
30004748:	e5d2e031 	ldrb	lr, [r2, #49]	; 0x31
3000474c:	e1c1100e 	bic	r1, r1, lr
    if (OSRdyTbl[y] == 0) {
30004750:	e3510000 	cmp	r1, #0
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30004754:	e7cc1003 	strb	r1, [ip, r3]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
30004758:	059f30dc 	ldreq	r3, [pc, #220]	; 3000483c <OSQPend+0x1e4>
3000475c:	05d2c032 	ldrbeq	ip, [r2, #50]	; 0x32
30004760:	05d31000 	ldrbeq	r1, [r3]
30004764:	01c1100c 	biceq	r1, r1, ip
30004768:	05c31000 	strbeq	r1, [r3]
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
3000476c:	e5d21030 	ldrb	r1, [r2, #48]	; 0x30
30004770:	e5d2c031 	ldrb	ip, [r2, #49]	; 0x31
30004774:	e0841001 	add	r1, r4, r1
30004778:	e2811008 	add	r1, r1, #8
3000477c:	e5d1e003 	ldrb	lr, [r1, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30004780:	e5d4300a 	ldrb	r3, [r4, #10]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30004784:	e18ec00c 	orr	ip, lr, ip
30004788:	e5c1c003 	strb	ip, [r1, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
3000478c:	e5d22032 	ldrb	r2, [r2, #50]	; 0x32
30004790:	e1823003 	orr	r3, r2, r3
30004794:	e5c4300a 	strb	r3, [r4, #10]
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
    OS_EXIT_CRITICAL();
30004798:	ebffeebb 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Sched();                                  /* Find next highest priority task ready to run       */
3000479c:	ebfff870 	bl	30002964 <OS_Sched>
    OS_ENTER_CRITICAL();
300047a0:	ebffeeb1 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {         /* Was task readied because of a timeout?             */
300047a4:	e5973000 	ldr	r3, [r7]
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    OS_ENTER_CRITICAL();
300047a8:	e1a01000 	mov	r1, r0
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {         /* Was task readied because of a timeout?             */
300047ac:	e5d3202d 	ldrb	r2, [r3, #45]	; 0x2d
300047b0:	e3520001 	cmp	r2, #1
300047b4:	0a000007 	beq	300047d8 <OSQPend+0x180>
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
        return ((void *)0);                      /*     No message received                            */
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    OSTCBCur->OSTCBMsg      = (void *)0;
300047b8:	e3a06000 	mov	r6, #0
        OS_EventTO(pevent);                      /* Yes                                                */
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
        return ((void *)0);                      /*     No message received                            */
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
300047bc:	e5934020 	ldr	r4, [r3, #32]
    OSTCBCur->OSTCBMsg      = (void *)0;
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
300047c0:	e583601c 	str	r6, [r3, #28]
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
        return ((void *)0);                      /*     No message received                            */
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    OSTCBCur->OSTCBMsg      = (void *)0;
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
300047c4:	e5c3602c 	strb	r6, [r3, #44]	; 0x2c
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
        return ((void *)0);                      /*     No message received                            */
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    OSTCBCur->OSTCBMsg      = (void *)0;
300047c8:	e5836020 	str	r6, [r3, #32]
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
    OS_EXIT_CRITICAL();
300047cc:	ebffeeae 	bl	3000028c <OS_CPU_SR_Restore>
    *err                    = OS_NO_ERR;
300047d0:	e5c56000 	strb	r6, [r5]
    return (msg);                                /*     Return message received                        */
300047d4:	eaffffcd 	b	30004710 <OSQPend+0xb8>
{
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
300047d8:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
300047dc:	e5d3c031 	ldrb	ip, [r3, #49]	; 0x31
300047e0:	e0842002 	add	r2, r4, r2
300047e4:	e2822008 	add	r2, r2, #8
300047e8:	e5d20003 	ldrb	r0, [r2, #3]
300047ec:	e1c0000c 	bic	r0, r0, ip
300047f0:	e5c20003 	strb	r0, [r2, #3]
    if (pevent->OSEventTbl[y] == 0x00) {
300047f4:	e3500000 	cmp	r0, #0
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
300047f8:	05d4200a 	ldrbeq	r2, [r4, #10]
300047fc:	05d30032 	ldrbeq	r0, [r3, #50]	; 0x32
30004800:	01c22000 	biceq	r2, r2, r0
30004804:	05c4200a 	strbeq	r2, [r4, #10]
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30004808:	e3a04000 	mov	r4, #0
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
3000480c:	e583401c 	str	r4, [r3, #28]
    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    if (pevent->OSEventTbl[y] == 0x00) {
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30004810:	e5c3402d 	strb	r4, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
30004814:	e5c3402c 	strb	r4, [r3, #44]	; 0x2c
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {         /* Was task readied because of a timeout?             */
        OS_EventTO(pevent);                      /* Yes                                                */
        OS_EXIT_CRITICAL();
30004818:	e1a00001 	mov	r0, r1
3000481c:	ebffee9a 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
30004820:	e3a0300a 	mov	r3, #10
30004824:	e5c53000 	strb	r3, [r5]
        return ((void *)0);                      /*     No message received                            */
30004828:	eaffffb8 	b	30004710 <OSQPend+0xb8>
3000482c:	3001d094 	mulcc	r1, r4, r0
30004830:	3001c764 	andcc	ip, r1, r4, ror #14
30004834:	3001d098 	mulcc	r1, r8, r0
30004838:	3001ce88 	andcc	ip, r1, r8, lsl #29
3000483c:	3001ce84 	andcc	ip, r1, r4, lsl #29

30004840 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30004840:	e92d40f0 	push	{r4, r5, r6, r7, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004844:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30004848:	e24dd00c 	sub	sp, sp, #12
3000484c:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004850:	0a000008 	beq	30004878 <OSQDel+0x38>
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004854:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
30004858:	03a03004 	moveq	r3, #4
3000485c:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004860:	0a000004 	beq	30004878 <OSQDel+0x38>
        *err = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
30004864:	e5d03000 	ldrb	r3, [r0]
30004868:	e3530002 	cmp	r3, #2
        *err = OS_ERR_EVENT_TYPE;
3000486c:	13a03001 	movne	r3, #1
30004870:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *err = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
30004874:	0a000003 	beq	30004888 <OSQDel+0x48>
             *err                   = OS_ERR_INVALID_OPT;
             pevent_return          = pevent;
             break;
    }
    return (pevent_return);
}
30004878:	e1a00004 	mov	r0, r4
3000487c:	e28dd00c 	add	sp, sp, #12
30004880:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
30004884:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30004888:	e59f3130 	ldr	r3, [pc, #304]	; 300049c0 <OSQDel+0x180>
3000488c:	e5d33000 	ldrb	r3, [r3]
30004890:	e3530000 	cmp	r3, #0
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
30004894:	13e03073 	mvnne	r3, #115	; 0x73
30004898:	15c53000 	strbne	r3, [r5]
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
3000489c:	1afffff5 	bne	30004878 <OSQDel+0x38>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
300048a0:	e58d1004 	str	r1, [sp, #4]
300048a4:	ebffee70 	bl	3000026c <OS_CPU_SR_Save>
*                 then, the storage can be reused.
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
300048a8:	e5d4600a 	ldrb	r6, [r4, #10]
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                              /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                             /* No                                       */
    }
    switch (opt) {
300048ac:	e59d1004 	ldr	r1, [sp, #4]
*                 then, the storage can be reused.
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
300048b0:	e2566000 	subs	r6, r6, #0
300048b4:	13a06001 	movne	r6, #1
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                              /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                             /* No                                       */
    }
    switch (opt) {
300048b8:	e3510000 	cmp	r1, #0
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
300048bc:	e1a07000 	mov	r7, r0
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                              /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                             /* No                                       */
    }
    switch (opt) {
300048c0:	1a000013 	bne	30004914 <OSQDel+0xd4>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
300048c4:	e3560000 	cmp	r6, #0
300048c8:	1a000017 	bne	3000492c <OSQDel+0xec>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
300048cc:	e59f20f0 	ldr	r2, [pc, #240]	; 300049c4 <OSQDel+0x184>
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
300048d0:	e3a0303f 	mov	r3, #63	; 0x3f
300048d4:	e5c43013 	strb	r3, [r4, #19]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
300048d8:	e5c46014 	strb	r6, [r4, #20]
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
300048dc:	e5941004 	ldr	r1, [r4, #4]
                 pq->OSQPtr             = OSQFreeList;
300048e0:	e592c000 	ldr	ip, [r2]
                 OSQFreeList            = pq;
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
300048e4:	e59f30dc 	ldr	r3, [pc, #220]	; 300049c8 <OSQDel+0x188>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
300048e8:	e581c000 	str	ip, [r1]
                 OSQFreeList            = pq;
300048ec:	e5821000 	str	r1, [r2]
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
300048f0:	e5c46000 	strb	r6, [r4]
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
300048f4:	e5932000 	ldr	r2, [r3]
                 pevent->OSEventCnt     = 0;
300048f8:	e1c460b8 	strh	r6, [r4, #8]
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
                 OSQFreeList            = pq;
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
300048fc:	e5842004 	str	r2, [r4, #4]
                 pevent->OSEventCnt     = 0;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
30004900:	e5834000 	str	r4, [r3]
                 OS_EXIT_CRITICAL();
30004904:	ebffee60 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                   = OS_NO_ERR;
30004908:	e1a04006 	mov	r4, r6
3000490c:	e5c56000 	strb	r6, [r5]
30004910:	eaffffd8 	b	30004878 <OSQDel+0x38>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                              /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                             /* No                                       */
    }
    switch (opt) {
30004914:	e3510001 	cmp	r1, #1
30004918:	0a000007 	beq	3000493c <OSQDel+0xfc>
             *err                   = OS_NO_ERR;
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
             break;

        default:
             OS_EXIT_CRITICAL();
3000491c:	ebffee5a 	bl	3000028c <OS_CPU_SR_Restore>
             *err                   = OS_ERR_INVALID_OPT;
30004920:	e3a03007 	mov	r3, #7
30004924:	e5c53000 	strb	r3, [r5]
30004928:	eaffffd2 	b	30004878 <OSQDel+0x38>
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
                 *err                   = OS_NO_ERR;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
3000492c:	ebffee56 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                   = OS_ERR_TASK_WAITING;
30004930:	e3a03008 	mov	r3, #8
30004934:	e5c53000 	strb	r3, [r5]
30004938:	eaffffce 	b	30004878 <OSQDel+0x38>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
3000493c:	e3560000 	cmp	r6, #0
30004940:	0a000006 	beq	30004960 <OSQDel+0x120>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q);
30004944:	e1a00004 	mov	r0, r4
30004948:	e3a01000 	mov	r1, #0
3000494c:	e3a02004 	mov	r2, #4
30004950:	ebfff045 	bl	30000a6c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
30004954:	e5d4300a 	ldrb	r3, [r4, #10]
30004958:	e3530000 	cmp	r3, #0
3000495c:	1afffff8 	bne	30004944 <OSQDel+0x104>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
30004960:	e3a02000 	mov	r2, #0
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
30004964:	e59f1058 	ldr	r1, [pc, #88]	; 300049c4 <OSQDel+0x184>
        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
30004968:	e3a0303f 	mov	r3, #63	; 0x3f
3000496c:	e5c43013 	strb	r3, [r4, #19]
             pevent->OSEventName[1] = OS_ASCII_NUL;
30004970:	e5c42014 	strb	r2, [r4, #20]
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
30004974:	e5940004 	ldr	r0, [r4, #4]
             pq->OSQPtr             = OSQFreeList;
30004978:	e591c000 	ldr	ip, [r1]
             OSQFreeList            = pq;
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
3000497c:	e59f3044 	ldr	r3, [pc, #68]	; 300049c8 <OSQDel+0x188>
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
30004980:	e580c000 	str	ip, [r0]
             OSQFreeList            = pq;
30004984:	e5810000 	str	r0, [r1]
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
30004988:	e5c42000 	strb	r2, [r4]
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
3000498c:	e5931000 	ldr	r1, [r3]
             pevent->OSEventCnt     = 0;
30004990:	e1c420b8 	strh	r2, [r4, #8]
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
             OSQFreeList            = pq;
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
30004994:	e5841004 	str	r1, [r4, #4]
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
30004998:	e1a00007 	mov	r0, r7
             pq->OSQPtr             = OSQFreeList;
             OSQFreeList            = pq;
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
3000499c:	e5834000 	str	r4, [r3]
             OS_EXIT_CRITICAL();
300049a0:	ebffee39 	bl	3000028c <OS_CPU_SR_Restore>
             if (tasks_waiting == OS_TRUE) {                  /* Reschedule only if task(s) were waiting  */
300049a4:	e3560001 	cmp	r6, #1
300049a8:	0a000002 	beq	300049b8 <OSQDel+0x178>
                 OS_Sched();                               /* Find highest priority task ready to run  */
             }
             *err                   = OS_NO_ERR;
300049ac:	e3a04000 	mov	r4, #0
300049b0:	e5c54000 	strb	r4, [r5]
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
             break;
300049b4:	eaffffaf 	b	30004878 <OSQDel+0x38>
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {                  /* Reschedule only if task(s) were waiting  */
                 OS_Sched();                               /* Find highest priority task ready to run  */
300049b8:	ebfff7e9 	bl	30002964 <OS_Sched>
300049bc:	eafffffa 	b	300049ac <OSQDel+0x16c>
300049c0:	3001d094 	mulcc	r1, r4, r0
300049c4:	3001ce80 	andcc	ip, r1, r0, lsl #29
300049c8:	3001d090 	mulcc	r1, r0, r0

300049cc <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
300049cc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
300049d0:	e59f3194 	ldr	r3, [pc, #404]	; 30004b6c <OSMutexPost+0x1a0>
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
300049d4:	e1a04000 	mov	r4, r0
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
300049d8:	e5d33000 	ldrb	r3, [r3]
300049dc:	e3530000 	cmp	r3, #0
300049e0:	13a00005 	movne	r0, #5
300049e4:	1a000006 	bne	30004a04 <OSMutexPost+0x38>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300049e8:	e3540000 	cmp	r4, #0
300049ec:	03a00004 	moveq	r0, #4
300049f0:	0a000003 	beq	30004a04 <OSMutexPost+0x38>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
300049f4:	e5d43000 	ldrb	r3, [r4]
300049f8:	e3530004 	cmp	r3, #4
300049fc:	13a00001 	movne	r0, #1
30004a00:	0a000001 	beq	30004a0c <OSMutexPost+0x40>
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
    pevent->OSEventPtr  = (void *)0;
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30004a04:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
30004a08:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30004a0c:	ebffee16 	bl	3000026c <OS_CPU_SR_Save>
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
30004a10:	e59f2158 	ldr	r2, [pc, #344]	; 30004b70 <OSMutexPost+0x1a4>
30004a14:	e5943004 	ldr	r3, [r4, #4]
30004a18:	e5922000 	ldr	r2, [r2]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30004a1c:	e1a05000 	mov	r5, r0
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
30004a20:	e1530002 	cmp	r3, r2
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
30004a24:	e1d410b8 	ldrh	r1, [r4, #8]
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
30004a28:	0a000002 	beq	30004a38 <OSMutexPost+0x6c>
        OS_EXIT_CRITICAL();
30004a2c:	ebffee16 	bl	3000028c <OS_CPU_SR_Restore>
30004a30:	e3a00078 	mov	r0, #120	; 0x78
        return (OS_ERR_NOT_MUTEX_OWNER);
30004a34:	eafffff2 	b	30004a04 <OSMutexPost+0x38>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
30004a38:	e5d3202e 	ldrb	r2, [r3, #46]	; 0x2e
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
30004a3c:	e1a06421 	lsr	r6, r1, #8
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
30004a40:	e1520006 	cmp	r2, r6
30004a44:	159f2128 	ldrne	r2, [pc, #296]	; 30004b74 <OSMutexPost+0x1a8>
30004a48:	0a00001e 	beq	30004ac8 <OSMutexPost+0xfc>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
    }
    OSTCBPrioTbl[pip] = (OS_TCB *)1;                  /* Reserve table entry                           */
30004a4c:	e3a03001 	mov	r3, #1
30004a50:	e7823106 	str	r3, [r2, r6, lsl #2]
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
30004a54:	e5d4700a 	ldrb	r7, [r4, #10]
30004a58:	e3570000 	cmp	r7, #0
30004a5c:	0a000011 	beq	30004aa8 <OSMutexPost+0xdc>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
30004a60:	e3a02010 	mov	r2, #16
30004a64:	e1a00004 	mov	r0, r4
30004a68:	e3a01000 	mov	r1, #0
30004a6c:	ebffeffe 	bl	30000a6c <OS_EventTaskRdy>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
        pevent->OSEventCnt |= prio;
30004a70:	e1d420b8 	ldrh	r2, [r4, #8]
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
30004a74:	e59f30f8 	ldr	r3, [pc, #248]	; 30004b74 <OSMutexPost+0x1a8>
    OSTCBPrioTbl[pip] = (OS_TCB *)1;                  /* Reserve table entry                           */
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
        pevent->OSEventCnt |= prio;
30004a78:	e3c220ff 	bic	r2, r2, #255	; 0xff
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
30004a7c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
30004a80:	e1560000 	cmp	r6, r0
    OSTCBPrioTbl[pip] = (OS_TCB *)1;                  /* Reserve table entry                           */
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
        pevent->OSEventCnt |= prio;
30004a84:	e1800002 	orr	r0, r0, r2
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
30004a88:	e5843004 	str	r3, [r4, #4]
    OSTCBPrioTbl[pip] = (OS_TCB *)1;                  /* Reserve table entry                           */
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
        pevent->OSEventCnt |= prio;
30004a8c:	e1c400b8 	strh	r0, [r4, #8]
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
30004a90:	3a000030 	bcc	30004b58 <OSMutexPost+0x18c>
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
30004a94:	e1a00005 	mov	r0, r5
30004a98:	ebffedfb 	bl	3000028c <OS_CPU_SR_Restore>
            OS_Sched();                               /*      Find highest priority task ready to run  */
30004a9c:	ebfff7b0 	bl	30002964 <OS_Sched>
30004aa0:	e3a000a0 	mov	r0, #160	; 0xa0
            return (OS_ERR_PIP_LOWER);
30004aa4:	eaffffd6 	b	30004a04 <OSMutexPost+0x38>
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
            return (OS_NO_ERR);
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
30004aa8:	e1d430b8 	ldrh	r3, [r4, #8]
    pevent->OSEventPtr  = (void *)0;
30004aac:	e5847004 	str	r7, [r4, #4]
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
            return (OS_NO_ERR);
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
30004ab0:	e38330ff 	orr	r3, r3, #255	; 0xff
30004ab4:	e1c430b8 	strh	r3, [r4, #8]
    pevent->OSEventPtr  = (void *)0;
    OS_EXIT_CRITICAL();
30004ab8:	e1a00005 	mov	r0, r5
30004abc:	ebffedf2 	bl	3000028c <OS_CPU_SR_Restore>
30004ac0:	e1a00007 	mov	r0, r7
    return (OS_NO_ERR);
30004ac4:	eaffffce 	b	30004a04 <OSMutexPost+0x38>
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30004ac8:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30004acc:	e59fc0a4 	ldr	ip, [pc, #164]	; 30004b78 <OSMutexPost+0x1ac>
30004ad0:	e5d3e031 	ldrb	lr, [r3, #49]	; 0x31
30004ad4:	e7dc0002 	ldrb	r0, [ip, r2]
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
30004ad8:	e3a08001 	mov	r8, #1
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30004adc:	e1c0000e 	bic	r0, r0, lr
    if (OSRdyTbl[y] == 0) {
30004ae0:	e3500000 	cmp	r0, #0
        OSRdyGrp &= ~ptcb->OSTCBBitY;
30004ae4:	059f7090 	ldreq	r7, [pc, #144]	; 30004b7c <OSMutexPost+0x1b0>
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30004ae8:	e7cc0002 	strb	r0, [ip, r2]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
30004aec:	05d3a032 	ldrbeq	sl, [r3, #50]	; 0x32
30004af0:	05d72000 	ldrbeq	r2, [r7]
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
30004af4:	e201e0ff 	and	lr, r1, #255	; 0xff
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
30004af8:	e1a001ae 	lsr	r0, lr, #3
30004afc:	e2000007 	and	r0, r0, #7


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
30004b00:	01c2a00a 	biceq	sl, r2, sl
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
30004b04:	e2012007 	and	r2, r1, #7
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
30004b08:	e1a01218 	lsl	r1, r8, r2
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
30004b0c:	e1a08018 	lsl	r8, r8, r0
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
30004b10:	159f7064 	ldrne	r7, [pc, #100]	; 30004b7c <OSMutexPost+0x1b0>
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
30004b14:	e20110ff 	and	r1, r1, #255	; 0xff
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
30004b18:	e20880ff 	and	r8, r8, #255	; 0xff
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
30004b1c:	15d7a000 	ldrbne	sl, [r7]
        OSRdyGrp &= ~ptcb->OSTCBBitY;
30004b20:	05c7a000 	strbeq	sl, [r7]
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
30004b24:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
30004b28:	e5c38032 	strb	r8, [r3, #50]	; 0x32
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
30004b2c:	e5c31031 	strb	r1, [r3, #49]	; 0x31
    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
30004b30:	e5c3e02e 	strb	lr, [r3, #46]	; 0x2e
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
30004b34:	e5c30030 	strb	r0, [r3, #48]	; 0x30
    ptcb->OSTCBX            = (INT8U) (prio & 0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30004b38:	e7dc9000 	ldrb	r9, [ip, r0]
    OSTCBPrioTbl[prio]      = ptcb;
30004b3c:	e59f2030 	ldr	r2, [pc, #48]	; 30004b74 <OSMutexPost+0x1a8>
    ptcb->OSTCBY            = (INT8U)((prio >> 4) & 0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & 0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
30004b40:	e18a8008 	orr	r8, sl, r8
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30004b44:	e1811009 	orr	r1, r1, r9
30004b48:	e7cc1000 	strb	r1, [ip, r0]
    ptcb->OSTCBY            = (INT8U)((prio >> 4) & 0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & 0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
30004b4c:	e5c78000 	strb	r8, [r7]
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    OSTCBPrioTbl[prio]      = ptcb;
30004b50:	e782310e 	str	r3, [r2, lr, lsl #2]
30004b54:	eaffffbc 	b	30004a4c <OSMutexPost+0x80>
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
            return (OS_ERR_PIP_LOWER);
        } else {
            OS_EXIT_CRITICAL();
30004b58:	e1a00005 	mov	r0, r5
30004b5c:	ebffedca 	bl	3000028c <OS_CPU_SR_Restore>
            OS_Sched();                               /*      Find highest priority task ready to run  */
30004b60:	ebfff77f 	bl	30002964 <OS_Sched>
30004b64:	e3a00000 	mov	r0, #0
            return (OS_NO_ERR);
30004b68:	eaffffa5 	b	30004a04 <OSMutexPost+0x38>
30004b6c:	3001d094 	mulcc	r1, r4, r0
30004b70:	3001d098 	mulcc	r1, r8, r0
30004b74:	3001dba8 	andcc	sp, r1, r8, lsr #23
30004b78:	3001ce88 	andcc	ip, r1, r8, lsl #29
30004b7c:	3001ce84 	andcc	ip, r1, r4, lsl #29

30004b80 <OSMutexPend>:
*
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/
void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
30004b80:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004b84:	e2525000 	subs	r5, r2, #0
*
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/
void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
30004b88:	e24dd014 	sub	sp, sp, #20
30004b8c:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004b90:	0a000008 	beq	30004bb8 <OSMutexPend+0x38>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004b94:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
30004b98:	03a03004 	moveq	r3, #4
30004b9c:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004ba0:	0a000004 	beq	30004bb8 <OSMutexPend+0x38>
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
30004ba4:	e5d03000 	ldrb	r3, [r0]
30004ba8:	e3530004 	cmp	r3, #4
        *err = OS_ERR_EVENT_TYPE;
30004bac:	13a03001 	movne	r3, #1
30004bb0:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
30004bb4:	0a000002 	beq	30004bc4 <OSMutexPend+0x44>
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
}
30004bb8:	e28dd014 	add	sp, sp, #20
30004bbc:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
30004bc0:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return;
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30004bc4:	e59f3314 	ldr	r3, [pc, #788]	; 30004ee0 <OSMutexPend+0x360>
30004bc8:	e5d33000 	ldrb	r3, [r3]
30004bcc:	e3530000 	cmp	r3, #0
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
30004bd0:	13a03002 	movne	r3, #2
30004bd4:	15c53000 	strbne	r3, [r5]
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return;
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30004bd8:	1afffff6 	bne	30004bb8 <OSMutexPend+0x38>
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
        return;
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
30004bdc:	e59f3300 	ldr	r3, [pc, #768]	; 30004ee4 <OSMutexPend+0x364>
30004be0:	e5d36000 	ldrb	r6, [r3]
30004be4:	e3560000 	cmp	r6, #0
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
30004be8:	13a03011 	movne	r3, #17
30004bec:	15c53000 	strbne	r3, [r5]
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
        return;
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
30004bf0:	1afffff0 	bne	30004bb8 <OSMutexPend+0x38>
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
        return;
    }
    OS_ENTER_CRITICAL();                                
30004bf4:	e58d1008 	str	r1, [sp, #8]
30004bf8:	ebffed9b 	bl	3000026c <OS_CPU_SR_Save>
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
30004bfc:	e1d4c0b8 	ldrh	ip, [r4, #8]
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
        return;
    }
    OS_ENTER_CRITICAL();                                
30004c00:	e1a02000 	mov	r2, r0
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
30004c04:	e20ce0ff 	and	lr, ip, #255	; 0xff
30004c08:	e35e00ff 	cmp	lr, #255	; 0xff
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
        return;
    }
    OS_ENTER_CRITICAL();                                
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
30004c0c:	e1a0342c 	lsr	r3, ip, #8
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
30004c10:	e59d1008 	ldr	r1, [sp, #8]
30004c14:	0a000076 	beq	30004df4 <OSMutexPend+0x274>
            *err  = OS_NO_ERR;
        }
        return;
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
30004c18:	e5940004 	ldr	r0, [r4, #4]
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
30004c1c:	e5d0c02e 	ldrb	ip, [r0, #46]	; 0x2e
30004c20:	e15c0003 	cmp	ip, r3
30004c24:	9a00002e 	bls	30004ce4 <OSMutexPend+0x164>
        if (mprio > OSTCBCur->OSTCBPrio) {
30004c28:	e59f62b8 	ldr	r6, [pc, #696]	; 30004ee8 <OSMutexPend+0x368>
30004c2c:	e596c000 	ldr	ip, [r6]
30004c30:	e5dc702e 	ldrb	r7, [ip, #46]	; 0x2e
30004c34:	e157000e 	cmp	r7, lr
30004c38:	259fe2ac 	ldrcs	lr, [pc, #684]	; 30004eec <OSMutexPend+0x36c>
30004c3c:	2a00002b 	bcs	30004cf0 <OSMutexPend+0x170>
            y = ptcb->OSTCBY;
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
30004c40:	e5d0a030 	ldrb	sl, [r0, #48]	; 0x30
30004c44:	e59fe2a0 	ldr	lr, [pc, #672]	; 30004eec <OSMutexPend+0x36c>
30004c48:	e5d08031 	ldrb	r8, [r0, #49]	; 0x31
30004c4c:	e7de700a 	ldrb	r7, [lr, sl]
30004c50:	e1170008 	tst	r7, r8
30004c54:	0a000078 	beq	30004e3c <OSMutexPend+0x2bc>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
30004c58:	e1c77008 	bic	r7, r7, r8
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
30004c5c:	e3570000 	cmp	r7, #0
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
        if (mprio > OSTCBCur->OSTCBPrio) {
            y = ptcb->OSTCBY;
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
30004c60:	e7ce700a 	strb	r7, [lr, sl]
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
30004c64:	1a00009a 	bne	30004ed4 <OSMutexPend+0x354>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
30004c68:	e59f7280 	ldr	r7, [pc, #640]	; 30004ef0 <OSMutexPend+0x370>
30004c6c:	e5d0a032 	ldrb	sl, [r0, #50]	; 0x32
30004c70:	e5d78000 	ldrb	r8, [r7]
30004c74:	e1c8a00a 	bic	sl, r8, sl
30004c78:	e5c7a000 	strb	sl, [r7]
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
30004c7c:	e2039007 	and	r9, r3, #7
30004c80:	e58d9004 	str	r9, [sp, #4]
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004c84:	e59db004 	ldr	fp, [sp, #4]
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004c88:	e3a09001 	mov	r9, #1
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004c8c:	e1a0bb19 	lsl	fp, r9, fp
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
30004c90:	e1a081a3 	lsr	r8, r3, #3
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004c94:	e1a09819 	lsl	r9, r9, r8
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004c98:	e20bb0ff 	and	fp, fp, #255	; 0xff
30004c9c:	e58db00c 	str	fp, [sp, #12]
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
30004ca0:	e5c0302e 	strb	r3, [r0, #46]	; 0x2e
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
30004ca4:	e5c08030 	strb	r8, [r0, #48]	; 0x30
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
30004ca8:	e59db004 	ldr	fp, [sp, #4]
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004cac:	e20990ff 	and	r9, r9, #255	; 0xff
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
30004cb0:	e5c0b02f 	strb	fp, [r0, #47]	; 0x2f
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004cb4:	e5c09032 	strb	r9, [r0, #50]	; 0x32
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004cb8:	e59db00c 	ldr	fp, [sp, #12]
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
30004cbc:	e18aa009 	orr	sl, sl, r9
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004cc0:	e5c0b031 	strb	fp, [r0, #49]	; 0x31
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30004cc4:	e7deb008 	ldrb	fp, [lr, r8]
30004cc8:	e59d900c 	ldr	r9, [sp, #12]
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
30004ccc:	e5c7a000 	strb	sl, [r7]
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30004cd0:	e189b00b 	orr	fp, r9, fp
30004cd4:	e7ceb008 	strb	fp, [lr, r8]
                if (pevent2 != (OS_EVENT *)0) {            /* Remove from event wait list              */
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
30004cd8:	e59f7214 	ldr	r7, [pc, #532]	; 30004ef4 <OSMutexPend+0x374>
30004cdc:	e7870103 	str	r0, [r7, r3, lsl #2]
30004ce0:	ea000002 	b	30004cf0 <OSMutexPend+0x170>
        }
        return;
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
30004ce4:	e59f61fc 	ldr	r6, [pc, #508]	; 30004ee8 <OSMutexPend+0x368>
30004ce8:	e59fe1fc 	ldr	lr, [pc, #508]	; 30004eec <OSMutexPend+0x36c>
30004cec:	e596c000 	ldr	ip, [r6]
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
        }
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_MUTEX;           /* Mutex not available, pend current task        */
30004cf0:	e5dc302c 	ldrb	r3, [ip, #44]	; 0x2c
30004cf4:	e3833010 	orr	r3, r3, #16
30004cf8:	e5cc302c 	strb	r3, [ip, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
30004cfc:	e5960000 	ldr	r0, [r6]
30004d00:	e3a0c000 	mov	ip, #0
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30004d04:	e5d03030 	ldrb	r3, [r0, #48]	; 0x30
30004d08:	e5c0c02d 	strb	ip, [r0, #45]	; 0x2d
    OSTCBCur->OSTCBDly     = timeout;                 /* Store timeout in current task's TCB           */
30004d0c:	e1c012ba 	strh	r1, [r0, #42]	; 0x2a
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
30004d10:	e580401c 	str	r4, [r0, #28]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30004d14:	e5d0c031 	ldrb	ip, [r0, #49]	; 0x31
30004d18:	e7de1003 	ldrb	r1, [lr, r3]
30004d1c:	e1c1100c 	bic	r1, r1, ip
    if (OSRdyTbl[y] == 0) {
30004d20:	e3510000 	cmp	r1, #0
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30004d24:	e7ce1003 	strb	r1, [lr, r3]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
30004d28:	059f31c0 	ldreq	r3, [pc, #448]	; 30004ef0 <OSMutexPend+0x370>
30004d2c:	05d0c032 	ldrbeq	ip, [r0, #50]	; 0x32
30004d30:	05d31000 	ldrbeq	r1, [r3]
30004d34:	01c1100c 	biceq	r1, r1, ip
30004d38:	05c31000 	strbeq	r1, [r3]
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30004d3c:	e5d01030 	ldrb	r1, [r0, #48]	; 0x30
30004d40:	e5d0c031 	ldrb	ip, [r0, #49]	; 0x31
30004d44:	e0841001 	add	r1, r4, r1
30004d48:	e2811008 	add	r1, r1, #8
30004d4c:	e5d1e003 	ldrb	lr, [r1, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30004d50:	e5d4300a 	ldrb	r3, [r4, #10]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30004d54:	e18ec00c 	orr	ip, lr, ip
30004d58:	e5c1c003 	strb	ip, [r1, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
30004d5c:	e5d01032 	ldrb	r1, [r0, #50]	; 0x32
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    OS_EXIT_CRITICAL();
30004d60:	e1a00002 	mov	r0, r2
30004d64:	e1813003 	orr	r3, r1, r3
30004d68:	e5c4300a 	strb	r3, [r4, #10]
30004d6c:	ebffed46 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Sched();                                       /* Find next highest priority task ready         */
30004d70:	ebfff6fb 	bl	30002964 <OS_Sched>
    OS_ENTER_CRITICAL();
30004d74:	ebffed3c 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we timed out during the pend           */
30004d78:	e5963000 	ldr	r3, [r6]
    OSTCBCur->OSTCBPendTO  = OS_FALSE;
    OSTCBCur->OSTCBDly     = timeout;                 /* Store timeout in current task's TCB           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
    OS_ENTER_CRITICAL();
30004d7c:	e1a01000 	mov	r1, r0
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we timed out during the pend           */
30004d80:	e5d3202d 	ldrb	r2, [r3, #45]	; 0x2d
30004d84:	e3520001 	cmp	r2, #1
30004d88:	1a000014 	bne	30004de0 <OSMutexPend+0x260>
{
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
30004d8c:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
30004d90:	e5d3c031 	ldrb	ip, [r3, #49]	; 0x31
30004d94:	e0842002 	add	r2, r4, r2
30004d98:	e2822008 	add	r2, r2, #8
30004d9c:	e5d20003 	ldrb	r0, [r2, #3]
30004da0:	e1c0000c 	bic	r0, r0, ip
30004da4:	e5c20003 	strb	r0, [r2, #3]
    if (pevent->OSEventTbl[y] == 0x00) {
30004da8:	e3500000 	cmp	r0, #0
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
30004dac:	05d4200a 	ldrbeq	r2, [r4, #10]
30004db0:	05d30032 	ldrbeq	r0, [r3, #50]	; 0x32
30004db4:	01c22000 	biceq	r2, r2, r0
30004db8:	05c4200a 	strbeq	r2, [r4, #10]
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30004dbc:	e3a02000 	mov	r2, #0
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
30004dc0:	e583201c 	str	r2, [r3, #28]
    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    if (pevent->OSEventTbl[y] == 0x00) {
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30004dc4:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
30004dc8:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        OS_EventTO(pevent);
        OS_EXIT_CRITICAL();
30004dcc:	e1a00001 	mov	r0, r1
30004dd0:	ebffed2d 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TIMEOUT;                            /* Indicate that we didn't get mutex within TO   */
30004dd4:	e3a0300a 	mov	r3, #10
30004dd8:	e5c53000 	strb	r3, [r5]
        return;
30004ddc:	eaffff75 	b	30004bb8 <OSMutexPend+0x38>
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
30004de0:	e3a04000 	mov	r4, #0
30004de4:	e583401c 	str	r4, [r3, #28]
    OS_EXIT_CRITICAL();
30004de8:	ebffed27 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;
30004dec:	e5c54000 	strb	r4, [r5]
30004df0:	eaffff70 	b	30004bb8 <OSMutexPend+0x38>
    OS_ENTER_CRITICAL();                                
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
30004df4:	e59f20ec 	ldr	r2, [pc, #236]	; 30004ee8 <OSMutexPend+0x368>
    }
    OS_ENTER_CRITICAL();                                
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
30004df8:	e20cccff 	and	ip, ip, #65280	; 0xff00
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
30004dfc:	e5922000 	ldr	r2, [r2]
    }
    OS_ENTER_CRITICAL();                                
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
30004e00:	e1c4c0b8 	strh	ip, [r4, #8]
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
30004e04:	e5d2102e 	ldrb	r1, [r2, #46]	; 0x2e
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
30004e08:	e5842004 	str	r2, [r4, #4]
    OS_ENTER_CRITICAL();                                
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
30004e0c:	e18cc001 	orr	ip, ip, r1
30004e10:	e1c4c0b8 	strh	ip, [r4, #8]
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
30004e14:	e5d2202e 	ldrb	r2, [r2, #46]	; 0x2e
30004e18:	e1520003 	cmp	r2, r3
30004e1c:	8a000003 	bhi	30004e30 <OSMutexPend+0x2b0>
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
30004e20:	ebffed19 	bl	3000028c <OS_CPU_SR_Restore>
            *err  = OS_ERR_PIP_LOWER;
30004e24:	e3e0305f 	mvn	r3, #95	; 0x5f
30004e28:	e5c53000 	strb	r3, [r5]
30004e2c:	eaffff61 	b	30004bb8 <OSMutexPend+0x38>
        } else {
            OS_EXIT_CRITICAL();
30004e30:	ebffed15 	bl	3000028c <OS_CPU_SR_Restore>
            *err  = OS_NO_ERR;
30004e34:	e5c56000 	strb	r6, [r5]
30004e38:	eaffff5e 	b	30004bb8 <OSMutexPend+0x38>
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
                }
                rdy = OS_TRUE;
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
30004e3c:	e590701c 	ldr	r7, [r0, #28]
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
30004e40:	e3570000 	cmp	r7, #0
30004e44:	0a00000a 	beq	30004e74 <OSMutexPend+0x2f4>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
30004e48:	e087a00a 	add	sl, r7, sl
30004e4c:	e28aa008 	add	sl, sl, #8
30004e50:	e5da9003 	ldrb	r9, [sl, #3]
30004e54:	e1c98008 	bic	r8, r9, r8
30004e58:	e3580000 	cmp	r8, #0
30004e5c:	e5ca8003 	strb	r8, [sl, #3]
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
30004e60:	05d0a032 	ldrbeq	sl, [r0, #50]	; 0x32
30004e64:	05d7800a 	ldrbeq	r8, [r7, #10]
30004e68:	01c8800a 	biceq	r8, r8, sl
30004e6c:	05c7800a 	strbeq	r8, [r7, #10]
30004e70:	e590701c 	ldr	r7, [r0, #28]
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
30004e74:	e1a091a3 	lsr	r9, r3, #3
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004e78:	e3a0b001 	mov	fp, #1
30004e7c:	e1a0891b 	lsl	r8, fp, r9
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
30004e80:	e203a007 	and	sl, r3, #7
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004e84:	e1a0ba1b 	lsl	fp, fp, sl
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004e88:	e20880ff 	and	r8, r8, #255	; 0xff
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
                if (pevent2 != (OS_EVENT *)0) {            /* Remove from event wait list              */
30004e8c:	e3570000 	cmp	r7, #0
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
30004e90:	e5c0b031 	strb	fp, [r0, #49]	; 0x31
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
30004e94:	e5c0302e 	strb	r3, [r0, #46]	; 0x2e
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
30004e98:	e5c09030 	strb	r9, [r0, #48]	; 0x30
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
30004e9c:	e5c0a02f 	strb	sl, [r0, #47]	; 0x2f
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
30004ea0:	e5c08032 	strb	r8, [r0, #50]	; 0x32
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
                if (pevent2 != (OS_EVENT *)0) {            /* Remove from event wait list              */
30004ea4:	0affff8b 	beq	30004cd8 <OSMutexPend+0x158>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
30004ea8:	e5d7a00a 	ldrb	sl, [r7, #10]
30004eac:	e188800a 	orr	r8, r8, sl
30004eb0:	e5c7800a 	strb	r8, [r7, #10]
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30004eb4:	e5d0a030 	ldrb	sl, [r0, #48]	; 0x30
30004eb8:	e5d08031 	ldrb	r8, [r0, #49]	; 0x31
30004ebc:	e087700a 	add	r7, r7, sl
30004ec0:	e2877008 	add	r7, r7, #8
30004ec4:	e5d7a003 	ldrb	sl, [r7, #3]
30004ec8:	e18a8008 	orr	r8, sl, r8
30004ecc:	e5c78003 	strb	r8, [r7, #3]
30004ed0:	eaffff80 	b	30004cd8 <OSMutexPend+0x158>
                rdy = OS_TRUE;
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
30004ed4:	e59f7014 	ldr	r7, [pc, #20]	; 30004ef0 <OSMutexPend+0x370>
30004ed8:	e5d7a000 	ldrb	sl, [r7]
30004edc:	eaffff66 	b	30004c7c <OSMutexPend+0xfc>
30004ee0:	3001d094 	mulcc	r1, r4, r0
30004ee4:	3001c764 	andcc	ip, r1, r4, ror #14
30004ee8:	3001d098 	mulcc	r1, r8, r0
30004eec:	3001ce88 	andcc	ip, r1, r8, lsl #29
30004ef0:	3001ce84 	andcc	ip, r1, r4, lsl #29
30004ef4:	3001dba8 	andcc	sp, r1, r8, lsr #23

30004ef8 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30004ef8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004efc:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30004f00:	e1a04000 	mov	r4, r0
30004f04:	e24dd00c 	sub	sp, sp, #12
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30004f08:	01a04005 	moveq	r4, r5
30004f0c:	0a000008 	beq	30004f34 <OSMutexDel+0x3c>
        return ((OS_EVENT *)0);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004f10:	e3540000 	cmp	r4, #0
        *err = OS_ERR_PEVENT_NULL;
30004f14:	03a03004 	moveq	r3, #4
30004f18:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return ((OS_EVENT *)0);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30004f1c:	0a000004 	beq	30004f34 <OSMutexDel+0x3c>
        *err = OS_ERR_PEVENT_NULL;
        return ((OS_EVENT *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
30004f20:	e5d43000 	ldrb	r3, [r4]
30004f24:	e3530004 	cmp	r3, #4
        *err = OS_ERR_EVENT_TYPE;
30004f28:	13a03001 	movne	r3, #1
30004f2c:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *err = OS_ERR_PEVENT_NULL;
        return ((OS_EVENT *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
30004f30:	0a000003 	beq	30004f44 <OSMutexDel+0x4c>
             *err          = OS_ERR_INVALID_OPT;
             pevent_return = pevent;
             break;
    }
    return (pevent_return);
}
30004f34:	e1a00004 	mov	r0, r4
30004f38:	e28dd00c 	add	sp, sp, #12
30004f3c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
30004f40:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30004f44:	e59f31d4 	ldr	r3, [pc, #468]	; 30005120 <OSMutexDel+0x228>
30004f48:	e5d33000 	ldrb	r3, [r3]
30004f4c:	e3530000 	cmp	r3, #0
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
30004f50:	13e03073 	mvnne	r3, #115	; 0x73
30004f54:	15c53000 	strbne	r3, [r5]
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30004f58:	1afffff5 	bne	30004f34 <OSMutexDel+0x3c>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
30004f5c:	e58d1004 	str	r1, [sp, #4]
30004f60:	ebffecc1 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
30004f64:	e5d4300a 	ldrb	r3, [r4, #10]
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30004f68:	e59d1004 	ldr	r1, [sp, #4]
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
30004f6c:	e2536000 	subs	r6, r3, #0
30004f70:	13a06001 	movne	r6, #1
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30004f74:	e3510000 	cmp	r1, #0
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
30004f78:	e1a07000 	mov	r7, r0
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30004f7c:	1a000012 	bne	30004fcc <OSMutexDel+0xd4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
30004f80:	e3560000 	cmp	r6, #0
30004f84:	1a000016 	bne	30004fe4 <OSMutexDel+0xec>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
30004f88:	e1d410b8 	ldrh	r1, [r4, #8]
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
30004f8c:	e3a0203f 	mov	r2, #63	; 0x3f
30004f90:	e5c42013 	strb	r2, [r4, #19]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
30004f94:	e59f2188 	ldr	r2, [pc, #392]	; 30005124 <OSMutexDel+0x22c>
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
30004f98:	e59f3188 	ldr	r3, [pc, #392]	; 30005128 <OSMutexDel+0x230>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
30004f9c:	e1a01421 	lsr	r1, r1, #8
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
30004fa0:	e5c46014 	strb	r6, [r4, #20]
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
30004fa4:	e7826101 	str	r6, [r2, r1, lsl #2]
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
30004fa8:	e5c46000 	strb	r6, [r4]
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
30004fac:	e5932000 	ldr	r2, [r3]
                 pevent->OSEventCnt  = 0;
30004fb0:	e1c460b8 	strh	r6, [r4, #8]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
30004fb4:	e5842004 	str	r2, [r4, #4]
                 pevent->OSEventCnt  = 0;
                 OSEventFreeList     = pevent;
30004fb8:	e5834000 	str	r4, [r3]
                 OS_EXIT_CRITICAL();
30004fbc:	ebffecb2 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                = OS_NO_ERR;
30004fc0:	e1a04006 	mov	r4, r6
30004fc4:	e5c56000 	strb	r6, [r5]
30004fc8:	eaffffd9 	b	30004f34 <OSMutexDel+0x3c>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30004fcc:	e3510001 	cmp	r1, #1
30004fd0:	0a000007 	beq	30004ff4 <OSMutexDel+0xfc>
             *err          = OS_NO_ERR;
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
             break;

        default:
             OS_EXIT_CRITICAL();
30004fd4:	ebffecac 	bl	3000028c <OS_CPU_SR_Restore>
             *err          = OS_ERR_INVALID_OPT;
30004fd8:	e3a03007 	mov	r3, #7
30004fdc:	e5c53000 	strb	r3, [r5]
30004fe0:	eaffffd3 	b	30004f34 <OSMutexDel+0x3c>
                 OSEventFreeList     = pevent;
                 OS_EXIT_CRITICAL();
                 *err                = OS_NO_ERR;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
30004fe4:	ebffeca8 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                = OS_ERR_TASK_WAITING;
30004fe8:	e3a03008 	mov	r3, #8
30004fec:	e5c53000 	strb	r3, [r5]
30004ff0:	eaffffcf 	b	30004f34 <OSMutexDel+0x3c>
             break;

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
             ptcb = (OS_TCB *)pevent->OSEventPtr;
30004ff4:	e5942004 	ldr	r2, [r4, #4]
                 pevent_return       = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
30004ff8:	e1d410b8 	ldrh	r1, [r4, #8]
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
             ptcb = (OS_TCB *)pevent->OSEventPtr;
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
30004ffc:	e3520000 	cmp	r2, #0
30005000:	0a000002 	beq	30005010 <OSMutexDel+0x118>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
30005004:	e5d2002e 	ldrb	r0, [r2, #46]	; 0x2e
30005008:	e1500421 	cmp	r0, r1, lsr #8
3000500c:	0a00001c 	beq	30005084 <OSMutexDel+0x18c>
30005010:	e59f810c 	ldr	r8, [pc, #268]	; 30005124 <OSMutexDel+0x22c>
30005014:	ea000004 	b	3000502c <OSMutexDel+0x134>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
30005018:	e1a00004 	mov	r0, r4
3000501c:	e3a01000 	mov	r1, #0
30005020:	e3a02010 	mov	r2, #16
30005024:	ebffee90 	bl	30000a6c <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
30005028:	e5d4300a 	ldrb	r3, [r4, #10]
3000502c:	e3530000 	cmp	r3, #0
30005030:	1afffff8 	bne	30005018 <OSMutexDel+0x120>
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
30005034:	e1d410b8 	ldrh	r1, [r4, #8]
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
30005038:	e3a02000 	mov	r2, #0
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
3000503c:	e59f30e4 	ldr	r3, [pc, #228]	; 30005128 <OSMutexDel+0x230>
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
30005040:	e1a01421 	lsr	r1, r1, #8
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
30005044:	e3a0003f 	mov	r0, #63	; 0x3f
30005048:	e5c40013 	strb	r0, [r4, #19]
             pevent->OSEventName[1] = OS_ASCII_NUL;
3000504c:	e5c42014 	strb	r2, [r4, #20]
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
30005050:	e7882101 	str	r2, [r8, r1, lsl #2]
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
30005054:	e5c42000 	strb	r2, [r4]
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
30005058:	e5931000 	ldr	r1, [r3]
             pevent->OSEventCnt  = 0;
3000505c:	e1c420b8 	strh	r2, [r4, #8]
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
30005060:	e5841004 	str	r1, [r4, #4]
             pevent->OSEventCnt  = 0;
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
             OS_EXIT_CRITICAL();
30005064:	e1a00007 	mov	r0, r7
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
             pevent->OSEventCnt  = 0;
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
30005068:	e5834000 	str	r4, [r3]
             OS_EXIT_CRITICAL();
3000506c:	ebffec86 	bl	3000028c <OS_CPU_SR_Restore>
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
30005070:	e3560001 	cmp	r6, #1
30005074:	0a000027 	beq	30005118 <OSMutexDel+0x220>
                 OS_Sched();                               /* Find highest priority task ready to run  */
             }
             *err          = OS_NO_ERR;
30005078:	e3a04000 	mov	r4, #0
3000507c:	e5c54000 	strb	r4, [r5]
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
             break;
30005080:	eaffffab 	b	30004f34 <OSMutexDel+0x3c>
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30005084:	e5d23030 	ldrb	r3, [r2, #48]	; 0x30
30005088:	e59f009c 	ldr	r0, [pc, #156]	; 3000512c <OSMutexDel+0x234>
3000508c:	e5d2e031 	ldrb	lr, [r2, #49]	; 0x31
30005090:	e7d0c003 	ldrb	ip, [r0, r3]
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
30005094:	e2018007 	and	r8, r1, #7
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
30005098:	e1ccc00e 	bic	ip, ip, lr
    if (OSRdyTbl[y] == 0) {
3000509c:	e35c0000 	cmp	ip, #0
        OSRdyGrp &= ~ptcb->OSTCBBitY;
300050a0:	059fe088 	ldreq	lr, [pc, #136]	; 30005130 <OSMutexDel+0x238>
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
300050a4:	e7c0c003 	strb	ip, [r0, r3]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
300050a8:	05d29032 	ldrbeq	r9, [r2, #50]	; 0x32
300050ac:	05de3000 	ldrbeq	r3, [lr]
             }
             break;

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
300050b0:	e201c0ff 	and	ip, r1, #255	; 0xff


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
300050b4:	01c39009 	biceq	r9, r3, r9
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
300050b8:	e1a031ac 	lsr	r3, ip, #3
300050bc:	e2033007 	and	r3, r3, #7
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
300050c0:	e3a0a001 	mov	sl, #1
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
300050c4:	e1a0181a 	lsl	r1, sl, r8
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
300050c8:	e1a0a31a 	lsl	sl, sl, r3
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
300050cc:	159fe05c 	ldrne	lr, [pc, #92]	; 30005130 <OSMutexDel+0x238>
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
300050d0:	e20110ff 	and	r1, r1, #255	; 0xff
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
300050d4:	e20aa0ff 	and	sl, sl, #255	; 0xff
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
300050d8:	15de9000 	ldrbne	r9, [lr]
        OSRdyGrp &= ~ptcb->OSTCBBitY;
300050dc:	05ce9000 	strbeq	r9, [lr]
    }
    ptcb->OSTCBPrio         = prio;
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
    ptcb->OSTCBX            = (INT8U) (prio & 0x07);
300050e0:	e5c2802f 	strb	r8, [r2, #47]	; 0x2f
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
300050e4:	e5c2a032 	strb	sl, [r2, #50]	; 0x32
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
300050e8:	e5c21031 	strb	r1, [r2, #49]	; 0x31
    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
300050ec:	e5c2c02e 	strb	ip, [r2, #46]	; 0x2e
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> 3) & 0x07);
300050f0:	e5c23030 	strb	r3, [r2, #48]	; 0x30
    ptcb->OSTCBX            = (INT8U) (prio & 0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
300050f4:	e7d0b003 	ldrb	fp, [r0, r3]
    OSTCBPrioTbl[prio]      = ptcb;
300050f8:	e59f8024 	ldr	r8, [pc, #36]	; 30005124 <OSMutexDel+0x22c>
    ptcb->OSTCBY            = (INT8U)((prio >> 4) & 0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & 0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
300050fc:	e189a00a 	orr	sl, r9, sl
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30005100:	e181100b 	orr	r1, r1, fp
30005104:	e7c01003 	strb	r1, [r0, r3]
    ptcb->OSTCBY            = (INT8U)((prio >> 4) & 0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & 0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
30005108:	e5cea000 	strb	sl, [lr]
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    OSTCBPrioTbl[prio]      = ptcb;
3000510c:	e788210c 	str	r2, [r8, ip, lsl #2]
30005110:	e5d4300a 	ldrb	r3, [r4, #10]
30005114:	eaffffc4 	b	3000502c <OSMutexDel+0x134>
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
             pevent->OSEventCnt  = 0;
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
                 OS_Sched();                               /* Find highest priority task ready to run  */
30005118:	ebfff611 	bl	30002964 <OS_Sched>
3000511c:	eaffffd5 	b	30005078 <OSMutexDel+0x180>
30005120:	3001d094 	mulcc	r1, r4, r0
30005124:	3001dba8 	andcc	sp, r1, r8, lsr #23
30005128:	3001d090 	mulcc	r1, r0, r0
3000512c:	3001ce88 	andcc	ip, r1, r8, lsl #29
30005130:	3001ce84 	andcc	ip, r1, r4, lsl #29

30005134 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
30005134:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30005138:	e2504000 	subs	r4, r0, #0
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
3000513c:	e1a05001 	mov	r5, r1
30005140:	e1a06002 	mov	r6, r2
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30005144:	03a00004 	moveq	r0, #4
30005148:	0a000006 	beq	30005168 <OSMboxPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
3000514c:	e3510000 	cmp	r1, #0
30005150:	03a00003 	moveq	r0, #3
30005154:	0a000003 	beq	30005168 <OSMboxPostOpt+0x34>
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
30005158:	e5d43000 	ldrb	r3, [r4]
3000515c:	e3530001 	cmp	r3, #1
30005160:	13a00001 	movne	r0, #1
30005164:	0a000001 	beq	30005170 <OSMboxPostOpt+0x3c>
        return (OS_MBOX_FULL);
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30005168:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
3000516c:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30005170:	ebffec3d 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
30005174:	e5d4300a 	ldrb	r3, [r4, #10]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30005178:	e1a07000 	mov	r7, r0
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
3000517c:	e3530000 	cmp	r3, #0
30005180:	0a000010 	beq	300051c8 <OSMboxPostOpt+0x94>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
30005184:	e3160001 	tst	r6, #1
30005188:	0a000014 	beq	300051e0 <OSMboxPostOpt+0xac>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);
3000518c:	e1a00004 	mov	r0, r4
30005190:	e1a01005 	mov	r1, r5
30005194:	e3a02002 	mov	r2, #2
30005198:	ebffee33 	bl	30000a6c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
3000519c:	e5d4300a 	ldrb	r3, [r4, #10]
300051a0:	e3530000 	cmp	r3, #0
300051a4:	1afffff8 	bne	3000518c <OSMboxPostOpt+0x58>
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
        }
        OS_EXIT_CRITICAL();
300051a8:	e1a00007 	mov	r0, r7
300051ac:	ebffec36 	bl	3000028c <OS_CPU_SR_Restore>
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {
300051b0:	e2166004 	ands	r6, r6, #4
300051b4:	13a00000 	movne	r0, #0
300051b8:	1affffea 	bne	30005168 <OSMboxPostOpt+0x34>
            OS_Sched();                                        /* Find HPT ready to run                */
300051bc:	ebfff5e8 	bl	30002964 <OS_Sched>
300051c0:	e1a00006 	mov	r0, r6
300051c4:	eaffffe7 	b	30005168 <OSMboxPostOpt+0x34>
        }
        return (OS_NO_ERR);
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
300051c8:	e5946004 	ldr	r6, [r4, #4]
300051cc:	e3560000 	cmp	r6, #0
300051d0:	0a000007 	beq	300051f4 <OSMboxPostOpt+0xc0>
        OS_EXIT_CRITICAL();
300051d4:	ebffec2c 	bl	3000028c <OS_CPU_SR_Restore>
300051d8:	e3a00014 	mov	r0, #20
        return (OS_MBOX_FULL);
300051dc:	eaffffe1 	b	30005168 <OSMboxPostOpt+0x34>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
300051e0:	e1a00004 	mov	r0, r4
300051e4:	e1a01005 	mov	r1, r5
300051e8:	e3a02002 	mov	r2, #2
300051ec:	ebffee1e 	bl	30000a6c <OS_EventTaskRdy>
300051f0:	eaffffec 	b	300051a8 <OSMboxPostOpt+0x74>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
        OS_EXIT_CRITICAL();
        return (OS_MBOX_FULL);
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
300051f4:	e5845004 	str	r5, [r4, #4]
    OS_EXIT_CRITICAL();
300051f8:	ebffec23 	bl	3000028c <OS_CPU_SR_Restore>
300051fc:	e1a00006 	mov	r0, r6
    return (OS_NO_ERR);
30005200:	eaffffd8 	b	30005168 <OSMboxPostOpt+0x34>

30005204 <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
30005204:	e92d4030 	push	{r4, r5, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30005208:	e2505000 	subs	r5, r0, #0
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
3000520c:	e24dd00c 	sub	sp, sp, #12
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
30005210:	03a00004 	moveq	r0, #4
30005214:	0a000006 	beq	30005234 <OSMboxPost+0x30>
        return (OS_ERR_PEVENT_NULL);
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
30005218:	e3510000 	cmp	r1, #0
3000521c:	03a00003 	moveq	r0, #3
30005220:	0a000003 	beq	30005234 <OSMboxPost+0x30>
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
30005224:	e5d53000 	ldrb	r3, [r5]
30005228:	e3530001 	cmp	r3, #1
3000522c:	13a00001 	movne	r0, #1
30005230:	0a000002 	beq	30005240 <OSMboxPost+0x3c>
        return (OS_MBOX_FULL);
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    OS_EXIT_CRITICAL();
    return (OS_NO_ERR);
}
30005234:	e28dd00c 	add	sp, sp, #12
30005238:	e8bd4030 	pop	{r4, r5, lr}
3000523c:	e12fff1e 	bx	lr
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
30005240:	e58d1004 	str	r1, [sp, #4]
30005244:	ebffec08 	bl	3000026c <OS_CPU_SR_Save>
    if (pevent->OSEventGrp != 0) {                        /* See if any task pending on mailbox        */
30005248:	e5d5300a 	ldrb	r3, [r5, #10]
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
3000524c:	e1a04000 	mov	r4, r0
    if (pevent->OSEventGrp != 0) {                        /* See if any task pending on mailbox        */
30005250:	e3530000 	cmp	r3, #0
30005254:	e59d1004 	ldr	r1, [sp, #4]
30005258:	1a000005 	bne	30005274 <OSMboxPost+0x70>
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
        return (OS_NO_ERR);
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
3000525c:	e5954004 	ldr	r4, [r5, #4]
30005260:	e3540000 	cmp	r4, #0
30005264:	0a00000a 	beq	30005294 <OSMboxPost+0x90>
        OS_EXIT_CRITICAL();
30005268:	ebffec07 	bl	3000028c <OS_CPU_SR_Restore>
3000526c:	e3a00014 	mov	r0, #20
        return (OS_MBOX_FULL);
30005270:	eaffffef 	b	30005234 <OSMboxPost+0x30>
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                        /* See if any task pending on mailbox        */
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
30005274:	e3a02002 	mov	r2, #2
30005278:	e1a00005 	mov	r0, r5
3000527c:	ebffedfa 	bl	30000a6c <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
30005280:	e1a00004 	mov	r0, r4
30005284:	ebffec00 	bl	3000028c <OS_CPU_SR_Restore>
        OS_Sched();                                   /* Find highest priority task ready to run       */
30005288:	ebfff5b5 	bl	30002964 <OS_Sched>
3000528c:	e3a00000 	mov	r0, #0
        return (OS_NO_ERR);
30005290:	eaffffe7 	b	30005234 <OSMboxPost+0x30>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
        OS_EXIT_CRITICAL();
        return (OS_MBOX_FULL);
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
30005294:	e5851004 	str	r1, [r5, #4]
    OS_EXIT_CRITICAL();
30005298:	ebffebfb 	bl	3000028c <OS_CPU_SR_Restore>
3000529c:	e1a00004 	mov	r0, r4
    return (OS_NO_ERR);
300052a0:	eaffffe3 	b	30005234 <OSMboxPost+0x30>

300052a4 <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
300052a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
300052a8:	e2525000 	subs	r5, r2, #0
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
300052ac:	e1a04000 	mov	r4, r0
300052b0:	e1a08001 	mov	r8, r1
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
300052b4:	01a06005 	moveq	r6, r5
300052b8:	0a00001f 	beq	3000533c <OSMboxPend+0x98>
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300052bc:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
300052c0:	03a03004 	moveq	r3, #4
300052c4:	05c53000 	strbeq	r3, [r5]
300052c8:	01a06000 	moveq	r6, r0

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                          /* Validate 'err'                                */
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
300052cc:	0a00001a 	beq	3000533c <OSMboxPend+0x98>
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
300052d0:	e5d03000 	ldrb	r3, [r0]
300052d4:	e3530001 	cmp	r3, #1
        *err = OS_ERR_EVENT_TYPE;
300052d8:	13a03001 	movne	r3, #1
300052dc:	15c53000 	strbne	r3, [r5]
300052e0:	13a06000 	movne	r6, #0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
300052e4:	1a000014 	bne	3000533c <OSMboxPend+0x98>
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
300052e8:	e59f316c 	ldr	r3, [pc, #364]	; 3000545c <OSMboxPend+0x1b8>
300052ec:	e5d36000 	ldrb	r6, [r3]
300052f0:	e3560000 	cmp	r6, #0
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
300052f4:	13a03002 	movne	r3, #2
300052f8:	15c53000 	strbne	r3, [r5]
300052fc:	13a06000 	movne	r6, #0
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
30005300:	1a00000d 	bne	3000533c <OSMboxPend+0x98>
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
        return ((void *)0);
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
30005304:	e59f3154 	ldr	r3, [pc, #340]	; 30005460 <OSMboxPend+0x1bc>
30005308:	e5d37000 	ldrb	r7, [r3]
3000530c:	e3570000 	cmp	r7, #0
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
30005310:	13a03011 	movne	r3, #17
30005314:	15c53000 	strbne	r3, [r5]
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
        return ((void *)0);
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
30005318:	1a000007 	bne	3000533c <OSMboxPend+0x98>
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
3000531c:	ebffebd2 	bl	3000026c <OS_CPU_SR_Save>
    msg = pevent->OSEventPtr;
30005320:	e5946004 	ldr	r6, [r4, #4]
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
        *err = OS_ERR_PEND_LOCKED;                    /* ... can't PEND when locked                    */
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
30005324:	e1a03000 	mov	r3, r0
    msg = pevent->OSEventPtr;
    if (msg != (void *)0) {                           /* See if there is already a message             */
30005328:	e3560000 	cmp	r6, #0
3000532c:	0a000005 	beq	30005348 <OSMboxPend+0xa4>
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
30005330:	e5847004 	str	r7, [r4, #4]
        OS_EXIT_CRITICAL();
30005334:	ebffebd4 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_NO_ERR;
30005338:	e5c57000 	strb	r7, [r5]
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
    OS_EXIT_CRITICAL();
    *err                    = OS_NO_ERR;
    return (msg);                                     /* Return the message received                   */
}
3000533c:	e1a00006 	mov	r0, r6
30005340:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30005344:	e12fff1e 	bx	lr
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
        OS_EXIT_CRITICAL();
        *err = OS_NO_ERR;
        return (msg);                                 /* Return the message received (or NULL)         */
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
30005348:	e59f7114 	ldr	r7, [pc, #276]	; 30005464 <OSMboxPend+0x1c0>
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
3000534c:	e59f0114 	ldr	r0, [pc, #276]	; 30005468 <OSMboxPend+0x1c4>
30005350:	e5971000 	ldr	r1, [r7]
30005354:	e5d1c02c 	ldrb	ip, [r1, #44]	; 0x2c
30005358:	e5d12030 	ldrb	r2, [r1, #48]	; 0x30
3000535c:	e38cc002 	orr	ip, ip, #2
30005360:	e5c1c02c 	strb	ip, [r1, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO = OS_FALSE;
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
30005364:	e1c182ba 	strh	r8, [r1, #42]	; 0x2a
        OS_EXIT_CRITICAL();
        *err = OS_NO_ERR;
        return (msg);                                 /* Return the message received (or NULL)         */
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
    OSTCBCur->OSTCBPendTO = OS_FALSE;
30005368:	e5c1602d 	strb	r6, [r1, #45]	; 0x2d
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
3000536c:	e581401c 	str	r4, [r1, #28]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30005370:	e7d0c002 	ldrb	ip, [r0, r2]
30005374:	e5d1e031 	ldrb	lr, [r1, #49]	; 0x31
30005378:	e1ccc00e 	bic	ip, ip, lr
    if (OSRdyTbl[y] == 0) {
3000537c:	e35c0000 	cmp	ip, #0
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
30005380:	e7c0c002 	strb	ip, [r0, r2]
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
30005384:	059f20e0 	ldreq	r2, [pc, #224]	; 3000546c <OSMboxPend+0x1c8>
30005388:	05d1c032 	ldrbeq	ip, [r1, #50]	; 0x32
3000538c:	05d20000 	ldrbeq	r0, [r2]
30005390:	01c0000c 	biceq	r0, r0, ip
30005394:	05c20000 	strbeq	r0, [r2]
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
30005398:	e5d10030 	ldrb	r0, [r1, #48]	; 0x30
3000539c:	e5d1c031 	ldrb	ip, [r1, #49]	; 0x31
300053a0:	e0840000 	add	r0, r4, r0
300053a4:	e2800008 	add	r0, r0, #8
300053a8:	e5d0e003 	ldrb	lr, [r0, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
300053ac:	e5d4200a 	ldrb	r2, [r4, #10]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    if (OSRdyTbl[y] == 0) {
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
300053b0:	e18ec00c 	orr	ip, lr, ip
300053b4:	e5c0c003 	strb	ip, [r0, #3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
300053b8:	e5d11032 	ldrb	r1, [r1, #50]	; 0x32
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    OS_EXIT_CRITICAL();
300053bc:	e1a00003 	mov	r0, r3
300053c0:	e1813002 	orr	r3, r1, r2
300053c4:	e5c4300a 	strb	r3, [r4, #10]
300053c8:	ebffebaf 	bl	3000028c <OS_CPU_SR_Restore>
    OS_Sched();                                       /* Find next highest priority task ready to run  */
300053cc:	ebfff564 	bl	30002964 <OS_Sched>
    OS_ENTER_CRITICAL();
300053d0:	ebffeba5 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we were given the message              */
300053d4:	e5973000 	ldr	r3, [r7]
    OSTCBCur->OSTCBPendTO = OS_FALSE;
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    OS_ENTER_CRITICAL();
300053d8:	e1a01000 	mov	r1, r0
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we were given the message              */
300053dc:	e5d3202d 	ldrb	r2, [r3, #45]	; 0x2d
300053e0:	e3520001 	cmp	r2, #1
300053e4:	0a000007 	beq	30005408 <OSMboxPend+0x164>
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
        return ((void *)0);                           /* Return a NULL message                         */
    }
    msg                     = OSTCBCur->OSTCBMsg;
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
300053e8:	e3a04000 	mov	r4, #0
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
        return ((void *)0);                           /* Return a NULL message                         */
    }
    msg                     = OSTCBCur->OSTCBMsg;
300053ec:	e5936020 	ldr	r6, [r3, #32]
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
300053f0:	e583401c 	str	r4, [r3, #28]
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
        return ((void *)0);                           /* Return a NULL message                         */
    }
    msg                     = OSTCBCur->OSTCBMsg;
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
300053f4:	e5c3402c 	strb	r4, [r3, #44]	; 0x2c
        OS_EXIT_CRITICAL();
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
        return ((void *)0);                           /* Return a NULL message                         */
    }
    msg                     = OSTCBCur->OSTCBMsg;
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
300053f8:	e5834020 	str	r4, [r3, #32]
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
    OS_EXIT_CRITICAL();
300053fc:	ebffeba2 	bl	3000028c <OS_CPU_SR_Restore>
    *err                    = OS_NO_ERR;
30005400:	e5c54000 	strb	r4, [r5]
    return (msg);                                     /* Return the message received                   */
30005404:	eaffffcc 	b	3000533c <OSMboxPend+0x98>
{
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
30005408:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
3000540c:	e5d3c031 	ldrb	ip, [r3, #49]	; 0x31
30005410:	e0842002 	add	r2, r4, r2
30005414:	e2822008 	add	r2, r2, #8
30005418:	e5d20003 	ldrb	r0, [r2, #3]
3000541c:	e1c0000c 	bic	r0, r0, ip
30005420:	e5c20003 	strb	r0, [r2, #3]
    if (pevent->OSEventTbl[y] == 0x00) {
30005424:	e3500000 	cmp	r0, #0
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
30005428:	05d4200a 	ldrbeq	r2, [r4, #10]
3000542c:	05d30032 	ldrbeq	r0, [r3, #50]	; 0x32
30005430:	01c22000 	biceq	r2, r2, r0
30005434:	05c4200a 	strbeq	r2, [r4, #10]
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30005438:	e3a02000 	mov	r2, #0
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
3000543c:	e583201c 	str	r2, [r3, #28]
    y                      = OSTCBCur->OSTCBY;
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    if (pevent->OSEventTbl[y] == 0x00) {
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    }
    OSTCBCur->OSTCBPendTO   = OS_FALSE;                /* Clear the Pend Timeout flag                  */
30005440:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
30005444:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {           /* See if we were given the message              */
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
        OS_EXIT_CRITICAL();
30005448:	e1a00001 	mov	r0, r1
3000544c:	ebffeb8e 	bl	3000028c <OS_CPU_SR_Restore>
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
30005450:	e3a0300a 	mov	r3, #10
30005454:	e5c53000 	strb	r3, [r5]
        return ((void *)0);                           /* Return a NULL message                         */
30005458:	eaffffb7 	b	3000533c <OSMboxPend+0x98>
3000545c:	3001d094 	mulcc	r1, r4, r0
30005460:	3001c764 	andcc	ip, r1, r4, ror #14
30005464:	3001d098 	mulcc	r1, r8, r0
30005468:	3001ce88 	andcc	ip, r1, r8, lsl #29
3000546c:	3001ce84 	andcc	ip, r1, r4, lsl #29

30005470 <OSMboxDel>:
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30005470:	e92d40f0 	push	{r4, r5, r6, r7, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30005474:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
30005478:	e24dd00c 	sub	sp, sp, #12
3000547c:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30005480:	0a000008 	beq	300054a8 <OSMboxDel+0x38>
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30005484:	e3500000 	cmp	r0, #0
        *err = OS_ERR_PEVENT_NULL;
30005488:	03a03004 	moveq	r3, #4
3000548c:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
30005490:	0a000004 	beq	300054a8 <OSMboxDel+0x38>
        *err = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
30005494:	e5d03000 	ldrb	r3, [r0]
30005498:	e3530001 	cmp	r3, #1
        *err = OS_ERR_EVENT_TYPE;
3000549c:	13a03001 	movne	r3, #1
300054a0:	15c53000 	strbne	r3, [r5]
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *err = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
300054a4:	0a000003 	beq	300054b8 <OSMboxDel+0x48>
             *err          = OS_ERR_INVALID_OPT;
             pevent_return = pevent;
             break;
    }
    return (pevent_return);
}
300054a8:	e1a00004 	mov	r0, r4
300054ac:	e28dd00c 	add	sp, sp, #12
300054b0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
300054b4:	e12fff1e 	bx	lr
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300054b8:	e59f3108 	ldr	r3, [pc, #264]	; 300055c8 <OSMboxDel+0x158>
300054bc:	e5d33000 	ldrb	r3, [r3]
300054c0:	e3530000 	cmp	r3, #0
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
300054c4:	13e03073 	mvnne	r3, #115	; 0x73
300054c8:	15c53000 	strbne	r3, [r5]
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300054cc:	1afffff5 	bne	300054a8 <OSMboxDel+0x38>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
300054d0:	e58d1004 	str	r1, [sp, #4]
300054d4:	ebffeb64 	bl	3000026c <OS_CPU_SR_Save>
*                 will no longer be guarded by the mailbox.
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
300054d8:	e5d4600a 	ldrb	r6, [r4, #10]
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
300054dc:	e59d1004 	ldr	r1, [sp, #4]
*                 will no longer be guarded by the mailbox.
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
300054e0:	e2566000 	subs	r6, r6, #0
300054e4:	13a06001 	movne	r6, #1
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
300054e8:	e3510000 	cmp	r1, #0
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
300054ec:	e1a07000 	mov	r7, r0
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
300054f0:	1a00000e 	bne	30005530 <OSMboxDel+0xc0>
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == OS_FALSE) {
300054f4:	e3560000 	cmp	r6, #0
300054f8:	1a000012 	bne	30005548 <OSMboxDel+0xd8>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
300054fc:	e59f30c8 	ldr	r3, [pc, #200]	; 300055cc <OSMboxDel+0x15c>
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
30005500:	e3a0203f 	mov	r2, #63	; 0x3f
30005504:	e5c42013 	strb	r2, [r4, #19]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
30005508:	e5c46014 	strb	r6, [r4, #20]
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
3000550c:	e5c46000 	strb	r6, [r4]
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
30005510:	e5932000 	ldr	r2, [r3]
                 pevent->OSEventCnt  = 0;
30005514:	e1c460b8 	strh	r6, [r4, #8]
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
30005518:	e5842004 	str	r2, [r4, #4]
                 pevent->OSEventCnt  = 0;
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
3000551c:	e5834000 	str	r4, [r3]
                 OS_EXIT_CRITICAL();
30005520:	ebffeb59 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                = OS_NO_ERR;
30005524:	e1a04006 	mov	r4, r6
30005528:	e5c56000 	strb	r6, [r5]
3000552c:	eaffffdd 	b	300054a8 <OSMboxDel+0x38>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30005530:	e3510001 	cmp	r1, #1
30005534:	0a000007 	beq	30005558 <OSMboxDel+0xe8>
             *err          = OS_NO_ERR;
             pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
             break;

        default:
             OS_EXIT_CRITICAL();
30005538:	ebffeb53 	bl	3000028c <OS_CPU_SR_Restore>
             *err          = OS_ERR_INVALID_OPT;
3000553c:	e3a03007 	mov	r3, #7
30005540:	e5c53000 	strb	r3, [r5]
30005544:	eaffffd7 	b	300054a8 <OSMboxDel+0x38>
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
                 *err                = OS_NO_ERR;
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
             } else {
                 OS_EXIT_CRITICAL();
30005548:	ebffeb4f 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                = OS_ERR_TASK_WAITING;
3000554c:	e3a03008 	mov	r3, #8
30005550:	e5c53000 	strb	r3, [r5]
30005554:	eaffffd3 	b	300054a8 <OSMboxDel+0x38>
                 pevent_return       = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
30005558:	e3560000 	cmp	r6, #0
3000555c:	0a000006 	beq	3000557c <OSMboxDel+0x10c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX);
30005560:	e1a00004 	mov	r0, r4
30005564:	e3a01000 	mov	r1, #0
30005568:	e3a02002 	mov	r2, #2
3000556c:	ebffed3e 	bl	30000a6c <OS_EventTaskRdy>
                 pevent_return       = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
30005570:	e5d4300a 	ldrb	r3, [r4, #10]
30005574:	e3530000 	cmp	r3, #0
30005578:	1afffff8 	bne	30005560 <OSMboxDel+0xf0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
3000557c:	e3a02000 	mov	r2, #0
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
30005580:	e59f3044 	ldr	r3, [pc, #68]	; 300055cc <OSMboxDel+0x15c>
        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
30005584:	e3a0103f 	mov	r1, #63	; 0x3f
30005588:	e5c41013 	strb	r1, [r4, #19]
             pevent->OSEventName[1] = OS_ASCII_NUL;
3000558c:	e5c42014 	strb	r2, [r4, #20]
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
30005590:	e5c42000 	strb	r2, [r4]
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
30005594:	e5931000 	ldr	r1, [r3]
             pevent->OSEventCnt     = 0;
30005598:	e1c420b8 	strh	r2, [r4, #8]
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
3000559c:	e5841004 	str	r1, [r4, #4]
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
300055a0:	e1a00007 	mov	r0, r7
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
300055a4:	e5834000 	str	r4, [r3]
             OS_EXIT_CRITICAL();
300055a8:	ebffeb37 	bl	3000028c <OS_CPU_SR_Restore>
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
300055ac:	e3560001 	cmp	r6, #1
300055b0:	0a000002 	beq	300055c0 <OSMboxDel+0x150>
                 OS_Sched();                               /* Find highest priority task ready to run  */
             }
             *err          = OS_NO_ERR;
300055b4:	e3a04000 	mov	r4, #0
300055b8:	e5c54000 	strb	r4, [r5]
             pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
             break;
300055bc:	eaffffb9 	b	300054a8 <OSMboxDel+0x38>
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
                 OS_Sched();                               /* Find highest priority task ready to run  */
300055c0:	ebfff4e7 	bl	30002964 <OS_Sched>
300055c4:	eafffffa 	b	300055b4 <OSMboxDel+0x144>
300055c8:	3001d094 	mulcc	r1, r4, r0
300055cc:	3001d090 	mulcc	r1, r0, r0

300055d0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
300055d0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                         /* Validate 'err'                                 */
300055d4:	e2535000 	subs	r5, r3, #0
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
300055d8:	e1a04000 	mov	r4, r0
300055dc:	e24dd008 	sub	sp, sp, #8
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                         /* Validate 'err'                                 */
300055e0:	01a04005 	moveq	r4, r5
300055e4:	0a000009 	beq	30005610 <OSFlagPost+0x40>
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
300055e8:	e3540000 	cmp	r4, #0
        *err = OS_FLAG_INVALID_PGRP;
300055ec:	03e03069 	mvneq	r3, #105	; 0x69
300055f0:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                         /* Validate 'err'                                 */
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
300055f4:	0a000005 	beq	30005610 <OSFlagPost+0x40>
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
300055f8:	e5d43000 	ldrb	r3, [r4]
300055fc:	e3530005 	cmp	r3, #5
        *err = OS_ERR_EVENT_TYPE;
30005600:	13a03001 	movne	r3, #1
30005604:	15c53000 	strbne	r3, [r5]
30005608:	13a04000 	movne	r4, #0
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
3000560c:	0a000003 	beq	30005620 <OSFlagPost+0x50>
    OS_ENTER_CRITICAL();
    flags_cur = pgrp->OSFlagFlags;
    OS_EXIT_CRITICAL();
    *err      = OS_NO_ERR;
    return (flags_cur);
}
30005610:	e1a00004 	mov	r0, r4
30005614:	e28dd008 	add	sp, sp, #8
30005618:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
3000561c:	e12fff1e 	bx	lr
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
30005620:	e58d1004 	str	r1, [sp, #4]
30005624:	e58d2000 	str	r2, [sp]
30005628:	ebffeb0f 	bl	3000026c <OS_CPU_SR_Save>
    switch (opt) {
3000562c:	e59d2000 	ldr	r2, [sp]
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
30005630:	e1a07000 	mov	r7, r0
    switch (opt) {
30005634:	e3520000 	cmp	r2, #0
30005638:	e59d1004 	ldr	r1, [sp, #4]
3000563c:	1a00003a 	bne	3000572c <OSFlagPost+0x15c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
30005640:	e1d430b8 	ldrh	r3, [r4, #8]
30005644:	e1c31001 	bic	r1, r3, r1
30005648:	e1c410b8 	strh	r1, [r4, #8]
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
3000564c:	e5946004 	ldr	r6, [r4, #4]
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
30005650:	e3560000 	cmp	r6, #0
30005654:	0a00003f 	beq	30005758 <OSFlagPost+0x188>
30005658:	e3a08000 	mov	r8, #0
        switch (pnode->OSFlagNodeWaitType) {
3000565c:	e5d63012 	ldrb	r3, [r6, #18]
30005660:	e3530003 	cmp	r3, #3
30005664:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30005668:	ea000029 	b	30005714 <OSFlagPost+0x144>
3000566c:	300056fc 	strdcc	r5, [r0], -ip
30005670:	300056e8 	andcc	r5, r0, r8, ror #13
30005674:	300056c0 	andcc	r5, r0, r0, asr #13
30005678:	3000567c 	andcc	r5, r0, ip, ror r6
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
3000567c:	e1d611b0 	ldrh	r1, [r6, #16]
30005680:	e1d430b8 	ldrh	r3, [r4, #8]
                 if (flags_rdy != (OS_FLAGS)0) {
30005684:	e0111003 	ands	r1, r1, r3
30005688:	1a000011 	bne	300056d4 <OSFlagPost+0x104>
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
3000568c:	e5966000 	ldr	r6, [r6]
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
30005690:	e3560000 	cmp	r6, #0
30005694:	1afffff0 	bne	3000565c <OSFlagPost+0x8c>
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
30005698:	e1a00007 	mov	r0, r7
3000569c:	ebffeafa 	bl	3000028c <OS_CPU_SR_Restore>
    if (sched == OS_TRUE) {
300056a0:	e3580001 	cmp	r8, #1
300056a4:	0a00002e 	beq	30005764 <OSFlagPost+0x194>
        OS_Sched();
    }
    OS_ENTER_CRITICAL();
300056a8:	ebffeaef 	bl	3000026c <OS_CPU_SR_Save>
    flags_cur = pgrp->OSFlagFlags;
300056ac:	e1d440b8 	ldrh	r4, [r4, #8]
    OS_EXIT_CRITICAL();
300056b0:	ebffeaf5 	bl	3000028c <OS_CPU_SR_Restore>
    *err      = OS_NO_ERR;
300056b4:	e3a03000 	mov	r3, #0
300056b8:	e5c53000 	strb	r3, [r5]
    return (flags_cur);
300056bc:	eaffffd3 	b	30005610 <OSFlagPost+0x40>
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
300056c0:	e1d611b0 	ldrh	r1, [r6, #16]
300056c4:	e1d430b8 	ldrh	r3, [r4, #8]
300056c8:	e0013003 	and	r3, r1, r3
300056cc:	e1510003 	cmp	r1, r3
300056d0:	1affffed 	bne	3000568c <OSFlagPost+0xbc>
                 break;

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
                 if (flags_rdy != (OS_FLAGS)0) {
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
300056d4:	e1a00006 	mov	r0, r6
300056d8:	ebffedcc 	bl	30000e10 <OS_FlagTaskRdy>
                     if (rdy == OS_TRUE) {
300056dc:	e3500001 	cmp	r0, #1
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
300056e0:	03a08001 	moveq	r8, #1
300056e4:	eaffffe8 	b	3000568c <OSFlagPost+0xbc>
                     }
                 }
                 break;

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
300056e8:	e1d410b8 	ldrh	r1, [r4, #8]
300056ec:	e1d631b0 	ldrh	r3, [r6, #16]
                 if (flags_rdy != (OS_FLAGS)0) {
300056f0:	e1d31001 	bics	r1, r3, r1
300056f4:	0affffe4 	beq	3000568c <OSFlagPost+0xbc>
300056f8:	eafffff5 	b	300056d4 <OSFlagPost+0x104>
                 }
                 break;

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
300056fc:	e1d611b0 	ldrh	r1, [r6, #16]
30005700:	e1d430b8 	ldrh	r3, [r4, #8]
30005704:	e1c13003 	bic	r3, r1, r3
30005708:	e1510003 	cmp	r1, r3
3000570c:	1affffde 	bne	3000568c <OSFlagPost+0xbc>
30005710:	eaffffef 	b	300056d4 <OSFlagPost+0x104>
                     }
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
30005714:	e1a00007 	mov	r0, r7
30005718:	ebffeadb 	bl	3000028c <OS_CPU_SR_Restore>
                 *err = OS_FLAG_ERR_WAIT_TYPE;
3000571c:	e3e03068 	mvn	r3, #104	; 0x68
30005720:	e5c53000 	strb	r3, [r5]
30005724:	e3a04000 	mov	r4, #0
                 return ((OS_FLAGS)0);
30005728:	eaffffb8 	b	30005610 <OSFlagPost+0x40>
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    switch (opt) {
3000572c:	e3520001 	cmp	r2, #1
30005730:	0a000004 	beq	30005748 <OSFlagPost+0x178>
        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
30005734:	ebffead4 	bl	3000028c <OS_CPU_SR_Restore>
             *err = OS_FLAG_INVALID_OPT;
30005738:	e3e03066 	mvn	r3, #102	; 0x66
3000573c:	e5c53000 	strb	r3, [r5]
30005740:	e3a04000 	mov	r4, #0
             return ((OS_FLAGS)0);
30005744:	eaffffb1 	b	30005610 <OSFlagPost+0x40>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
30005748:	e1d430b8 	ldrh	r3, [r4, #8]
3000574c:	e1811003 	orr	r1, r1, r3
30005750:	e1c410b8 	strh	r1, [r4, #8]
             break;
30005754:	eaffffbc 	b	3000564c <OSFlagPost+0x7c>
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
30005758:	e1a00007 	mov	r0, r7
3000575c:	ebffeaca 	bl	3000028c <OS_CPU_SR_Restore>
30005760:	eaffffd0 	b	300056a8 <OSFlagPost+0xd8>
    if (sched == OS_TRUE) {
        OS_Sched();
30005764:	ebfff47e 	bl	30002964 <OS_Sched>
30005768:	eaffffce 	b	300056a8 <OSFlagPost+0xd8>

3000576c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
3000576c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
30005770:	e24dd028 	sub	sp, sp, #40	; 0x28
30005774:	e59d4048 	ldr	r4, [sp, #72]	; 0x48
30005778:	e1a05000 	mov	r5, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
3000577c:	e3540000 	cmp	r4, #0
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
30005780:	e1a06002 	mov	r6, r2
30005784:	e1a07003 	mov	r7, r3
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30005788:	01a09004 	moveq	r9, r4
3000578c:	0a000017 	beq	300057f0 <OSFlagPend+0x84>
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
30005790:	e3500000 	cmp	r0, #0
        *err = OS_FLAG_INVALID_PGRP;
30005794:	03e03069 	mvneq	r3, #105	; 0x69
30005798:	05c43000 	strbeq	r3, [r4]
3000579c:	01a09000 	moveq	r9, r0

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
300057a0:	0a000012 	beq	300057f0 <OSFlagPend+0x84>
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300057a4:	e59f32a0 	ldr	r3, [pc, #672]	; 30005a4c <OSFlagPend+0x2e0>
300057a8:	e5d39000 	ldrb	r9, [r3]
300057ac:	e3590000 	cmp	r9, #0
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
300057b0:	13a03002 	movne	r3, #2
300057b4:	15c43000 	strbne	r3, [r4]
300057b8:	13a09000 	movne	r9, #0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
300057bc:	1a00000b 	bne	300057f0 <OSFlagPend+0x84>
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
        return ((OS_FLAGS)0);
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
300057c0:	e59f3288 	ldr	r3, [pc, #648]	; 30005a50 <OSFlagPend+0x2e4>
300057c4:	e5d33000 	ldrb	r3, [r3]
300057c8:	e3530000 	cmp	r3, #0
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
300057cc:	13a03011 	movne	r3, #17
300057d0:	15c43000 	strbne	r3, [r4]
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
        return ((OS_FLAGS)0);
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
300057d4:	1a000005 	bne	300057f0 <OSFlagPend+0x84>
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
        return ((OS_FLAGS)0);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
300057d8:	e5d02000 	ldrb	r2, [r0]
300057dc:	e3520005 	cmp	r2, #5
        *err = OS_ERR_EVENT_TYPE;
300057e0:	13a02001 	movne	r2, #1
300057e4:	15c42000 	strbne	r2, [r4]
300057e8:	11a09003 	movne	r9, r3
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
        *err = OS_ERR_PEND_LOCKED;                         /* ... can't PEND when locked               */
        return ((OS_FLAGS)0);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
300057ec:	0a000003 	beq	30005800 <OSFlagPend+0x94>
        }
    }
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
    return (flags_rdy);
}
300057f0:	e1a00009 	mov	r0, r9
300057f4:	e28dd028 	add	sp, sp, #40	; 0x28
300057f8:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
300057fc:	e12fff1e 	bx	lr
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
30005800:	e216a080 	ands	sl, r6, #128	; 0x80
        consume    = OS_TRUE;
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
30005804:	e58d100c 	str	r1, [sp, #12]
        *err = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
        wait_type &= ~OS_FLAG_CONSUME;
30005808:	1206607f 	andne	r6, r6, #127	; 0x7f
3000580c:	13a0a001 	movne	sl, #1
        consume    = OS_TRUE;
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
30005810:	ebffea95 	bl	3000026c <OS_CPU_SR_Save>
    switch (wait_type) {
30005814:	e59d100c 	ldr	r1, [sp, #12]
        consume    = OS_TRUE;
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
30005818:	e1a08000 	mov	r8, r0
    switch (wait_type) {
3000581c:	e3560003 	cmp	r6, #3
30005820:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
30005824:	ea000028 	b	300058cc <OSFlagPend+0x160>
30005828:	30005890 	mulcc	r0, r0, r8
3000582c:	300058b0 	undefined instruction 0x300058b0
30005830:	30005870 	andcc	r5, r0, r0, ror r8
30005834:	30005838 	andcc	r5, r0, r8, lsr r8
                 OS_EXIT_CRITICAL();
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
30005838:	e1d530b8 	ldrh	r3, [r5, #8]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
3000583c:	e0119003 	ands	r9, r1, r3
30005840:	0a000073 	beq	30005a14 <OSFlagPend+0x2a8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
30005844:	e35a0001 	cmp	sl, #1
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
30005848:	01c33009 	biceq	r3, r3, r9
3000584c:	01c530b8 	strheq	r3, [r5, #8]
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
30005850:	e59f31fc 	ldr	r3, [pc, #508]	; 30005a54 <OSFlagPend+0x2e8>
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
30005854:	e1a00008 	mov	r0, r8
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
30005858:	e5933000 	ldr	r3, [r3]
3000585c:	e1c392b8 	strh	r9, [r3, #40]	; 0x28
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
30005860:	ebffea89 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                    = OS_NO_ERR;
30005864:	e3a03000 	mov	r3, #0
30005868:	e5c43000 	strb	r3, [r4]
                 return (flags_rdy);
3000586c:	eaffffdf 	b	300057f0 <OSFlagPend+0x84>
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
30005870:	e1d530b8 	ldrh	r3, [r5, #8]
30005874:	e0019003 	and	r9, r1, r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
30005878:	e1590001 	cmp	r9, r1
3000587c:	1a000040 	bne	30005984 <OSFlagPend+0x218>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
30005880:	e35a0001 	cmp	sl, #1
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
30005884:	01c33001 	biceq	r3, r3, r1
30005888:	01c530b8 	strheq	r3, [r5, #8]
3000588c:	eaffffef 	b	30005850 <OSFlagPend+0xe4>
             }
             break;

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
30005890:	e1d530b8 	ldrh	r3, [r5, #8]
30005894:	e1c19003 	bic	r9, r1, r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
30005898:	e1590001 	cmp	r9, r1
3000589c:	1a00000f 	bne	300058e0 <OSFlagPend+0x174>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
300058a0:	e35a0001 	cmp	sl, #1
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
300058a4:	01833001 	orreq	r3, r3, r1
300058a8:	01c530b8 	strheq	r3, [r5, #8]
300058ac:	eaffffe7 	b	30005850 <OSFlagPend+0xe4>
                 OS_EXIT_CRITICAL();
             }
             break;

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
300058b0:	e1d530b8 	ldrh	r3, [r5, #8]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
300058b4:	e1d19003 	bics	r9, r1, r3
300058b8:	0a00004c 	beq	300059f0 <OSFlagPend+0x284>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
300058bc:	e35a0001 	cmp	sl, #1
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
300058c0:	01893003 	orreq	r3, r9, r3
300058c4:	01c530b8 	strheq	r3, [r5, #8]
300058c8:	eaffffe0 	b	30005850 <OSFlagPend+0xe4>
             }
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
300058cc:	ebffea6e 	bl	3000028c <OS_CPU_SR_Restore>
             flags_rdy = (OS_FLAGS)0;
             *err      = OS_FLAG_ERR_WAIT_TYPE;
300058d0:	e3e03068 	mvn	r3, #104	; 0x68
300058d4:	e5c43000 	strb	r3, [r4]
300058d8:	e3a09000 	mov	r9, #0
             return (flags_rdy);
300058dc:	eaffffc3 	b	300057f0 <OSFlagPend+0x84>
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *err                    = OS_NO_ERR;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
300058e0:	e1a02001 	mov	r2, r1
300058e4:	e1a00005 	mov	r0, r5
300058e8:	e28d1014 	add	r1, sp, #20
300058ec:	e3a03000 	mov	r3, #0
300058f0:	e58d7000 	str	r7, [sp]
300058f4:	ebffecfe 	bl	30000cf4 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
300058f8:	e1a00008 	mov	r0, r8
300058fc:	ebffea62 	bl	3000028c <OS_CPU_SR_Restore>
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
             *err      = OS_FLAG_ERR_WAIT_TYPE;
             return (flags_rdy);
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
30005900:	ebfff417 	bl	30002964 <OS_Sched>
    OS_ENTER_CRITICAL();
30005904:	ebffea58 	bl	3000026c <OS_CPU_SR_Save>
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {                /* Have we timed-out?                       */
30005908:	e59f3144 	ldr	r3, [pc, #324]	; 30005a54 <OSFlagPend+0x2e8>
3000590c:	e5933000 	ldr	r3, [r3]
30005910:	e5d3202d 	ldrb	r2, [r3, #45]	; 0x2d
30005914:	e3520001 	cmp	r2, #1
30005918:	0a000022 	beq	300059a8 <OSFlagPend+0x23c>
        flags_rdy             = (OS_FLAGS)0;
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
        return (flags_rdy);
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
3000591c:	e35a0001 	cmp	sl, #1
        OS_EXIT_CRITICAL();
        flags_rdy             = (OS_FLAGS)0;
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
        return (flags_rdy);
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
30005920:	e1d392b8 	ldrh	r9, [r3, #40]	; 0x28
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
30005924:	1a000009 	bne	30005950 <OSFlagPend+0x1e4>
        switch (wait_type) {
30005928:	e3560003 	cmp	r6, #3
3000592c:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
30005930:	ea00000a 	b	30005960 <OSFlagPend+0x1f4>
30005934:	30005974 	andcc	r5, r0, r4, ror r9
30005938:	30005974 	andcc	r5, r0, r4, ror r9
3000593c:	30005944 	andcc	r5, r0, r4, asr #18
30005940:	30005944 	andcc	r5, r0, r4, asr #18
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
30005944:	e1d530b8 	ldrh	r3, [r5, #8]
30005948:	e1c33009 	bic	r3, r3, r9
3000594c:	e1c530b8 	strh	r3, [r5, #8]
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
    }
    OS_EXIT_CRITICAL();
30005950:	ebffea4d 	bl	3000028c <OS_CPU_SR_Restore>
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
30005954:	e3a03000 	mov	r3, #0
30005958:	e5c43000 	strb	r3, [r4]
    return (flags_rdy);
3000595c:	eaffffa3 	b	300057f0 <OSFlagPend+0x84>
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
30005960:	ebffea49 	bl	3000028c <OS_CPU_SR_Restore>
                 *err = OS_FLAG_ERR_WAIT_TYPE;
30005964:	e3e03068 	mvn	r3, #104	; 0x68
30005968:	e5c43000 	strb	r3, [r4]
3000596c:	e3a09000 	mov	r9, #0
                 return ((OS_FLAGS)0);
30005970:	eaffff9e 	b	300057f0 <OSFlagPend+0x84>
                 break;

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
30005974:	e1d530b8 	ldrh	r3, [r5, #8]
30005978:	e1893003 	orr	r3, r9, r3
3000597c:	e1c530b8 	strh	r3, [r5, #8]
                 break;
30005980:	eafffff2 	b	30005950 <OSFlagPend+0x1e4>
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *err                    = OS_NO_ERR;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
30005984:	e1a02001 	mov	r2, r1
30005988:	e1a00005 	mov	r0, r5
3000598c:	e28d1014 	add	r1, sp, #20
30005990:	e3a03002 	mov	r3, #2
30005994:	e58d7000 	str	r7, [sp]
30005998:	ebffecd5 	bl	30000cf4 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
3000599c:	e1a00008 	mov	r0, r8
300059a0:	ebffea39 	bl	3000028c <OS_CPU_SR_Restore>
             }
             break;
300059a4:	eaffffd5 	b	30005900 <OSFlagPend+0x194>
             return (flags_rdy);
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {                /* Have we timed-out?                       */
        OSTCBCur->OSTCBPendTO = OS_FALSE;
300059a8:	e3a02000 	mov	r2, #0
300059ac:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
300059b0:	e59d1018 	ldr	r1, [sp, #24]
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
300059b4:	e59d2014 	ldr	r2, [sp, #20]
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
300059b8:	e3510000 	cmp	r1, #0
300059bc:	0a00001d 	beq	30005a38 <OSFlagPend+0x2cc>
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
300059c0:	e3520000 	cmp	r2, #0
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
300059c4:	e5812000 	str	r2, [r1]
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
300059c8:	0a000000 	beq	300059d0 <OSFlagPend+0x264>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
300059cc:	e5821004 	str	r1, [r2, #4]
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
300059d0:	e59d201c 	ldr	r2, [sp, #28]
300059d4:	e3a09000 	mov	r9, #0
    OS_Sched();                                            /* Find next HPT ready to run               */
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {                /* Have we timed-out?                       */
        OSTCBCur->OSTCBPendTO = OS_FALSE;
        OS_FlagUnlink(&node);
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
300059d8:	e5c3902c 	strb	r9, [r3, #44]	; 0x2c
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
300059dc:	e5829024 	str	r9, [r2, #36]	; 0x24
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBPendTO == OS_TRUE) {                /* Have we timed-out?                       */
        OSTCBCur->OSTCBPendTO = OS_FALSE;
        OS_FlagUnlink(&node);
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
        OS_EXIT_CRITICAL();
300059e0:	ebffea29 	bl	3000028c <OS_CPU_SR_Restore>
        flags_rdy             = (OS_FLAGS)0;
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
300059e4:	e3a0300a 	mov	r3, #10
300059e8:	e5c43000 	strb	r3, [r4]
        return (flags_rdy);
300059ec:	eaffff7f 	b	300057f0 <OSFlagPend+0x84>
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *err                    = OS_NO_ERR;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
300059f0:	e1a02001 	mov	r2, r1
300059f4:	e1a00005 	mov	r0, r5
300059f8:	e28d1014 	add	r1, sp, #20
300059fc:	e3a03001 	mov	r3, #1
30005a00:	e58d7000 	str	r7, [sp]
30005a04:	ebffecba 	bl	30000cf4 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
30005a08:	e1a00008 	mov	r0, r8
30005a0c:	ebffea1e 	bl	3000028c <OS_CPU_SR_Restore>
             }
             break;
30005a10:	eaffffba 	b	30005900 <OSFlagPend+0x194>
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *err                    = OS_NO_ERR;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
30005a14:	e1a02001 	mov	r2, r1
30005a18:	e1a00005 	mov	r0, r5
30005a1c:	e28d1014 	add	r1, sp, #20
30005a20:	e3a03003 	mov	r3, #3
30005a24:	e58d7000 	str	r7, [sp]
30005a28:	ebffecb1 	bl	30000cf4 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
30005a2c:	e1a00008 	mov	r0, r8
30005a30:	ebffea15 	bl	3000028c <OS_CPU_SR_Restore>
             }
             break;
30005a34:	eaffffb1 	b	30005900 <OSFlagPend+0x194>

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30005a38:	e59dc020 	ldr	ip, [sp, #32]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30005a3c:	e3520000 	cmp	r2, #0

    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
30005a40:	e58c2004 	str	r2, [ip, #4]
        if (pnode_next != (OS_FLAG_NODE *)0) {
30005a44:	1affffe0 	bne	300059cc <OSFlagPend+0x260>
30005a48:	eaffffe0 	b	300059d0 <OSFlagPend+0x264>
30005a4c:	3001d094 	mulcc	r1, r4, r0
30005a50:	3001c764 	andcc	ip, r1, r4, ror #14
30005a54:	3001d098 	mulcc	r1, r8, r0

30005a58 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *err)
{
30005a58:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30005a5c:	e2525000 	subs	r5, r2, #0
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *err)
{
30005a60:	e24dd008 	sub	sp, sp, #8
30005a64:	e1a04000 	mov	r4, r0
#endif



#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
30005a68:	0a00000e 	beq	30005aa8 <OSFlagDel+0x50>
        return (pgrp);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
30005a6c:	e3500000 	cmp	r0, #0
        *err = OS_FLAG_INVALID_PGRP;
30005a70:	03e03069 	mvneq	r3, #105	; 0x69
30005a74:	05c53000 	strbeq	r3, [r5]

#if OS_ARG_CHK_EN > 0
    if (err == (INT8U *)0) {                               /* Validate 'err'                           */
        return (pgrp);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
30005a78:	0a00000a 	beq	30005aa8 <OSFlagDel+0x50>
        *err = OS_FLAG_INVALID_PGRP;
        return (pgrp);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30005a7c:	e59f3128 	ldr	r3, [pc, #296]	; 30005bac <OSFlagDel+0x154>
30005a80:	e5d33000 	ldrb	r3, [r3]
30005a84:	e3530000 	cmp	r3, #0
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
30005a88:	13e03073 	mvnne	r3, #115	; 0x73
30005a8c:	15c53000 	strbne	r3, [r5]
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return (pgrp);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
30005a90:	1a000004 	bne	30005aa8 <OSFlagDel+0x50>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pgrp);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
30005a94:	e5d03000 	ldrb	r3, [r0]
30005a98:	e3530005 	cmp	r3, #5
        *err = OS_ERR_EVENT_TYPE;
30005a9c:	13a03001 	movne	r3, #1
30005aa0:	15c53000 	strbne	r3, [r5]
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pgrp);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
30005aa4:	0a000003 	beq	30005ab8 <OSFlagDel+0x60>
             *err                 = OS_ERR_INVALID_OPT;
             pgrp_return          = pgrp;
             break;
    }
    return (pgrp_return);
}
30005aa8:	e1a00004 	mov	r0, r4
30005aac:	e28dd008 	add	sp, sp, #8
30005ab0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30005ab4:	e12fff1e 	bx	lr
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
30005ab8:	e58d1004 	str	r1, [sp, #4]
30005abc:	ebffe9ea 	bl	3000026c <OS_CPU_SR_Save>
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
30005ac0:	e5946004 	ldr	r6, [r4, #4]
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30005ac4:	e59d1004 	ldr	r1, [sp, #4]
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
30005ac8:	e2567000 	subs	r7, r6, #0
30005acc:	13a07001 	movne	r7, #1
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30005ad0:	e3510000 	cmp	r1, #0
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
        *err = OS_ERR_EVENT_TYPE;
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
30005ad4:	e1a08000 	mov	r8, r0
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30005ad8:	1a00000e 	bne	30005b18 <OSFlagDel+0xc0>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
30005adc:	e3570000 	cmp	r7, #0
30005ae0:	1a00002b 	bne	30005b94 <OSFlagDel+0x13c>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
30005ae4:	e59f30c4 	ldr	r3, [pc, #196]	; 30005bb0 <OSFlagDel+0x158>
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
30005ae8:	e3a0203f 	mov	r2, #63	; 0x3f
30005aec:	e5c4200a 	strb	r2, [r4, #10]
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
30005af0:	e5c4700b 	strb	r7, [r4, #11]
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
30005af4:	e5c47000 	strb	r7, [r4]
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
30005af8:	e5932000 	ldr	r2, [r3]
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
30005afc:	e1c470b8 	strh	r7, [r4, #8]
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
30005b00:	e5842004 	str	r2, [r4, #4]
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
                 OSFlagFreeList       = pgrp;
30005b04:	e5834000 	str	r4, [r3]
                 OS_EXIT_CRITICAL();
30005b08:	ebffe9df 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                 = OS_NO_ERR;
30005b0c:	e1a04007 	mov	r4, r7
30005b10:	e5c57000 	strb	r7, [r5]
30005b14:	eaffffe3 	b	30005aa8 <OSFlagDel+0x50>
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
30005b18:	e3510001 	cmp	r1, #1
30005b1c:	0a000003 	beq	30005b30 <OSFlagDel+0xd8>
             *err = OS_NO_ERR;
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
             break;

        default:
             OS_EXIT_CRITICAL();
30005b20:	ebffe9d9 	bl	3000028c <OS_CPU_SR_Restore>
             *err                 = OS_ERR_INVALID_OPT;
30005b24:	e3a03007 	mov	r3, #7
30005b28:	e5c53000 	strb	r3, [r5]
30005b2c:	eaffffdd 	b	30005aa8 <OSFlagDel+0x50>
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
30005b30:	e3560000 	cmp	r6, #0
30005b34:	0a000005 	beq	30005b50 <OSFlagDel+0xf8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
30005b38:	e1a00006 	mov	r0, r6
30005b3c:	e3a01000 	mov	r1, #0
30005b40:	ebffecb2 	bl	30000e10 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
30005b44:	e5966000 	ldr	r6, [r6]
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
30005b48:	e3560000 	cmp	r6, #0
30005b4c:	1afffff9 	bne	30005b38 <OSFlagDel+0xe0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
30005b50:	e3a02000 	mov	r2, #0
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
30005b54:	e59f3054 	ldr	r3, [pc, #84]	; 30005bb0 <OSFlagDel+0x158>
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
30005b58:	e3a0103f 	mov	r1, #63	; 0x3f
30005b5c:	e5c4100a 	strb	r1, [r4, #10]
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
30005b60:	e5c4200b 	strb	r2, [r4, #11]
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
30005b64:	e5c42000 	strb	r2, [r4]
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
30005b68:	e5931000 	ldr	r1, [r3]
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
30005b6c:	e1c420b8 	strh	r2, [r4, #8]
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
30005b70:	e5841004 	str	r1, [r4, #4]
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
             OSFlagFreeList       = pgrp;
             OS_EXIT_CRITICAL();
30005b74:	e1a00008 	mov	r0, r8
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
             OSFlagFreeList       = pgrp;
30005b78:	e5834000 	str	r4, [r3]
             OS_EXIT_CRITICAL();
30005b7c:	ebffe9c2 	bl	3000028c <OS_CPU_SR_Restore>
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
30005b80:	e3570001 	cmp	r7, #1
30005b84:	0a000006 	beq	30005ba4 <OSFlagDel+0x14c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
             }
             *err = OS_NO_ERR;
30005b88:	e3a04000 	mov	r4, #0
30005b8c:	e5c54000 	strb	r4, [r5]
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
             break;
30005b90:	eaffffc4 	b	30005aa8 <OSFlagDel+0x50>
                 OSFlagFreeList       = pgrp;
                 OS_EXIT_CRITICAL();
                 *err                 = OS_NO_ERR;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
30005b94:	ebffe9bc 	bl	3000028c <OS_CPU_SR_Restore>
                 *err                 = OS_ERR_TASK_WAITING;
30005b98:	e3a03008 	mov	r3, #8
30005b9c:	e5c53000 	strb	r3, [r5]
30005ba0:	eaffffc0 	b	30005aa8 <OSFlagDel+0x50>
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
             OSFlagFreeList       = pgrp;
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
                 OS_Sched();                               /* Find highest priority task ready to run  */
30005ba4:	ebfff36e 	bl	30002964 <OS_Sched>
30005ba8:	eafffff6 	b	30005b88 <OSFlagDel+0x130>
30005bac:	3001d094 	mulcc	r1, r4, r0
30005bb0:	3001dba0 	andcc	sp, r1, r0, lsr #23

30005bb4 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
30005bb4:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
30005bb8:	e59f305c 	ldr	r3, [pc, #92]	; 30005c1c <OSSchedUnlock+0x68>
30005bbc:	e5d33000 	ldrb	r3, [r3]
30005bc0:	e3530001 	cmp	r3, #1
30005bc4:	0a000001 	beq	30005bd0 <OSSchedUnlock+0x1c>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
30005bc8:	e8bd4010 	pop	{r4, lr}
30005bcc:	e12fff1e 	bx	lr
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
        OS_ENTER_CRITICAL();
30005bd0:	ebffe9a5 	bl	3000026c <OS_CPU_SR_Save>
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
30005bd4:	e59f3044 	ldr	r3, [pc, #68]	; 30005c20 <OSSchedUnlock+0x6c>
30005bd8:	e5d32000 	ldrb	r2, [r3]
30005bdc:	e3520000 	cmp	r2, #0
30005be0:	0a00000b 	beq	30005c14 <OSSchedUnlock+0x60>
            OSLockNesting--;                               /* Decrement lock nesting level             */
30005be4:	e2422001 	sub	r2, r2, #1
30005be8:	e20220ff 	and	r2, r2, #255	; 0xff
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
30005bec:	e3520000 	cmp	r2, #0


    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
        OS_ENTER_CRITICAL();
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
            OSLockNesting--;                               /* Decrement lock nesting level             */
30005bf0:	e5c32000 	strb	r2, [r3]
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
30005bf4:	1a000006 	bne	30005c14 <OSSchedUnlock+0x60>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
30005bf8:	e59f3024 	ldr	r3, [pc, #36]	; 30005c24 <OSSchedUnlock+0x70>
30005bfc:	e5d33000 	ldrb	r3, [r3]
30005c00:	e3530000 	cmp	r3, #0
30005c04:	1a000002 	bne	30005c14 <OSSchedUnlock+0x60>
                    OS_EXIT_CRITICAL();
30005c08:	ebffe99f 	bl	3000028c <OS_CPU_SR_Restore>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
30005c0c:	e8bd4010 	pop	{r4, lr}
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
            OSLockNesting--;                               /* Decrement lock nesting level             */
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
30005c10:	eafff353 	b	30002964 <OS_Sched>
                }
            } else {
                OS_EXIT_CRITICAL();
            }
        } else {
            OS_EXIT_CRITICAL();
30005c14:	ebffe99c 	bl	3000028c <OS_CPU_SR_Restore>
30005c18:	eaffffea 	b	30005bc8 <OSSchedUnlock+0x14>
30005c1c:	3001c76c 	andcc	ip, r1, ip, ror #14
30005c20:	3001c764 	andcc	ip, r1, r4, ror #14
30005c24:	3001d094 	mulcc	r1, r4, r0

30005c28 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
30005c28:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
30005c2c:	eb00034a 	bl	3000695c <OSTimeTickHook>
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
30005c30:	ebffe98d 	bl	3000026c <OS_CPU_SR_Save>
    OSTime++;
30005c34:	e59f30e8 	ldr	r3, [pc, #232]	; 30005d24 <OSTimeTick+0xfc>
30005c38:	e5932000 	ldr	r2, [r3]
30005c3c:	e2822001 	add	r2, r2, #1
30005c40:	e5832000 	str	r2, [r3]
    OS_EXIT_CRITICAL();
30005c44:	ebffe990 	bl	3000028c <OS_CPU_SR_Restore>
#endif
    if (OSRunning == OS_TRUE) {
30005c48:	e59f30d8 	ldr	r3, [pc, #216]	; 30005d28 <OSTimeTick+0x100>
30005c4c:	e5d33000 	ldrb	r3, [r3]
30005c50:	e3530001 	cmp	r3, #1
30005c54:	0a000001 	beq	30005c60 <OSTimeTick+0x38>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
30005c58:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30005c5c:	e12fff1e 	bx	lr
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
30005c60:	e59f20c4 	ldr	r2, [pc, #196]	; 30005d2c <OSTimeTick+0x104>
30005c64:	e5d21000 	ldrb	r1, [r2]
30005c68:	e3510001 	cmp	r1, #1
30005c6c:	0afffff9 	beq	30005c58 <OSTimeTick+0x30>
30005c70:	3a000002 	bcc	30005c80 <OSTimeTick+0x58>
30005c74:	e3510002 	cmp	r1, #2
                 OSTickStepState = OS_TICK_STEP_WAIT;
                 break;

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
30005c78:	13a03000 	movne	r3, #0
30005c7c:	e5c23000 	strb	r3, [r2]
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
30005c80:	e59f30a8 	ldr	r3, [pc, #168]	; 30005d30 <OSTimeTick+0x108>
30005c84:	e5934000 	ldr	r4, [r3]
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
30005c88:	e5d4302e 	ldrb	r3, [r4, #46]	; 0x2e
30005c8c:	e353003f 	cmp	r3, #63	; 0x3f
30005c90:	0afffff0 	beq	30005c58 <OSTimeTick+0x30>
                    } else {
                        ptcb->OSTCBPendTO  = OS_FALSE;
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
30005c94:	e59f6098 	ldr	r6, [pc, #152]	; 30005d34 <OSTimeTick+0x10c>
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30005c98:	e59f5098 	ldr	r5, [pc, #152]	; 30005d38 <OSTimeTick+0x110>
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
                        ptcb->OSTCBPendTO  = OS_TRUE;                          /* Indicate PEND timeout    */
30005c9c:	e3a07001 	mov	r7, #1
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
30005ca0:	ebffe971 	bl	3000026c <OS_CPU_SR_Save>
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
30005ca4:	e1d432ba 	ldrh	r3, [r4, #42]	; 0x2a
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
30005ca8:	e2432001 	sub	r2, r3, #1
30005cac:	e1a02802 	lsl	r2, r2, #16
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
30005cb0:	e3530000 	cmp	r3, #0
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
30005cb4:	e1a02822 	lsr	r2, r2, #16
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
30005cb8:	0a000013 	beq	30005d0c <OSTimeTick+0xe4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
30005cbc:	e3520000 	cmp	r2, #0
30005cc0:	e1c422ba 	strh	r2, [r4, #42]	; 0x2a
30005cc4:	1a000010 	bne	30005d0c <OSTimeTick+0xe4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
30005cc8:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
30005ccc:	e2132037 	ands	r2, r3, #55	; 0x37
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
30005cd0:	120330c8 	andne	r3, r3, #200	; 0xc8
30005cd4:	15c4302c 	strbne	r3, [r4, #44]	; 0x2c
                        ptcb->OSTCBPendTO  = OS_TRUE;                          /* Indicate PEND timeout    */
30005cd8:	15c4702d 	strbne	r7, [r4, #45]	; 0x2d
                    } else {
                        ptcb->OSTCBPendTO  = OS_FALSE;
30005cdc:	05c4202d 	strbeq	r2, [r4, #45]	; 0x2d
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
30005ce0:	e3130008 	tst	r3, #8
30005ce4:	1a000008 	bne	30005d0c <OSTimeTick+0xe4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
30005ce8:	e5d43032 	ldrb	r3, [r4, #50]	; 0x32
30005cec:	e5d62000 	ldrb	r2, [r6]
30005cf0:	e1823003 	orr	r3, r2, r3
30005cf4:	e5c63000 	strb	r3, [r6]
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
30005cf8:	e5d43030 	ldrb	r3, [r4, #48]	; 0x30
30005cfc:	e5d42031 	ldrb	r2, [r4, #49]	; 0x31
30005d00:	e7d51003 	ldrb	r1, [r5, r3]
30005d04:	e1812002 	orr	r2, r1, r2
30005d08:	e7c52003 	strb	r2, [r5, r3]
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
30005d0c:	e5944014 	ldr	r4, [r4, #20]
            OS_EXIT_CRITICAL();
30005d10:	ebffe95d 	bl	3000028c <OS_CPU_SR_Restore>
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
30005d14:	e5d4302e 	ldrb	r3, [r4, #46]	; 0x2e
30005d18:	e353003f 	cmp	r3, #63	; 0x3f
30005d1c:	1affffdf 	bne	30005ca0 <OSTimeTick+0x78>
30005d20:	eaffffcc 	b	30005c58 <OSTimeTick+0x30>
30005d24:	3001d0a0 	andcc	sp, r1, r0, lsr #1
30005d28:	3001c76c 	andcc	ip, r1, ip, ror #14
30005d2c:	3001cb4c 	andcc	ip, r1, ip, asr #22
30005d30:	3001cb48 	andcc	ip, r1, r8, asr #22
30005d34:	3001ce84 	andcc	ip, r1, r4, lsl #29
30005d38:	3001ce88 	andcc	ip, r1, r8, lsl #29

30005d3c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
30005d3c:	e92d4010 	push	{r4, lr}
    if (OSRunning == OS_FALSE) {
30005d40:	e59f3060 	ldr	r3, [pc, #96]	; 30005da8 <OSStart+0x6c>
30005d44:	e5d33000 	ldrb	r3, [r3]
30005d48:	e3530000 	cmp	r3, #0
30005d4c:	1a000013 	bne	30005da0 <OSStart+0x64>
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
30005d50:	e59f3054 	ldr	r3, [pc, #84]	; 30005dac <OSStart+0x70>
30005d54:	e59f2054 	ldr	r2, [pc, #84]	; 30005db0 <OSStart+0x74>
30005d58:	e5d33000 	ldrb	r3, [r3]
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005d5c:	e59f1050 	ldr	r1, [pc, #80]	; 30005db4 <OSStart+0x78>
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
30005d60:	e7d23003 	ldrb	r3, [r2, r3]
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005d64:	e7d11003 	ldrb	r1, [r1, r3]
30005d68:	e7d22001 	ldrb	r2, [r2, r1]
30005d6c:	e59f1044 	ldr	r1, [pc, #68]	; 30005db8 <OSStart+0x7c>
30005d70:	e0823183 	add	r3, r2, r3, lsl #3
void  OSStart (void)
{
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
        OSPrioCur     = OSPrioHighRdy;
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
30005d74:	e59f2040 	ldr	r2, [pc, #64]	; 30005dbc <OSStart+0x80>
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005d78:	e20330ff 	and	r3, r3, #255	; 0xff
void  OSStart (void)
{
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
        OSPrioCur     = OSPrioHighRdy;
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
30005d7c:	e7922103 	ldr	r2, [r2, r3, lsl #2]
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005d80:	e5c13000 	strb	r3, [r1]
{
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
        OSPrioCur     = OSPrioHighRdy;
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
        OSTCBCur      = OSTCBHighRdy;
30005d84:	e59f1034 	ldr	r1, [pc, #52]	; 30005dc0 <OSStart+0x84>
30005d88:	e5812000 	str	r2, [r1]

void  OSStart (void)
{
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
        OSPrioCur     = OSPrioHighRdy;
30005d8c:	e59f1030 	ldr	r1, [pc, #48]	; 30005dc4 <OSStart+0x88>
30005d90:	e5c13000 	strb	r3, [r1]
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
30005d94:	e59f302c 	ldr	r3, [pc, #44]	; 30005dc8 <OSStart+0x8c>
30005d98:	e5832000 	str	r2, [r3]
        OSTCBCur      = OSTCBHighRdy;
        OSStartHighRdy();                            /* Execute target specific code to start task     */
30005d9c:	ebffe93c 	bl	30000294 <OSStartHighRdy>
    }
}
30005da0:	e8bd4010 	pop	{r4, lr}
30005da4:	e12fff1e 	bx	lr
30005da8:	3001c76c 	andcc	ip, r1, ip, ror #14
30005dac:	3001ce84 	andcc	ip, r1, r4, lsl #29
30005db0:	30006abc 	undefined instruction 0x30006abc
30005db4:	3001ce88 	andcc	ip, r1, r8, lsl #29
30005db8:	3001c776 	andcc	ip, r1, r6, ror r7
30005dbc:	3001dba8 	andcc	sp, r1, r8, lsr #23
30005dc0:	3001d098 	mulcc	r1, r8, r0
30005dc4:	3001cb44 	andcc	ip, r1, r4, asr #22
30005dc8:	3001ce7c 	andcc	ip, r1, ip, ror lr

30005dcc <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
30005dcc:	e92d4010 	push	{r4, lr}
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSRunning == OS_TRUE) {
30005dd0:	e59f30c8 	ldr	r3, [pc, #200]	; 30005ea0 <OSIntExit+0xd4>
30005dd4:	e5d33000 	ldrb	r3, [r3]
30005dd8:	e3530001 	cmp	r3, #1
30005ddc:	0a000001 	beq	30005de8 <OSIntExit+0x1c>
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
30005de0:	e8bd4010 	pop	{r4, lr}
30005de4:	e12fff1e 	bx	lr
#endif



    if (OSRunning == OS_TRUE) {
        OS_ENTER_CRITICAL();
30005de8:	ebffe91f 	bl	3000026c <OS_CPU_SR_Save>
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
30005dec:	e59f30b0 	ldr	r3, [pc, #176]	; 30005ea4 <OSIntExit+0xd8>
#endif



    if (OSRunning == OS_TRUE) {
        OS_ENTER_CRITICAL();
30005df0:	e1a04000 	mov	r4, r0
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
30005df4:	e5d32000 	ldrb	r2, [r3]
30005df8:	e3520000 	cmp	r2, #0
30005dfc:	0a000007 	beq	30005e20 <OSIntExit+0x54>
            OSIntNesting--;
30005e00:	e2422001 	sub	r2, r2, #1
30005e04:	e20220ff 	and	r2, r2, #255	; 0xff
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
30005e08:	e3520000 	cmp	r2, #0


    if (OSRunning == OS_TRUE) {
        OS_ENTER_CRITICAL();
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
            OSIntNesting--;
30005e0c:	e5c32000 	strb	r2, [r3]
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
30005e10:	0a000002 	beq	30005e20 <OSIntExit+0x54>
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
                }
            }
        }
        OS_EXIT_CRITICAL();
30005e14:	e1a00004 	mov	r0, r4
30005e18:	ebffe91b 	bl	3000028c <OS_CPU_SR_Restore>
30005e1c:	eaffffef 	b	30005de0 <OSIntExit+0x14>
        OS_ENTER_CRITICAL();
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
            OSIntNesting--;
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
30005e20:	e59f3080 	ldr	r3, [pc, #128]	; 30005ea8 <OSIntExit+0xdc>
30005e24:	e5d33000 	ldrb	r3, [r3]
30005e28:	e3530000 	cmp	r3, #0
30005e2c:	1afffff8 	bne	30005e14 <OSIntExit+0x48>
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
30005e30:	e59f3074 	ldr	r3, [pc, #116]	; 30005eac <OSIntExit+0xe0>
30005e34:	e59f2074 	ldr	r2, [pc, #116]	; 30005eb0 <OSIntExit+0xe4>
30005e38:	e5d33000 	ldrb	r3, [r3]
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005e3c:	e59f1070 	ldr	r1, [pc, #112]	; 30005eb4 <OSIntExit+0xe8>
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
30005e40:	e7d23003 	ldrb	r3, [r2, r3]
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005e44:	e7d10003 	ldrb	r0, [r1, r3]
            OSIntNesting--;
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
30005e48:	e59f1068 	ldr	r1, [pc, #104]	; 30005eb8 <OSIntExit+0xec>
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005e4c:	e7d22000 	ldrb	r2, [r2, r0]
            OSIntNesting--;
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
30005e50:	e5d11000 	ldrb	r1, [r1]
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005e54:	e0823183 	add	r3, r2, r3, lsl #3
30005e58:	e20330ff 	and	r3, r3, #255	; 0xff
30005e5c:	e59f2058 	ldr	r2, [pc, #88]	; 30005ebc <OSIntExit+0xf0>
            OSIntNesting--;
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
30005e60:	e1510003 	cmp	r1, r3
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
30005e64:	e5c23000 	strb	r3, [r2]
            OSIntNesting--;
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
30005e68:	0affffe9 	beq	30005e14 <OSIntExit+0x48>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
30005e6c:	e59f104c 	ldr	r1, [pc, #76]	; 30005ec0 <OSIntExit+0xf4>
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
30005e70:	e59f204c 	ldr	r2, [pc, #76]	; 30005ec4 <OSIntExit+0xf8>
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
30005e74:	e7913103 	ldr	r3, [r1, r3, lsl #2]
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
30005e78:	e5921000 	ldr	r1, [r2]
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
30005e7c:	e5930034 	ldr	r0, [r3, #52]	; 0x34
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
30005e80:	e2811001 	add	r1, r1, #1
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
30005e84:	e2800001 	add	r0, r0, #1
30005e88:	e5830034 	str	r0, [r3, #52]	; 0x34
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
30005e8c:	e5821000 	str	r1, [r2]
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
30005e90:	e59f2030 	ldr	r2, [pc, #48]	; 30005ec8 <OSIntExit+0xfc>
30005e94:	e5823000 	str	r3, [r2]
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
30005e98:	ebffe90e 	bl	300002d8 <raw_int_switch>
30005e9c:	eaffffdc 	b	30005e14 <OSIntExit+0x48>
30005ea0:	3001c76c 	andcc	ip, r1, ip, ror #14
30005ea4:	3001d094 	mulcc	r1, r4, r0
30005ea8:	3001c764 	andcc	ip, r1, r4, ror #14
30005eac:	3001ce84 	andcc	ip, r1, r4, lsl #29
30005eb0:	30006abc 	undefined instruction 0x30006abc
30005eb4:	3001ce88 	andcc	ip, r1, r8, lsl #29
30005eb8:	3001cb44 	andcc	ip, r1, r4, asr #22
30005ebc:	3001c776 	andcc	ip, r1, r6, ror r7
30005ec0:	3001dba8 	andcc	sp, r1, r8, lsr #23
30005ec4:	3001ce04 	andcc	ip, r1, r4, lsl #28
30005ec8:	3001ce7c 	andcc	ip, r1, ip, ror lr

30005ecc <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
30005ecc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
30005ed0:	e24dd020 	sub	sp, sp, #32
#if OS_VERSION >= 204
    OSInitHookBegin();                                           /* Call port specific initialization code   */
30005ed4:	eb0002a2 	bl	30006964 <OSInitHookBegin>
*/

static  void  OS_InitMisc (void)
{
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
30005ed8:	e59f1228 	ldr	r1, [pc, #552]	; 30006108 <OSInit+0x23c>
30005edc:	e3a02000 	mov	r2, #0
30005ee0:	e5812000 	str	r2, [r1]
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
30005ee4:	e59f1220 	ldr	r1, [pc, #544]	; 3000610c <OSInit+0x240>
30005ee8:	e59f0220 	ldr	r0, [pc, #544]	; 30006110 <OSInit+0x244>
30005eec:	e5c12000 	strb	r2, [r1]
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
30005ef0:	e59f121c 	ldr	r1, [pc, #540]	; 30006114 <OSInit+0x248>
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
30005ef4:	e1a03002 	mov	r3, r2
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
30005ef8:	e5c12000 	strb	r2, [r1]

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
30005efc:	e59f1214 	ldr	r1, [pc, #532]	; 30006118 <OSInit+0x24c>
30005f00:	e5c12000 	strb	r2, [r1]

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
30005f04:	e59f1210 	ldr	r1, [pc, #528]	; 3000611c <OSInit+0x250>
30005f08:	e5c12000 	strb	r2, [r1]

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
30005f0c:	e59f120c 	ldr	r1, [pc, #524]	; 30006120 <OSInit+0x254>
30005f10:	e5812000 	str	r2, [r1]
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
30005f14:	e59f1208 	ldr	r1, [pc, #520]	; 30006124 <OSInit+0x258>
30005f18:	e5812000 	str	r2, [r1]

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
30005f1c:	e59f1204 	ldr	r1, [pc, #516]	; 30006128 <OSInit+0x25c>
30005f20:	e5812000 	str	r2, [r1]
    OSIdleCtrMax  = 0L;
30005f24:	e59f1200 	ldr	r1, [pc, #512]	; 3000612c <OSInit+0x260>
30005f28:	e5812000 	str	r2, [r1]
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
30005f2c:	e59f11fc 	ldr	r1, [pc, #508]	; 30006130 <OSInit+0x264>
30005f30:	e5c12000 	strb	r2, [r1]
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
30005f34:	e59f11f8 	ldr	r1, [pc, #504]	; 30006134 <OSInit+0x268>
30005f38:	e5c12000 	strb	r2, [r1]
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0;
30005f3c:	e1a01002 	mov	r1, r2
30005f40:	e7c01003 	strb	r1, [r0, r3]
30005f44:	e2833001 	add	r3, r3, #1
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
30005f48:	e3530008 	cmp	r3, #8
        *prdytbl++ = 0;
30005f4c:	e3a02000 	mov	r2, #0
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
30005f50:	1afffffa 	bne	30005f40 <OSInit+0x74>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
30005f54:	e59f01dc 	ldr	r0, [pc, #476]	; 30006138 <OSInit+0x26c>
30005f58:	e59f11dc 	ldr	r1, [pc, #476]	; 3000613c <OSInit+0x270>
30005f5c:	e5c02000 	strb	r2, [r0]
    OSPrioHighRdy = 0;
30005f60:	e59f01d8 	ldr	r0, [pc, #472]	; 30006140 <OSInit+0x274>

    OSTCBHighRdy  = (OS_TCB *)0;
    OSTCBCur      = (OS_TCB *)0;
30005f64:	e1a03002 	mov	r3, r2
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
    OSPrioHighRdy = 0;
30005f68:	e5c02000 	strb	r2, [r0]

    OSTCBHighRdy  = (OS_TCB *)0;
30005f6c:	e59f01d0 	ldr	r0, [pc, #464]	; 30006144 <OSInit+0x278>
30005f70:	e5802000 	str	r2, [r0]
    OSTCBCur      = (OS_TCB *)0;
30005f74:	e59f01cc 	ldr	r0, [pc, #460]	; 30006148 <OSInit+0x27c>
30005f78:	e5802000 	str	r2, [r0]
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
        *pdest++ = (INT8U)0;
30005f7c:	e7c12003 	strb	r2, [r1, r3]
30005f80:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30005f84:	e3530e79 	cmp	r3, #1936	; 0x790
30005f88:	1afffffb 	bne	30005f7c <OSInit+0xb0>
30005f8c:	e3a03000 	mov	r3, #0
30005f90:	e59f01b4 	ldr	r0, [pc, #436]	; 3000614c <OSInit+0x280>
        *pdest++ = (INT8U)0;
30005f94:	e1a02003 	mov	r2, r3
30005f98:	e7c02003 	strb	r2, [r0, r3]
30005f9c:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30005fa0:	e3530c01 	cmp	r3, #256	; 0x100
30005fa4:	1afffffb 	bne	30005f98 <OSInit+0xcc>
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
30005fa8:	e59fe1a0 	ldr	lr, [pc, #416]	; 30006150 <OSInit+0x284>
30005fac:	e59f31a0 	ldr	r3, [pc, #416]	; 30006154 <OSInit+0x288>
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
30005fb0:	e3a0c03f 	mov	ip, #63	; 0x3f
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
30005fb4:	e3a02000 	mov	r2, #0
    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
        ptcb1->OSTCBNext = ptcb2;
30005fb8:	e5033044 	str	r3, [r3, #-68]	; 0x44
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
30005fbc:	e543c010 	strb	ip, [r3, #-16]
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
30005fc0:	e543200f 	strb	r2, [r3, #-15]
#endif
        ptcb1++;
        ptcb2++;
30005fc4:	e2833058 	add	r3, r3, #88	; 0x58

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
30005fc8:	e153000e 	cmp	r3, lr
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
30005fcc:	e3a00000 	mov	r0, #0

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
30005fd0:	1afffff8 	bne	30005fb8 <OSInit+0xec>
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    OSTCBFreeList           = &OSTCBTbl[0];
30005fd4:	e59fc17c 	ldr	ip, [pc, #380]	; 30006158 <OSInit+0x28c>
30005fd8:	e59f217c 	ldr	r2, [pc, #380]	; 3000615c <OSInit+0x290>
30005fdc:	e58c1000 	str	r1, [ip]
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
30005fe0:	e3a0c03f 	mov	ip, #63	; 0x3f
30005fe4:	e5c1c780 	strb	ip, [r1, #1920]	; 0x780
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
30005fe8:	e59fc170 	ldr	ip, [pc, #368]	; 30006160 <OSInit+0x294>
    OSTCBFreeList           = &OSTCBTbl[0];
30005fec:	e1a03000 	mov	r3, r0
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
30005ff0:	e58c0000 	str	r0, [ip]
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
30005ff4:	e581074c 	str	r0, [r1, #1868]	; 0x74c
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
30005ff8:	e5c10781 	strb	r0, [r1, #1921]	; 0x781
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
        *pdest++ = (INT8U)0;
30005ffc:	e1a01000 	mov	r1, r0
30006000:	e7c21003 	strb	r1, [r2, r3]
30006004:	e2833001 	add	r3, r3, #1
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
30006008:	e3530f5a 	cmp	r3, #360	; 0x168
3000600c:	1afffffb 	bne	30006000 <OSInit+0x134>
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
30006010:	e59f114c 	ldr	r1, [pc, #332]	; 30006164 <OSInit+0x298>

    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
30006014:	e3a0c000 	mov	ip, #0
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
30006018:	e2413f51 	sub	r3, r1, #324	; 0x144
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
        pevent1->OSEventPtr     = pevent2;
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
3000601c:	e3a0003f 	mov	r0, #63	; 0x3f

    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
30006020:	e3a04000 	mov	r4, #0
30006024:	e543c024 	strb	ip, [r3, #-36]	; 0x24
        pevent1->OSEventPtr     = pevent2;
30006028:	e5033020 	str	r3, [r3, #-32]
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
3000602c:	e5430011 	strb	r0, [r3, #-17]
        pevent1->OSEventName[1] = OS_ASCII_NUL;
30006030:	e5434010 	strb	r4, [r3, #-16]
#endif
        pevent1++;
        pevent2++;
30006034:	e2833024 	add	r3, r3, #36	; 0x24


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
30006038:	e1530001 	cmp	r3, r1
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
        pevent1->OSEventPtr     = pevent2;
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
3000603c:	e3a0503f 	mov	r5, #63	; 0x3f


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
30006040:	1afffff6 	bne	30006020 <OSInit+0x154>
    pevent1->OSEventPtr             = (OS_EVENT *)0;
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
#endif
    OSEventFreeList                 = &OSEventTbl[0];
30006044:	e59f311c 	ldr	r3, [pc, #284]	; 30006168 <OSInit+0x29c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
30006048:	e5c24144 	strb	r4, [r2, #324]	; 0x144
    pevent1->OSEventPtr             = (OS_EVENT *)0;
3000604c:	e5824148 	str	r4, [r2, #328]	; 0x148
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
#endif
    OSEventFreeList                 = &OSEventTbl[0];
30006050:	e5832000 	str	r2, [r3]
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    pevent1->OSEventPtr             = (OS_EVENT *)0;
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
30006054:	e5c25157 	strb	r5, [r2, #343]	; 0x157
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
30006058:	e5c24158 	strb	r4, [r2, #344]	; 0x158
    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
3000605c:	ebffeb4b 	bl	30000d90 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
30006060:	ebffeba8 	bl	30000f08 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
30006064:	ebffebc5 	bl	30000f80 <OS_QInit>
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
30006068:	e59fc0fc 	ldr	ip, [pc, #252]	; 3000616c <OSInit+0x2a0>
3000606c:	e59fe0fc 	ldr	lr, [pc, #252]	; 30006170 <OSInit+0x2a4>
30006070:	e28c2f7f 	add	r2, ip, #508	; 0x1fc
30006074:	e1a03005 	mov	r3, r5
30006078:	e3a07080 	mov	r7, #128	; 0x80
3000607c:	e3a06003 	mov	r6, #3
30006080:	e1a01004 	mov	r1, r4
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
30006084:	e28d801f 	add	r8, sp, #31
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
30006088:	e59f00e4 	ldr	r0, [pc, #228]	; 30006174 <OSInit+0x2a8>
3000608c:	e58de000 	str	lr, [sp]
30006090:	e58dc004 	str	ip, [sp, #4]
30006094:	e58d7008 	str	r7, [sp, #8]
30006098:	e58d400c 	str	r4, [sp, #12]
3000609c:	e58d6010 	str	r6, [sp, #16]
300060a0:	ebfff437 	bl	30003184 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
300060a4:	e1a00005 	mov	r0, r5
300060a8:	e1a02008 	mov	r2, r8
300060ac:	e59f10c4 	ldr	r1, [pc, #196]	; 30006178 <OSInit+0x2ac>
300060b0:	ebffecaa 	bl	30001360 <OSTaskNameSet>
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
300060b4:	e59fc0c0 	ldr	ip, [pc, #192]	; 3000617c <OSInit+0x2b0>
300060b8:	e59fe0c0 	ldr	lr, [pc, #192]	; 30006180 <OSInit+0x2b4>
300060bc:	e28c2f7f 	add	r2, ip, #508	; 0x1fc
300060c0:	e3a0303e 	mov	r3, #62	; 0x3e
300060c4:	e1a01004 	mov	r1, r4
300060c8:	e59f00b4 	ldr	r0, [pc, #180]	; 30006184 <OSInit+0x2b8>
300060cc:	e58de000 	str	lr, [sp]
300060d0:	e58dc004 	str	ip, [sp, #4]
300060d4:	e58d7008 	str	r7, [sp, #8]
300060d8:	e58d6010 	str	r6, [sp, #16]
300060dc:	e58d400c 	str	r4, [sp, #12]
300060e0:	ebfff427 	bl	30003184 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
300060e4:	e1a02008 	mov	r2, r8
300060e8:	e3a0003e 	mov	r0, #62	; 0x3e
300060ec:	e59f1094 	ldr	r1, [pc, #148]	; 30006188 <OSInit+0x2bc>
300060f0:	ebffec9a 	bl	30001360 <OSTaskNameSet>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
300060f4:	ebfff471 	bl	300032c0 <OSTmr_Init>
#endif

#if OS_VERSION >= 204
    OSInitHookEnd();                                             /* Call port specific init. code            */
300060f8:	eb00021a 	bl	30006968 <OSInitHookEnd>
#endif

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
    OSDebugInit();
#endif
}
300060fc:	e28dd020 	add	sp, sp, #32
30006100:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
30006104:	e12fff1e 	bx	lr
30006108:	3001d0a0 	andcc	sp, r1, r0, lsr #1
3000610c:	3001d094 	mulcc	r1, r4, r0
30006110:	3001ce88 	andcc	ip, r1, r8, lsl #29
30006114:	3001c764 	andcc	ip, r1, r4, ror #14
30006118:	3001ce15 	andcc	ip, r1, r5, lsl lr
3000611c:	3001c76c 	andcc	ip, r1, ip, ror #14
30006120:	3001ce04 	andcc	ip, r1, r4, lsl #28
30006124:	3001c770 	andcc	ip, r1, r0, ror r7
30006128:	3001dca8 	andcc	sp, r1, r8, lsr #25
3000612c:	3001ce0c 	andcc	ip, r1, ip, lsl #28
30006130:	3001dba4 	andcc	sp, r1, r4, lsr #23
30006134:	3001ce84 	andcc	ip, r1, r4, lsl #29
30006138:	3001cb44 	andcc	ip, r1, r4, asr #22
3000613c:	3001d410 	andcc	sp, r1, r0, lsl r4
30006140:	3001c776 	andcc	ip, r1, r6, ror r7
30006144:	3001ce7c 	andcc	ip, r1, ip, ror lr
30006148:	3001d098 	mulcc	r1, r8, r0
3000614c:	3001dba8 	andcc	sp, r1, r8, lsr #23
30006150:	3001dba0 	andcc	sp, r1, r0, lsr #23
30006154:	3001d468 	andcc	sp, r1, r8, ror #8
30006158:	3001ce10 	andcc	ip, r1, r0, lsl lr
3000615c:	3001d2a8 	andcc	sp, r1, r8, lsr #5
30006160:	3001cb48 	andcc	ip, r1, r8, asr #22
30006164:	3001d410 	andcc	sp, r1, r0, lsl r4
30006168:	3001d090 	mulcc	r1, r0, r0
3000616c:	3001d0a8 	andcc	sp, r1, r8, lsr #1
30006170:	0000ffff 	strdeq	pc, [r0], -pc
30006174:	3000293c 	andcc	r2, r0, ip, lsr r9
30006178:	30006d0c 	andcc	r6, r0, ip, lsl #26
3000617c:	3001cc04 	andcc	ip, r1, r4, lsl #24
30006180:	0000fffe 	strdeq	pc, [r0], -lr
30006184:	30002c60 	andcc	r2, r0, r0, ror #24
30006188:	30006d1c 	andcc	r6, r0, ip, lsl sp

3000618c <test_task>:
	}
}

void test_task()
{
	if(1 == test_switch) {
3000618c:	e59fc058 	ldr	ip, [pc, #88]	; 300061ec <test_task+0x60>

	}
}

void test_task()
{
30006190:	e92d4010 	push	{r4, lr}
	if(1 == test_switch) {
30006194:	e59c3000 	ldr	r3, [ip]
30006198:	e3530001 	cmp	r3, #1
3000619c:	0a000010 	beq	300061e4 <test_task+0x58>

		return;
	}

	test_switch = 1;
300061a0:	e3a0e001 	mov	lr, #1

	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
300061a4:	e3a01000 	mov	r1, #0
300061a8:	e59f2040 	ldr	r2, [pc, #64]	; 300061f0 <test_task+0x64>
300061ac:	e3a03005 	mov	r3, #5
300061b0:	e59f003c 	ldr	r0, [pc, #60]	; 300061f4 <test_task+0x68>
	if(1 == test_switch) {

		return;
	}

	test_switch = 1;
300061b4:	e58ce000 	str	lr, [ip]

	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
300061b8:	ebfff4a3 	bl	3000344c <OSTaskCreate>

	OSTaskCreate( test_task2, 0, &stk2[STK_LEN -1], 6);
300061bc:	e3a01000 	mov	r1, #0
300061c0:	e59f2030 	ldr	r2, [pc, #48]	; 300061f8 <test_task+0x6c>
300061c4:	e3a03006 	mov	r3, #6
300061c8:	e59f002c 	ldr	r0, [pc, #44]	; 300061fc <test_task+0x70>
300061cc:	ebfff49e 	bl	3000344c <OSTaskCreate>
	
	OSTaskCreate( test_task3, 0, &stk3[STK_LEN -1], 3);
300061d0:	e59f0028 	ldr	r0, [pc, #40]	; 30006200 <test_task+0x74>
300061d4:	e3a01000 	mov	r1, #0
300061d8:	e59f2024 	ldr	r2, [pc, #36]	; 30006204 <test_task+0x78>
300061dc:	e3a03003 	mov	r3, #3
300061e0:	ebfff499 	bl	3000344c <OSTaskCreate>

}
300061e4:	e8bd4010 	pop	{r4, lr}
300061e8:	e12fff1e 	bx	lr
300061ec:	30006ea0 	andcc	r6, r0, r0, lsr #29
300061f0:	30007ea0 	andcc	r7, r0, r0, lsr #29
300061f4:	30006240 	andcc	r6, r0, r0, asr #4
300061f8:	30008ea0 	andcc	r8, r0, r0, lsr #29
300061fc:	30006224 	andcc	r6, r0, r4, lsr #4
30006200:	30006208 	andcc	r6, r0, r8, lsl #4
30006204:	30009ea0 	andcc	r9, r0, r0, lsr #29

30006208 <test_task3>:

	}
}

static void test_task3(void* p_arg)
{
30006208:	e92d4010 	push	{r4, lr}
	p_arg = p_arg;

	while(1) {

		printk("c ");
3000620c:	e59f000c 	ldr	r0, [pc, #12]	; 30006220 <test_task3+0x18>
30006210:	ebffe9c0 	bl	30000918 <printk>
		OSTimeDly(4);
30006214:	e3a00004 	mov	r0, #4
30006218:	ebfff23e 	bl	30002b18 <OSTimeDly>
3000621c:	eafffffa 	b	3000620c <test_task3+0x4>
30006220:	30006d2c 	andcc	r6, r0, ip, lsr #26

30006224 <test_task2>:
		OSTimeDly(5);
	}
}

static void test_task2(void* p_arg)
{
30006224:	e92d4010 	push	{r4, lr}
	p_arg = p_arg;

	while(1) {

		printk("b ");
30006228:	e59f000c 	ldr	r0, [pc, #12]	; 3000623c <test_task2+0x18>
3000622c:	ebffe9b9 	bl	30000918 <printk>
		OSTimeDly(2);
30006230:	e3a00002 	mov	r0, #2
30006234:	ebfff237 	bl	30002b18 <OSTimeDly>
30006238:	eafffffa 	b	30006228 <test_task2+0x4>
3000623c:	30006d30 	andcc	r6, r0, r0, lsr sp

30006240 <test_task1>:
static OS_STK stk1[STK_LEN];
static OS_STK stk2[STK_LEN];
static OS_STK stk3[STK_LEN];

static void test_task1(void* p_arg)
{
30006240:	e92d4010 	push	{r4, lr}
	p_arg = p_arg;

	while(1) {

		printk("a ");
30006244:	e59f000c 	ldr	r0, [pc, #12]	; 30006258 <test_task1+0x18>
30006248:	ebffe9b2 	bl	30000918 <printk>
		OSTimeDly(5);
3000624c:	e3a00005 	mov	r0, #5
30006250:	ebfff230 	bl	30002b18 <OSTimeDly>
30006254:	eafffffa 	b	30006244 <test_task1+0x4>
30006258:	30006d34 	andcc	r6, r0, r4, lsr sp

3000625c <test_sem>:



void test_sem()
{
	if(1 == test_switch) {
3000625c:	e59f3068 	ldr	r3, [pc, #104]	; 300062cc <test_sem+0x70>
}



void test_sem()
{
30006260:	e92d4010 	push	{r4, lr}
	if(1 == test_switch) {
30006264:	e5932000 	ldr	r2, [r3]
30006268:	e3520001 	cmp	r2, #1
3000626c:	0a000011 	beq	300062b8 <test_sem+0x5c>

		return;
	}

	test_switch = 1;
30006270:	e3a02001 	mov	r2, #1
30006274:	e5832000 	str	r2, [r3]

	p_sem = OSSemCreate(2); 
30006278:	e3a00002 	mov	r0, #2
3000627c:	ebffed1a 	bl	300016ec <OSSemCreate>
30006280:	e59f3048 	ldr	r3, [pc, #72]	; 300062d0 <test_sem+0x74>

	if(0 == p_sem) {
30006284:	e3500000 	cmp	r0, #0
		return;
	}

	test_switch = 1;

	p_sem = OSSemCreate(2); 
30006288:	e5830000 	str	r0, [r3]

	if(0 == p_sem) {
3000628c:	0a00000b 	beq	300062c0 <test_sem+0x64>
	
		printk("error in OSSemCreate\n");
	}

	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
30006290:	e3a01000 	mov	r1, #0
30006294:	e59f2038 	ldr	r2, [pc, #56]	; 300062d4 <test_sem+0x78>
30006298:	e3a03005 	mov	r3, #5
3000629c:	e59f0034 	ldr	r0, [pc, #52]	; 300062d8 <test_sem+0x7c>
300062a0:	ebfff469 	bl	3000344c <OSTaskCreate>

	OSTaskCreate( test_task2, 0, &stk2[STK_LEN -1], 6);
300062a4:	e59f0030 	ldr	r0, [pc, #48]	; 300062dc <test_sem+0x80>
300062a8:	e3a01000 	mov	r1, #0
300062ac:	e59f202c 	ldr	r2, [pc, #44]	; 300062e0 <test_sem+0x84>
300062b0:	e3a03006 	mov	r3, #6
300062b4:	ebfff464 	bl	3000344c <OSTaskCreate>
	

}
300062b8:	e8bd4010 	pop	{r4, lr}
300062bc:	e12fff1e 	bx	lr

	p_sem = OSSemCreate(2); 

	if(0 == p_sem) {
	
		printk("error in OSSemCreate\n");
300062c0:	e59f001c 	ldr	r0, [pc, #28]	; 300062e4 <test_sem+0x88>
300062c4:	ebffe993 	bl	30000918 <printk>
300062c8:	eafffff0 	b	30006290 <test_sem+0x34>
300062cc:	30006ea0 	andcc	r6, r0, r0, lsr #29
300062d0:	30009ea4 	andcc	r9, r0, r4, lsr #29
300062d4:	3000bea4 	andcc	fp, r0, r4, lsr #29
300062d8:	30006314 	andcc	r6, r0, r4, lsl r3
300062dc:	300062e8 	andcc	r6, r0, r8, ror #5
300062e0:	3000dea4 	andcc	sp, r0, r4, lsr #29
300062e4:	30006d38 	andcc	r6, r0, r8, lsr sp

300062e8 <test_task2>:
		OSTimeDly(5);
	}
}

static void test_task2(void* p_arg)
{
300062e8:	e92d4010 	push	{r4, lr}
300062ec:	e59f4018 	ldr	r4, [pc, #24]	; 3000630c <test_task2+0x24>
	p_arg = p_arg;

	while(1) {

		OSSemPost(p_sem);
300062f0:	e5940000 	ldr	r0, [r4]
300062f4:	ebfff4f9 	bl	300036e0 <OSSemPost>

		printk("give ");
300062f8:	e59f0010 	ldr	r0, [pc, #16]	; 30006310 <test_task2+0x28>
300062fc:	ebffe985 	bl	30000918 <printk>
		OSTimeDly(10);
30006300:	e3a0000a 	mov	r0, #10
30006304:	ebfff203 	bl	30002b18 <OSTimeDly>
30006308:	eafffff8 	b	300062f0 <test_task2+0x8>
3000630c:	30009ea4 	andcc	r9, r0, r4, lsr #29
30006310:	30006d50 	andcc	r6, r0, r0, asr sp

30006314 <test_task1>:
static OS_STK stk2[STK_LEN];

static OS_EVENT* p_sem;

static void test_task1(void* p_arg)
{
30006314:	e92d4030 	push	{r4, r5, lr}
30006318:	e59f5028 	ldr	r5, [pc, #40]	; 30006348 <test_task1+0x34>
3000631c:	e24dd00c 	sub	sp, sp, #12
30006320:	e28d4007 	add	r4, sp, #7

	p_arg = p_arg;

	while(1) {
		
		OSSemPend(p_sem, 0, &err);
30006324:	e5950000 	ldr	r0, [r5]
30006328:	e3a01000 	mov	r1, #0
3000632c:	e1a02004 	mov	r2, r4
30006330:	ebfff517 	bl	30003794 <OSSemPend>

		printk("get ");
30006334:	e59f0010 	ldr	r0, [pc, #16]	; 3000634c <test_task1+0x38>
30006338:	ebffe976 	bl	30000918 <printk>
		OSTimeDly(5);
3000633c:	e3a00005 	mov	r0, #5
30006340:	ebfff1f4 	bl	30002b18 <OSTimeDly>
30006344:	eafffff6 	b	30006324 <test_task1+0x10>
30006348:	30009ea4 	andcc	r9, r0, r4, lsr #29
3000634c:	30006d58 	andcc	r6, r0, r8, asr sp

30006350 <test_mutex>:
}



void test_mutex()
{
30006350:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	INT8U err;

	if(1 == test_switch) {
30006354:	e59f3070 	ldr	r3, [pc, #112]	; 300063cc <test_mutex+0x7c>
}



void test_mutex()
{
30006358:	e24dd00c 	sub	sp, sp, #12
	INT8U err;

	if(1 == test_switch) {
3000635c:	e5932000 	ldr	r2, [r3]
30006360:	e3520001 	cmp	r2, #1
30006364:	0a000012 	beq	300063b4 <test_mutex+0x64>

		return;
	}

	test_switch = 1;
30006368:	e3a02001 	mov	r2, #1
3000636c:	e5832000 	str	r2, [r3]

	p_mutex = OSMutexCreate(4, &err); 
30006370:	e3a00004 	mov	r0, #4
30006374:	e28d1007 	add	r1, sp, #7
30006378:	ebffede1 	bl	30001b04 <OSMutexCreate>
3000637c:	e59f304c 	ldr	r3, [pc, #76]	; 300063d0 <test_mutex+0x80>

	if(0 == p_mutex) {
30006380:	e3500000 	cmp	r0, #0
		return;
	}

	test_switch = 1;

	p_mutex = OSMutexCreate(4, &err); 
30006384:	e5830000 	str	r0, [r3]

	if(0 == p_mutex) {
30006388:	0a00000c 	beq	300063c0 <test_mutex+0x70>
	
		printk("error in OSMutexCreate\n");
	}

	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
3000638c:	e3a01000 	mov	r1, #0
30006390:	e59f203c 	ldr	r2, [pc, #60]	; 300063d4 <test_mutex+0x84>
30006394:	e3a03005 	mov	r3, #5
30006398:	e59f0038 	ldr	r0, [pc, #56]	; 300063d8 <test_mutex+0x88>
3000639c:	ebfff42a 	bl	3000344c <OSTaskCreate>

	OSTaskCreate( test_task2, 0, &stk2[STK_LEN -1], 6);
300063a0:	e59f0034 	ldr	r0, [pc, #52]	; 300063dc <test_mutex+0x8c>
300063a4:	e3a01000 	mov	r1, #0
300063a8:	e59f2030 	ldr	r2, [pc, #48]	; 300063e0 <test_mutex+0x90>
300063ac:	e3a03006 	mov	r3, #6
300063b0:	ebfff425 	bl	3000344c <OSTaskCreate>
	

}
300063b4:	e28dd00c 	add	sp, sp, #12
300063b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300063bc:	e12fff1e 	bx	lr

	p_mutex = OSMutexCreate(4, &err); 

	if(0 == p_mutex) {
	
		printk("error in OSMutexCreate\n");
300063c0:	e59f001c 	ldr	r0, [pc, #28]	; 300063e4 <test_mutex+0x94>
300063c4:	ebffe953 	bl	30000918 <printk>
300063c8:	eaffffef 	b	3000638c <test_mutex+0x3c>
300063cc:	30006ea0 	andcc	r6, r0, r0, lsr #29
300063d0:	3000dea8 	andcc	sp, r0, r8, lsr #29
300063d4:	3000fea8 	andcc	pc, r0, r8, lsr #29
300063d8:	30006414 	andcc	r6, r0, r4, lsl r4
300063dc:	300063e8 	andcc	r6, r0, r8, ror #7
300063e0:	30011ea8 	andcc	r1, r1, r8, lsr #29
300063e4:	30006d60 	andcc	r6, r0, r0, ror #26

300063e8 <test_task2>:
		OSTimeDly(5);
	}
}

static void test_task2(void* p_arg)
{
300063e8:	e92d4010 	push	{r4, lr}
300063ec:	e59f4018 	ldr	r4, [pc, #24]	; 3000640c <test_task2+0x24>
	p_arg = p_arg;

	while(1) {

		OSMutexPost(p_mutex);
300063f0:	e5940000 	ldr	r0, [r4]
300063f4:	ebfff974 	bl	300049cc <OSMutexPost>

		printk("produce ");
300063f8:	e59f0010 	ldr	r0, [pc, #16]	; 30006410 <test_task2+0x28>
300063fc:	ebffe945 	bl	30000918 <printk>
		OSTimeDly(10);
30006400:	e3a0000a 	mov	r0, #10
30006404:	ebfff1c3 	bl	30002b18 <OSTimeDly>
30006408:	eafffff8 	b	300063f0 <test_task2+0x8>
3000640c:	3000dea8 	andcc	sp, r0, r8, lsr #29
30006410:	30006d78 	andcc	r6, r0, r8, ror sp

30006414 <test_task1>:
static OS_STK stk2[STK_LEN];

static OS_EVENT* p_mutex;

static void test_task1(void* p_arg)
{
30006414:	e92d4030 	push	{r4, r5, lr}
30006418:	e59f5028 	ldr	r5, [pc, #40]	; 30006448 <test_task1+0x34>
3000641c:	e24dd00c 	sub	sp, sp, #12
30006420:	e28d4007 	add	r4, sp, #7

	p_arg = p_arg;

	while(1) {
		
		OSMutexPend(p_mutex, 0, &err);
30006424:	e5950000 	ldr	r0, [r5]
30006428:	e3a01000 	mov	r1, #0
3000642c:	e1a02004 	mov	r2, r4
30006430:	ebfff9d2 	bl	30004b80 <OSMutexPend>

		printk("consume ");
30006434:	e59f0010 	ldr	r0, [pc, #16]	; 3000644c <test_task1+0x38>
30006438:	ebffe936 	bl	30000918 <printk>
		OSTimeDly(5);
3000643c:	e3a00005 	mov	r0, #5
30006440:	ebfff1b4 	bl	30002b18 <OSTimeDly>
30006444:	eafffff6 	b	30006424 <test_task1+0x10>
30006448:	3000dea8 	andcc	sp, r0, r8, lsr #29
3000644c:	30006d84 	andcc	r6, r0, r4, lsl #27

30006450 <test_mbox>:



void test_mbox()
{
	if(1 == test_switch) {
30006450:	e59f3068 	ldr	r3, [pc, #104]	; 300064c0 <test_mbox+0x70>
}



void test_mbox()
{
30006454:	e92d4010 	push	{r4, lr}
	if(1 == test_switch) {
30006458:	e5932000 	ldr	r2, [r3]
3000645c:	e3520001 	cmp	r2, #1
30006460:	0a000011 	beq	300064ac <test_mbox+0x5c>

		return;
	}

	test_switch = 1;
30006464:	e3a02001 	mov	r2, #1
30006468:	e5832000 	str	r2, [r3]

	p_mbox = OSMboxCreate(0); 
3000646c:	e3a00000 	mov	r0, #0
30006470:	ebffef2d 	bl	3000212c <OSMboxCreate>
30006474:	e59f3048 	ldr	r3, [pc, #72]	; 300064c4 <test_mbox+0x74>

	if(0 == p_mbox) {
30006478:	e3500000 	cmp	r0, #0
		return;
	}

	test_switch = 1;

	p_mbox = OSMboxCreate(0); 
3000647c:	e5830000 	str	r0, [r3]

	if(0 == p_mbox) {
30006480:	0a00000b 	beq	300064b4 <test_mbox+0x64>
	
		printk("error in OSMboxCreate\n");
	}

	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
30006484:	e3a01000 	mov	r1, #0
30006488:	e59f2038 	ldr	r2, [pc, #56]	; 300064c8 <test_mbox+0x78>
3000648c:	e3a03005 	mov	r3, #5
30006490:	e59f0034 	ldr	r0, [pc, #52]	; 300064cc <test_mbox+0x7c>
30006494:	ebfff3ec 	bl	3000344c <OSTaskCreate>

	OSTaskCreate( test_task2, 0, &stk2[STK_LEN -1], 6);
30006498:	e59f0030 	ldr	r0, [pc, #48]	; 300064d0 <test_mbox+0x80>
3000649c:	e3a01000 	mov	r1, #0
300064a0:	e59f202c 	ldr	r2, [pc, #44]	; 300064d4 <test_mbox+0x84>
300064a4:	e3a03006 	mov	r3, #6
300064a8:	ebfff3e7 	bl	3000344c <OSTaskCreate>
	

}
300064ac:	e8bd4010 	pop	{r4, lr}
300064b0:	e12fff1e 	bx	lr

	p_mbox = OSMboxCreate(0); 

	if(0 == p_mbox) {
	
		printk("error in OSMboxCreate\n");
300064b4:	e59f001c 	ldr	r0, [pc, #28]	; 300064d8 <test_mbox+0x88>
300064b8:	ebffe916 	bl	30000918 <printk>
300064bc:	eafffff0 	b	30006484 <test_mbox+0x34>
300064c0:	30006ea0 	andcc	r6, r0, r0, lsr #29
300064c4:	30011eac 	andcc	r1, r1, ip, lsr #29
300064c8:	30013eac 	andcc	r3, r1, ip, lsr #29
300064cc:	30006528 	andcc	r6, r0, r8, lsr #10
300064d0:	300064dc 	ldrdcc	r6, [r0], -ip
300064d4:	30015eac 	andcc	r5, r1, ip, lsr #29
300064d8:	30006d90 	mulcc	r0, r0, sp

300064dc <test_task2>:
		OSTimeDly(5);
	}
}

static void test_task2(void* p_arg)
{
300064dc:	e92d4070 	push	{r4, r5, r6, lr}
300064e0:	e59f4030 	ldr	r4, [pc, #48]	; 30006518 <test_task2+0x3c>
300064e4:	e59f5030 	ldr	r5, [pc, #48]	; 3000651c <test_task2+0x40>
	p_arg = p_arg;

	while(1) {

		data += 1;
300064e8:	e5943014 	ldr	r3, [r4, #20]
		printk("send %d ", data);
300064ec:	e59f002c 	ldr	r0, [pc, #44]	; 30006520 <test_task2+0x44>
{
	p_arg = p_arg;

	while(1) {

		data += 1;
300064f0:	e2833001 	add	r3, r3, #1
		printk("send %d ", data);
300064f4:	e1a01003 	mov	r1, r3
{
	p_arg = p_arg;

	while(1) {

		data += 1;
300064f8:	e5843014 	str	r3, [r4, #20]
		printk("send %d ", data);
300064fc:	ebffe905 	bl	30000918 <printk>
		
		OSMboxPost(p_mbox, &data);
30006500:	e5950000 	ldr	r0, [r5]
30006504:	e59f1018 	ldr	r1, [pc, #24]	; 30006524 <test_task2+0x48>
30006508:	ebfffb3d 	bl	30005204 <OSMboxPost>
		OSTimeDly(10);
3000650c:	e3a0000a 	mov	r0, #10
30006510:	ebfff180 	bl	30002b18 <OSTimeDly>
30006514:	eafffff3 	b	300064e8 <test_task2+0xc>
30006518:	30015e9c 	mulcc	r1, ip, lr
3000651c:	30011eac 	andcc	r1, r1, ip, lsr #29
30006520:	30006da8 	andcc	r6, r0, r8, lsr #27
30006524:	30015eb0 	undefined instruction 0x30015eb0

30006528 <test_task1>:
static OS_EVENT* p_mbox;

static INT32U data = 0;

static void test_task1(void* p_arg)
{
30006528:	e92d4030 	push	{r4, r5, lr}
3000652c:	e59f502c 	ldr	r5, [pc, #44]	; 30006560 <test_task1+0x38>
30006530:	e24dd00c 	sub	sp, sp, #12
30006534:	e28d4007 	add	r4, sp, #7

	p_arg = p_arg;

	while(1) {
		
		p_data = (INT32U*) OSMboxPend(p_mbox, 0, &err);
30006538:	e1a02004 	mov	r2, r4
3000653c:	e5950000 	ldr	r0, [r5]
30006540:	e3a01000 	mov	r1, #0
30006544:	ebfffb56 	bl	300052a4 <OSMboxPend>

		printk("receive %d ", *p_data);
30006548:	e5901000 	ldr	r1, [r0]
3000654c:	e59f0010 	ldr	r0, [pc, #16]	; 30006564 <test_task1+0x3c>
30006550:	ebffe8f0 	bl	30000918 <printk>
		OSTimeDly(5);
30006554:	e3a00005 	mov	r0, #5
30006558:	ebfff16e 	bl	30002b18 <OSTimeDly>
3000655c:	eafffff5 	b	30006538 <test_task1+0x10>
30006560:	30011eac 	andcc	r1, r1, ip, lsr #29
30006564:	30006db4 	undefined instruction 0x30006db4

30006568 <timer_func>:

static void timer_func(void* tmr, void* arg)
{
	static INT32U data = 0;

	printk("%d ", data ++);
30006568:	e59f3020 	ldr	r3, [pc, #32]	; 30006590 <timer_func+0x28>
static OS_STK stk1[STK_LEN];

static OS_TMR* p_tmr;

static void timer_func(void* tmr, void* arg)
{
3000656c:	e92d4010 	push	{r4, lr}
	static INT32U data = 0;

	printk("%d ", data ++);
30006570:	e5932000 	ldr	r2, [r3]
30006574:	e59f0018 	ldr	r0, [pc, #24]	; 30006594 <timer_func+0x2c>
30006578:	e1a01002 	mov	r1, r2
3000657c:	e2822001 	add	r2, r2, #1
30006580:	e5832000 	str	r2, [r3]
30006584:	ebffe8e3 	bl	30000918 <printk>

}
30006588:	e8bd4010 	pop	{r4, lr}
3000658c:	e12fff1e 	bx	lr
30006590:	30015eb4 	undefined instruction 0x30015eb4
30006594:	30006dbc 	undefined instruction 0x30006dbc

30006598 <test_tmr>:
	}
}


void test_tmr()
{
30006598:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	INT8U err;

	if(1 == test_switch) {
3000659c:	e59fc07c 	ldr	ip, [pc, #124]	; 30006620 <test_tmr+0x88>
	}
}


void test_tmr()
{
300065a0:	e24dd01c 	sub	sp, sp, #28
	INT8U err;

	if(1 == test_switch) {
300065a4:	e59c3000 	ldr	r3, [ip]
300065a8:	e3530001 	cmp	r3, #1
300065ac:	0a000015 	beq	30006608 <test_tmr+0x70>

		return;
	}

	test_switch = 1;
300065b0:	e3a0e001 	mov	lr, #1
300065b4:	e58ce000 	str	lr, [ip]

	p_tmr = OSTmrCreate(10,                     /* first tick      */
300065b8:	e3a0c000 	mov	ip, #0
300065bc:	e58dc000 	str	ip, [sp]
300065c0:	e59fc05c 	ldr	ip, [pc, #92]	; 30006624 <test_tmr+0x8c>
300065c4:	e59f305c 	ldr	r3, [pc, #92]	; 30006628 <test_tmr+0x90>
300065c8:	e58dc004 	str	ip, [sp, #4]
300065cc:	e3a0000a 	mov	r0, #10
300065d0:	e28dc017 	add	ip, sp, #23
300065d4:	e3a01005 	mov	r1, #5
300065d8:	e3a02002 	mov	r2, #2
300065dc:	e58dc008 	str	ip, [sp, #8]
300065e0:	ebfff681 	bl	30003fec <OSTmrCreate>
300065e4:	e59f3040 	ldr	r3, [pc, #64]	; 3000662c <test_tmr+0x94>
			    0,                      /* func parameters */
                            "timer1",               /* timer name      */
                            &err                    /* error point     */
			);

	if(0 == p_tmr) {
300065e8:	e3500000 	cmp	r0, #0
		return;
	}

	test_switch = 1;

	p_tmr = OSTmrCreate(10,                     /* first tick      */
300065ec:	e5830004 	str	r0, [r3, #4]
			    0,                      /* func parameters */
                            "timer1",               /* timer name      */
                            &err                    /* error point     */
			);

	if(0 == p_tmr) {
300065f0:	0a000007 	beq	30006614 <test_tmr+0x7c>
		
		printk("error in OSTmrCreate\n");
	}


	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
300065f4:	e59f0034 	ldr	r0, [pc, #52]	; 30006630 <test_tmr+0x98>
300065f8:	e3a01000 	mov	r1, #0
300065fc:	e59f2030 	ldr	r2, [pc, #48]	; 30006634 <test_tmr+0x9c>
30006600:	e3a03005 	mov	r3, #5
30006604:	ebfff390 	bl	3000344c <OSTaskCreate>

}
30006608:	e28dd01c 	add	sp, sp, #28
3000660c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006610:	e12fff1e 	bx	lr
                            &err                    /* error point     */
			);

	if(0 == p_tmr) {
		
		printk("error in OSTmrCreate\n");
30006614:	e59f001c 	ldr	r0, [pc, #28]	; 30006638 <test_tmr+0xa0>
30006618:	ebffe8be 	bl	30000918 <printk>
3000661c:	eafffff4 	b	300065f4 <test_tmr+0x5c>
30006620:	30006ea0 	andcc	r6, r0, r0, lsr #29
30006624:	30006dc0 	andcc	r6, r0, r0, asr #27
30006628:	30006568 	andcc	r6, r0, r8, ror #10
3000662c:	30015eb4 	undefined instruction 0x30015eb4
30006630:	3000663c 	andcc	r6, r0, ip, lsr r6
30006634:	30017eb8 	undefined instruction 0x30017eb8
30006638:	30006dc8 	andcc	r6, r0, r8, asr #27

3000663c <test_task1>:
	printk("%d ", data ++);

}

static void test_task1(void* p_arg)
{
3000663c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	INT8U err;

	p_arg = p_arg;

	if(OS_FALSE == OSTmrStart(p_tmr, &err)) {
30006640:	e59f302c 	ldr	r3, [pc, #44]	; 30006674 <test_task1+0x38>
	printk("%d ", data ++);

}

static void test_task1(void* p_arg)
{
30006644:	e24dd00c 	sub	sp, sp, #12
	INT8U err;

	p_arg = p_arg;

	if(OS_FALSE == OSTmrStart(p_tmr, &err)) {
30006648:	e28d1007 	add	r1, sp, #7
3000664c:	e5930004 	ldr	r0, [r3, #4]
30006650:	ebfff52b 	bl	30003b04 <OSTmrStart>
30006654:	e3500000 	cmp	r0, #0
30006658:	0a000002 	beq	30006668 <test_task1+0x2c>
		printk("error in OSTmrStart");
	}

	while(1) {
	
		OSTimeDly(15);
3000665c:	e3a0000f 	mov	r0, #15
30006660:	ebfff12c 	bl	30002b18 <OSTimeDly>
30006664:	eafffffc 	b	3000665c <test_task1+0x20>

	p_arg = p_arg;

	if(OS_FALSE == OSTmrStart(p_tmr, &err)) {

		printk("error in OSTmrStart");
30006668:	e59f0008 	ldr	r0, [pc, #8]	; 30006678 <test_task1+0x3c>
3000666c:	ebffe8a9 	bl	30000918 <printk>
30006670:	eafffff9 	b	3000665c <test_task1+0x20>
30006674:	30015eb4 	undefined instruction 0x30015eb4
30006678:	30006de0 	andcc	r6, r0, r0, ror #27

3000667c <test_q>:
}


void test_q()
{
	if(1 == test_switch) {
3000667c:	e59f306c 	ldr	r3, [pc, #108]	; 300066f0 <test_q+0x74>
	}
}


void test_q()
{
30006680:	e92d4010 	push	{r4, lr}
	if(1 == test_switch) {
30006684:	e5932000 	ldr	r2, [r3]
30006688:	e3520001 	cmp	r2, #1
3000668c:	0a000012 	beq	300066dc <test_q+0x60>
		return;
	}

	test_switch = 1;

	p_queue = OSQCreate(queue, QUEUE_SIZE); 
30006690:	e59f405c 	ldr	r4, [pc, #92]	; 300066f4 <test_q+0x78>
	if(1 == test_switch) {

		return;
	}

	test_switch = 1;
30006694:	e3a02001 	mov	r2, #1

	p_queue = OSQCreate(queue, QUEUE_SIZE); 
30006698:	e1a00004 	mov	r0, r4
3000669c:	e3a01005 	mov	r1, #5
	if(1 == test_switch) {

		return;
	}

	test_switch = 1;
300066a0:	e5832000 	str	r2, [r3]

	p_queue = OSQCreate(queue, QUEUE_SIZE); 
300066a4:	ebffec84 	bl	300018bc <OSQCreate>

	if(0 == p_queue) {
300066a8:	e3500000 	cmp	r0, #0
		return;
	}

	test_switch = 1;

	p_queue = OSQCreate(queue, QUEUE_SIZE); 
300066ac:	e5840014 	str	r0, [r4, #20]

	if(0 == p_queue) {
300066b0:	0a00000b 	beq	300066e4 <test_q+0x68>
	
		printk("error in OSQCreate\n");
	}

	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
300066b4:	e3a01000 	mov	r1, #0
300066b8:	e59f2038 	ldr	r2, [pc, #56]	; 300066f8 <test_q+0x7c>
300066bc:	e3a03005 	mov	r3, #5
300066c0:	e59f0034 	ldr	r0, [pc, #52]	; 300066fc <test_q+0x80>
300066c4:	ebfff360 	bl	3000344c <OSTaskCreate>

	OSTaskCreate( test_task2, 0, &stk2[STK_LEN -1], 6);
300066c8:	e59f0030 	ldr	r0, [pc, #48]	; 30006700 <test_q+0x84>
300066cc:	e3a01000 	mov	r1, #0
300066d0:	e59f202c 	ldr	r2, [pc, #44]	; 30006704 <test_q+0x88>
300066d4:	e3a03006 	mov	r3, #6
300066d8:	ebfff35b 	bl	3000344c <OSTaskCreate>
	

}
300066dc:	e8bd4010 	pop	{r4, lr}
300066e0:	e12fff1e 	bx	lr

	p_queue = OSQCreate(queue, QUEUE_SIZE); 

	if(0 == p_queue) {
	
		printk("error in OSQCreate\n");
300066e4:	e59f001c 	ldr	r0, [pc, #28]	; 30006708 <test_q+0x8c>
300066e8:	ebffe88a 	bl	30000918 <printk>
300066ec:	eafffff0 	b	300066b4 <test_q+0x38>
300066f0:	30006ea0 	andcc	r6, r0, r0, lsr #29
300066f4:	30017ebc 	undefined instruction 0x30017ebc
300066f8:	30019ed0 	ldrdcc	r9, [r1], -r0
300066fc:	3000674c 	andcc	r6, r0, ip, asr #14
30006700:	3000670c 	andcc	r6, r0, ip, lsl #14
30006704:	3001bed0 	ldrdcc	fp, [r1], -r0
30006708:	30006df4 	strdcc	r6, [r0], -r4

3000670c <test_task2>:
		data ++;
	}
}

static void test_task2(void* p_arg)
{
3000670c:	e92d4030 	push	{r4, r5, lr}
30006710:	e59f502c 	ldr	r5, [pc, #44]	; 30006744 <test_task2+0x38>
30006714:	e24dd00c 	sub	sp, sp, #12
30006718:	e28d4007 	add	r4, sp, #7

	p_arg = p_arg;

	while(1) {
		
		val = (INT32U) OSQPend(p_queue, 0, &err);
3000671c:	e1a02004 	mov	r2, r4
30006720:	e5950014 	ldr	r0, [r5, #20]
30006724:	e3a01000 	mov	r1, #0
30006728:	ebfff7ca 	bl	30004658 <OSQPend>
3000672c:	e1a01000 	mov	r1, r0

		printk("get %d ", val);
30006730:	e59f0010 	ldr	r0, [pc, #16]	; 30006748 <test_task2+0x3c>
30006734:	ebffe877 	bl	30000918 <printk>
		OSTimeDly(50);
30006738:	e3a00032 	mov	r0, #50	; 0x32
3000673c:	ebfff0f5 	bl	30002b18 <OSTimeDly>
30006740:	eafffff5 	b	3000671c <test_task2+0x10>
30006744:	30017ebc 	undefined instruction 0x30017ebc
30006748:	30006e08 	andcc	r6, r0, r8, lsl #28

3000674c <test_task1>:
static void* queue[QUEUE_SIZE] = {0};

static INT32U data = 0;

static void test_task1(void* p_arg)
{
3000674c:	e92d4070 	push	{r4, r5, r6, lr}
30006750:	e59f404c 	ldr	r4, [pc, #76]	; 300067a4 <test_task1+0x58>
30006754:	e59f504c 	ldr	r5, [pc, #76]	; 300067a8 <test_task1+0x5c>
30006758:	e5941028 	ldr	r1, [r4, #40]	; 0x28

	p_arg = p_arg;

	while(1) {

		while(OS_NO_ERR != OSQPost(p_queue, (void*)(data))){
3000675c:	e5950014 	ldr	r0, [r5, #20]
30006760:	ebfff78c 	bl	30004598 <OSQPost>
30006764:	e3500000 	cmp	r0, #0
30006768:	1a000009 	bne	30006794 <test_task1+0x48>

			OSTimeDly(5);
		}

		printk("give %d ", data);
3000676c:	e5941028 	ldr	r1, [r4, #40]	; 0x28
30006770:	e59f0034 	ldr	r0, [pc, #52]	; 300067ac <test_task1+0x60>
30006774:	ebffe867 	bl	30000918 <printk>
		data ++;
30006778:	e5941028 	ldr	r1, [r4, #40]	; 0x28

	p_arg = p_arg;

	while(1) {

		while(OS_NO_ERR != OSQPost(p_queue, (void*)(data))){
3000677c:	e5950014 	ldr	r0, [r5, #20]

			OSTimeDly(5);
		}

		printk("give %d ", data);
		data ++;
30006780:	e2811001 	add	r1, r1, #1
30006784:	e5841028 	str	r1, [r4, #40]	; 0x28

	p_arg = p_arg;

	while(1) {

		while(OS_NO_ERR != OSQPost(p_queue, (void*)(data))){
30006788:	ebfff782 	bl	30004598 <OSQPost>
3000678c:	e3500000 	cmp	r0, #0
30006790:	0afffff5 	beq	3000676c <test_task1+0x20>

			OSTimeDly(5);
30006794:	e3a00005 	mov	r0, #5
30006798:	ebfff0de 	bl	30002b18 <OSTimeDly>
3000679c:	e5941028 	ldr	r1, [r4, #40]	; 0x28
300067a0:	eaffffed 	b	3000675c <test_task1+0x10>
300067a4:	3001beac 	andcc	fp, r1, ip, lsr #29
300067a8:	30017ebc 	undefined instruction 0x30017ebc
300067ac:	30006e10 	andcc	r6, r0, r0, lsl lr

300067b0 <test_m>:
	}
}


void test_m()
{
300067b0:	e92d4010 	push	{r4, lr}
	INT8U err;

	INT8U* p_addr;

	if(1 == test_switch) {
300067b4:	e59fc064 	ldr	ip, [pc, #100]	; 30006820 <test_m+0x70>
	}
}


void test_m()
{
300067b8:	e24dd008 	sub	sp, sp, #8
	INT8U err;

	INT8U* p_addr;

	if(1 == test_switch) {
300067bc:	e59c3000 	ldr	r3, [ip]
300067c0:	e3530001 	cmp	r3, #1
300067c4:	0a00000f 	beq	30006808 <test_m+0x58>
	if((INT32U)p_addr & 0x3) {
		
		p_addr =(INT8U*) (((INT32U)p_addr & 0xfffffffc) + 4);
	}
	
	p_mem = OSMemCreate(p_addr,  /* start address */
300067c8:	e59f4054 	ldr	r4, [pc, #84]	; 30006824 <test_m+0x74>
	if(1 == test_switch) {

		return;
	}

	test_switch = 1;
300067cc:	e3a0e001 	mov	lr, #1
	if((INT32U)p_addr & 0x3) {
		
		p_addr =(INT8U*) (((INT32U)p_addr & 0xfffffffc) + 4);
	}
	
	p_mem = OSMemCreate(p_addr,  /* start address */
300067d0:	e1a00004 	mov	r0, r4
300067d4:	e3a0101e 	mov	r1, #30
300067d8:	e3a02020 	mov	r2, #32
300067dc:	e28d3007 	add	r3, sp, #7
	if(1 == test_switch) {

		return;
	}

	test_switch = 1;
300067e0:	e58ce000 	str	lr, [ip]
	if((INT32U)p_addr & 0x3) {
		
		p_addr =(INT8U*) (((INT32U)p_addr & 0xfffffffc) + 4);
	}
	
	p_mem = OSMemCreate(p_addr,  /* start address */
300067e4:	ebffedf2 	bl	30001fb4 <OSMemCreate>
				30,  /* block number */
				32,  /* block size*/
				&err /* error point  */
			);

	if(0 == p_mem) {
300067e8:	e3500000 	cmp	r0, #0
	if((INT32U)p_addr & 0x3) {
		
		p_addr =(INT8U*) (((INT32U)p_addr & 0xfffffffc) + 4);
	}
	
	p_mem = OSMemCreate(p_addr,  /* start address */
300067ec:	e5840400 	str	r0, [r4, #1024]	; 0x400
				30,  /* block number */
				32,  /* block size*/
				&err /* error point  */
			);

	if(0 == p_mem) {
300067f0:	0a000007 	beq	30006814 <test_m+0x64>

		printk("error in OSMemCreate \n");
	}


	OSTaskCreate( test_task1, 0, &stk1[STK_LEN -1], 5);
300067f4:	e59f002c 	ldr	r0, [pc, #44]	; 30006828 <test_m+0x78>
300067f8:	e3a01000 	mov	r1, #0
300067fc:	e59f2028 	ldr	r2, [pc, #40]	; 3000682c <test_m+0x7c>
30006800:	e3a03005 	mov	r3, #5
30006804:	ebfff310 	bl	3000344c <OSTaskCreate>

}
30006808:	e28dd008 	add	sp, sp, #8
3000680c:	e8bd4010 	pop	{r4, lr}
30006810:	e12fff1e 	bx	lr
				&err /* error point  */
			);

	if(0 == p_mem) {

		printk("error in OSMemCreate \n");
30006814:	e59f0014 	ldr	r0, [pc, #20]	; 30006830 <test_m+0x80>
30006818:	ebffe83e 	bl	30000918 <printk>
3000681c:	eafffff4 	b	300067f4 <test_m+0x44>
30006820:	30006ea0 	andcc	r6, r0, r0, lsr #29
30006824:	3001bed8 	ldrdcc	fp, [r1], -r8
30006828:	30006834 	andcc	r6, r0, r4, lsr r8
3000682c:	3001c6d8 	ldrdcc	ip, [r1], -r8
30006830:	30006e1c 	andcc	r6, r0, ip, lsl lr

30006834 <test_task1>:

static INT8U buffer[1024];


static void test_task1(void* p_arg)
{
30006834:	e92d4070 	push	{r4, r5, r6, lr}
30006838:	e24dd008 	sub	sp, sp, #8
3000683c:	e59f6044 	ldr	r6, [pc, #68]	; 30006888 <test_task1+0x54>
30006840:	e3a04000 	mov	r4, #0
30006844:	e28d5007 	add	r5, sp, #7
30006848:	ea000006 	b	30006868 <test_task1+0x34>
	
		p_data = OSMemGet(p_mem, &err);	
		
		if(0 != p_data) {

			count ++;
3000684c:	e2844001 	add	r4, r4, #1
30006850:	e20440ff 	and	r4, r4, #255	; 0xff

			printk("get %d block memory\n", count);
30006854:	e1a01004 	mov	r1, r4
30006858:	e59f002c 	ldr	r0, [pc, #44]	; 3000688c <test_task1+0x58>
3000685c:	ebffe82d 	bl	30000918 <printk>
		}else {

			printk("no memory now\n");
		}

		OSTimeDly(15);
30006860:	e3a0000f 	mov	r0, #15
30006864:	ebfff0ab 	bl	30002b18 <OSTimeDly>

	p_arg = p_arg;

	while(1) {
	
		p_data = OSMemGet(p_mem, &err);	
30006868:	e1a01005 	mov	r1, r5
3000686c:	e5960400 	ldr	r0, [r6, #1024]	; 0x400
30006870:	ebffedb1 	bl	30001f3c <OSMemGet>
		
		if(0 != p_data) {
30006874:	e3500000 	cmp	r0, #0
30006878:	1afffff3 	bne	3000684c <test_task1+0x18>
			count ++;

			printk("get %d block memory\n", count);
		}else {

			printk("no memory now\n");
3000687c:	e59f000c 	ldr	r0, [pc, #12]	; 30006890 <test_task1+0x5c>
30006880:	ebffe824 	bl	30000918 <printk>
30006884:	eafffff5 	b	30006860 <test_task1+0x2c>
30006888:	3001bed8 	ldrdcc	fp, [r1], -r8
3000688c:	30006e34 	andcc	r6, r0, r4, lsr lr
30006890:	30006e4c 	andcc	r6, r0, ip, asr #28

30006894 <OSTaskStkInit>:
{
        INT32U *stk;
        INT32U temp = (INT32U)(ptos);
        stk = (INT32U  *)temp;

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
30006894:	e1a03002 	mov	r3, r2
30006898:	e4030004 	str	r0, [r3], #-4


#include "ucos_ii.h"

OS_STK *OSTaskStkInit (void (*p_task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
{
3000689c:	e92d0ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp}
        INT32U temp = (INT32U)(ptos);
        stk = (INT32U  *)temp;

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
        *(--stk)  = (INT32U)0;             /* R12                                                */
300068a0:	e243a004 	sub	sl, r3, #4
        *(--stk)  = (INT32U)0;             /* R11                                                */
300068a4:	e24a8004 	sub	r8, sl, #4
        *(--stk)  = (INT32U)0;             /* R10                                                */
300068a8:	e2487004 	sub	r7, r8, #4
        *(--stk)  = (INT32U)0;             /* R9                                                 */
300068ac:	e2476004 	sub	r6, r7, #4
        *(--stk)  = (INT32U)0;             /* R8                                                 */
300068b0:	e2465004 	sub	r5, r6, #4
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
300068b4:	e2450004 	sub	r0, r5, #4
        *(--stk)  = (INT32U)0;             /* R6                                                 */
300068b8:	e2409004 	sub	r9, r0, #4


#include "ucos_ii.h"

OS_STK *OSTaskStkInit (void (*p_task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
{
300068bc:	e24dd018 	sub	sp, sp, #24
        *(--stk)  = (INT32U)0;             /* R10                                                */
        *(--stk)  = (INT32U)0;             /* R9                                                 */
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
300068c0:	e249b004 	sub	fp, r9, #4
        INT32U *stk;
        INT32U temp = (INT32U)(ptos);
        stk = (INT32U  *)temp;

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
300068c4:	e3a0c000 	mov	ip, #0
        *(--stk)  = (INT32U)0;             /* R9                                                 */
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
300068c8:	e24b4004 	sub	r4, fp, #4
        *(--stk)  = (INT32U)0;             /* R12                                                */
        *(--stk)  = (INT32U)0;             /* R11                                                */
        *(--stk)  = (INT32U)0;             /* R10                                                */
        *(--stk)  = (INT32U)0;             /* R9                                                 */
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
300068cc:	e58d0004 	str	r0, [sp, #4]
        INT32U *stk;
        INT32U temp = (INT32U)(ptos);
        stk = (INT32U  *)temp;

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
300068d0:	e502c004 	str	ip, [r2, #-4]
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
        *(--stk)  = (INT32U)0;             /* R3                                                 */
300068d4:	e2440004 	sub	r0, r4, #4
        INT32U temp = (INT32U)(ptos);
        stk = (INT32U  *)temp;

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
        *(--stk)  = (INT32U)0;             /* R12                                                */
300068d8:	e503c004 	str	ip, [r3, #-4]
        *(--stk)  = (INT32U)0;             /* R11                                                */
        *(--stk)  = (INT32U)0;             /* R10                                                */
        *(--stk)  = (INT32U)0;             /* R9                                                 */
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
300068dc:	e59d3004 	ldr	r3, [sp, #4]
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
300068e0:	e58d4014 	str	r4, [sp, #20]
        *(--stk)  = (INT32U)0;             /* R3                                                 */
300068e4:	e58d0010 	str	r0, [sp, #16]
        *(--stk)  = (INT32U)0;             /* R2                                                 */
300068e8:	e2404004 	sub	r4, r0, #4
        stk = (INT32U  *)temp;

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
        *(--stk)  = (INT32U)0;             /* R12                                                */
        *(--stk)  = (INT32U)0;             /* R11                                                */
300068ec:	e50ac004 	str	ip, [sl, #-4]
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
        *(--stk)  = (INT32U)0;             /* R3                                                 */
        *(--stk)  = (INT32U)0;             /* R2                                                 */
300068f0:	e58d400c 	str	r4, [sp, #12]

        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
        *(--stk)  = (INT32U)0;             /* R12                                                */
        *(--stk)  = (INT32U)0;             /* R11                                                */
        *(--stk)  = (INT32U)0;             /* R10                                                */
300068f4:	e508c004 	str	ip, [r8, #-4]
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
        *(--stk)  = (INT32U)0;             /* R3                                                 */
        *(--stk)  = (INT32U)0;             /* R2                                                 */
        *(--stk)  = (INT32U)0;             /* R1                                                 */
300068f8:	e2440004 	sub	r0, r4, #4
        *(stk)    = (INT32U)p_task;       /* Entry Point                                        */
        *(--stk)  = (INT32U)0;             /* LR                                                 */
        *(--stk)  = (INT32U)0;             /* R12                                                */
        *(--stk)  = (INT32U)0;             /* R11                                                */
        *(--stk)  = (INT32U)0;             /* R10                                                */
        *(--stk)  = (INT32U)0;             /* R9                                                 */
300068fc:	e507c004 	str	ip, [r7, #-4]
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
        *(--stk)  = (INT32U)0;             /* R3                                                 */
30006900:	e59d4014 	ldr	r4, [sp, #20]
        *(--stk)  = (INT32U)0;             /* LR                                                 */
        *(--stk)  = (INT32U)0;             /* R12                                                */
        *(--stk)  = (INT32U)0;             /* R11                                                */
        *(--stk)  = (INT32U)0;             /* R10                                                */
        *(--stk)  = (INT32U)0;             /* R9                                                 */
        *(--stk)  = (INT32U)0;             /* R8                                                 */
30006904:	e506c004 	str	ip, [r6, #-4]
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
30006908:	e505c004 	str	ip, [r5, #-4]
        *(--stk)  = (INT32U)0;             /* R6                                                 */
3000690c:	e503c004 	str	ip, [r3, #-4]
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
        *(--stk)  = (INT32U)0;             /* R3                                                 */
        *(--stk)  = (INT32U)0;             /* R2                                                 */
30006910:	e59d3010 	ldr	r3, [sp, #16]
        *(--stk)  = (INT32U)0;             /* R1                                                 */
30006914:	e58d0008 	str	r0, [sp, #8]
        *(--stk)  = (INT32U)0;             /* R10                                                */
        *(--stk)  = (INT32U)0;             /* R9                                                 */
        *(--stk)  = (INT32U)0;             /* R8                                                 */
        *(--stk)  = (INT32U)0;             /* R7 :                                               */
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
30006918:	e509c004 	str	ip, [r9, #-4]
        *(--stk)  = (INT32U)0;             /* R4                                                 */
3000691c:	e50bc004 	str	ip, [fp, #-4]
        *(--stk)  = (INT32U)0;             /* R3                                                 */
30006920:	e504c004 	str	ip, [r4, #-4]
        *(--stk)  = (INT32U)0;             /* R2                                                 */
30006924:	e503c004 	str	ip, [r3, #-4]
        *(--stk)  = (INT32U)0;             /* R1                                                 */
30006928:	e59d400c 	ldr	r4, [sp, #12]
        *(--stk)  = (INT32U)p_arg;         /* R0 argument                                        */
3000692c:	e59d3008 	ldr	r3, [sp, #8]
        *(--stk)  = (INT32U)0;             /* R6                                                 */
        *(--stk)  = (INT32U)0;             /* R5                                                 */
        *(--stk)  = (INT32U)0;             /* R4                                                 */
        *(--stk)  = (INT32U)0;             /* R3                                                 */
        *(--stk)  = (INT32U)0;             /* R2                                                 */
        *(--stk)  = (INT32U)0;             /* R1                                                 */
30006930:	e504c004 	str	ip, [r4, #-4]
        *(--stk)  = (INT32U)p_arg;         /* R0 argument                                        */
30006934:	e2400004 	sub	r0, r0, #4
30006938:	e5031004 	str	r1, [r3, #-4]
        *(--stk)  = (INT32U)0x00000013L;   /* CPSR                                               */
3000693c:	e3a03013 	mov	r3, #19
30006940:	e5003004 	str	r3, [r0, #-4]

        return stk;
}
30006944:	e2400004 	sub	r0, r0, #4
30006948:	e28dd018 	add	sp, sp, #24
3000694c:	e8bd0ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp}
30006950:	e12fff1e 	bx	lr

30006954 <OSTaskDelHook>:
{
	printk("task create here\n");
}

void OSTaskDelHook(OS_TCB* p_tcb)
{}
30006954:	e12fff1e 	bx	lr

30006958 <OSTaskIdleHook>:

void OSTaskIdleHook()
{}
30006958:	e12fff1e 	bx	lr

3000695c <OSTimeTickHook>:

void OSTimeTickHook()
{}
3000695c:	e12fff1e 	bx	lr

30006960 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB* p_tcb)
{}
30006960:	e12fff1e 	bx	lr

30006964 <OSInitHookBegin>:

void OSInitHookBegin()
{}
30006964:	e12fff1e 	bx	lr

30006968 <OSInitHookEnd>:

void OSInitHookEnd()
{}
30006968:	e12fff1e 	bx	lr

3000696c <OSTaskStatHook>:

void OSTaskStatHook()
{}
3000696c:	e12fff1e 	bx	lr

30006970 <OSTaskSwHook>:

void OSTaskSwHook()
{}
30006970:	e12fff1e 	bx	lr

30006974 <OSTaskCreateHook>:

        return stk;
}

void OSTaskCreateHook(OS_TCB* p_tcb )
{
30006974:	e92d4010 	push	{r4, lr}
	printk("task create here\n");
30006978:	e59f0008 	ldr	r0, [pc, #8]	; 30006988 <OSTaskCreateHook+0x14>
3000697c:	ebffe7e5 	bl	30000918 <printk>
}
30006980:	e8bd4010 	pop	{r4, lr}
30006984:	e12fff1e 	bx	lr
30006988:	30006e5c 	andcc	r6, r0, ip, asr lr

3000698c <__aeabi_uidiv>:
3000698c:	e2512001 	subs	r2, r1, #1
30006990:	012fff1e 	bxeq	lr
30006994:	3a000036 	bcc	30006a74 <__aeabi_uidiv+0xe8>
30006998:	e1500001 	cmp	r0, r1
3000699c:	9a000022 	bls	30006a2c <__aeabi_uidiv+0xa0>
300069a0:	e1110002 	tst	r1, r2
300069a4:	0a000023 	beq	30006a38 <__aeabi_uidiv+0xac>
300069a8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
300069ac:	01a01181 	lsleq	r1, r1, #3
300069b0:	03a03008 	moveq	r3, #8
300069b4:	13a03001 	movne	r3, #1
300069b8:	e3510201 	cmp	r1, #268435456	; 0x10000000
300069bc:	31510000 	cmpcc	r1, r0
300069c0:	31a01201 	lslcc	r1, r1, #4
300069c4:	31a03203 	lslcc	r3, r3, #4
300069c8:	3afffffa 	bcc	300069b8 <__aeabi_uidiv+0x2c>
300069cc:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
300069d0:	31510000 	cmpcc	r1, r0
300069d4:	31a01081 	lslcc	r1, r1, #1
300069d8:	31a03083 	lslcc	r3, r3, #1
300069dc:	3afffffa 	bcc	300069cc <__aeabi_uidiv+0x40>
300069e0:	e3a02000 	mov	r2, #0
300069e4:	e1500001 	cmp	r0, r1
300069e8:	20400001 	subcs	r0, r0, r1
300069ec:	21822003 	orrcs	r2, r2, r3
300069f0:	e15000a1 	cmp	r0, r1, lsr #1
300069f4:	204000a1 	subcs	r0, r0, r1, lsr #1
300069f8:	218220a3 	orrcs	r2, r2, r3, lsr #1
300069fc:	e1500121 	cmp	r0, r1, lsr #2
30006a00:	20400121 	subcs	r0, r0, r1, lsr #2
30006a04:	21822123 	orrcs	r2, r2, r3, lsr #2
30006a08:	e15001a1 	cmp	r0, r1, lsr #3
30006a0c:	204001a1 	subcs	r0, r0, r1, lsr #3
30006a10:	218221a3 	orrcs	r2, r2, r3, lsr #3
30006a14:	e3500000 	cmp	r0, #0
30006a18:	11b03223 	lsrsne	r3, r3, #4
30006a1c:	11a01221 	lsrne	r1, r1, #4
30006a20:	1affffef 	bne	300069e4 <__aeabi_uidiv+0x58>
30006a24:	e1a00002 	mov	r0, r2
30006a28:	e12fff1e 	bx	lr
30006a2c:	03a00001 	moveq	r0, #1
30006a30:	13a00000 	movne	r0, #0
30006a34:	e12fff1e 	bx	lr
30006a38:	e3510801 	cmp	r1, #65536	; 0x10000
30006a3c:	21a01821 	lsrcs	r1, r1, #16
30006a40:	23a02010 	movcs	r2, #16
30006a44:	33a02000 	movcc	r2, #0
30006a48:	e3510c01 	cmp	r1, #256	; 0x100
30006a4c:	21a01421 	lsrcs	r1, r1, #8
30006a50:	22822008 	addcs	r2, r2, #8
30006a54:	e3510010 	cmp	r1, #16
30006a58:	21a01221 	lsrcs	r1, r1, #4
30006a5c:	22822004 	addcs	r2, r2, #4
30006a60:	e3510004 	cmp	r1, #4
30006a64:	82822003 	addhi	r2, r2, #3
30006a68:	908220a1 	addls	r2, r2, r1, lsr #1
30006a6c:	e1a00230 	lsr	r0, r0, r2
30006a70:	e12fff1e 	bx	lr
30006a74:	e52de008 	str	lr, [sp, #-8]!
30006a78:	eb000008 	bl	30006aa0 <__div0>
30006a7c:	e3a00000 	mov	r0, #0
30006a80:	e49de008 	ldr	lr, [sp], #8
30006a84:	e12fff1e 	bx	lr

30006a88 <__aeabi_uidivmod>:
30006a88:	e92d4003 	push	{r0, r1, lr}
30006a8c:	ebffffbe 	bl	3000698c <__aeabi_uidiv>
30006a90:	e8bd4006 	pop	{r1, r2, lr}
30006a94:	e0030092 	mul	r3, r2, r0
30006a98:	e0411003 	sub	r1, r1, r3
30006a9c:	e12fff1e 	bx	lr

30006aa0 <__div0>:
30006aa0:	e92d4002 	push	{r1, lr}
30006aa4:	e3a00008 	mov	r0, #8
30006aa8:	ebffe592 	bl	300000f8 <raise>
30006aac:	e8bd4002 	pop	{r1, lr}
30006ab0:	e12fff1e 	bx	lr

Disassembly of section .rodata:

30006ab4 <init>:
30006ab4:	300000b0 	strhcc	r0, [r0], -r0
30006ab8:	00000000 	andeq	r0, r0, r0

30006abc <OSUnMapTbl>:
30006abc:	00010000 	andeq	r0, r1, r0
30006ac0:	00010002 	andeq	r0, r1, r2
30006ac4:	00010003 	andeq	r0, r1, r3
30006ac8:	00010002 	andeq	r0, r1, r2
30006acc:	00010004 	andeq	r0, r1, r4
30006ad0:	00010002 	andeq	r0, r1, r2
30006ad4:	00010003 	andeq	r0, r1, r3
30006ad8:	00010002 	andeq	r0, r1, r2
30006adc:	00010005 	andeq	r0, r1, r5
30006ae0:	00010002 	andeq	r0, r1, r2
30006ae4:	00010003 	andeq	r0, r1, r3
30006ae8:	00010002 	andeq	r0, r1, r2
30006aec:	00010004 	andeq	r0, r1, r4
30006af0:	00010002 	andeq	r0, r1, r2
30006af4:	00010003 	andeq	r0, r1, r3
30006af8:	00010002 	andeq	r0, r1, r2
30006afc:	00010006 	andeq	r0, r1, r6
30006b00:	00010002 	andeq	r0, r1, r2
30006b04:	00010003 	andeq	r0, r1, r3
30006b08:	00010002 	andeq	r0, r1, r2
30006b0c:	00010004 	andeq	r0, r1, r4
30006b10:	00010002 	andeq	r0, r1, r2
30006b14:	00010003 	andeq	r0, r1, r3
30006b18:	00010002 	andeq	r0, r1, r2
30006b1c:	00010005 	andeq	r0, r1, r5
30006b20:	00010002 	andeq	r0, r1, r2
30006b24:	00010003 	andeq	r0, r1, r3
30006b28:	00010002 	andeq	r0, r1, r2
30006b2c:	00010004 	andeq	r0, r1, r4
30006b30:	00010002 	andeq	r0, r1, r2
30006b34:	00010003 	andeq	r0, r1, r3
30006b38:	00010002 	andeq	r0, r1, r2
30006b3c:	00010007 	andeq	r0, r1, r7
30006b40:	00010002 	andeq	r0, r1, r2
30006b44:	00010003 	andeq	r0, r1, r3
30006b48:	00010002 	andeq	r0, r1, r2
30006b4c:	00010004 	andeq	r0, r1, r4
30006b50:	00010002 	andeq	r0, r1, r2
30006b54:	00010003 	andeq	r0, r1, r3
30006b58:	00010002 	andeq	r0, r1, r2
30006b5c:	00010005 	andeq	r0, r1, r5
30006b60:	00010002 	andeq	r0, r1, r2
30006b64:	00010003 	andeq	r0, r1, r3
30006b68:	00010002 	andeq	r0, r1, r2
30006b6c:	00010004 	andeq	r0, r1, r4
30006b70:	00010002 	andeq	r0, r1, r2
30006b74:	00010003 	andeq	r0, r1, r3
30006b78:	00010002 	andeq	r0, r1, r2
30006b7c:	00010006 	andeq	r0, r1, r6
30006b80:	00010002 	andeq	r0, r1, r2
30006b84:	00010003 	andeq	r0, r1, r3
30006b88:	00010002 	andeq	r0, r1, r2
30006b8c:	00010004 	andeq	r0, r1, r4
30006b90:	00010002 	andeq	r0, r1, r2
30006b94:	00010003 	andeq	r0, r1, r3
30006b98:	00010002 	andeq	r0, r1, r2
30006b9c:	00010005 	andeq	r0, r1, r5
30006ba0:	00010002 	andeq	r0, r1, r2
30006ba4:	00010003 	andeq	r0, r1, r3
30006ba8:	00010002 	andeq	r0, r1, r2
30006bac:	00010004 	andeq	r0, r1, r4
30006bb0:	00010002 	andeq	r0, r1, r2
30006bb4:	00010003 	andeq	r0, r1, r3
30006bb8:	00010002 	andeq	r0, r1, r2

30006bbc <OSDebugEn>:
30006bbc:	00000001 	andeq	r0, r0, r1

30006bc0 <OSEndiannessTest>:
30006bc0:	12345678 	eorsne	r5, r4, #125829120	; 0x7800000

30006bc4 <OSEventEn>:
30006bc4:	000a0001 	andeq	r0, sl, r1

30006bc6 <OSEventMax>:
30006bc6:	0010000a 	andseq	r0, r0, sl

30006bc8 <OSEventNameSize>:
30006bc8:	00240010 	eoreq	r0, r4, r0, lsl r0

30006bca <OSEventSize>:
30006bca:	01680024 	cmneq	r8, r4, lsr #32

30006bcc <OSEventTblSize>:
30006bcc:	00010168 	andeq	r0, r1, r8, ror #2

30006bce <OSFlagEn>:
30006bce:	001c0001 	andseq	r0, ip, r1

30006bd0 <OSFlagGrpSize>:
30006bd0:	0014001c 	andseq	r0, r4, ip, lsl r0

30006bd2 <OSFlagNodeSize>:
30006bd2:	00020014 	andeq	r0, r2, r4, lsl r0

30006bd4 <OSFlagWidth>:
30006bd4:	00050002 	andeq	r0, r5, r2

30006bd6 <OSFlagMax>:
30006bd6:	00100005 	andseq	r0, r0, r5

30006bd8 <OSFlagNameSize>:
30006bd8:	003f0010 	eorseq	r0, pc, r0, lsl r0

30006bda <OSLowestPrio>:
30006bda:	0001003f 	andeq	r0, r1, pc, lsr r0

30006bdc <OSMboxEn>:
30006bdc:	00010001 	andeq	r0, r1, r1

30006bde <OSMemEn>:
30006bde:	00050001 	andeq	r0, r5, r1

30006be0 <OSMemMax>:
30006be0:	00100005 	andseq	r0, r0, r5

30006be2 <OSMemNameSize>:
30006be2:	00240010 	eoreq	r0, r4, r0, lsl r0

30006be4 <OSMemSize>:
30006be4:	00b40024 	adcseq	r0, r4, r4, lsr #32

30006be6 <OSMemTblSize>:
30006be6:	000100b4 	strheq	r0, [r1], -r4

30006be8 <OSMutexEn>:
30006be8:	00040001 	andeq	r0, r4, r1

30006bea <OSPtrSize>:
30006bea:	00010004 	andeq	r0, r1, r4

30006bec <OSQEn>:
30006bec:	00040001 	andeq	r0, r4, r1

30006bee <OSQMax>:
30006bee:	00180004 	andseq	r0, r8, r4

30006bf0 <OSQSize>:
30006bf0:	00080018 	andeq	r0, r8, r8, lsl r0

30006bf2 <OSRdyTblSize>:
30006bf2:	00010008 	andeq	r0, r1, r8

30006bf4 <OSSemEn>:
30006bf4:	00040001 	andeq	r0, r4, r1

30006bf6 <OSStkWidth>:
30006bf6:	00010004 	andeq	r0, r1, r4

30006bf8 <OSTaskCreateEn>:
30006bf8:	00010001 	andeq	r0, r1, r1

30006bfa <OSTaskCreateExtEn>:
30006bfa:	00010001 	andeq	r0, r1, r1

30006bfc <OSTaskDelEn>:
30006bfc:	00800001 	addeq	r0, r0, r1

30006bfe <OSTaskIdleStkSize>:
30006bfe:	00010080 	andeq	r0, r1, r0, lsl #1

30006c00 <OSTaskProfileEn>:
30006c00:	00160001 	andseq	r0, r6, r1

30006c02 <OSTaskMax>:
30006c02:	00100016 	andseq	r0, r0, r6, lsl r0

30006c04 <OSTaskNameSize>:
30006c04:	00010010 	andeq	r0, r1, r0, lsl r0

30006c06 <OSTaskStatEn>:
30006c06:	00800001 	addeq	r0, r0, r1

30006c08 <OSTaskStatStkSize>:
30006c08:	00010080 	andeq	r0, r1, r0, lsl #1

30006c0a <OSTaskStatStkChkEn>:
30006c0a:	00010001 	andeq	r0, r1, r1

30006c0c <OSTaskSwHookEn>:
30006c0c:	00400001 	subeq	r0, r0, r1

30006c0e <OSTCBPrioTblMax>:
30006c0e:	00580040 	subseq	r0, r8, r0, asr #32

30006c10 <OSTCBSize>:
30006c10:	00640058 	rsbeq	r0, r4, r8, asr r0

30006c12 <OSTicksPerSec>:
30006c12:	00010064 	andeq	r0, r1, r4, rrx

30006c14 <OSTimeTickHookEn>:
30006c14:	011b0001 	tsteq	fp, r1

30006c16 <OSVersionNbr>:
30006c16:	0001011b 	andeq	r0, r1, fp, lsl r1

30006c18 <OSTmrEn>:
30006c18:	00100001 	andseq	r0, r0, r1

30006c1a <OSTmrCfgMax>:
30006c1a:	00100010 	andseq	r0, r0, r0, lsl r0

30006c1c <OSTmrCfgNameSize>:
30006c1c:	00080010 	andeq	r0, r8, r0, lsl r0

30006c1e <OSTmrCfgWheelSize>:
30006c1e:	00640008 	rsbeq	r0, r4, r8

30006c20 <OSTmrCfgTicksPerSec>:
30006c20:	00340064 	eorseq	r0, r4, r4, rrx

30006c22 <OSTmrSize>:
30006c22:	03400034 	movteq	r0, #52	; 0x34

30006c24 <OSTmrTblSize>:
30006c24:	00080340 	andeq	r0, r8, r0, asr #6

30006c26 <OSTmrWheelSize>:
30006c26:	00400008 	subeq	r0, r0, r8

30006c28 <OSTmrWheelTblSize>:
30006c28:	15720040 	ldrbne	r0, [r2, #-64]!	; 0x40

30006c2a <OSDataSize>:
30006c2a:	Address 0x30006c2a is out of bounds.


Disassembly of section .rodata.str1.4:

30006c2c <.rodata.str1.4>:
30006c2c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	; 0xfffffe60
30006c30:	726f776f 	rsbvc	r7, pc, #29097984	; 0x1bc0000
30006c34:	000a646c 	andeq	r6, sl, ip, ror #8
30006c38:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
30006c3c:	756d6d5f 	strbvc	r6, [sp, #-3423]!	; 0xd5f
30006c40:	0000000a 	andeq	r0, r0, sl
30006c44:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
30006c48:	20676e69 	rsbcs	r6, r7, r9, ror #28
30006c4c:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
30006c50:	000a6b74 	andeq	r6, sl, r4, ror fp
30006c54:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
30006c58:	72747320 	rsbsvc	r7, r4, #-2147483648	; 0x80000000
30006c5c:	20676e69 	rsbcs	r6, r7, r9, ror #28
30006c60:	093a3a3a 	ldmdbeq	sl!, {r1, r3, r4, r5, r9, fp, ip, sp}
30006c64:	740a7325 	strvc	r7, [sl], #-805	; 0x325
30006c68:	20747365 	rsbscs	r7, r4, r5, ror #6
30006c6c:	72616863 	rsbvc	r6, r1, #6488064	; 0x630000
30006c70:	3a3a3a20 	bcc	30e954f8 <_SVC_STACK+0x6954fc>
30006c74:	0a632520 	beq	318d00fc <_SVC_STACK+0x10d0100>
30006c78:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
30006c7c:	67696420 	strbvs	r6, [r9, -r0, lsr #8]!
30006c80:	3a207469 	bcc	30823e2c <_SVC_STACK+0x23e30>
30006c84:	25203a3a 	strcs	r3, [r0, #-2618]!	; 0xa3a
30006c88:	65740a64 	ldrbvs	r0, [r4, #-2660]!	; 0xa64
30006c8c:	58207473 	stmdapl	r0!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
30006c90:	3a3a3a20 	bcc	30e95518 <_SVC_STACK+0x69551c>
30006c94:	0a782520 	beq	31e1011c <_SVC_STACK+0x1610120>
30006c98:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
30006c9c:	736e7520 	cmnvc	lr, #134217728	; 0x8000000
30006ca0:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
30006ca4:	3a3a2064 	bcc	30e8ee3c <_SVC_STACK+0x68ee40>
30006ca8:	7525203a 	strvc	r2, [r5, #-58]!	; 0x3a
30006cac:	7365740a 	cmnvc	r5, #167772160	; 0xa000000
30006cb0:	657a2074 	ldrbvs	r2, [sl, #-116]!	; 0x74
30006cb4:	3a206f72 	bcc	30822a84 <_SVC_STACK+0x22a88>
30006cb8:	25203a3a 	strcs	r3, [r0, #-2618]!	; 0xa3a
30006cbc:	00000a64 	andeq	r0, r0, r4, ror #20
30006cc0:	73696874 	cmnvc	r9, #7602176	; 0x740000
30006cc4:	20736920 	rsbscs	r6, r3, r0, lsr #18
30006cc8:	74207325 	strtvc	r7, [r0], #-805	; 0x325
30006ccc:	00747365 	rsbseq	r7, r4, r5, ror #6
30006cd0:	33323130 	teqcc	r2, #12
30006cd4:	37363534 	undefined instruction 0x37363534
30006cd8:	62613938 	rsbvs	r3, r1, #917504	; 0xe0000
30006cdc:	66656463 	strbtvs	r6, [r5], -r3, ror #8
30006ce0:	00000000 	andeq	r0, r0, r0
30006ce4:	542d534f 	strtpl	r5, [sp], #-847	; 0x34f
30006ce8:	6f4c726d 	svcvs	0x004c726d
30006cec:	00006b63 	andeq	r6, r0, r3, ror #22
30006cf0:	542d534f 	strtpl	r5, [sp], #-847	; 0x34f
30006cf4:	6953726d 	ldmdbvs	r3, {r0, r2, r3, r5, r6, r9, ip, sp, lr}^
30006cf8:	00000067 	andeq	r0, r0, r7, rrx
30006cfc:	4f2f4375 	svcmi	0x002f4375
30006d00:	49492d53 	stmdbmi	r9, {r0, r1, r4, r6, r8, sl, fp, sp}^
30006d04:	726d5420 	rsbvc	r5, sp, #536870912	; 0x20000000
30006d08:	00000000 	andeq	r0, r0, r0
30006d0c:	4f2f4375 	svcmi	0x002f4375
30006d10:	49492d53 	stmdbmi	r9, {r0, r1, r4, r6, r8, sl, fp, sp}^
30006d14:	6c644920 	stclvs	9, cr4, [r4], #-128	; 0xffffff80
30006d18:	00000065 	andeq	r0, r0, r5, rrx
30006d1c:	4f2f4375 	svcmi	0x002f4375
30006d20:	49492d53 	stmdbmi	r9, {r0, r1, r4, r6, r8, sl, fp, sp}^
30006d24:	61745320 	cmnvs	r4, r0, lsr #6
30006d28:	00000074 	andeq	r0, r0, r4, ror r0
30006d2c:	00002063 	andeq	r2, r0, r3, rrx
30006d30:	00002062 	andeq	r2, r0, r2, rrx
30006d34:	00002061 	andeq	r2, r0, r1, rrx
30006d38:	6f727265 	svcvs	0x00727265
30006d3c:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006d40:	53534f20 	cmppl	r3, #128	; 0x80
30006d44:	72436d65 	subvc	r6, r3, #6464	; 0x1940
30006d48:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
30006d4c:	0000000a 	andeq	r0, r0, sl
30006d50:	65766967 	ldrbvs	r6, [r6, #-2407]!	; 0x967
30006d54:	00000020 	andeq	r0, r0, r0, lsr #32
30006d58:	20746567 	rsbscs	r6, r4, r7, ror #10
30006d5c:	00000000 	andeq	r0, r0, r0
30006d60:	6f727265 	svcvs	0x00727265
30006d64:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006d68:	4d534f20 	ldclmi	15, cr4, [r3, #-128]	; 0xffffff80
30006d6c:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
30006d70:	61657243 	cmnvs	r5, r3, asr #4
30006d74:	000a6574 	andeq	r6, sl, r4, ror r5
30006d78:	646f7270 	strbtvs	r7, [pc], #624	; 30006d80 <OSDataSize+0x156>
30006d7c:	20656375 	rsbcs	r6, r5, r5, ror r3
30006d80:	00000000 	andeq	r0, r0, r0
30006d84:	736e6f63 	cmnvc	lr, #396	; 0x18c
30006d88:	20656d75 	rsbcs	r6, r5, r5, ror sp
30006d8c:	00000000 	andeq	r0, r0, r0
30006d90:	6f727265 	svcvs	0x00727265
30006d94:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006d98:	4d534f20 	ldclmi	15, cr4, [r3, #-128]	; 0xffffff80
30006d9c:	43786f62 	cmnmi	r8, #392	; 0x188
30006da0:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
30006da4:	00000a65 	andeq	r0, r0, r5, ror #20
30006da8:	646e6573 	strbtvs	r6, [lr], #-1395	; 0x573
30006dac:	20642520 	rsbcs	r2, r4, r0, lsr #10
30006db0:	00000000 	andeq	r0, r0, r0
30006db4:	65636572 	strbvs	r6, [r3, #-1394]!	; 0x572
30006db8:	20657669 	rsbcs	r7, r5, r9, ror #12
30006dbc:	00206425 	eoreq	r6, r0, r5, lsr #8
30006dc0:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0x974
30006dc4:	00003172 	andeq	r3, r0, r2, ror r1
30006dc8:	6f727265 	svcvs	0x00727265
30006dcc:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006dd0:	54534f20 	ldrbpl	r4, [r3], #-3872	; 0xf20
30006dd4:	7243726d 	subvc	r7, r3, #-805306362	; 0xd0000006
30006dd8:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
30006ddc:	0000000a 	andeq	r0, r0, sl
30006de0:	6f727265 	svcvs	0x00727265
30006de4:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006de8:	54534f20 	ldrbpl	r4, [r3], #-3872	; 0xf20
30006dec:	7453726d 	ldrbvc	r7, [r3], #-621	; 0x26d
30006df0:	00747261 	rsbseq	r7, r4, r1, ror #4
30006df4:	6f727265 	svcvs	0x00727265
30006df8:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006dfc:	51534f20 	cmppl	r3, r0, lsr #30
30006e00:	61657243 	cmnvs	r5, r3, asr #4
30006e04:	000a6574 	andeq	r6, sl, r4, ror r5
30006e08:	20746567 	rsbscs	r6, r4, r7, ror #10
30006e0c:	00206425 	eoreq	r6, r0, r5, lsr #8
30006e10:	65766967 	ldrbvs	r6, [r6, #-2407]!	; 0x967
30006e14:	20642520 	rsbcs	r2, r4, r0, lsr #10
30006e18:	00000000 	andeq	r0, r0, r0
30006e1c:	6f727265 	svcvs	0x00727265
30006e20:	6e692072 	mcrvs	0, 3, r2, cr9, cr2, {3}
30006e24:	4d534f20 	ldclmi	15, cr4, [r3, #-128]	; 0xffffff80
30006e28:	72436d65 	subvc	r6, r3, #6464	; 0x1940
30006e2c:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
30006e30:	00000a20 	andeq	r0, r0, r0, lsr #20
30006e34:	20746567 	rsbscs	r6, r4, r7, ror #10
30006e38:	62206425 	eorvs	r6, r0, #620756992	; 0x25000000
30006e3c:	6b636f6c 	blvs	318e2bf4 <_SVC_STACK+0x10e2bf8>
30006e40:	6d656d20 	stclvs	13, cr6, [r5, #-128]!	; 0xffffff80
30006e44:	0a79726f 	beq	31e63808 <_SVC_STACK+0x166380c>
30006e48:	00000000 	andeq	r0, r0, r0
30006e4c:	6d206f6e 	stcvs	15, cr6, [r0, #-440]!	; 0xfffffe48
30006e50:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
30006e54:	6f6e2079 	svcvs	0x006e2079
30006e58:	00000a77 	andeq	r0, r0, r7, ror sl
30006e5c:	6b736174 	blvs	31cdf434 <_SVC_STACK+0x14df438>
30006e60:	65726320 	ldrbvs	r6, [r2, #-800]!	; 0x320
30006e64:	20657461 	rsbcs	r7, r5, r1, ror #8
30006e68:	65726568 	ldrbvs	r6, [r2, #-1384]!	; 0x568
30006e6c:	0000000a 	andeq	r0, r0, sl

Disassembly of section .data:

30006e80 <digits>:
30006e80:	30006cd0 	ldrdcc	r6, [r0], -r0

Disassembly of section .bss:

30006ea0 <test_switch>:
30006ea0:	00000000 	andeq	r0, r0, r0

30006ea4 <stk1>:
	...

30007ea4 <stk2>:
	...

30008ea4 <stk3>:
	...

30009ea4 <p_sem>:
30009ea4:	00000000 	andeq	r0, r0, r0

30009ea8 <stk1>:
	...

3000bea8 <stk2>:
	...

3000dea8 <p_mutex>:
3000dea8:	00000000 	andeq	r0, r0, r0

3000deac <stk1>:
	...

3000feac <stk2>:
	...

30011eac <p_mbox>:
30011eac:	00000000 	andeq	r0, r0, r0

30011eb0 <stk1>:
	...

30013eb0 <stk2>:
	...

30015eb0 <data>:
30015eb0:	00000000 	andeq	r0, r0, r0

30015eb4 <data.1779>:
30015eb4:	00000000 	andeq	r0, r0, r0

30015eb8 <p_tmr>:
30015eb8:	00000000 	andeq	r0, r0, r0

30015ebc <stk1>:
	...

30017ebc <queue>:
	...

30017ed0 <p_queue>:
30017ed0:	00000000 	andeq	r0, r0, r0

30017ed4 <stk1>:
	...

30019ed4 <stk2>:
	...

3001bed4 <data>:
3001bed4:	00000000 	andeq	r0, r0, r0

3001bed8 <buffer>:
	...

3001c2d8 <p_mem>:
3001c2d8:	00000000 	andeq	r0, r0, r0

3001c2dc <stk1>:
	...

3001c6dc <numbers>:
	...

3001c720 <OSTmrFreeList>:
3001c720:	00000000 	andeq	r0, r0, r0

3001c724 <OSTmrWheelTbl>:
	...

3001c764 <OSLockNesting>:
3001c764:	00000000 	andeq	r0, r0, r0

3001c768 <OSTmrSemSignal>:
3001c768:	00000000 	andeq	r0, r0, r0

3001c76c <OSRunning>:
3001c76c:	00000000 	andeq	r0, r0, r0

3001c770 <OSIdleCtr>:
3001c770:	00000000 	andeq	r0, r0, r0

3001c774 <OSTmrUsed>:
	...

3001c776 <OSPrioHighRdy>:
	...

3001c778 <OSFlagTbl>:
	...

3001c804 <OSTmrTbl>:
	...

3001cb44 <OSPrioCur>:
3001cb44:	00000000 	andeq	r0, r0, r0

3001cb48 <OSTCBList>:
3001cb48:	00000000 	andeq	r0, r0, r0

3001cb4c <OSTickStepState>:
3001cb4c:	00000000 	andeq	r0, r0, r0

3001cb50 <OSMemTbl>:
	...

3001cc04 <OSTaskStatStk>:
	...

3001ce04 <OSCtxSwCtr>:
3001ce04:	00000000 	andeq	r0, r0, r0

3001ce08 <OSTmrFree>:
3001ce08:	00000000 	andeq	r0, r0, r0

3001ce0c <OSIdleCtrMax>:
3001ce0c:	00000000 	andeq	r0, r0, r0

3001ce10 <OSTCBFreeList>:
3001ce10:	00000000 	andeq	r0, r0, r0

3001ce14 <OSCPUUsage>:
	...

3001ce15 <OSTaskCtr>:
3001ce15:	00000000 	andeq	r0, r0, r0

3001ce18 <OSMemFreeList>:
3001ce18:	00000000 	andeq	r0, r0, r0

3001ce1c <OSQTbl>:
	...

3001ce7c <OSTCBHighRdy>:
3001ce7c:	00000000 	andeq	r0, r0, r0

3001ce80 <OSQFreeList>:
3001ce80:	00000000 	andeq	r0, r0, r0

3001ce84 <OSRdyGrp>:
3001ce84:	00000000 	andeq	r0, r0, r0

3001ce88 <OSRdyTbl>:
	...

3001ce90 <OSTmrTaskStk>:
	...

3001d090 <OSEventFreeList>:
3001d090:	00000000 	andeq	r0, r0, r0

3001d094 <OSIntNesting>:
3001d094:	00000000 	andeq	r0, r0, r0

3001d098 <OSTCBCur>:
3001d098:	00000000 	andeq	r0, r0, r0

3001d09c <OSTmrTime>:
3001d09c:	00000000 	andeq	r0, r0, r0

3001d0a0 <OSTime>:
3001d0a0:	00000000 	andeq	r0, r0, r0

3001d0a4 <OSTmrSem>:
3001d0a4:	00000000 	andeq	r0, r0, r0

3001d0a8 <OSTaskIdleStk>:
	...

3001d2a8 <OSEventTbl>:
	...

3001d410 <OSTCBTbl>:
	...

3001dba0 <OSFlagFreeList>:
3001dba0:	00000000 	andeq	r0, r0, r0

3001dba4 <OSStatRdy>:
3001dba4:	00000000 	andeq	r0, r0, r0

3001dba8 <OSTCBPrioTbl>:
	...

3001dca8 <OSIdleCtrRun>:
3001dca8:	00000000 	andeq	r0, r0, r0

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002541 	andeq	r2, r0, r1, asr #10
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	0000001b 	andeq	r0, r0, fp, lsl r0
  10:	00543405 	subseq	r3, r4, r5, lsl #8
  14:	01080206 	tsteq	r8, r6, lsl #4
  18:	04120109 	ldreq	r0, [r2], #-265	; 0x109
  1c:	01150114 	tsteq	r5, r4, lsl r1
  20:	01180317 	tsteq	r8, r7, lsl r3
  24:	Address 0x00000024 is out of bounds.


Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <MEM_SIZE+0x8d0d24>
   4:	74632820 	strbtvc	r2, [r3], #-2080	; 0x820
   8:	312d676e 	teqcc	sp, lr, ror #14
   c:	312e362e 	teqcc	lr, lr, lsr #12
  10:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  14:	00332e34 	eorseq	r2, r3, r4, lsr lr

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000045 	andeq	r0, r0, r5, asr #32
       4:	001d0002 	andseq	r0, sp, r2
       8:	01020000 	tsteq	r2, r0
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	tsteq	r0, r0
      18:	00010000 	andeq	r0, r1, r0
      1c:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
      20:	0000732e 	andeq	r7, r0, lr, lsr #6
      24:	00000000 	andeq	r0, r0, r0
      28:	00400205 	subeq	r0, r0, r5, lsl #4
      2c:	1d033000 	stcne	0, cr3, [r3]
      30:	2f2f2f01 	svccs	0x002f2f01
      34:	2f2f2f2f 	svccs	0x002f2f2f
      38:	2f2f2f2f 	svccs	0x002f2f2f
      3c:	302f2f31 	eorcc	r2, pc, r1, lsr pc
      40:	312f2f2f 	teqcc	pc, pc, lsr #30
      44:	01001202 	tsteq	r0, r2, lsl #4
      48:	00003a01 	andeq	r3, r0, r1, lsl #20
      4c:	1e000200 	cdpne	2, 0, cr0, cr0, cr0, {0}
      50:	02000000 	andeq	r0, r0, #0
      54:	0d0efb01 	vstreq	d15, [lr, #-4]
      58:	01010100 	tsteq	r1, r0, lsl #2
      5c:	00000001 	andeq	r0, r0, r1
      60:	01000001 	tsteq	r0, r1
      64:	61747300 	cmnvs	r4, r0, lsl #6
      68:	732e7472 	teqvc	lr, #1912602624	; 0x72000000
      6c:	00000000 	andeq	r0, r0, r0
      70:	02050000 	andeq	r0, r5, #0
      74:	30000000 	andcc	r0, r0, r0
      78:	2f011203 	svccs	0x00011203
      7c:	2f2f2f2f 	svccs	0x002f2f2f
      80:	12022f2f 	andne	r2, r2, #188	; 0xbc
      84:	64010100 	strvs	r0, [r1], #-256	; 0x100
      88:	02000000 	andeq	r0, r0, #0
      8c:	00001d00 	andeq	r1, r0, r0, lsl #26
      90:	fb010200 	blx	4089a <DISABLE_IRQ+0x4081a>
      94:	01000d0e 	tsteq	r0, lr, lsl #26
      98:	00010101 	andeq	r0, r1, r1, lsl #2
      9c:	00010000 	andeq	r0, r1, r0
      a0:	62000100 	andvs	r0, r0, #0
      a4:	2e746f6f 	cdpcs	15, 7, cr6, cr4, cr15, {3}
      a8:	00000063 	andeq	r0, r0, r3, rrx
      ac:	05000000 	streq	r0, [r0]
      b0:	0000b002 	andeq	fp, r0, r2
      b4:	4d011a30 	vstrmi	s2, [r1, #-192]	; 0xffffff40
      b8:	014c6949 	cmpeq	ip, r9, asr #18
      bc:	5269494d 	rsbpl	r4, r9, #1261568	; 0x134000
      c0:	03183001 	tsteq	r8, #1
      c4:	4b344a7a 	blmi	d12ab4 <MEM_SIZE+0x512ab4>
      c8:	032e0903 	teqeq	lr, #49152	; 0xc000
      cc:	674b2e77 	smlsldxvs	r2, fp, r7, lr
      d0:	68674c68 	stmdavs	r7!, {r3, r5, r6, sl, fp, lr}^
      d4:	306a2f2f 	rsbcc	r2, sl, pc, lsr #30
      d8:	2f69494b 	svccs	0x0069494b
      dc:	49665803 	stmdbmi	r6!, {r0, r1, fp, ip, lr}^
      e0:	2f662b03 	svccs	0x00662b03
      e4:	2e090330 	mcrcs	3, 0, r0, cr9, cr0, {1}
      e8:	0a023030 	beq	8c1b0 <DISABLE_IRQ+0x8c130>
      ec:	58010100 	stmdapl	r1, {r8}
      f0:	02000000 	andeq	r0, r0, #0
      f4:	00002100 	andeq	r2, r0, r0, lsl #2
      f8:	fb010200 	blx	40902 <DISABLE_IRQ+0x40882>
      fc:	01000d0e 	tsteq	r0, lr, lsl #26
     100:	00010101 	andeq	r0, r1, r1, lsl #2
     104:	00010000 	andeq	r0, r1, r0
     108:	61000100 	tstvs	r0, r0, lsl #2
     10c:	726f6e62 	rsbvc	r6, pc, #1568	; 0x620
     110:	2e6c616d 	powcsez	f6, f4, #5.0
     114:	00000073 	andeq	r0, r0, r3, ror r0
     118:	05000000 	streq	r0, [r0]
     11c:	0001d802 	andeq	sp, r1, r2, lsl #16
     120:	012a0330 	teqeq	sl, r0, lsr r3
     124:	31313131 	teqcc	r1, r1, lsr r1
     128:	2f2f3432 	svccs	0x002f3432
     12c:	2f323230 	svccs	0x00323230
     130:	302f2f30 	eorcc	r2, pc, r0, lsr pc
     134:	2f2f2f30 	svccs	0x002f2f30
     138:	2f2f2f30 	svccs	0x002f2f30
     13c:	3030312f 	eorscc	r3, r0, pc, lsr #2
     140:	2f2f302f 	svccs	0x002f302f
     144:	06023033 	undefined instruction 0x06023033
     148:	59010100 	stmdbpl	r1, {r8}
     14c:	02000000 	andeq	r0, r0, #0
     150:	00001c00 	andeq	r1, r0, r0, lsl #24
     154:	fb010200 	blx	4095e <DISABLE_IRQ+0x408de>
     158:	01000d0e 	tsteq	r0, lr, lsl #26
     15c:	00010101 	andeq	r0, r1, r1, lsl #2
     160:	00010000 	andeq	r0, r1, r0
     164:	63000100 	movwvs	r0, #256	; 0x100
     168:	732e7570 	teqvc	lr, #469762048	; 0x1c000000
     16c:	00000000 	andeq	r0, r0, r0
     170:	02050000 	andeq	r0, r5, #0
     174:	3000026c 	andcc	r0, r0, ip, ror #4
     178:	2f011903 	svccs	0x00011903
     17c:	2f2f2f2f 	svccs	0x002f2f2f
     180:	2f322f2f 	svccs	0x00322f2f
     184:	2f2f3033 	svccs	0x002f3033
     188:	332f2f33 	teqcc	pc, #204	; 0xcc
     18c:	2f322f2f 	svccs	0x00322f2f
     190:	2f332f2f 	svccs	0x00332f2f
     194:	2f2f352f 	svccs	0x002f352f
     198:	2f2f342f 	svccs	0x002f342f
     19c:	2f2f342f 	svccs	0x002f342f
     1a0:	022f2f33 	eoreq	r2, pc, #204	; 0xcc
     1a4:	0101000c 	tsteq	r1, ip
     1a8:	00000075 	andeq	r0, r0, r5, ror r0
     1ac:	001c0002 	andseq	r0, ip, r2
     1b0:	01020000 	tsteq	r2, r0
     1b4:	000d0efb 	strdeq	r0, [sp], -fp
     1b8:	01010101 	tsteq	r1, r1, lsl #2
     1bc:	01000000 	tsteq	r0, r0
     1c0:	00010000 	andeq	r0, r1, r0
     1c4:	2e756d6d 	cdpcs	13, 7, cr6, cr5, cr13, {3}
     1c8:	00000063 	andeq	r0, r0, r3, rrx
     1cc:	05000000 	streq	r0, [r0]
     1d0:	00032402 	andeq	r2, r3, r2, lsl #8
     1d4:	01190330 	tsteq	r9, r0, lsr r3
     1d8:	080e0315 	stmdaeq	lr, {r0, r2, r4, r8, r9}
     1dc:	4d014c20 	stcmi	12, cr4, [r1, #-128]	; 0xffffff80
     1e0:	4c85014d 	stfmis	f0, [r5], {77}	; 0x4d
     1e4:	29343401 	ldmdbcs	r4!, {r0, sl, ip, sp}
     1e8:	2e79034f 	cdpcs	3, 7, cr0, cr9, cr15, {2}
     1ec:	79033330 	stmdbvc	r3, {r4, r5, r8, r9, ip, sp}
     1f0:	7903352e 	stmdbvc	r3, {r1, r2, r3, r5, r8, sl, ip, sp}
     1f4:	4a71032e 	bmi	1c40eb4 <MEM_SIZE+0x1440eb4>
     1f8:	034a1f03 	movteq	r1, #44803	; 0xaf03
     1fc:	4f304a79 	svcmi	0x00304a79
     200:	352e7903 	strcc	r7, [lr, #-2307]!	; 0x903
     204:	032e7903 	teqeq	lr, #49152	; 0xc000
     208:	45344a0a 	ldrmi	r4, [r4, #-2570]!	; 0xa0a
     20c:	2e79034f 	cdpcs	3, 7, cr0, cr9, cr15, {2}
     210:	79033330 	stmdbvc	r3, {r4, r5, r8, r9, ip, sp}
     214:	7903352e 	stmdbvc	r3, {r1, r2, r3, r5, r8, sl, ip, sp}
     218:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     21c:	01000202 	tsteq	r0, r2, lsl #4
     220:	00011001 	andeq	r1, r1, r1
     224:	2c000200 	sfmcs	f0, 4, [r0], {0}	; (stccs 2, cr0, [r0], {0})
     228:	02000000 	andeq	r0, r0, #0
     22c:	0d0efb01 	vstreq	d15, [lr, #-4]
     230:	01010100 	tsteq	r1, r0, lsl #2
     234:	00000001 	andeq	r0, r0, r1
     238:	01000001 	tsteq	r0, r1
     23c:	7000002e 	andvc	r0, r0, lr, lsr #32
     240:	746e6972 	strbtvc	r6, [lr], #-2418	; 0x972
     244:	0000632e 	andeq	r6, r0, lr, lsr #6
     248:	736f0000 	cmnvc	pc, #0
     24c:	7570635f 	ldrbvc	r6, [r0, #-863]!	; 0x35f
     250:	0100682e 	tsteq	r0, lr, lsr #16
     254:	00000000 	andeq	r0, r0, r0
     258:	04100205 	ldreq	r0, [r0], #-517	; 0x205
     25c:	ce033000 	cdpgt	0, 0, cr3, cr3, cr0, {0}
     260:	67010100 	strvs	r0, [r1, -r0, lsl #2]
     264:	4f304d65 	svcmi	0x00304d65
     268:	03303345 	teqeq	r0, #335544321	; 0x14000001
     26c:	03352e79 	teqeq	r5, #1936	; 0x790
     270:	6a516679 	bvs	1459c5c <MEM_SIZE+0xc59c5c>
     274:	4b2d2108 	blmi	b4869c <MEM_SIZE+0x34869c>
     278:	4e4d6831 	mcrmi	8, 2, r6, cr13, cr1, {1}
     27c:	032e6803 	teqeq	lr, #196608	; 0x30000
     280:	bd2f2e18 	stclt	14, cr2, [pc, #-96]!	; 0xffffffa0
     284:	72034d65 	andvc	r4, r3, #6464	; 0x1940
     288:	2d67bc82 	stclcs	12, cr11, [r7, #-520]!	; 0xfffffdf8
     28c:	039f844b 	orrseq	r8, pc, #1258291200	; 0x4b000000
     290:	4b15ba0a 	blmi	56eac0 <DISABLE_IRQ+0x56ea40>
     294:	6bb9672f 	blvs	fee59f58 <rEINTPEND+0xa8e59eb0>
     298:	4c4f494b 	mcrrmi	9, 4, r4, pc, cr11
     29c:	71036751 	tstvc	r3, r1, asr r7
     2a0:	03014c02 	movweq	r4, #7170	; 0x1c02
     2a4:	03834a11 	orreq	r4, r3, #69632	; 0x11000
     2a8:	03c12e18 	biceq	r2, r1, #384	; 0x180
     2ac:	32832e64 	addcc	r2, r3, #1600	; 0x640
     2b0:	2e0b03bb 	mcrcs	3, 0, r0, cr11, cr11, {5}
     2b4:	2e7903bb 	mrccs	3, 3, r0, cr9, cr11, {5}
     2b8:	2e1903bb 	mrccs	3, 0, r0, cr9, cr11, {5}
     2bc:	2b4d2b4a 	blcs	134afec <MEM_SIZE+0xb4afec>
     2c0:	292e0a03 	stmdbcs	lr!, {r0, r1, r9, fp}
     2c4:	034d322c 	movteq	r3, #53804	; 0xd22c
     2c8:	032b2e79 	teqeq	fp, #1936	; 0x790
     2cc:	69312e0a 	ldmdbvs	r1!, {r1, r3, r9, sl, fp, sp}
     2d0:	4d4c312b 	stfmie	f3, [ip, #-172]	; 0xffffff54
     2d4:	827f8503 	rsbshi	r8, pc, #12582912	; 0xc00000
     2d8:	fd036567 	stc2	5, cr6, [r3, #-412]	; 0xfffffe64
     2dc:	77034a00 	strvc	r4, [r3, -r0, lsl #20]
     2e0:	2e032a2e 	vmlacs.f32	s4, s6, s29
     2e4:	302f4b66 	eorcc	r4, pc, r6, ror #22
     2e8:	825a0331 	subshi	r0, sl, #-1006632960	; 0xc4000000
     2ec:	4c504f4c 	mrrcmi	15, 4, r4, r0, cr12
     2f0:	4c4c4c4c 	mcrrmi	12, 4, r4, ip, cr12
     2f4:	5903304d 	stmdbpl	r3, {r0, r2, r3, r6, ip, sp}
     2f8:	2e270366 	cdpcs	3, 2, cr0, cr7, cr6, {3}
     2fc:	2f4a6703 	svccs	0x004a6703
     300:	2e70032f 	cdpcs	3, 7, cr0, cr0, cr15, {1}
     304:	4d2e1103 	stfmis	f1, [lr, #-12]!
     308:	2df32f2d 	ldclcs	15, cr2, [r3, #180]!	; 0xb4
     30c:	034a6c03 	movteq	r6, #44035	; 0xac03
     310:	03804a23 	orreq	r4, r0, #143360	; 0x23000
     314:	2e827ed8 	mcrcs	14, 4, r7, cr2, cr8, {6}
     318:	499f304e 	ldmibmi	pc, {r1, r2, r3, r6, ip, sp}
     31c:	30862d4b 	addcc	r2, r6, fp, asr #26
     320:	4a01af03 	bmi	6bf34 <DISABLE_IRQ+0x6beb4>
     324:	312bbd6d 	teqcc	fp, sp, ror #26
     328:	2933852f 	ldmdbcs	r3!, {r0, r1, r2, r3, r5, r8, sl, pc}
     32c:	3d082f33 	stccc	15, cr2, [r8, #-204]	; 0xffffff34
     330:	01000c02 	tsteq	r0, r2, lsl #24
     334:	00004601 	andeq	r4, r0, r1, lsl #12
     338:	22000200 	andcs	r0, r0, #0
     33c:	02000000 	andeq	r0, r0, #0
     340:	0d0efb01 	vstreq	d15, [lr, #-4]
     344:	01010100 	tsteq	r1, r0, lsl #2
     348:	00000001 	andeq	r0, r0, r1
     34c:	01000001 	tsteq	r0, r1
     350:	746e6900 	strbtvc	r6, [lr], #-2304	; 0x900
     354:	75727265 	ldrbvc	r7, [r2, #-613]!	; 0x265
     358:	632e7470 	teqvs	lr, #1879048192	; 0x70000000
     35c:	00000000 	andeq	r0, r0, r0
     360:	02050000 	andeq	r0, r5, #0
     364:	300009a8 	andcc	r0, r0, r8, lsr #19
     368:	4c6c2f1a 	stclmi	15, cr2, [ip], #-104	; 0xffffff98
     36c:	134c6c2f 	movtne	r6, #52271	; 0xcc2f
     370:	8313309f 	tsthi	r3, #159	; 0x9f
     374:	694b302c 	stmdbvs	fp, {r2, r3, r5, ip, sp}^
     378:	04022f31 	streq	r2, [r2], #-3889	; 0xf31
     37c:	ab010100 	blge	40784 <DISABLE_IRQ+0x40704>
     380:	02000015 	andeq	r0, r0, #21
     384:	0000b900 	andeq	fp, r0, r0, lsl #18
     388:	fb010200 	blx	40b92 <DISABLE_IRQ+0x40b12>
     38c:	01000d0e 	tsteq	r0, lr, lsl #26
     390:	00010101 	andeq	r0, r1, r1, lsl #2
     394:	00010000 	andeq	r0, r1, r0
     398:	002e0100 	eoreq	r0, lr, r0, lsl #2
     39c:	5f736f00 	svcpl	0x00736f00
     3a0:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
     3a4:	0100632e 	tsteq	r0, lr, lsr #6
     3a8:	736f0000 	cmnvc	pc, #0
     3ac:	616c665f 	cmnvs	ip, pc, asr r6
     3b0:	00632e67 	rsbeq	r2, r3, r7, ror #28
     3b4:	6f000001 	svcvs	0x00000001
     3b8:	656d5f73 	strbvs	r5, [sp, #-3955]!	; 0xf73
     3bc:	00632e6d 	rsbeq	r2, r3, sp, ror #28
     3c0:	6f000001 	svcvs	0x00000001
     3c4:	2e715f73 	mrccs	15, 3, r5, cr1, cr3, {3}
     3c8:	00010063 	andeq	r0, r1, r3, rrx
     3cc:	5f736f00 	svcpl	0x00736f00
     3d0:	6b736174 	blvs	1cd89a8 <MEM_SIZE+0x14d89a8>
     3d4:	0100632e 	tsteq	r0, lr, lsr #6
     3d8:	736f0000 	cmnvc	pc, #0
     3dc:	726d745f 	rsbvc	r7, sp, #1593835520	; 0x5f000000
     3e0:	0100632e 	tsteq	r0, lr, lsr #6
     3e4:	736f0000 	cmnvc	pc, #0
     3e8:	6762645f 	undefined instruction 0x6762645f
     3ec:	632e725f 	teqvs	lr, #-268435451	; 0xf0000005
     3f0:	00000100 	andeq	r0, r0, r0, lsl #2
     3f4:	745f736f 	ldrbvc	r7, [pc], #879	; 3fc <DISABLE_IRQ+0x37c>
     3f8:	2e656d69 	cdpcs	13, 6, cr6, cr5, cr9, {3}
     3fc:	00010063 	andeq	r0, r1, r3, rrx
     400:	5f736f00 	svcpl	0x00736f00
     404:	2e6d6573 	mcrcs	5, 3, r6, cr13, cr3, {3}
     408:	00010063 	andeq	r0, r1, r3, rrx
     40c:	5f736f00 	svcpl	0x00736f00
     410:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0x56d
     414:	00632e78 	rsbeq	r2, r3, r8, ror lr
     418:	6f000001 	svcvs	0x00000001
     41c:	626d5f73 	rsbvs	r5, sp, #460	; 0x1cc
     420:	632e786f 	teqvs	lr, #7274496	; 0x6f0000
     424:	00000100 	andeq	r0, r0, r0, lsl #2
     428:	635f736f 	cmpvs	pc, #-1140850687	; 0xbc000001
     42c:	682e7570 	stmdavs	lr!, {r4, r5, r6, r8, sl, ip, sp, lr}
     430:	00000100 	andeq	r0, r0, r0, lsl #2
     434:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
     438:	2e69695f 	mcrcs	9, 3, r6, cr9, cr15, {2}
     43c:	00010068 	andeq	r0, r1, r8, rrx
     440:	05000000 	streq	r0, [r0]
     444:	000a2c02 	andeq	r2, sl, r2, lsl #24
     448:	02aa0330 	adceq	r0, sl, #-1073741824	; 0xc0000000
     44c:	67831301 	strvs	r1, [r3, r1, lsl #6]
     450:	9e02b503 	cfsh32ls	mvfx11, mvfx2, #3
     454:	66110314 	undefined instruction 0x66110314
     458:	2e1b0313 	mrccs	3, 0, r0, cr11, cr3, {0}
     45c:	032e1003 	teqeq	lr, #3
     460:	10034a70 	andne	r4, r3, r0, ror sl
     464:	652f2f2e 	strvs	r2, [pc, #-3886]!	; fffff53e <rEINTPEND+0xa9fff496>
     468:	03302d2f 	teqeq	r0, #3008	; 0xbc0
     46c:	2f2f4a13 	svccs	0x002f4a13
     470:	034a6c03 	movteq	r6, #44035	; 0xac03
     474:	032a2e16 	teqeq	sl, #352	; 0x160
     478:	16032e6e 	strne	r2, [r3], -lr, ror #28
     47c:	03362f2e 	teqeq	r6, #184	; 0xb8
     480:	2f362e78 	svccs	0x00362e78
     484:	302e7803 	eorcc	r7, lr, r3, lsl #16
     488:	78032f32 	stmdavc	r3, {r1, r4, r5, r8, r9, sl, fp, sp}
     48c:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     490:	2f2d2f2f 	svccs	0x002d2f2f
     494:	32492f2d 	subcc	r2, r9, #180	; 0xb4
     498:	32ba1303 	adcscc	r1, sl, #201326592	; 0xc000000
     49c:	2c302c30 	ldccs	12, cr2, [r0], #-192	; 0xffffff40
     4a0:	302d6730 	eorcc	r6, sp, r0, lsr r7
     4a4:	4b2d9fa0 	blmi	b6832c <MEM_SIZE+0x36832c>
     4a8:	9e130367 	cdpls	3, 1, cr0, cr3, cr7, {3}
     4ac:	2fd74b16 	svccs	0x00d74b16
     4b0:	2f2c3084 	svccs	0x002c3084
     4b4:	4a120330 	bmi	48117c <DISABLE_IRQ+0x4810fc>
     4b8:	4b010903 	blmi	428cc <DISABLE_IRQ+0x4284c>
     4bc:	034d494d 	movteq	r4, #55629	; 0xd94d
     4c0:	132e02c5 	teqne	lr, #1342177292	; 0x5000000c
     4c4:	0365a148 	cmneq	r5, #18
     4c8:	4813661f 	ldmdami	r3, {r0, r1, r2, r3, r4, r9, sl, sp, lr}
     4cc:	f30365a1 	vrshl.u8	d6, d17, d19
     4d0:	29176600 	ldmdbcs	r7, {r9, sl, sp, lr}
     4d4:	302d8333 	eorcc	r8, sp, r3, lsr r3
     4d8:	322c302c 	eorcc	r3, ip, #44	; 0x2c
     4dc:	2e15034c 	cdpcs	3, 1, cr0, cr5, cr12, {2}
     4e0:	302cd817 	eorcc	sp, ip, r7, lsl r8
     4e4:	0204332c 	andeq	r3, r4, #-1342177280	; 0xb0000000
     4e8:	2e7d9703 	cdpcs	7, 7, cr9, cr13, cr3, {0}
     4ec:	2f332933 	svccs	0x00332933
     4f0:	4c2d2f2d 	stcmi	15, cr2, [sp], #-180	; 0xffffff4c
     4f4:	2e7a0335 	mrccs	3, 3, r0, cr10, cr5, {1}
     4f8:	2f303130 	svccs	0x00303130
     4fc:	7a032f2f 	bvc	cc1c0 <DISABLE_IRQ+0xcc140>
     500:	302f352e 	eorcc	r3, pc, lr, lsr #10
     504:	302d9f31 	eorcc	r9, sp, r1, lsr pc
     508:	9e1303a0 	cdpls	3, 1, cr0, cr3, cr0, {5}
     50c:	0301042e 	movweq	r0, #5166	; 0x142e
     510:	654a00fd 	strbvs	r0, [sl, #-253]	; 0xfd
     514:	83030204 	movwhi	r0, #12804	; 0x3204
     518:	17034a7f 	smlsdxne	r3, pc, sl, r4
     51c:	2e69032e 	cdpcs	3, 6, cr0, cr9, cr14, {1}
     520:	2b2e1a03 	blcs	b86d34 <MEM_SIZE+0x386d34>
     524:	312f304b 	teqcc	pc, fp, asr #32
     528:	032e7803 	teqeq	lr, #196608	; 0x30000
     52c:	294d4a0d 	stmdbcs	sp, {r0, r2, r3, r9, fp, lr}^
     530:	362a2c33 	undefined instruction 0x362a2c33
     534:	339e1b03 	orrscc	r1, lr, #3072	; 0xc00
     538:	302c3629 	eorcc	r3, ip, r9, lsr #12
     53c:	2f2b2d30 	svccs	0x002b2d30
     540:	674b302f 	strbvs	r3, [fp, -pc, lsr #32]
     544:	29034b2d 	stmdbcs	r3, {r0, r2, r3, r5, r8, r9, fp, lr}
     548:	522f2fba 	eorpl	r2, pc, #744	; 0x2e8
     54c:	332f2f2d 	teqcc	pc, #180	; 0xb4
     550:	03664e03 	cmneq	r6, #48	; 0x30
     554:	2d2f4a26 	vstmdbcs	pc!, {s8-s45}
     558:	8272032f 	rsbshi	r0, r2, #-1140850688	; 0xbc000000
     55c:	2f010903 	svccs	0x00010903
     560:	2f2d522f 	svccs	0x002d522f
     564:	0368332f 	cmneq	r8, #-1140850688	; 0xbc000000
     568:	2d2f2e72 	stccs	14, cr2, [pc, #-456]!	; 0xfffffe38
     56c:	0303042f 	movweq	r0, #13359	; 0x342f
     570:	2e4a7a98 	mcrcs	10, 2, r7, cr10, cr8, {4}
     574:	e9030104 	stmdb	r3, {r2, r8}
     578:	04654a05 	strbteq	r4, [r5], #-2565	; 0xa05
     57c:	7aac0303 	bvc	feb01190 <rEINTPEND+0xa8b010e8>
     580:	2e6b0366 	cdpcs	3, 6, cr0, cr11, cr6, {3}
     584:	2b2e1603 	blcs	b85d98 <MEM_SIZE+0x385d98>
     588:	32462f30 	subcc	r2, r6, #192	; 0xc0
     58c:	2e0a032a 	cdpcs	3, 0, cr0, cr10, cr10, {1}
     590:	2e7a034e 	cdpcs	3, 7, cr0, cr10, cr14, {2}
     594:	04332b34 	ldrteq	r2, [r3], #-2868	; 0xb34
     598:	02c20304 	sbceq	r0, r2, #268435456	; 0x10000000
     59c:	0104019e 	undefined instruction 0x0104019e
     5a0:	4a038603 	bmi	e1db4 <DISABLE_IRQ+0xe1d34>
     5a4:	042d2f65 	strteq	r2, [sp], #-3941	; 0xf65
     5a8:	7d8c0304 	stcvc	3, cr0, [ip, #16]
     5ac:	33294f2e 	teqcc	r9, #184	; 0xb8
     5b0:	322a4e29 	eorcc	r4, sl, #656	; 0x290
     5b4:	03050431 	movweq	r0, #21553	; 0x5431
     5b8:	136601ff 	cmnne	r6, #-1073741761	; 0xc000003f
     5bc:	2c684c4b 	stclcs	12, cr4, [r8], #-300	; 0xfffffed4
     5c0:	06044830 	undefined instruction 0x06044830
     5c4:	4a7fa503 	bmi	1fe99d8 <MEM_SIZE+0x17e99d8>
     5c8:	79032f18 	stmdbvc	r3, {r3, r4, r8, r9, sl, fp, sp}
     5cc:	312f342e 	teqcc	pc, lr, lsr #8
     5d0:	2c4ca467 	cfstrdcs	mvd10, [ip], {103}	; 0x67
     5d4:	2e090330 	mcrcs	3, 0, r0, cr9, cr0, {1}
     5d8:	332e7803 	teqcc	lr, #196608	; 0x30000
     5dc:	7a03342b 	bvc	cd690 <DISABLE_IRQ+0xcd610>
     5e0:	2b30342e 	blcs	c0d6a0 <MEM_SIZE+0x40d6a0>
     5e4:	332e7a03 	teqcc	lr, #12288	; 0x3000
     5e8:	6e032f32 	mcrvs	15, 0, r2, cr3, cr2, {1}
     5ec:	d624034a 	strtle	r0, [r4], -sl, asr #6
     5f0:	302c681a 	eorcc	r6, ip, sl, lsl r8
     5f4:	2d312d52 	ldccs	13, cr2, [r1, #-328]!	; 0xfffffeb8
     5f8:	2c4d3130 	stfcse	f3, [sp], {48}	; 0x30
     5fc:	2c2f2d30 	stccs	13, cr2, [pc], #-192	; 0xffffff40
     600:	2e6f0331 	mcrcs	3, 3, r0, cr15, cr1, {1}
     604:	04302d30 	ldrteq	r2, [r0], #-3376	; 0xd30
     608:	79ee0307 	stmibvc	lr!, {r0, r1, r2, r8, r9}^
     60c:	00c90382 	sbceq	r0, r9, r2, lsl #7
     610:	03080401 	movweq	r0, #33793	; 0x8401
     614:	352e2e51 	strcc	r2, [lr, #-3665]!	; 0xe51
     618:	032f4b2f 	teqeq	pc, #48128	; 0xbc00
     61c:	2f366659 	svccs	0x00366659
     620:	0504304b 	streq	r3, [r4, #-75]	; 0x4b
     624:	8205e303 	andhi	lr, r5, #201326592	; 0xc000000
     628:	03010903 	movweq	r0, #6403	; 0x1903
     62c:	032e2e77 	teqeq	lr, #1904	; 0x770
     630:	032f4a09 	teqeq	pc, #36864	; 0x9000
     634:	6b036619 	blvs	d9ea0 <DISABLE_IRQ+0xd9e20>
     638:	2f2f6a4a 	svccs	0x002f6a4a
     63c:	304e4b68 	subcc	r4, lr, r8, ror #22
     640:	0301042c 	movweq	r0, #5164	; 0x142c
     644:	652e01b2 	strvs	r0, [lr, #-434]!	; 0x1b2
     648:	d5030504 	strle	r0, [r3, #-1284]	; 0x504
     64c:	034b4a7e 	movteq	r4, #47742	; 0xba7e
     650:	314b2e76 	cmpcc	fp, r6, ror lr
     654:	7ec6034b 	cdpvc	3, 12, cr0, cr6, cr11, {2}
     658:	010c0366 	tsteq	ip, r6, ror #6
     65c:	2e2e7403 	cdpcs	4, 2, cr7, cr14, cr3, {0}
     660:	2f4a0c03 	svccs	0x004a0c03
     664:	03662b03 	cmneq	r6, #3072	; 0xc00
     668:	2f6a4a59 	svccs	0x006a4a59
     66c:	2f2f302d 	svccs	0x002f302d
     670:	4e4e4b68 	vmlsmi.f64	d20, d14, d24
     674:	4b294b67 	blmi	a53418 <MEM_SIZE+0x253418>
     678:	30302d36 	eorscc	r2, r0, r6, lsr sp
     67c:	09032d9f 	stmdbeq	r3, {r0, r1, r2, r3, r4, r7, r8, sl, fp, sp}
     680:	01048382 	smlabbeq	r4, r2, r3, r8
     684:	6604c903 	strvs	ip, [r4], -r3, lsl #18
     688:	03660a03 	cmneq	r6, #12288	; 0x3000
     68c:	65522e76 	ldrbvs	r2, [r2, #-3702]	; 0xe76
     690:	2f302c30 	svccs	0x00302c30
     694:	6a4d4b2f 	bvs	1353358 <MEM_SIZE+0xb53358>
     698:	7403322a 	strvc	r3, [r3], #-554	; 0x22a
     69c:	6612032e 	ldrvs	r0, [r2], -lr, lsr #6
     6a0:	de030504 	cfsh32le	mvfx0, mvfx3, #4
     6a4:	0a038279 	beq	e1090 <DISABLE_IRQ+0xe1010>
     6a8:	2e76032e 	cdpcs	3, 7, cr0, cr6, cr14, {1}
     6ac:	314a0a03 	cmpcc	sl, r3, lsl #20
     6b0:	03492f4b 	movteq	r2, #40779	; 0x9f4b
     6b4:	63032e22 	movwvs	r2, #15906	; 0x3e22
     6b8:	33492f4a 	movtcc	r2, #40778	; 0x9f4a
     6bc:	4b682f2f 	blmi	1a0c380 <MEM_SIZE+0x120c380>
     6c0:	0301044f 	movweq	r0, #5199	; 0x144f
     6c4:	044a04e8 	strbeq	r0, [sl], #-1256	; 0x4e8
     6c8:	7b9b0305 	blvc	fe6c12e4 <rEINTPEND+0xa86c123c>
     6cc:	0301044a 	movweq	r0, #5194	; 0x144a
     6d0:	4c4a04e5 	cfstrdmi	mvd0, [sl], {229}	; 0xe5
     6d4:	042c302c 	strteq	r3, [ip], #-44	; 0x2c
     6d8:	7b9e0305 	blvc	fe7812f4 <rEINTPEND+0xa878124c>
     6dc:	0429332e 	strteq	r3, [r9], #-814	; 0x32e
     6e0:	04c30301 	strbeq	r0, [r3], #769	; 0x301
     6e4:	046a2d2e 	strbteq	r2, [sl], #-3374	; 0xd2e
     6e8:	7bc00305 	blvc	ff001304 <rEINTPEND+0xa900125c>
     6ec:	7a032f4a 	bvc	cc41c <DISABLE_IRQ+0xcc39c>
     6f0:	034b2f4a 	movteq	r2, #48970	; 0xbf4a
     6f4:	4b2f2e78 	blmi	bcc0dc <MEM_SIZE+0x3cc0dc>
     6f8:	7f890336 	svcvc	0x00890336
     6fc:	2e0a0382 	cdpcs	3, 0, cr0, cr10, cr2, {4}
     700:	032e7603 	teqeq	lr, #3145728	; 0x300000
     704:	4b4d4a0a 	blmi	1352f34 <MEM_SIZE+0xb52f34>
     708:	1d03652f 	cfstr32ne	mvfx6, [r3, #-188]	; 0xffffff44
     70c:	6668032e 	strbtvs	r0, [r8], -lr, lsr #6
     710:	2f33652f 	svccs	0x0033652f
     714:	4f4b682f 	svcmi	0x004b682f
     718:	92030104 	andls	r0, r3, #1
     71c:	2dbb4a05 	ldccs	10, cr4, [fp, #20]!
     720:	2c302c30 	ldccs	12, cr2, [r0], #-192	; 0xffffff40
     724:	03050432 	movweq	r0, #21554	; 0x5432
     728:	2f4a7af0 	svccs	0x004a7af0
     72c:	2e74032f 	cdpcs	3, 7, cr0, cr4, cr15, {1}
     730:	2f314b2f 	svccs	0x00314b2f
     734:	7f990367 	svcvc	0x00990367
     738:	01090366 	tsteq	r9, r6, ror #6
     73c:	2e2e7703 	cdpcs	7, 2, cr7, cr14, cr3, {0}
     740:	4e2e0903 	cdpmi	9, 2, cr0, cr14, cr3, {0}
     744:	6618034b 	ldrvs	r0, [r8], -fp, asr #6
     748:	2f667303 	svccs	0x00667303
     74c:	4b4e4e4b 	blmi	1394080 <MEM_SIZE+0xb94080>
     750:	2e6f034b 	cdpcs	3, 6, cr0, cr15, cr11, {2}
     754:	032f672f 	teqeq	pc, #12320768	; 0xbc0000
     758:	294b2e09 	stmdbcs	fp, {r0, r3, r9, sl, fp, sp}^
     75c:	0309044b 	movweq	r0, #37963	; 0x944b
     760:	36667f9f 	uqadd8cc	r7, r6, pc
     764:	2e2e7803 	cdpcs	8, 2, cr7, cr14, cr3, {0}
     768:	492f3136 	stmdbmi	pc!, {r1, r2, r4, r5, r8, ip, sp}
     76c:	03494b33 	movteq	r4, #39731	; 0x9b33
     770:	74032e10 	strvc	r2, [r3], #-3600	; 0xe10
     774:	854b4b66 	strbhi	r4, [fp, #-2918]	; 0xb66
     778:	332f474d 	teqcc	pc, #20185088	; 0x1340000
     77c:	4a7f9f03 	bmi	1fe8390 <MEM_SIZE+0x17e8390>
     780:	032e1003 	teqeq	lr, #3
     784:	10032e70 	andne	r2, r3, r0, ror lr
     788:	036a4d2e 	cmneq	sl, #2944	; 0xb80
     78c:	7603820d 	strvc	r8, [r3], -sp, lsl #4
     790:	2d4b4b66 	vstrcs	d20, [fp, #-408]	; 0xfffffe68
     794:	4d654c30 	stclmi	12, cr4, [r5, #-192]!	; 0xffffff40
     798:	a7034b4b 	strge	r4, [r3, -fp, asr #22]
     79c:	03362e7d 	teqeq	r6, #2000	; 0x7d0
     7a0:	03362e78 	teqeq	r6, #1920	; 0x780
     7a4:	6f038214 	svcvs	0x00038214
     7a8:	4b4b2f66 	blmi	12cc548 <MEM_SIZE+0xacc548>
     7ac:	044e304c 	strbeq	r3, [lr], #-76	; 0x4c
     7b0:	05b90301 	ldreq	r0, [r9, #769]!	; 0x301
     7b4:	0309044a 	movweq	r0, #37962	; 0x944a
     7b8:	2f2e7ac4 	svccs	0x002e7ac4
     7bc:	03010431 	movweq	r0, #5169	; 0x1431
     7c0:	2f2e05b7 	svccs	0x002e05b7
     7c4:	09046531 	stmdbeq	r4, {r0, r4, r5, r8, sl, sp, lr}
     7c8:	667abf03 	ldrbtvs	fp, [sl], -r3, lsl #30
     7cc:	03824303 	orreq	r4, r2, #201326592	; 0xc000000
     7d0:	034e2e09 	movteq	r2, #60937	; 0xee09
     7d4:	032f6609 	teqeq	pc, #9437184	; 0x900000
     7d8:	2f2f6679 	svccs	0x002f6679
     7dc:	042f4c2f 	strteq	r4, [pc], #3119	; 7e4 <DISABLE_IRQ+0x764>
     7e0:	04ec0304 	strbteq	r0, [ip], #772	; 0x304
     7e4:	2e11032e 	cdpcs	3, 1, cr0, cr1, cr14, {1}
     7e8:	032e6f03 	teqeq	lr, #12
     7ec:	6a4d2e11 	bvs	134c038 <MEM_SIZE+0xb4c038>
     7f0:	03821403 	orreq	r1, r2, #50331648	; 0x3000000
     7f4:	4b4b666f 	blmi	12da1b8 <MEM_SIZE+0xada1b8>
     7f8:	654c302d 	strbvs	r3, [ip, #-45]	; 0x2d
     7fc:	324b2f4d 	subcc	r2, fp, #308	; 0x134
     800:	3029332a 	eorcc	r3, r9, sl, lsr #6
     804:	034b2f31 	movteq	r2, #48945	; 0xbf31
     808:	032e7ce7 	teqeq	lr, #59136	; 0xe700
     80c:	03692e09 	cmneq	r9, #144	; 0x90
     810:	7903820b 	stmdbvc	r3, {r0, r1, r3, r9, pc}
     814:	2c312f4a 	ldccs	15, cr2, [r1], #-296	; 0xfffffed8
     818:	312d2d30 	teqcc	sp, r0, lsr sp
     81c:	7e9f034b 	cdpvc	3, 9, cr0, cr15, cr11, {2}
     820:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     824:	032e7703 	teqeq	lr, #786432	; 0xc0000
     828:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
     82c:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     830:	03662503 	cmneq	r6, #12582912	; 0xc00000
     834:	2f2d665f 	svccs	0x002d665f
     838:	304c4b2f 	subcc	r4, ip, pc, lsr #22
     83c:	4b4b4b2f 	blmi	12d3500 <MEM_SIZE+0xad3500>
     840:	2f2c4f30 	svccs	0x002c4f30
     844:	32302b2c 	eorscc	r2, r0, #45056	; 0xb000
     848:	03010432 	movweq	r0, #5170	; 0x1432
     84c:	044a0591 	strbeq	r0, [sl], #-1425	; 0x591
     850:	7aed0304 	bvc	ffb41468 <rEINTPEND+0xa9b413c0>
     854:	0301042e 	movweq	r0, #5166	; 0x142e
     858:	042e0592 	strteq	r0, [lr], #-1426	; 0x592
     85c:	7aed0304 	bvc	ffb41474 <rEINTPEND+0xa9b413cc>
     860:	0104322e 	tsteq	r4, lr, lsr #4
     864:	2e059003 	cdpcs	0, 0, cr9, cr5, cr3, {0}
     868:	04046531 	streq	r6, [r4], #-1329	; 0x531
     86c:	667adc03 	ldrbtvs	sp, [sl], -r3, lsl #24
     870:	2f4a1603 	svccs	0x004a1603
     874:	9b03302d 	blls	cc930 <DISABLE_IRQ+0xcc8b0>
     878:	0a03ba7f 	beq	ef27c <DISABLE_IRQ+0xef1fc>
     87c:	2e76032e 	cdpcs	3, 7, cr0, cr6, cr14, {1}
     880:	4d2e0a03 	vstmdbmi	lr!, {s0-s2}
     884:	4b33492f 	blmi	cd2d48 <MEM_SIZE+0x4d2d48>
     888:	2f2f3265 	svccs	0x002f3265
     88c:	66780352 	undefined instruction 0x66780352
     890:	302e0b03 	eorcc	r0, lr, r3, lsl #22
     894:	30667403 	rsbcc	r7, r6, r3, lsl #8
     898:	2d2f2f2c 	stccs	15, cr2, [pc, #-176]!	; 0xffffff50
     89c:	30312b30 	eorscc	r2, r1, r0, lsr fp
     8a0:	83030a04 	movwhi	r0, #14852	; 0x3a04
     8a4:	0f036604 	svceq	0x00036604
     8a8:	2e71032e 	cdpcs	3, 7, cr0, cr1, cr14, {1}
     8ac:	032e0f03 	teqeq	lr, #12
     8b0:	0f032e71 	svceq	0x00032e71
     8b4:	6a696a2e 	bvs	1a5b174 <MEM_SIZE+0x125b174>
     8b8:	03821303 	orreq	r1, r2, #201326592	; 0xc000000
     8bc:	834b6670 	movthi	r6, #46704	; 0xb670
     8c0:	4c302d2f 	ldcmi	13, cr2, [r0], #-188	; 0xffffff44
     8c4:	302d2f30 	eorcc	r2, sp, r0, lsr pc
     8c8:	4b4d6530 	blmi	1359d90 <MEM_SIZE+0xb59d90>
     8cc:	4a7c9c03 	bmi	1f278e0 <MEM_SIZE+0x17278e0>
     8d0:	032e0903 	teqeq	lr, #49152	; 0xc000
     8d4:	09032e77 	stmdbeq	r3, {r0, r1, r2, r4, r5, r6, r9, sl, fp, sp}
     8d8:	652f4d2e 	strvs	r4, [pc, #-3374]!	; fffffbb2 <rEINTPEND+0xa9fffb0a>
     8dc:	32656733 	rsbcc	r6, r5, #13369344	; 0xcc0000
     8e0:	2f2d882f 	svccs	0x002d882f
     8e4:	3150302d 	cmpcc	r0, sp, lsr #32
     8e8:	2f2f2f2b 	svccs	0x002f2f2b
     8ec:	0104322d 	tsteq	r4, sp, lsr #4
     8f0:	4a04dd03 	bmi	137d04 <DISABLE_IRQ+0x137c84>
     8f4:	a0030a04 	andge	r0, r3, r4, lsl #20
     8f8:	312f2e7b 	teqcc	pc, fp, ror lr
     8fc:	db030104 	blle	c0d14 <DISABLE_IRQ+0xc0c94>
     900:	312f2e04 	teqcc	pc, r4, lsl #28
     904:	030a0465 	movweq	r0, #42085	; 0xa465
     908:	4c4a7ba5 	mcrrmi	11, 10, r7, sl, cr5
     90c:	2f666f03 	svccs	0x00666f03
     910:	76034b2f 	strvc	r4, [r3], -pc, lsr #22
     914:	034b2f2e 	movteq	r2, #48942	; 0xbf2e
     918:	03827f95 	orreq	r7, r2, #596	; 0x254
     91c:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
     920:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     924:	33652f4d 	cmncc	r5, #308	; 0x134
     928:	1a03654b 	bne	d9e5c <DISABLE_IRQ+0xd9ddc>
     92c:	4a6a032e 	bmi	1a815ec <MEM_SIZE+0x12815ec>
     930:	2f326567 	svccs	0x00326567
     934:	2f2d682f 	svccs	0x002d682f
     938:	2d2f2f2d 	stccs	15, cr2, [pc, #-180]!	; 0xffffff4c
     93c:	892f674c 	stmdbhi	pc!, {r2, r3, r6, r8, r9, sl, sp, lr}
     940:	79034b2f 	stmdbvc	r3, {r0, r1, r2, r3, r5, r8, r9, fp, lr}
     944:	03042f2e 	movweq	r2, #20270	; 0x4f2e
     948:	9e01ec03 	cdpls	12, 0, cr14, cr1, cr3, {0}
     94c:	2e780336 	mrccs	3, 3, r0, cr8, cr6, {1}
     950:	316a4d36 	cmncc	sl, r6, lsr sp
     954:	2b2f302c 	blcs	bcca0c <MEM_SIZE+0x3cca0c>
     958:	312b2f31 	teqcc	fp, r1, lsr pc
     95c:	a02f322b 	eorge	r3, pc, fp, lsr #4
     960:	4a7fb903 	bmi	1feed74 <MEM_SIZE+0x17eed74>
     964:	2e780336 	mrccs	3, 3, r0, cr8, cr6, {1}
     968:	2f6a4d36 	svccs	0x006a4d36
     96c:	30455283 	subcc	r5, r5, r3, lsl #5
     970:	302d302c 	eorcc	r3, sp, ip, lsr #32
     974:	7faf034b 	svcvc	0x00af034b
     978:	306e2e2e 	rsbcc	r2, lr, lr, lsr #28
     97c:	4f32302c 	svcmi	0x0032302c
     980:	a0030104 	andge	r0, r3, r4, lsl #2
     984:	03044a08 	movweq	r4, #18952	; 0x4a08
     988:	4a77e303 	bmi	1df959c <MEM_SIZE+0x15f959c>
     98c:	9d030104 	stflss	f0, [r3, #-16]
     990:	2c4c4a08 	mcrrcs	10, 0, r4, ip, cr8
     994:	03042c30 	movweq	r2, #19504	; 0x4c30
     998:	2e77e703 	cdpcs	7, 7, cr14, cr7, cr3, {0}
     99c:	01042933 	tsteq	r4, r3, lsr r9
     9a0:	2e07fa03 	vmlacs.f32	s30, s14, s6
     9a4:	03046a2d 	movweq	r6, #18989	; 0x4a2d
     9a8:	4a788903 	bmi	1e22dbc <MEM_SIZE+0x1622dbc>
     9ac:	79032f4b 	stmdbvc	r3, {r0, r1, r3, r6, r8, r9, sl, fp, sp}
     9b0:	304b4b4a 	subcc	r4, fp, sl, asr #22
     9b4:	2f4a6c03 	svccs	0x004a6c03
     9b8:	314b2f31 	cmpcc	fp, r1, lsr pc
     9bc:	b2034b2f 	andlt	r4, r3, #48128	; 0xbc00
     9c0:	6e2e2e7f 	mcrvs	14, 1, r2, cr14, cr15, {3}
     9c4:	32302c30 	eorscc	r2, r0, #12288	; 0x3000
     9c8:	0301044f 	movweq	r0, #5199	; 0x144f
     9cc:	bb4a08b8 	bllt	1282cb4 <MEM_SIZE+0xa82cb4>
     9d0:	302c302d 	eorcc	r3, ip, sp, lsr #32
     9d4:	0304322c 	movweq	r3, #16940	; 0x422c
     9d8:	4a77cb03 	bmi	1df35ec <MEM_SIZE+0x15f35ec>
     9dc:	6e03304b 	cdpvs	0, 0, cr3, cr3, cr11, {2}
     9e0:	2f314b66 	svccs	0x00314b66
     9e4:	672f314b 	strvs	r3, [pc, -fp, asr #2]!
     9e8:	2e7fb503 	cdpcs	5, 7, cr11, cr15, cr3, {0}
     9ec:	032e0903 	teqeq	lr, #49152	; 0xc000
     9f0:	09032e77 	stmdbeq	r3, {r0, r1, r2, r4, r5, r6, r9, sl, fp, sp}
     9f4:	652f4d2e 	strvs	r4, [pc, #-3374]!	; fffffcce <rEINTPEND+0xa9fffc26>
     9f8:	30672f33 	rsbcc	r2, r7, r3, lsr pc
     9fc:	302d2f2d 	eorcc	r2, sp, sp, lsr #30
     a00:	2f63502f 	svccs	0x0063502f
     a04:	7f900367 	svcvc	0x00900367
     a08:	2e0c032e 	cdpcs	3, 0, cr0, cr12, cr14, {1}
     a0c:	032e7403 	teqeq	lr, #50331648	; 0x3000000
     a10:	2f4d660c 	svccs	0x004d660c
     a14:	652f3265 	strvs	r3, [pc, #-613]!	; 7b7 <DISABLE_IRQ+0x737>
     a18:	32492f32 	subcc	r2, r9, #200	; 0xc8
     a1c:	4b2f4f4e 	blmi	bd475c <MEM_SIZE+0x3d475c>
     a20:	2c354c4b 	ldccs	12, cr4, [r5], #-300	; 0xfffffed4
     a24:	2f672f2f 	svccs	0x00672f2f
     a28:	4e332b2f 	vaddmi.f64	d2, d3, d31
     a2c:	31302d2c 	teqcc	r0, ip, lsr #26
     a30:	66630330 	undefined instruction 0x66630330
     a34:	4b30364b 	blmi	c0e368 <MEM_SIZE+0x40e368>
     a38:	80030b04 	andhi	r0, r3, r4, lsl #22
     a3c:	10034a03 	andne	r4, r3, r3, lsl #20
     a40:	2e70032e 	cdpcs	3, 7, cr0, cr0, cr14, {1}
     a44:	4d2e1003 	stcmi	0, cr1, [lr, #-12]!
     a48:	820d036a 	andhi	r0, sp, #-1476395007	; 0xa8000001
     a4c:	4b667603 	blmi	199e260 <MEM_SIZE+0x119e260>
     a50:	4c302d4b 	ldcmi	13, cr2, [r0], #-300	; 0xfffffed4
     a54:	4b4b4d65 	blmi	12d3ff0 <MEM_SIZE+0xad3ff0>
     a58:	2e7cce03 	cdpcs	14, 7, cr12, cr12, cr3, {0}
     a5c:	2e780336 	mrccs	3, 3, r0, cr8, cr6, {1}
     a60:	82140336 	andshi	r0, r4, #-671088640	; 0xd8000000
     a64:	2f666f03 	svccs	0x00666f03
     a68:	304c4b4b 	subcc	r4, ip, fp, asr #22
     a6c:	0301044e 	movweq	r0, #5198	; 0x144e
     a70:	044a05be 	strbeq	r0, [sl], #-1470	; 0x5be
     a74:	7ac0030b 	bvc	ff0016a8 <rEINTPEND+0xa9001600>
     a78:	04322d2e 	ldrteq	r2, [r2], #-3374	; 0xd2e
     a7c:	05bc0301 	ldreq	r0, [ip, #769]!	; 0x301
     a80:	65312f2e 	ldrvs	r2, [r1, #-3886]!	; 0xf2e
     a84:	ba030b04 	blt	c369c <DISABLE_IRQ+0xc361c>
     a88:	4703667a 	smlsdxmi	r3, sl, r6, r6
     a8c:	2e090382 	cdpcs	3, 0, cr0, cr9, cr2, {4}
     a90:	2f4a0b03 	svccs	0x004a0b03
     a94:	69667803 	stmdbvs	r6!, {r0, r1, fp, ip, sp, lr}^
     a98:	2f2f2d30 	svccs	0x002f2d30
     a9c:	0302042f 	movweq	r0, #9263	; 0x242f
     aa0:	032e06c4 	teqeq	lr, #205520896	; 0xc400000
     aa4:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
     aa8:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     aac:	33492f4d 	movtcc	r2, #40781	; 0x9f4d
     ab0:	0903654b 	stmdbeq	r3, {r0, r1, r3, r6, r8, sl, sp, lr}
     ab4:	2f2f612e 	svccs	0x002f612e
     ab8:	b1034b2f 	tstlt	r3, pc, lsr #22
     abc:	2f362e7e 	svccs	0x00362e7e
     ac0:	ec033067 	stc	0, cr3, [r3], {103}	; 0x67
     ac4:	6e2e827d 	mcrvs	2, 1, r8, cr14, cr13, {3}
     ac8:	32302c30 	eorscc	r2, r0, #12288	; 0x3000
     acc:	0104504f 	tsteq	r4, pc, asr #32
     ad0:	6606cd03 	strvs	ip, [r6], -r3, lsl #26
     ad4:	b6030204 	strlt	r0, [r3], -r4, lsl #4
     ad8:	01044a79 	tsteq	r4, r9, ror sl
     adc:	4a06ca03 	bmi	1b32f0 <DISABLE_IRQ+0x1b3270>
     ae0:	2c302c4c 	ldccs	12, cr2, [r0], #-304	; 0xfffffed0
     ae4:	b9030204 	stmdblt	r3, {r2, r9}
     ae8:	29332e79 	ldmdbcs	r3!, {r0, r3, r4, r5, r6, r9, sl, fp, sp}
     aec:	a8030104 	stmdage	r3, {r2, r8}
     af0:	6a2d2e06 	bvs	b4c310 <MEM_SIZE+0x34c310>
     af4:	db030204 	blle	c130c <DISABLE_IRQ+0xc128c>
     af8:	304b4a79 	subcc	r4, fp, r9, ror sl
     afc:	2f4a7203 	svccs	0x004a7203
     b00:	4b4b324b 	blmi	12cd434 <MEM_SIZE+0xacd434>
     b04:	4a670330 	bmi	19c17cc <MEM_SIZE+0x11c17cc>
     b08:	4b2f312f 	blmi	bccfcc <MEM_SIZE+0x3ccfcc>
     b0c:	034b2f31 	movteq	r2, #48945	; 0xbf31
     b10:	2e2e7fac 	cdpcs	15, 2, cr7, cr14, cr12, {5}
     b14:	302c306e 	eorcc	r3, ip, lr, rrx
     b18:	04504f32 	ldrbeq	r4, [r0], #-3890	; 0xf32
     b1c:	06eb0301 	strbteq	r0, [fp], r1, lsl #6
     b20:	302dbb66 	eorcc	fp, sp, r6, ror #22
     b24:	322c302c 	eorcc	r3, ip, #44	; 0x2c
     b28:	97030204 	strls	r0, [r3, -r4, lsl #4]
     b2c:	304b4a79 	subcc	r4, fp, r9, ror sl
     b30:	2f667803 	svccs	0x00667803
     b34:	2e6f0367 	cdpcs	3, 6, cr0, cr15, cr7, {3}
     b38:	4b2f314b 	blmi	bcd06c <MEM_SIZE+0x3cd06c>
     b3c:	03672f31 	cmneq	r7, #196	; 0xc4
     b40:	032e7eaf 	teqeq	lr, #2800	; 0xaf0
     b44:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
     b48:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
     b4c:	3265674e 	rsbcc	r6, r5, #20447232	; 0x1380000
     b50:	304c4b2f 	subcc	r4, ip, pc, lsr #22
     b54:	484e2f2c 	stmdami	lr, {r2, r3, r5, r8, r9, sl, fp, sp}^
     b58:	342f3031 	strtcc	r3, [pc], #49	; b60 <DISABLE_IRQ+0xae0>
     b5c:	eb032f62 	bl	cc8ec <DISABLE_IRQ+0xcc86c>
     b60:	0b039e7e 	bleq	e8560 <DISABLE_IRQ+0xe84e0>
     b64:	2e75032e 	cdpcs	3, 7, cr0, cr5, cr14, {1}
     b68:	4d660b03 	fstmdbxmi	r6!, {d16}	;@ Deprecated
     b6c:	4b33652f 	blmi	cda030 <MEM_SIZE+0x4da030>
     b70:	00c80365 	sbceq	r0, r8, r5, ror #6
     b74:	7fbd032e 	svcvc	0x00bd032e
     b78:	7a033566 	bvc	ce118 <DISABLE_IRQ+0xce098>
     b7c:	7a03342e 	bvc	cdc3c <DISABLE_IRQ+0xcdbbc>
     b80:	032f352e 	teqeq	pc, #192937984	; 0xb800000
     b84:	4b2fd60e 	blmi	bf63c4 <MEM_SIZE+0x3f63c4>
     b88:	4a1e032f 	bmi	78184c <DISABLE_IRQ+0x7817cc>
     b8c:	2e52032f 	cdpcs	3, 5, cr0, cr2, cr15, {1}
     b90:	4a2a034b 	bmi	a818c4 <MEM_SIZE+0x2818c4>
     b94:	4a6c034c 	bmi	1b018cc <MEM_SIZE+0x13018cc>
     b98:	032f4b4b 	teqeq	pc, #76800	; 0x12c00
     b9c:	304f4a11 	subcc	r4, pc, r1, lsl sl
     ba0:	2f827103 	svccs	0x00827103
     ba4:	034f2f4b 	movteq	r2, #65355	; 0xff4b
     ba8:	032f4a55 	teqeq	pc, #348160	; 0x55000
     bac:	01044a2a 	tsteq	r4, sl, lsr #20
     bb0:	4a01d103 	bmi	74fc4 <DISABLE_IRQ+0x74f44>
     bb4:	82090335 	andhi	r0, r9, #-738197504	; 0xd4000000
     bb8:	2f4a7803 	svccs	0x004a7803
     bbc:	034d6783 	movteq	r6, #55171	; 0xd783
     bc0:	039e7ea6 	orrseq	r7, lr, #2656	; 0xa60
     bc4:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
     bc8:	4a09032e 	bmi	241888 <DISABLE_IRQ+0x241808>
     bcc:	32492f31 	subcc	r2, r9, #196	; 0xc4
     bd0:	6e33492f 	cdpvs	9, 3, cr4, cr3, cr15, {1}
     bd4:	034a7803 	movteq	r7, #43011	; 0xa803
     bd8:	de032e0b 	cdple	14, 0, cr2, cr3, cr11, {0}
     bdc:	2cbc2e08 	ldccs	14, cr2, [ip], #32
     be0:	a4032c30 	strge	r2, [r3], #-3120	; 0xc30
     be4:	29332e77 	ldmdbcs	r3!, {r0, r1, r2, r4, r5, r6, r9, sl, fp, sp}
     be8:	2e08bd03 	cdpcs	13, 0, cr11, cr8, cr3, {0}
     bec:	c6036a2d 	strgt	r6, [r3], -sp, lsr #20
     bf0:	2f2f4a77 	svccs	0x002f4a77
     bf4:	2f4a7903 	svccs	0x004a7903
     bf8:	9403304b 	strls	r3, [r3], #-75	; 0x4b
     bfc:	09034a7f 	stmdbeq	r3, {r0, r1, r2, r3, r4, r5, r6, r9, fp, lr}
     c00:	2e77032e 	cdpcs	3, 7, cr0, cr7, cr14, {1}
     c04:	4d4a0903 	stclmi	9, cr0, [sl, #-12]
     c08:	2f32492f 	svccs	0x0032492f
     c0c:	036e3365 	cmneq	lr, #-1811939327	; 0x94000001
     c10:	0b036678 	bleq	da5f8 <DISABLE_IRQ+0xda578>
     c14:	0983032e 	stmibeq	r3, {r1, r2, r3, r5, r8, r9}
     c18:	302dbb2e 	eorcc	fp, sp, lr, lsr #22
     c1c:	322c302c 	eorcc	r3, ip, #44	; 0x2c
     c20:	4a76fb03 	bmi	1dbf834 <MEM_SIZE+0x15bf834>
     c24:	e503302f 	str	r3, [r3, #-47]	; 0x2f
     c28:	a62e660a 	strtge	r6, [lr], -sl, lsl #12
     c2c:	324b4b2f 	subcc	r4, fp, #48128	; 0xbc00
     c30:	1a032f2a 	bne	cc8e0 <DISABLE_IRQ+0xcc860>
     c34:	302d302e 	eorcc	r3, sp, lr, lsr #32
     c38:	2e6d032c 	cdpcs	3, 6, cr0, cr13, cr12, {1}
     c3c:	362e7903 	strtcc	r7, [lr], -r3, lsl #18
     c40:	032e1203 	teqeq	lr, #805306368	; 0x30000000
     c44:	4f032e1f 	svcmi	0x00032e1f
     c48:	2e31032e 	cdpcs	3, 3, cr0, cr1, cr14, {1}
     c4c:	302e6003 	eorcc	r6, lr, r3
     c50:	2e65032f 	cdpcs	3, 6, cr0, cr5, cr15, {1}
     c54:	032e3d03 	teqeq	lr, #192	; 0xc0
     c58:	2f2f2e4b 	svccs	0x002f2e4b
     c5c:	2f2e7703 	svccs	0x002e7703
     c60:	2e11032f 	cdpcs	3, 1, cr0, cr1, cr15, {1}
     c64:	322e1003 	eorcc	r1, lr, #3
     c68:	2f2f3232 	svccs	0x002f3232
     c6c:	32332f2f 	eorscc	r2, r3, #188	; 0xbc
     c70:	2d304c31 	ldccs	12, cr4, [r0, #-196]!	; 0xffffff3c
     c74:	2d312d2f 	ldccs	13, cr2, [r1, #-188]!	; 0xffffff44
     c78:	2d31312d 	ldfcss	f3, [r1, #-180]!	; 0xffffff4c
     c7c:	4b2d4b2f 	blmi	b53940 <MEM_SIZE+0x353940>
     c80:	2d4b2d2f 	stclcs	13, cr2, [fp, #-188]	; 0xffffff44
     c84:	2f2f2d2f 	svccs	0x002f2d2f
     c88:	034b484f 	movteq	r4, #47183	; 0xb84f
     c8c:	03d67df8 	bicseq	r7, r6, #15872	; 0x3e00
     c90:	672f4a09 	strvs	r4, [pc, -r9, lsl #20]!
     c94:	7ed6032f 	cdpvc	3, 13, cr0, cr6, cr15, {1}
     c98:	2d2f3566 	cfstr32cs	mvfx3, [pc, #-408]!	; 0xfffffe68
     c9c:	2703672f 	strcs	r6, [r3, -pc, lsr #14]
     ca0:	2f2d6782 	svccs	0x002d6782
     ca4:	032e5a03 	teqeq	lr, #12288	; 0x3000
     ca8:	5a032e26 	bpl	cc548 <DISABLE_IRQ+0xcc4c8>
     cac:	2e26032e 	cdpcs	3, 2, cr0, cr6, cr14, {1}
     cb0:	03665a03 	cmneq	r6, #12288	; 0x3000
     cb4:	5a032e26 	bpl	cc554 <DISABLE_IRQ+0xcc4d4>
     cb8:	29332f2e 	ldmdbcs	r3!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}
     cbc:	2c302c33 	ldccs	12, cr2, [r0], #-204	; 0xffffff34
     cc0:	3250294c 	subscc	r2, r0, #1245184	; 0x130000
     cc4:	0308044b 	movweq	r0, #33867	; 0x844b
     cc8:	740877da 	strvc	r7, [r8], #-2010	; 0x7da
     ccc:	2e78031a 	mrccs	3, 3, r0, cr8, cr10, {0}
     cd0:	2203362e 	andcs	r3, r3, #48234496	; 0x2e00000
     cd4:	4a61034a 	bmi	1841a04 <MEM_SIZE+0x1041a04>
     cd8:	2f2f2d2f 	svccs	0x002f2d2f
     cdc:	2d6c4e4e 	stclcs	14, cr4, [ip, #-312]!	; 0xfffffec8
     ce0:	312c2f2f 	teqcc	ip, pc, lsr #30
     ce4:	50303149 	eorspl	r3, r0, r9, asr #2
     ce8:	4b666f03 	blmi	199c8fc <MEM_SIZE+0x119c8fc>
     cec:	0f034b29 	svceq	0x00034b29
     cf0:	4b2d672e 	blmi	b5a9b0 <MEM_SIZE+0x35a9b0>
     cf4:	2f4b2d67 	svccs	0x004b2d67
     cf8:	ba7ee703 	blt	1fba90c <MEM_SIZE+0x17ba90c>
     cfc:	4a0b0336 	bmi	2c19dc <DISABLE_IRQ+0x2c195c>
     d00:	2f4a7603 	svccs	0x004a7603
     d04:	832f2d2f 	teqhi	pc, #3008	; 0xbc0
     d08:	2fa0302d 	svccs	0x00a0302d
     d0c:	1f032c31 	svcne	0x00032c31
     d10:	7a031882 	bvc	c6f20 <DISABLE_IRQ+0xc6ea0>
     d14:	0903342e 	stmdbeq	r3, {r1, r2, r3, r5, sl, ip, sp}
     d18:	0369692e 	cmneq	r9, #753664	; 0xb8000
     d1c:	61036611 	tstvs	r3, r1, lsl r6
     d20:	034b4b4a 	movteq	r4, #47946	; 0xbb4a
     d24:	e8088212 	stmda	r8, {r1, r4, r9, pc}
     d28:	4b2f3048 	blmi	bcce50 <MEM_SIZE+0x3cce50>
     d2c:	2d302c30 	ldccs	12, cr2, [r0, #-192]!	; 0xffffff40
     d30:	03010448 	movweq	r0, #5192	; 0x1448
     d34:	039e09fb 	orrseq	r0, lr, #4112384	; 0x3ec000
     d38:	49832e0b 	stmibmi	r3, {r0, r1, r3, r9, sl, fp, sp}
     d3c:	d6100369 	ldrle	r0, [r0], -r9, ror #6
     d40:	332e7003 	teqcc	lr, #3
     d44:	30306e4f 	eorscc	r6, r0, pc, asr #28
     d48:	2f4a6c03 	svccs	0x004a6c03
     d4c:	2f302d2f 	svccs	0x00302d2f
     d50:	032b312f 	teqeq	fp, #-1073741813	; 0xc000000b
     d54:	2f2d2e09 	svccs	0x002d2e09
     d58:	0878df03 	ldmdaeq	r8!, {r0, r1, r8, r9, sl, fp, ip, lr, pc}^
     d5c:	2c303520 	cfldr32cs	mvfx3, [r0], #-128	; 0xffffff80
     d60:	2f4b2f2f 	svccs	0x004b2f2f
     d64:	67672f4b 	strbvs	r2, [r7, -fp, asr #30]!
     d68:	0305042f 	movweq	r0, #21551	; 0x542f
     d6c:	039e02fe 	orrseq	r0, lr, #-536870897	; 0xe000000f
     d70:	7503010b 	strvc	r0, [r3, #-267]	; 0x10b
     d74:	0b032e2e 	bleq	cc634 <DISABLE_IRQ+0xcc5b4>
     d78:	034b4d2e 	movteq	r4, #48430	; 0xbd2e
     d7c:	63036622 	movwvs	r6, #13858	; 0x3622
     d80:	4b89304a 	blmi	fe24ceb0 <rEINTPEND+0xa824ce08>
     d84:	2d9f4f4e 	ldccs	15, cr4, [pc, #312]	; 0x138
     d88:	2f67a030 	svccs	0x0067a030
     d8c:	9e66032f 	cdpls	3, 6, cr0, cr6, cr15, {1}
     d90:	314bf932 	cmppcc	fp, r2, lsr r9
     d94:	7ec7034b 	cdpvc	3, 12, cr0, cr7, cr11, {2}
     d98:	0109039e 	undefined instruction 0x0109039e
     d9c:	2e2e7703 	cdpcs	7, 2, cr7, cr14, cr3, {0}
     da0:	032e0903 	teqeq	lr, #49152	; 0xc000
     da4:	64034a20 	strvs	r4, [r3], #-2592	; 0xa20
     da8:	4e4b2f4a 	cdpmi	15, 4, cr2, cr11, cr10, {2}
     dac:	2d2f674e 	stccs	7, cr6, [pc, #-312]!	; 0xfffffec8
     db0:	67672f2f 	strbvs	r2, [r7, -pc, lsr #30]!
     db4:	2f9f4b2d 	svccs	0x009f4b2d
     db8:	4b660903 	blmi	19831cc <MEM_SIZE+0x11831cc>
     dbc:	032e7803 	teqeq	lr, #196608	; 0x30000
     dc0:	314b6670 	cmpcc	fp, r0, ror r6
     dc4:	2e0e034b 	cdpcs	3, 0, cr0, cr14, cr11, {2}
     dc8:	ba7cf603 	blt	1f3e5dc <MEM_SIZE+0x173e5dc>
     dcc:	032e0f03 	teqeq	lr, #12
     dd0:	0f032e71 	svceq	0x00032e71
     dd4:	4b6a852e 	blmi	1aa2294 <MEM_SIZE+0x12a2294>
     dd8:	6600c903 	strvs	ip, [r0], -r3, lsl #18
     ddc:	4a7fbd03 	bmi	1ff01f0 <MEM_SIZE+0x17f01f0>
     de0:	4e4b6830 	mcrmi	8, 2, r6, cr11, cr0, {1}
     de4:	302d9f4f 	eorcc	r9, sp, pc, asr #30
     de8:	9f4b2fa2 	svcls	0x004b2fa2
     dec:	2f88302d 	svccs	0x0088302d
     df0:	b0030204 	andlt	r0, r3, r4, lsl #4
     df4:	2f2f4a05 	svccs	0x002f4a05
     df8:	2f2f2d52 	svccs	0x002f2d52
     dfc:	03050433 	movweq	r0, #21555	; 0x5433
     e00:	31667ac5 	cmncc	r6, r5, asr #21
     e04:	2b2f2f2c 	blcs	bccabc <MEM_SIZE+0x3ccabc>
     e08:	304c2f31 	subcc	r2, ip, r1, lsr pc
     e0c:	2f2f2d2f 	svccs	0x002f2d2f
     e10:	2d2f4b68 	vstmdbcs	pc!, {d4-<overflow reg d55>}
     e14:	034c2d2f 	movteq	r2, #52527	; 0xcd2f
     e18:	75032e0b 	strvc	r2, [r3, #-3595]	; 0xe0b
     e1c:	312b322e 	teqcc	fp, lr, lsr #4
     e20:	312b322b 	teqcc	fp, fp, lsr #4
     e24:	0334332b 	teqeq	r4, #-1409286144	; 0xac000000
     e28:	304b2e7a 	subcc	r2, fp, sl, ror lr
     e2c:	4b2f304b 	blmi	bccf60 <MEM_SIZE+0x3ccf60>
     e30:	2e7fbe03 	cdpcs	14, 7, cr11, cr15, cr3, {0}
     e34:	4b314b50 	blmi	c53b7c <MEM_SIZE+0x453b7c>
     e38:	c8030204 	stmdagt	r3, {r2, r9}
     e3c:	2d2f2e05 	stccs	14, cr2, [pc, #-20]!	; 0xffffffec
     e40:	0305042f 	movweq	r0, #21551	; 0x542f
     e44:	580879bd 	stmdapl	r8, {r0, r2, r3, r4, r5, r7, r8, fp, ip, sp, lr}
     e48:	032e0a03 	teqeq	lr, #12288	; 0x3000
     e4c:	032e2e76 	teqeq	lr, #1888	; 0x760
     e50:	1f03d60a 	svcne	0x0003d60a
     e54:	8265034a 	rsbhi	r0, r5, #671088641	; 0x28000001
     e58:	1403862f 	strne	r8, [r3], #-1583	; 0x62f
     e5c:	68034b82 	stmdavs	r3, {r1, r7, r8, r9, fp, lr}
     e60:	30314b2e 	eorscc	r4, r1, lr, lsr #22
     e64:	c003302c 	andgt	r3, r3, ip, lsr #32
     e68:	4c672e05 	stclmi	14, cr2, [r7], #-20	; 0xffffffec
     e6c:	48302c68 	ldmdami	r0!, {r3, r5, r6, sl, fp, sp}
     e70:	2e7ac103 	expcse	f4, f3
     e74:	f32f2d9f 	undefined instruction 0xf32f2d9f
     e78:	2f4d834b 	svccs	0x004d834b
     e7c:	0306044b 	movweq	r0, #25675	; 0x644b
     e80:	049e03c9 	ldreq	r0, [lr], #969	; 0x3c9
     e84:	02d80301 	sbcseq	r0, r8, #67108864	; 0x4000000
     e88:	65836582 	strvs	r6, [r3, #1410]	; 0x582
     e8c:	a8030604 	stmdage	r3, {r2, r9, sl}
     e90:	10034a7d 	andne	r4, r3, sp, ror sl
     e94:	2e70032e 	cdpcs	3, 7, cr0, cr0, cr14, {1}
     e98:	312e1103 	teqcc	lr, r3, lsl #2
     e9c:	2f2f2d2b 	svccs	0x002f2d2b
     ea0:	03312f30 	teqeq	r1, #192	; 0xc0
     ea4:	15032e77 	strne	r2, [r3, #-3703]	; 0xe77
     ea8:	032f2d4a 	teqeq	pc, #4736	; 0x1280
     eac:	4d4e2e76 	stclmi	14, cr2, [lr, #-472]	; 0xfffffe28
     eb0:	312f3329 	teqcc	pc, r9, lsr #6
     eb4:	2c302f2b 	ldccs	15, cr2, [r0], #-172	; 0xffffff54
     eb8:	322e7803 	eorcc	r7, lr, #196608	; 0x30000
     ebc:	036c4b34 	cmneq	ip, #53248	; 0xd000
     ec0:	8a342e7a 	bhi	d0c8b0 <MEM_SIZE+0x50c8b0>
     ec4:	03821f03 	orreq	r1, r2, #12
     ec8:	03ac0823 	undefined instruction 0x03ac0823
     ecc:	05048243 	streq	r8, [r4, #-579]	; 0x243
     ed0:	027ae303 	rsbseq	lr, sl, #201326592	; 0xc000000
     ed4:	0a030124 	beq	c136c <DISABLE_IRQ+0xc12ec>
     ed8:	2e76032e 	cdpcs	3, 7, cr0, cr6, cr14, {1}
     edc:	660a034a 	strvs	r0, [sl], -sl, asr #6
     ee0:	034a1c03 	movteq	r1, #44035	; 0xac03
     ee4:	862f8268 	strthi	r8, [pc], -r8, ror #4
     ee8:	4b821103 	blmi	fe0852fc <rEINTPEND+0xa8085254>
     eec:	4b2e6b03 	blmi	b9bb00 <MEM_SIZE+0x39bb00>
     ef0:	9f2f4c31 	svcls	0x002f4c31
     ef4:	4bbb2f2d 	blmi	feeccbb0 <rEINTPEND+0xa8eccb08>
     ef8:	2f2f4d83 	svccs	0x002f4d83
     efc:	9e7ed803 	cdpls	8, 7, cr13, cr14, cr3, {0}
     f00:	03011603 	movweq	r1, #5635	; 0x1603
     f04:	032e2e6a 	teqeq	lr, #1696	; 0x6a0
     f08:	032f4a16 	teqeq	pc, #90112	; 0x16000
     f0c:	2f4a00c3 	svccs	0x004a00c3
     f10:	4e4a4003 	cdpmi	0, 4, cr4, cr10, cr3, {0}
     f14:	672f2d2f 	strvs	r2, [pc, -pc, lsr #26]!
     f18:	302f304b 	eorcc	r3, pc, fp, asr #32
     f1c:	4e2f4c2c 	cdpmi	12, 2, cr4, cr15, cr12, {1}
     f20:	302f2c51 	eorcc	r2, pc, r1, asr ip
     f24:	2e09032d 	cdpcs	3, 0, cr0, cr9, cr13, {1}
     f28:	7403304b 	strvc	r3, [r3], #-75	; 0x4b
     f2c:	2e0c0382 	cdpcs	3, 0, cr0, cr12, cr2, {4}
     f30:	032e7503 	teqeq	lr, #12582912	; 0xc00000
     f34:	2f2f2e0b 	svccs	0x002f2e0b
     f38:	2f65302d 	svccs	0x0065302d
     f3c:	312b322d 	teqcc	fp, sp, lsr #4
     f40:	12034b2d 	andne	r4, r3, #46080	; 0xb400
     f44:	2f2f2a2e 	svccs	0x002f2a2e
     f48:	4b4b302f 	blmi	12cd00c <MEM_SIZE+0xacd00c>
     f4c:	2f2e6e03 	svccs	0x002e6e03
     f50:	492f9f4b 	stmdbmi	pc!, {r0, r1, r3, r6, r8, r9, sl, fp, ip, pc}
     f54:	3163312f 	cmncc	r3, pc, lsr #2
     f58:	032d2f2d 	teqeq	sp, #180	; 0xb4
     f5c:	31674a5b 	cmncc	r7, fp, asr sl
     f60:	03090467 	movweq	r0, #37991	; 0x9467
     f64:	369e01fe 	undefined instruction 0x369e01fe
     f68:	8211036a 	andshi	r0, r1, #-1476395007	; 0xa8000001
     f6c:	2f4a7203 	svccs	0x004a7203
     f70:	83502f2d 	cmphi	r0, #180	; 0xb4
     f74:	4b304b4b 	blmi	c13ca8 <MEM_SIZE+0x413ca8>
     f78:	832e7503 	teqhi	lr, #12582912	; 0xc00000
     f7c:	06044b4b 	streq	r4, [r4], -fp, asr #22
     f80:	4a05ab03 	bmi	16bb94 <DISABLE_IRQ+0x16bb14>
     f84:	03114b13 	tsteq	r1, #19456	; 0x4c00
     f88:	164a7da4 	strbne	r7, [sl], -r4, lsr #27
     f8c:	0904104c 	stmdbeq	r4, {r2, r3, r6, ip}
     f90:	4a7ccf03 	bmi	1f34ba4 <MEM_SIZE+0x1734ba4>
     f94:	2e780336 	mrccs	3, 3, r0, cr8, cr6, {1}
     f98:	2f31362e 	svccs	0x0031362e
     f9c:	494b3349 	stmdbmi	fp, {r0, r3, r6, r8, r9, ip, sp}^
     fa0:	032e2403 	teqeq	lr, #50331648	; 0x3000000
     fa4:	49676660 	stmdbmi	r7!, {r5, r6, r9, sl, sp, lr}^
     fa8:	32496732 	subcc	r6, r9, #13107200	; 0xc80000
     fac:	6d2f2d4b 	stcvs	13, cr2, [pc, #-300]!	; 0xfffffed4
     fb0:	b1030104 	tstlt	r3, r4, lsl #2
     fb4:	09042e03 	stmdbeq	r4, {r0, r1, r9, sl, fp, sp}
     fb8:	2e7ccf03 	cdpcs	15, 7, cr12, cr12, cr3, {0}
     fbc:	b1030104 	tstlt	r3, r4, lsl #2
     fc0:	09044a03 	stmdbeq	r4, {r0, r1, r9, fp, lr}
     fc4:	2e7ccf03 	cdpcs	15, 7, cr12, cr12, cr3, {0}
     fc8:	042f2c30 	strteq	r2, [pc], #3120	; fd0 <DISABLE_IRQ+0xf50>
     fcc:	03ae0301 	undefined instruction 0x03ae0301
     fd0:	2d67302e 	stclcs	0, cr3, [r7, #-184]!	; 0xffffff48
     fd4:	2d9fa030 	ldccs	0, cr10, [pc, #192]	; 0xc0
     fd8:	0309044b 	movweq	r0, #37963	; 0x944b
     fdc:	042e7cce 	strteq	r7, [lr], #-3278	; 0xcce
     fe0:	03b20301 	undefined instruction 0x03b20301
     fe4:	0309042e 	movweq	r0, #37934	; 0x942e
     fe8:	2f4a7cce 	svccs	0x004a7cce
     fec:	2f2d2f2f 	svccs	0x002d2f2f
     ff0:	042f4b6c 	strteq	r4, [pc], #2924	; ff8 <DISABLE_IRQ+0xf78>
     ff4:	03c00301 	biceq	r0, r0, #67108864	; 0x4000000
     ff8:	842fd74a 	strthi	sp, [pc], #1866	; 1000 <DISABLE_IRQ+0xf80>
     ffc:	042f2c30 	strteq	r2, [pc], #3120	; 1004 <DISABLE_IRQ+0xf84>
    1000:	7cb50309 	ldcvc	3, cr0, [r5], #36	; 0x24
    1004:	034b4b2e 	movteq	r4, #47918	; 0xbb2e
    1008:	2f4b2e6f 	svccs	0x004b2e6f
    100c:	0306042f 	movweq	r0, #25647	; 0x642f
    1010:	32ba05da 	adcscc	r0, sl, #914358272	; 0x36800000
    1014:	0384322a 	orreq	r3, r4, #-1610612734	; 0xa0000002
    1018:	33827ccf 	orrcc	r7, r2, #52992	; 0xcf00
    101c:	2f4d4f29 	svccs	0x004d4f29
    1020:	654b3365 	strbvs	r3, [fp, #-869]	; 0x365
    1024:	032e3d03 	teqeq	lr, #192	; 0xc0
    1028:	65676647 	strbvs	r6, [r7, #-1607]!	; 0x647
    102c:	3e086732 	mcrcc	7, 0, r6, cr8, cr2, {1}
    1030:	034b2d84 	movteq	r2, #48516	; 0xbd84
    1034:	672fd619 	undefined instruction 0x672fd619
    1038:	31672f35 	cmncc	r7, r5, lsr pc
    103c:	2f31672f 	svccs	0x0031672f
    1040:	2e540367 	cdpcs	3, 5, cr0, cr4, cr7, {3}
    1044:	19034b2f 	stmdbne	r3, {r0, r1, r2, r3, r5, r8, r9, fp, lr}
    1048:	6e034b82 	vmlavs.f64	d4, d19, d2
    104c:	874b2f2e 	strbhi	r2, [fp, -lr, lsr #30]
    1050:	fc03672b 	stc2	7, cr6, [r3], {43}	; 0x2b
    1054:	2c304a7e 	ldccs	10, cr4, [r0], #-504	; 0xfffffe08
    1058:	652f4d30 	strvs	r4, [pc, #-3376]!	; 330 <DISABLE_IRQ+0x2b0>
    105c:	03654b33 	cmneq	r5, #52224	; 0xcc00
    1060:	62032e22 	andvs	r2, r3, #544	; 0x220
    1064:	3265674a 	rsbcc	r6, r5, #19398656	; 0x1280000
    1068:	6752f42f 	ldrbvs	pc, [r2, -pc, lsr #8]
    106c:	2f31672f 	svccs	0x0031672f
    1070:	672f3167 	strvs	r3, [pc, -r7, ror #2]!
    1074:	4a7f9503 	bmi	1fe6488 <MEM_SIZE+0x17e6488>
    1078:	4d332933 	ldcmi	9, cr2, [r3, #-204]!	; 0xffffff34
    107c:	4b33492f 	blmi	cd3540 <MEM_SIZE+0x4d3540>
    1080:	2e180365 	cdpcs	3, 1, cr0, cr8, cr5, {3}
    1084:	67666c03 	strbvs	r6, [r6, -r3, lsl #24]!
    1088:	4b4b3265 	blmi	12cda24 <MEM_SIZE+0xacda24>
    108c:	2a2e0903 	bcs	b834a0 <MEM_SIZE+0x3834a0>
    1090:	03673132 	cmneq	r7, #-2147483636	; 0x8000000c
    1094:	334a7efc 	movtcc	r7, #44796	; 0xaefc
    1098:	2f4d3329 	svccs	0x004d3329
    109c:	654b3365 	strbvs	r3, [fp, #-869]	; 0x365
    10a0:	032e3303 	teqeq	lr, #201326592	; 0xc000000
    10a4:	65678251 	strbvs	r8, [r7, #-593]!	; 0x251
    10a8:	22084b32 	andcs	r4, r8, #51200	; 0xc800
    10ac:	034b2f83 	movteq	r2, #49027	; 0xbf83
    10b0:	2f2d2e18 	svccs	0x002d2e18
    10b4:	2e6a032f 	cdpcs	3, 6, cr0, cr10, cr15, {1}
    10b8:	0a034ba0 	beq	d3f40 <DISABLE_IRQ+0xd3ec0>
    10bc:	0b032f2e 	bleq	ccd7c <DISABLE_IRQ+0xcccfc>
    10c0:	31672f66 	cmncc	r7, r6, ror #30
    10c4:	6c03672f 	stcvs	7, cr6, [r3], {47}	; 0x2f
    10c8:	7f8c032e 	svcvc	0x008c032e
    10cc:	33293382 	teqcc	r9, #134217730	; 0x8000002
    10d0:	32652f4d 	rsbcc	r2, r5, #308	; 0x134
    10d4:	4b33492f 	blmi	cd3598 <MEM_SIZE+0x4d3598>
    10d8:	2e1c0365 	cdpcs	3, 1, cr0, cr12, cr5, {3}
    10dc:	67666803 	strbvs	r6, [r6, -r3, lsl #16]!
    10e0:	034b3265 	movteq	r3, #45669	; 0xb265
    10e4:	672f820a 	strvs	r8, [pc, -sl, lsl #4]!
    10e8:	042e7403 	strteq	r7, [lr], #-1027	; 0x403
    10ec:	07d30301 	ldrbeq	r0, [r3, r1, lsl #6]
    10f0:	302dbb4a 	eorcc	fp, sp, sl, asr #22
    10f4:	322c302c 	eorcc	r3, ip, #44	; 0x2c
    10f8:	ae030604 	cfmadd32ge	mvax0, mvfx0, mvfx3, mvfx4
    10fc:	2f4b4a78 	svccs	0x004b4a78
    1100:	03672f52 	cmneq	r7, #328	; 0x148
    1104:	304a7f89 	subcc	r7, sl, r9, lsl #31
    1108:	2f4d302c 	svccs	0x004d302c
    110c:	654b3365 	strbvs	r3, [fp, #-869]	; 0x365
    1110:	032e2203 	teqeq	lr, #805306368	; 0x30000000
    1114:	65674a62 	strbvs	r4, [r7, #-2658]!	; 0xa62
    1118:	03f42f32 	mvnseq	r2, #200	; 0xc8
    111c:	034a0491 	movteq	r0, #42129	; 0xa491
    1120:	032f2e0f 	teqeq	pc, #240	; 0xf0
    1124:	79032e77 	stmdbvc	r3, {r0, r1, r2, r4, r5, r6, r9, sl, fp, sp}
    1128:	32352f4a 	eorscc	r2, r5, #296	; 0x128
    112c:	322a2f31 	eorcc	r2, sl, #196	; 0xc4
    1130:	032a2f2d 	teqeq	sl, #180	; 0xb4
    1134:	2f2f2e76 	svccs	0x002f2e76
    1138:	3030342f 	eorscc	r3, r0, pc, lsr #8
    113c:	2e7be903 	cdpcs	9, 7, cr14, cr11, cr3, {0}
    1140:	2f314b2f 	svccs	0x00314b2f
    1144:	672f3167 	strvs	r3, [pc, -r7, ror #2]!
    1148:	9e7ef703 	cdpls	7, 7, cr15, cr14, cr3, {0}
    114c:	7803522e 	stmdavc	r3, {r1, r2, r3, r5, r9, ip, lr}
    1150:	034d8a2e 	movteq	r8, #55854	; 0xda2e
    1154:	70036610 	andvc	r6, r3, r0, lsl r6
    1158:	2e380366 	cdpcs	3, 3, cr0, cr8, cr6, {3}
    115c:	2f664a03 	svccs	0x00664a03
    1160:	2e120365 	cdpcs	3, 1, cr0, cr2, cr5, {3}
    1164:	03326567 	teqeq	r2, #432013312	; 0x19c00000
    1168:	892e04c5 	stmdbhi	lr!, {r0, r2, r6, r7, sl}
    116c:	2a2f2d2f 	bcs	bcc630 <MEM_SIZE+0x3cc630>
    1170:	03322b31 	teqeq	r2, #50176	; 0xc400
    1174:	032e7bba 	teqeq	lr, #190464	; 0x2e800
    1178:	2f2e04c5 	svccs	0x002e04c5
    117c:	2e7bba03 	vaddcs.f32	s23, s22, s6
    1180:	03303031 	teqeq	r0, #49	; 0x31
    1184:	302f2e7a 	eorcc	r2, pc, sl, ror lr
    1188:	04be032f 	ldrteq	r0, [lr], #815	; 0x32f
    118c:	c3032f2e 	movwgt	r2, #16174	; 0x3f2e
    1190:	01042e7b 	tsteq	r4, fp, ror lr
    1194:	2e098703 	cdpcs	7, 0, cr8, cr9, cr3, {0}
    1198:	2c302ca0 	ldccs	12, cr2, [r0], #-640	; 0xfffffd80
    119c:	fb030604 	blx	c29b6 <DISABLE_IRQ+0xc2936>
    11a0:	044b2e76 	strbeq	r2, [fp], #-3702	; 0xe76
    11a4:	08e50301 	stmiaeq	r5!, {r0, r8, r9}^
    11a8:	046a2d2e 	strbteq	r2, [sl], #-3374	; 0xd2e
    11ac:	77a40306 	strvc	r0, [r4, r6, lsl #6]!
    11b0:	034b2f4a 	movteq	r2, #48970	; 0xbf4a
    11b4:	652f2e52 	strvs	r2, [pc, #-3666]!	; 36a <DISABLE_IRQ+0x2ea>
    11b8:	4d4a2303 	stclmi	3, cr2, [sl, #-12]
    11bc:	2f2f302c 	svccs	0x002f302c
    11c0:	2f2e6a03 	svccs	0x002e6a03
    11c4:	2e0c034b 	cdpcs	3, 0, cr0, cr12, cr11, {2}
    11c8:	ba078703 	blt	1e2ddc <DISABLE_IRQ+0x1e2d5c>
    11cc:	03ba1d03 	undefined instruction 0x03ba1d03
    11d0:	2f832e6e 	svccs	0x00832e6e
    11d4:	d932474d 	ldmdble	r2!, {r0, r2, r3, r6, r8, r9, sl, lr}
    11d8:	304b302c 	subcc	r3, fp, ip, lsr #32
    11dc:	4b682f2d 	blmi	1a0ce98 <MEM_SIZE+0x120ce98>
    11e0:	032f2b4d 	teqeq	pc, #78848	; 0x13400
    11e4:	11036676 	tstne	r3, r6, ror r6
    11e8:	09042f4a 	stmdbeq	r4, {r1, r3, r6, r8, r9, sl, fp, sp}
    11ec:	8278ce03 	rsbshi	ip, r8, #48	; 0x30
    11f0:	032e0a03 	teqeq	lr, #12288	; 0x3000
    11f4:	032e2e76 	teqeq	lr, #1888	; 0x760
    11f8:	2f312e0a 	svccs	0x00312e0a
    11fc:	494b3349 	stmdbmi	fp, {r0, r3, r6, r8, r9, ip, sp}^
    1200:	032e3e03 	teqeq	lr, #48	; 0x30
    1204:	49678246 	stmdbmi	r7!, {r1, r2, r6, r9, pc}^
    1208:	4a650332 	bmi	1941ed8 <MEM_SIZE+0x1141ed8>
    120c:	032e2103 	teqeq	lr, #-1073741824	; 0xc0000000
    1210:	21032e5f 	tstcs	r3, pc, asr lr
    1214:	2e7a034a 	cdpcs	3, 7, cr0, cr10, cr10, {2}
    1218:	2a503034 	bcs	140d2f0 <MEM_SIZE+0xc0d2f0>
    121c:	2f2f304b 	svccs	0x002f304b
    1220:	2f2f302d 	svccs	0x002f302d
    1224:	03667403 	cmneq	r6, #50331648	; 0x3000000
    1228:	032f4a2a 	teqeq	pc, #172032	; 0x2a000
    122c:	6c2f6664 	stcvs	6, cr6, [pc], #-400	; 0xfffffe70
    1230:	316b814b 	cmncc	fp, fp, asr #2
    1234:	2f304b2a 	svccs	0x00304b2a
    1238:	2d312d2f 	ldccs	13, cr2, [r1, #-188]!	; 0xffffff44
    123c:	4c4d2f2f 	mcrrmi	15, 2, r2, sp, cr15
    1240:	0304042a 	movweq	r0, #17450	; 0x442a
    1244:	03820382 	orreq	r0, r2, #134217730	; 0x8000002
    1248:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
    124c:	4a09032e 	bmi	241f0c <DISABLE_IRQ+0x241e8c>
    1250:	8226034e 	eorhi	r0, r6, #939524097	; 0x38000001
    1254:	2f4a5d03 	svccs	0x004a5d03
    1258:	4c4b2f2d 	mcrrmi	15, 2, r2, fp, cr13
    125c:	034b6c81 	movteq	r6, #48257	; 0xbc81
    1260:	032f4a17 	teqeq	pc, #94208	; 0x17000
    1264:	862f2e6d 	strthi	r2, [pc], -sp, ror #28
    1268:	2c30674b 	ldccs	7, cr6, [r0], #-300	; 0xfffffed4
    126c:	4b362d31 	blmi	d8c738 <MEM_SIZE+0x58c738>
    1270:	4b827003 	blmi	fe09d284 <rEINTPEND+0xa809d1dc>
    1274:	622e7903 	eorvs	r7, lr, #49152	; 0xc000
    1278:	2f9e1403 	svccs	0x009e1403
    127c:	302d2f2d 	eorcc	r2, sp, sp, lsr #30
    1280:	667f8003 	ldrbtvs	r8, [pc], -r3
    1284:	032e0903 	teqeq	lr, #49152	; 0xc000
    1288:	09032e77 	stmdbeq	r3, {r0, r1, r2, r4, r5, r6, r9, sl, fp, sp}
    128c:	17034e2e 	strne	r4, [r3, -lr, lsr #28]
    1290:	666c0382 	strbtvs	r0, [ip], -r2, lsl #7
    1294:	6c2f2d4b 	stcvs	13, cr2, [pc], #-300	; 0xfffffed4
    1298:	294f862f 	stmdbcs	pc, {r0, r1, r2, r3, r5, r9, sl, pc}^
    129c:	2c2c322f 	sfmcs	f3, 4, [ip], #-188	; (stccs 2, cr3, [ip], #-188)	; 0xffffff44
    12a0:	67312d31 	undefined instruction 0x67312d31
    12a4:	4b2e7603 	blmi	b9eab8 <MEM_SIZE+0x39eab8>
    12a8:	672e7803 	strvs	r7, [lr, -r3, lsl #16]!
    12ac:	ae034b4b 	vmlsge.f64	d4, d3, d11
    12b0:	09032e7f 	stmdbeq	r3, {r0, r1, r2, r3, r4, r5, r6, r9, sl, fp, sp}
    12b4:	2e77032e 	cdpcs	3, 7, cr0, cr7, cr14, {1}
    12b8:	4e2e0903 	cdpmi	9, 2, cr0, cr14, cr3, {0}
    12bc:	03821603 	orreq	r1, r2, #3145728	; 0x300000
    12c0:	2d4b666d 	stclcs	6, cr6, [fp, #-436]	; 0xfffffe4c
    12c4:	862f6c2f 	strthi	r6, [pc], -pc, lsr #24
    12c8:	2d302c30 	ldccs	12, cr2, [r0, #-192]!	; 0xffffff40
    12cc:	30312b4c 	eorscc	r2, r1, ip, asr #22
    12d0:	2e770367 	cdpcs	3, 7, cr0, cr7, cr7, {3}
    12d4:	2e78034b 	cdpcs	3, 7, cr0, cr8, cr11, {2}
    12d8:	034b4b67 	movteq	r4, #47975	; 0xbb67
    12dc:	032e7f96 	teqeq	lr, #600	; 0x258
    12e0:	76032e0a 	strvc	r2, [r3], -sl, lsl #28
    12e4:	4a0a032e 	bmi	281fa4 <DISABLE_IRQ+0x281f24>
    12e8:	32492f4d 	subcc	r2, r9, #308	; 0x134
    12ec:	6733654b 	ldrvs	r6, [r3, -fp, asr #10]!
    12f0:	65673249 	strbvs	r3, [r7, #-585]!	; 0x249
    12f4:	672f2f32 	undefined instruction 0x672f2f32
    12f8:	2f2f2c30 	svccs	0x002f2c30
    12fc:	302c312c 	eorcc	r3, ip, ip, lsr #2
    1300:	17032f30 	smladxne	r3, r0, pc, r2
    1304:	666c034a 	strbtvs	r0, [ip], -sl, asr #6
    1308:	be030104 	adflts	f0, f3, f4
    130c:	04042e02 	streq	r2, [r4], #-3586	; 0xe02
    1310:	2e7dc203 	cdpcs	2, 7, cr12, cr13, cr3, {0}
    1314:	be030104 	adflts	f0, f3, f4
    1318:	04044a02 	streq	r4, [r4], #-2562	; 0xa02
    131c:	2e7dc203 	cdpcs	2, 7, cr12, cr13, cr3, {0}
    1320:	01042f4b 	tsteq	r4, fp, asr #30
    1324:	2e02ba03 	vmlacs.f32	s22, s4, s6
    1328:	302d6730 	eorcc	r6, sp, r0, lsr r7
    132c:	4b2d9fa0 	blmi	b691b4 <MEM_SIZE+0x3691b4>
    1330:	c1030404 	tstgt	r3, r4, lsl #8
    1334:	2f2f667d 	svccs	0x002f667d
    1338:	6d2f2d2f 	stcvs	13, cr2, [pc, #-188]!	; 0xffffff44
    133c:	2d2d312d 	stfcss	f3, [sp, #-180]!	; 0xffffff4c
    1340:	042f2f31 	strteq	r2, [pc], #3889	; 1348 <DISABLE_IRQ+0x12c8>
    1344:	02c90301 	sbceq	r0, r9, #67108864	; 0x4000000
    1348:	842fd72e 	strthi	sp, [pc], #1838	; 1350 <DISABLE_IRQ+0x12d0>
    134c:	042f2c30 	strteq	r2, [pc], #3120	; 1354 <DISABLE_IRQ+0x12d4>
    1350:	7da80304 	stcvc	3, cr0, [r8, #16]!
    1354:	034b4b2e 	movteq	r4, #47918	; 0xbb2e
    1358:	03ba7e9c 	undefined instruction 0x03ba7e9c
    135c:	75032e0b 	strvc	r2, [r3, #-3595]	; 0xe0b
    1360:	0b032e2e 	bleq	ccc20 <DISABLE_IRQ+0xccba0>
    1364:	492f312e 	stmdbmi	pc!, {r1, r2, r3, r5, r8, ip, sp}
    1368:	03494b33 	movteq	r4, #39731	; 0x9b33
    136c:	032e00c4 	teqeq	lr, #196	; 0xc4
    1370:	49678240 	stmdbmi	r7!, {r6, r9, pc}^
    1374:	4a640332 	bmi	1902044 <MEM_SIZE+0x1102044>
    1378:	032e2203 	teqeq	lr, #805306368	; 0x30000000
    137c:	22032e5e 	andcs	r2, r3, #1504	; 0x5e0
    1380:	2e7a034a 	cdpcs	3, 7, cr0, cr10, cr10, {2}
    1384:	2a503034 	bcs	140d45c <MEM_SIZE+0xc0d45c>
    1388:	312f304b 	teqcc	pc, fp, asr #32
    138c:	2f2f2f2b 	svccs	0x002f2f2b
    1390:	2f302d2f 	svccs	0x00302d2f
    1394:	6671032f 	ldrbtvs	r0, [r1], -pc, lsr #6
    1398:	2f4a3003 	svccs	0x004a3003
    139c:	2f666103 	svccs	0x00666103
    13a0:	6b814b6c 	blvs	fe054158 <rEINTPEND+0xa80540b0>
    13a4:	304b2a31 	subcc	r2, fp, r1, lsr sl
    13a8:	2f2b312f 	svccs	0x002b312f
    13ac:	2d2f2f2f 	stccs	15, cr2, [pc, #-188]!	; 0xffffff44
    13b0:	2f2f2d31 	svccs	0x002f2d31
    13b4:	042a4c4d 	strteq	r4, [sl], #-3149	; 0xc4d
    13b8:	01f7030a 	mvnseq	r0, sl, lsl #6
    13bc:	2e09039e 	mcrcs	3, 0, r0, cr9, cr14, {4}
    13c0:	032e7703 	teqeq	lr, #786432	; 0xc0000
    13c4:	6a862e09 	bvs	fe18cbf0 <rEINTPEND+0xa818cb48>
    13c8:	03822203 	orreq	r2, r2, #805306368	; 0x30000000
    13cc:	63314a61 	teqvs	r1, #397312	; 0x61000
    13d0:	2f302c31 	svccs	0x00302c31
    13d4:	7a03304b 	bvc	cd508 <DISABLE_IRQ+0xcd488>
    13d8:	4b69342e 	blmi	1a4e498 <MEM_SIZE+0x124e498>
    13dc:	2d2f8468 	cfstrscs	mvf8, [pc, #-416]!	; 0xfffffe60
    13e0:	2f2c2f2f 	svccs	0x002c2f2f
    13e4:	4b2f302d 	blmi	bcd4a0 <MEM_SIZE+0x3cd4a0>
    13e8:	2d2f354b 	cfstr32cs	mvfx3, [pc, #-300]!	; 0xfffffed4
    13ec:	dc03674c 	stcle	7, cr6, [r3], {76}	; 0x4c
    13f0:	038a2e00 	orreq	r2, sl, #0
    13f4:	2f2f2e78 	svccs	0x002f2e78
    13f8:	8603302c 	strhi	r3, [r3], -ip, lsr #32
    13fc:	fe034a7f 	mcr2	10, 0, r4, cr3, cr15, {3}
    1400:	33462e00 	movtcc	r2, #28160	; 0x6e00
    1404:	79032d30 	stmdbvc	r3, {r4, r5, r8, sl, fp, sp}
    1408:	032d362e 	teqeq	sp, #48234496	; 0x2e00000
    140c:	332f2e79 	teqcc	pc, #1936	; 0x790
    1410:	30292f2f 	eorcc	r2, r9, pc, lsr #30
    1414:	2f2e0b03 	svccs	0x002e0b03
    1418:	30492f2c 	subcc	r2, r9, ip, lsr #30
    141c:	4a7f8a03 	bmi	1fe3c30 <MEM_SIZE+0x17e3c30>
    1420:	ca034b4b 	bgt	d4154 <DISABLE_IRQ+0xd40d4>
    1424:	0e03ba7e 	mcreq	10, 0, fp, cr3, cr14, {3}
    1428:	2e72032e 	cdpcs	3, 7, cr0, cr2, cr14, {1}
    142c:	2e0e032e 	cdpcs	3, 0, cr0, cr14, cr14, {1}
    1430:	33492f31 	movtcc	r2, #40753	; 0x9f31
    1434:	d903494b 	stmdble	r3, {r0, r1, r3, r6, r8, fp, lr}
    1438:	ab032e00 	blge	ccc40 <DISABLE_IRQ+0xccbc0>
    143c:	4967667f 	stmdbmi	r7!, {r0, r1, r2, r3, r4, r5, r6, r9, sl, sp, lr}^
    1440:	32496732 	subcc	r6, r9, #13107200	; 0xc80000
    1444:	48312d4b 	ldmdami	r1!, {r0, r1, r3, r6, r8, sl, fp, sp}
    1448:	4a0e0330 	bmi	382110 <DISABLE_IRQ+0x382090>
    144c:	bbbc672f 	bllt	fef1b110 <rEINTPEND+0xa8f1b068>
    1450:	2f2f2d2f 	svccs	0x002f2d2f
    1454:	4c9e0f03 	ldcmi	15, cr0, [lr], {3}
    1458:	302b2f2d 	eorcc	r2, fp, sp, lsr #30
    145c:	2f30452f 	svccs	0x0030452f
    1460:	2f2f2d2f 	svccs	0x002f2d2f
    1464:	2e780336 	mrccs	3, 3, r0, cr8, cr6, {1}
    1468:	492e0903 	stmdbmi	lr!, {r0, r1, r8, fp}
    146c:	5803522f 	stmdapl	r3, {r0, r1, r2, r3, r5, r9, ip, lr}
    1470:	662b0366 	strtvs	r0, [fp], -r6, ror #6
    1474:	03010467 	movweq	r0, #5223	; 0x1467
    1478:	044a0280 	strbeq	r0, [sl], #-640	; 0x280
    147c:	7e80030a 	cdpvc	3, 8, cr0, cr0, cr10, {0}
    1480:	01042f2e 	tsteq	r4, lr, lsr #30
    1484:	2e01fd03 	cdpcs	13, 0, cr15, cr1, cr3, {0}
    1488:	302d6730 	eorcc	r6, sp, r0, lsr r7
    148c:	4b2d9fa0 	blmi	b69314 <MEM_SIZE+0x369314>
    1490:	fe030a04 	cdp2	10, 0, cr0, cr3, cr4, {0}
    1494:	01042e7d 	tsteq	r4, sp, ror lr
    1498:	2e028203 	cdpcs	2, 0, cr8, cr2, cr3, {0}
    149c:	fe030a04 	cdp2	10, 0, cr0, cr3, cr4, {0}
    14a0:	2f2f4a7d 	svccs	0x002f4a7d
    14a4:	042f2d2f 	strteq	r2, [pc], #3375	; 14ac <DISABLE_IRQ+0x142c>
    14a8:	02980301 	addseq	r0, r8, #67108864	; 0x4000000
    14ac:	842fd766 	strthi	sp, [pc], #1894	; 14b4 <DISABLE_IRQ+0x1434>
    14b0:	042f2c30 	strteq	r2, [pc], #3120	; 14b8 <DISABLE_IRQ+0x1438>
    14b4:	7de5030a 	stclvc	3, cr0, [r5, #40]!	; 0x28
    14b8:	304b4b2e 	subcc	r4, fp, lr, lsr #22
    14bc:	b9032f4b 	stmdblt	r3, {r0, r1, r3, r6, r8, r9, sl, fp, sp}
    14c0:	2f2d4a7f 	svccs	0x002d4a7f
    14c4:	2d2f2f2d 	stccs	15, cr2, [pc, #-180]!	; 0xffffff4c
    14c8:	682f674c 	stmdavs	pc!, {r2, r3, r6, r8, r9, sl, sp, lr}
    14cc:	4a10032f 	bmi	402190 <DISABLE_IRQ+0x402110>
    14d0:	a5bb4b2f 	ldrge	r4, [fp, #2863]!	; 0xb2f
    14d4:	2d304930 	ldccs	9, cr4, [r0, #-192]!	; 0xffffff40
    14d8:	032e0d03 	teqeq	lr, #192	; 0xc0
    14dc:	30292e74 	eorcc	r2, r9, r4, ror lr
    14e0:	0d032f2f 	stceq	15, cr2, [r3, #-188]	; 0xffffff44
    14e4:	03672f2e 	cmneq	r7, #184	; 0xb8
    14e8:	b603f268 	strlt	pc, [r3], -r8, ror #4
    14ec:	0320087e 	teqeq	r0, #8257536	; 0x7e0000
    14f0:	73032e0d 	movwvc	r2, #15885	; 0x3e0d
    14f4:	4a0d032e 	bmi	3421b4 <DISABLE_IRQ+0x342134>
    14f8:	33492f4d 	movtcc	r2, #40781	; 0x9f4d
    14fc:	ca03494b 	bgt	d3a30 <DISABLE_IRQ+0xd39b0>
    1500:	ba032e00 	blt	ccd08 <DISABLE_IRQ+0xccc88>
    1504:	4967827f 	stmdbmi	r7!, {r0, r1, r2, r3, r4, r5, r6, r9, pc}^
    1508:	29334b32 	ldmdbcs	r3!, {r1, r4, r5, r8, r9, fp, lr}
    150c:	2e7a034f 	cdpcs	3, 7, cr0, cr10, cr15, {2}
    1510:	2a503034 	bcs	140d5e8 <MEM_SIZE+0xc0d5e8>
    1514:	2b2c304e 	blcs	b0d654 <MEM_SIZE+0x30d654>
    1518:	2f2f2f31 	svccs	0x002f2f31
    151c:	2f2f302d 	svccs	0x002f302d
    1520:	03667203 	cmneq	r6, #805306368	; 0x30000000
    1524:	032f4a36 	teqeq	pc, #221184	; 0x36000
    1528:	6e2f665a 	mcrvs	6, 1, r6, cr15, cr10, {2}
    152c:	a34b312c 	movtge	r3, #45356	; 0xb12c
    1530:	332b6e81 	teqcc	fp, #2064	; 0x810
    1534:	314b2a2c 	cmpcc	fp, ip, lsr #20
    1538:	2d2f2f2f 	stccs	15, cr2, [pc, #-188]!	; 0xffffff44
    153c:	2f2f2d31 	svccs	0x002f2d31
    1540:	cb034c4d 	blgt	d467c <DISABLE_IRQ+0xd45fc>
    1544:	03892e02 	orreq	r2, r9, #32
    1548:	2f2f2e79 	svccs	0x002f2e79
    154c:	9903302c 	stmdbls	r3, {r2, r3, r5, ip, sp}
    1550:	e7034a7d 	smlsdx	r3, sp, sl, r4
    1554:	4c322e02 	ldcmi	14, cr2, [r2], #-8
    1558:	79032d2f 	stmdbvc	r3, {r0, r1, r2, r3, r5, r8, sl, fp, sp}
    155c:	032d362e 	teqeq	sp, #48234496	; 0x2e00000
    1560:	332f2e79 	teqcc	pc, #1936	; 0x790
    1564:	30292f2f 	eorcc	r2, r9, pc, lsr #30
    1568:	2f2e0b03 	svccs	0x002e0b03
    156c:	30492f2c 	subcc	r2, r9, ip, lsr #30
    1570:	667d9f03 	ldrbtvs	r9, [sp], -r3, lsl #30
    1574:	d3030b04 	movwle	r0, #15108	; 0x3b04
    1578:	0336d600 	teqeq	r6, #0
    157c:	4d522e78 	ldclmi	14, cr2, [r2, #-480]	; 0xfffffe20
    1580:	8219036a 	andshi	r0, r9, #-1476395007	; 0xa8000001
    1584:	2f4a6a03 	svccs	0x004a6a03
    1588:	4c4b2f2d 	mcrrmi	15, 2, r2, fp, cr13
    158c:	674b6c81 	strbvs	r6, [fp, -r1, lsl #25]
    1590:	034b676a 	movteq	r6, #46954	; 0xb76a
    1594:	0c032e76 	stceq	14, cr2, [r3], {118}	; 0x76
    1598:	034b2f9e 	movteq	r2, #49054	; 0xbf9e
    159c:	362e7f95 	qadd8cc	r7, lr, r5
    15a0:	362e7803 	strtcc	r7, [lr], -r3, lsl #16
    15a4:	11036a4d 	tstne	r3, sp, asr #20
    15a8:	66720382 	ldrbtvs	r0, [r2], -r2, lsl #7
    15ac:	6c2f2d4b 	stcvs	13, cr2, [pc], #-300	; 0xfffffed4
    15b0:	79034b67 	stmdbvc	r3, {r0, r1, r2, r5, r6, r8, r9, fp, lr}
    15b4:	4b4b672e 	blmi	12db274 <MEM_SIZE+0xadb274>
    15b8:	034b2f34 	movteq	r2, #48948	; 0xbf34
    15bc:	032e7f8e 	teqeq	lr, #568	; 0x238
    15c0:	77032e09 	strvc	r2, [r3, -r9, lsl #28]
    15c4:	4a09032e 	bmi	242284 <DISABLE_IRQ+0x242204>
    15c8:	33652f4d 	cmncc	r5, #308	; 0x134
    15cc:	6732654b 	ldrvs	r6, [r2, -fp, asr #10]!
    15d0:	49673265 	stmdbmi	r7!, {r0, r2, r5, r6, r9, ip, sp}^
    15d4:	302d2f32 	eorcc	r2, sp, r2, lsr pc
    15d8:	032f2f4b 	teqeq	pc, #300	; 0x12c
    15dc:	6c032e17 	stcvs	14, cr2, [r3], {23}
    15e0:	03010466 	movweq	r0, #5222	; 0x1466
    15e4:	042e03b6 	strteq	r0, [lr], #-950	; 0x3b6
    15e8:	7cca030b 	stclvc	3, cr0, [sl], {11}
    15ec:	0301042e 	movweq	r0, #5166	; 0x142e
    15f0:	044a03b6 	strbeq	r0, [sl], #-950	; 0x3b6
    15f4:	7cca030b 	stclvc	3, cr0, [sl], {11}
    15f8:	042d4c2e 	strteq	r4, [sp], #-3118	; 0xc2e
    15fc:	03b30301 	undefined instruction 0x03b30301
    1600:	2d67302e 	stclcs	0, cr3, [r7, #-184]!	; 0xffffff48
    1604:	2d9fa030 	ldccs	0, cr10, [pc, #192]	; 0xc0
    1608:	030b044b 	movweq	r0, #46155	; 0xb44b
    160c:	042e7cc9 	strteq	r7, [lr], #-3273	; 0xcc9
    1610:	03b70301 	undefined instruction 0x03b70301
    1614:	030b042e 	movweq	r0, #46126	; 0xb42e
    1618:	2f4a7cc9 	svccs	0x004a7cc9
    161c:	2f2d2f2f 	svccs	0x002d2f2f
    1620:	2d312d6d 	ldccs	13, cr2, [r1, #-436]!	; 0xfffffe4c
    1624:	2f2f312d 	svccs	0x002f312d
    1628:	c1030104 	tstgt	r3, r4, lsl #2
    162c:	2fd72e03 	svccs	0x00d72e03
    1630:	2f2c3084 	svccs	0x002c3084
    1634:	b0030b04 	andlt	r0, r3, r4, lsl #22
    1638:	4b4b2e7c 	blmi	12cd030 <MEM_SIZE+0xacd030>
    163c:	ba7edc03 	blt	1fb8650 <MEM_SIZE+0x17b8650>
    1640:	032e0a03 	teqeq	lr, #12288	; 0x3000
    1644:	032e2e76 	teqeq	lr, #1888	; 0x760
    1648:	2f312e0a 	svccs	0x00312e0a
    164c:	494b3349 	stmdbmi	fp, {r0, r3, r6, r8, r9, ip, sp}^
    1650:	032e3e03 	teqeq	lr, #48	; 0x30
    1654:	49678246 	stmdbmi	r7!, {r1, r2, r6, r9, pc}^
    1658:	4a650332 	bmi	1942328 <MEM_SIZE+0x1142328>
    165c:	032e2103 	teqeq	lr, #-1073741824	; 0xc0000000
    1660:	21032e5f 	tstcs	r3, pc, asr lr
    1664:	2e7a034a 	cdpcs	3, 7, cr0, cr10, cr10, {2}
    1668:	2a503034 	bcs	140d740 <MEM_SIZE+0xc0d740>
    166c:	2f2f304b 	svccs	0x002f304b
    1670:	2f2f302d 	svccs	0x002f302d
    1674:	03667403 	cmneq	r6, #50331648	; 0x3000000
    1678:	032f4a2a 	teqeq	pc, #172032	; 0x2a000
    167c:	6c2f6664 	stcvs	6, cr6, [pc], #-400	; 0xfffffe70
    1680:	316b814b 	cmncc	fp, fp, asr #2
    1684:	2f304b2a 	svccs	0x00304b2a
    1688:	2d312d2f 	ldccs	13, cr2, [r1, #-188]!	; 0xffffff44
    168c:	4c4d2f2f 	mcrrmi	15, 2, r2, sp, cr15
    1690:	0302042a 	movweq	r0, #9258	; 0x242a
    1694:	038204ab 	orreq	r0, r2, #-1426063360	; 0xab000000
    1698:	73032e0d 	movwvc	r2, #15885	; 0x3e0d
    169c:	4a0d032e 	bmi	34235c <DISABLE_IRQ+0x3422dc>
    16a0:	33492f4d 	movtcc	r2, #40781	; 0x9f4d
    16a4:	d103654b 	tstle	r3, fp, asr #10
    16a8:	b4032e00 	strlt	r2, [r3], #-3584	; 0xe00
    16ac:	2d67827f 	sfmcs	f0, 3, [r7, #-508]!	; (stclcs 2, cr8, [r7, #-508]!)	; 0xfffffe04
    16b0:	0d03682f 	stceq	8, cr6, [r3, #-188]	; 0xffffff44
    16b4:	03672f66 	cmneq	r7, #408	; 0x198
    16b8:	034bf20c 	movteq	pc, #45580	; 0xb20c
    16bc:	50034a22 	andpl	r4, r3, r2, lsr #20
    16c0:	4a32032e 	bmi	c82380 <MEM_SIZE+0x482380>
    16c4:	2f2f4d4b 	svccs	0x002f4d4b
    16c8:	49034b2f 	stmdbmi	r3, {r0, r1, r2, r3, r5, r8, r9, fp, lr}
    16cc:	9e21032e 	cdpls	3, 2, cr0, cr1, cr14, {1}
    16d0:	2e09034b 	cdpcs	3, 0, cr0, cr9, cr11, {2}
    16d4:	4b4a7403 	blmi	129e6e8 <MEM_SIZE+0xa9e6e8>
    16d8:	03667503 	cmneq	r6, #12582912	; 0xc00000
    16dc:	674bba14 	smlaldvs	fp, fp, r4, sl
    16e0:	032e4203 	teqeq	lr, #805306368	; 0x30000000
    16e4:	672f4a0a 	strvs	r4, [pc, -sl, lsl #20]!
    16e8:	672e7a03 	strvs	r7, [lr, -r3, lsl #20]!
    16ec:	682e3b03 	stmdavs	lr!, {r0, r1, r8, r9, fp, ip, sp}
    16f0:	4a7dc203 	bmi	1f71f04 <MEM_SIZE+0x1771f04>
    16f4:	4a0c034a 	bmi	302424 <DISABLE_IRQ+0x3023a4>
    16f8:	032e7403 	teqeq	lr, #50331648	; 0x3000000
    16fc:	2f4d4a0c 	svccs	0x004d4a0c
    1700:	65673365 	strbvs	r3, [r7, #-869]!	; 0x365
    1704:	32496732 	subcc	r6, r9, #13107200	; 0xc80000
    1708:	f803654b 	undefined instruction 0xf803654b
    170c:	8d032e00 	stchi	14, cr2, [r3]
    1710:	0335827f 	teqeq	r5, #-268435449	; 0xf0000007
    1714:	2f502e7a 	svccs	0x00502e7a
    1718:	12032f2d 	andne	r2, r3, #180	; 0xb4
    171c:	2f4b2fd6 	svccs	0x004b2fd6
    1720:	2f4a2303 	svccs	0x004a2303
    1724:	4b2f4b2d 	blmi	bd43e0 <MEM_SIZE+0x3d43e0>
    1728:	4b2e4703 	blmi	b9333c <MEM_SIZE+0x39333c>
    172c:	1e032f4b 	cdpne	15, 0, cr2, cr3, cr11, {2}
    1730:	2f4b4b66 	svccs	0x004b4b66
    1734:	2f660d03 	svccs	0x00660d03
    1738:	0e032f4b 	cdpeq	15, 0, cr2, cr3, cr11, {2}
    173c:	03673066 	cmneq	r7, #102	; 0x66
    1740:	03bb2e66 	undefined instruction 0x03bb2e66
    1744:	2f2f4a1b 	svccs	0x002f4a1b
    1748:	2d9e0a03 	vldrcs	s0, [lr, #12]
    174c:	03d92f2f 	bicseq	r2, r9, #188	; 0xbc
    1750:	4b2f660f 	blmi	bdaf94 <MEM_SIZE+0x3daf94>
    1754:	2f2e7903 	svccs	0x002e7903
    1758:	2e7a0367 	cdpcs	3, 7, cr0, cr10, cr7, {3}
    175c:	7fac0367 	svcvc	0x00ac0367
    1760:	034cbb2e 	movteq	fp, #52014	; 0xcb2e
    1764:	d2032e3d 	andle	r2, r3, #976	; 0x3d0
    1768:	2f2f4a03 	svccs	0x002f4a03
    176c:	2f2f2d52 	svccs	0x002f2d52
    1770:	7ca00333 	stcvc	3, cr0, [r0], #204	; 0xcc
    1774:	03e0034a 	mvneq	r0, #671088641	; 0x28000001
    1778:	7ca1032e 	stcvc	3, cr0, [r1], #184	; 0xb8
    177c:	034b302e 	movteq	r3, #45102	; 0xb02e
    1780:	4cbb2e6b 	ldcmi	14, cr2, [fp], #428	; 0x1ac
    1784:	bb2e5c03 	bllt	b98798 <MEM_SIZE+0x398798>
    1788:	0483034c 	streq	r0, [r3], #844	; 0x34c
    178c:	2f2d2f2e 	svccs	0x002d2f2e
    1790:	9e79a603 	cdpls	6, 7, cr10, cr9, cr3, {0}
    1794:	032e0b03 	teqeq	lr, #3072	; 0xc00
    1798:	032e2e75 	teqeq	lr, #1872	; 0x750
    179c:	2f312e0b 	svccs	0x00312e0b
    17a0:	49673349 	stmdbmi	r7!, {r0, r3, r6, r8, r9, ip, sp}^
    17a4:	03494b32 	movteq	r4, #39730	; 0x9b32
    17a8:	48032e3c 	stmdami	r3, {r2, r3, r4, r5, r9, sl, fp, sp}
    17ac:	29334b82 	ldmdbcs	r3!, {r1, r7, r8, r9, fp, lr}
    17b0:	2e7a034f 	cdpcs	3, 7, cr0, cr10, cr15, {2}
    17b4:	2a503034 	bcs	140d88c <MEM_SIZE+0xc0d88c>
    17b8:	2f2f304b 	svccs	0x002f304b
    17bc:	2f2f302d 	svccs	0x002f302d
    17c0:	03667403 	cmneq	r6, #50331648	; 0x3000000
    17c4:	032f4a2c 	teqeq	pc, #180224	; 0x2c000
    17c8:	674b666a 	strbvs	r6, [fp, -sl, ror #12]
    17cc:	2a31502c 	bcs	c55884 <MEM_SIZE+0x455884>
    17d0:	2f2f304b 	svccs	0x002f304b
    17d4:	2f2d312d 	svccs	0x002d312d
    17d8:	034c4d2f 	movteq	r4, #52527	; 0xcd2f
    17dc:	032f2e66 	teqeq	pc, #1632	; 0x660
    17e0:	01046615 	tsteq	r4, r5, lsl r6
    17e4:	35823f03 	strcc	r3, [r2, #3843]	; 0xf03
    17e8:	03821203 	orreq	r1, r2, #805306368	; 0x30000000
    17ec:	832f4a6f 	teqhi	pc, #454656	; 0x6f000
    17f0:	2f2f2d4b 	svccs	0x002f2d4b
    17f4:	2e0c0383 	cdpcs	3, 0, cr0, cr12, cr3, {4}
    17f8:	362e7503 	strtcc	r7, [lr], -r3, lsl #10
    17fc:	9e00de03 	cdpls	14, 0, cr13, cr0, cr3, {0}
    1800:	312e0c03 	teqcc	lr, r3, lsl #24
    1804:	0330832f 	teqeq	r0, #-1140850688	; 0xbc000000
    1808:	52038230 	andpl	r8, r3, #3
    180c:	ba10034a 	blt	40253c <DISABLE_IRQ+0x4024bc>
    1810:	0d034b51 	vstreq	d4, [r3, #-324]	; 0xfffffebc
    1814:	79032f66 	stmdbvc	r3, {r1, r2, r5, r6, r8, r9, sl, fp, sp}
    1818:	2e7a032e 	cdpcs	3, 7, cr0, cr10, cr14, {1}
    181c:	2f492f2f 	svccs	0x00492f2f
    1820:	4b682f2d 	blmi	1a0d4dc <MEM_SIZE+0x120d4dc>
    1824:	4b31304b 	blmi	c4d958 <MEM_SIZE+0x44d958>
    1828:	032fa283 	teqeq	pc, #805306376	; 0x30000008
    182c:	91032e6d 	tstls	r3, sp, ror #28
    1830:	2f3c087f 	svccs	0x003c087f
    1834:	82068a03 	andhi	r8, r6, #12288	; 0x3000
    1838:	032f2d67 	teqeq	pc, #6592	; 0x19c0
    183c:	038279f8 	orreq	r7, r2, #4063232	; 0x3e0000
    1840:	032e0688 	teqeq	lr, #142606336	; 0x8800000
    1844:	032e79f8 	teqeq	lr, #4063232	; 0x3e0000
    1848:	032e0688 	teqeq	lr, #142606336	; 0x8800000
    184c:	482e79f9 	stmdami	lr!, {r0, r3, r4, r5, r6, r7, r8, fp, ip, sp, lr}
    1850:	03304c4b 	teqeq	r0, #19200	; 0x4b00
    1854:	58087ef2 	stmdapl	r8, {r1, r4, r5, r6, r7, r9, sl, fp, ip, sp, lr}
    1858:	82140335 	andshi	r0, r4, #-738197504	; 0xd4000000
    185c:	2f4a6d03 	svccs	0x004a6d03
    1860:	4c672f2d 	stclmi	15, cr2, [r7], #-180	; 0xffffff4c
    1864:	0d03302c 	stceq	0, cr3, [r3, #-176]	; 0xffffff50
    1868:	6674032e 	ldrbtvs	r0, [r4], -lr, lsr #6
    186c:	82078403 	andhi	r8, r7, #50331648	; 0x3000000
    1870:	032f2d67 	teqeq	pc, #6592	; 0x19c0
    1874:	032e78fd 	teqeq	lr, #16580608	; 0xfd0000
    1878:	032e0783 	teqeq	lr, #34340864	; 0x20c0000
    187c:	032e78fd 	teqeq	lr, #16580608	; 0xfd0000
    1880:	032e0783 	teqeq	lr, #34340864	; 0x20c0000
    1884:	036678fd 	cmneq	r6, #16580608	; 0xfd0000
    1888:	032e0783 	teqeq	lr, #34340864	; 0x20c0000
    188c:	2f2e78fd 	svccs	0x002e78fd
    1890:	2c322a32 	ldccs	10, cr2, [r2], #-200	; 0xffffff38
    1894:	2a4c2c30 	bcs	130c95c <MEM_SIZE+0xb0c95c>
    1898:	7f8a034f 	svcvc	0x008a034f
    189c:	034c9008 	movteq	r9, #49160	; 0xc008
    18a0:	692e058b 	stmdbvs	lr!, {r0, r1, r3, r7, r8, sl}
    18a4:	2e270367 	cdpcs	3, 2, cr0, cr7, cr7, {3}
    18a8:	302e5903 	eorcc	r5, lr, r3, lsl #18
    18ac:	4d4b4c4c 	stclmi	12, cr4, [fp, #-304]	; 0xfffffed0
    18b0:	1b034b4b 	blne	d45e4 <DISABLE_IRQ+0xd4564>
    18b4:	2f654d4a 	svccs	0x00654d4a
    18b8:	3167322d 	cmncc	r7, sp, lsr #4
    18bc:	034b302b 	movteq	r3, #45099	; 0xb02b
    18c0:	494a01c9 	stmdbmi	sl, {r0, r3, r6, r7, r8}^
    18c4:	f5036583 	undefined instruction 0xf5036583
    18c8:	e6034a78 	undefined instruction 0xe6034a78
    18cc:	2b2f4a06 	blcs	bd40ec <MEM_SIZE+0x3d40ec>
    18d0:	03312f30 	teqeq	r1, #192	; 0xc0
    18d4:	2a322e79 	bcs	c8d2c0 <MEM_SIZE+0x48d2c0>
    18d8:	622e0f03 	eorvs	r0, lr, #12
    18dc:	292d2f4d 	pushcs	{r0, r2, r3, r6, r8, r9, sl, fp, sp}
    18e0:	2e1d0331 	mrccs	3, 0, r0, cr13, cr1, {1}
    18e4:	78f50365 	ldmvc	r5!, {r0, r2, r5, r6, r8, r9}^
    18e8:	04e2034a 	strbteq	r0, [r2], #842	; 0x34a
    18ec:	7b9e032e 	blvc	fe7825ac <rEINTPEND+0xa8782504>
    18f0:	04e5032e 	strbteq	r0, [r5], #814	; 0x32e
    18f4:	304b2b2e 	subcc	r2, fp, lr, lsr #22
    18f8:	7803312f 	stmdavc	r3, {r0, r1, r2, r3, r5, r8, ip, sp}
    18fc:	032a322e 	teqeq	sl, #-536870910	; 0xe0000002
    1900:	7a032e10 	bvc	cd148 <DISABLE_IRQ+0xcd0c8>
    1904:	2b332f2e 	blcs	ccd5c4 <MEM_SIZE+0x4cd5c4>
    1908:	7ba0032f 	blvc	fe8025cc <rEINTPEND+0xa8802524>
    190c:	0332322e 	teqeq	r2, #-536870910	; 0xe0000002
    1910:	032e05c6 	teqeq	lr, #830472192	; 0x31800000
    1914:	5d03d623 	stcpl	6, cr13, [r3, #-140]	; 0xffffff74
    1918:	d623032e 	strtle	r0, [r3], -lr, lsr #6
    191c:	03821f03 	orreq	r1, r2, #12
    1920:	03740823 	cmneq	r4, #2293760	; 0x230000
    1924:	328279de 	addcc	r7, r2, #3637248	; 0x378000
    1928:	00480234 	subeq	r0, r8, r4, lsr r2
    192c:	005f0101 	subseq	r0, pc, r1, lsl #2
    1930:	00020000 	andeq	r0, r2, r0
    1934:	00000030 	andeq	r0, r0, r0, lsr r0
    1938:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    193c:	0101000d 	tsteq	r1, sp
    1940:	00000101 	andeq	r0, r0, r1, lsl #2
    1944:	00000100 	andeq	r0, r0, r0, lsl #2
    1948:	00002e01 	andeq	r2, r0, r1, lsl #28
    194c:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
    1950:	7361745f 	cmnvc	r1, #1593835520	; 0x5f000000
    1954:	00632e6b 	rsbeq	r2, r3, fp, ror #28
    1958:	6f000000 	svcvs	0x00000000
    195c:	70635f73 	rsbvc	r5, r3, r3, ror pc
    1960:	00682e75 	rsbeq	r2, r8, r5, ror lr
    1964:	00000001 	andeq	r0, r0, r1
    1968:	8c020500 	cfstr32hi	mvfx0, [r2], {0}
    196c:	03300061 	teqeq	r0, #97	; 0x61
    1970:	2d13012f 	ldfcss	f0, [r3, #-188]	; 0xffffff44
    1974:	80306b2f 	eorshi	r6, r0, pc, lsr #22
    1978:	a0a03030 	adcge	r3, r0, r0, lsr r0
    197c:	20086603 	andcs	r6, r8, r3, lsl #12
    1980:	6e034b33 	vmovvs.16	d3[0], r4
    1984:	034b3382 	movteq	r3, #45954	; 0xb382
    1988:	4b33826f 	blmi	ce234c <MEM_SIZE+0x4e234c>
    198c:	01000802 	tsteq	r0, r2, lsl #16
    1990:	00006c01 	andeq	r6, r0, r1, lsl #24
    1994:	3c000200 	sfmcc	f0, 4, [r0], {0}	; (stccc 2, cr0, [r0], {0})
    1998:	02000000 	andeq	r0, r0, #0
    199c:	0d0efb01 	vstreq	d15, [lr, #-4]
    19a0:	01010100 	tsteq	r1, r0, lsl #2
    19a4:	00000001 	andeq	r0, r0, r1
    19a8:	01000001 	tsteq	r0, r1
    19ac:	7400002e 	strvc	r0, [r0], #-46	; 0x2e
    19b0:	5f747365 	svcpl	0x00747365
    19b4:	2e6d6573 	mcrcs	5, 3, r6, cr13, cr3, {3}
    19b8:	00000063 	andeq	r0, r0, r3, rrx
    19bc:	5f736f00 	svcpl	0x00736f00
    19c0:	2e757063 	cdpcs	0, 7, cr7, cr5, cr3, {3}
    19c4:	00010068 	andeq	r0, r1, r8, rrx
    19c8:	6f637500 	svcvs	0x00637500
    19cc:	69695f73 	stmdbvs	r9!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    19d0:	0000682e 	andeq	r6, r0, lr, lsr #16
    19d4:	00000000 	andeq	r0, r0, r0
    19d8:	625c0205 	subsvs	r0, ip, #1342177280	; 0x50000000
    19dc:	2c033000 	stccs	0, cr3, [r3], {0}
    19e0:	2f2d1301 	svccs	0x002d1301
    19e4:	2c684c6b 	stclcs	12, cr4, [r8], #-428	; 0xfffffe54
    19e8:	a1a03330 	lsrge	r3, r0, r3
    19ec:	034a7803 	movteq	r7, #43011	; 0xa803
    19f0:	4f3c0865 	svcmi	0x003c0865
    19f4:	69034b4c 	stmdbvs	r3, {r2, r3, r6, r8, r9, fp, lr}
    19f8:	4b84899e 	blmi	fe124078 <rEINTPEND+0xa8123fd0>
    19fc:	01000a02 	tsteq	r0, r2, lsl #20
    1a00:	00006e01 	andeq	r6, r0, r1, lsl #28
    1a04:	3e000200 	cdpcc	2, 0, cr0, cr0, cr0, {0}
    1a08:	02000000 	andeq	r0, r0, #0
    1a0c:	0d0efb01 	vstreq	d15, [lr, #-4]
    1a10:	01010100 	tsteq	r1, r0, lsl #2
    1a14:	00000001 	andeq	r0, r0, r1
    1a18:	01000001 	tsteq	r0, r1
    1a1c:	7400002e 	strvc	r0, [r0], #-46	; 0x2e
    1a20:	5f747365 	svcpl	0x00747365
    1a24:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0x56d
    1a28:	00632e78 	rsbeq	r2, r3, r8, ror lr
    1a2c:	6f000000 	svcvs	0x00000000
    1a30:	70635f73 	rsbvc	r5, r3, r3, ror pc
    1a34:	00682e75 	rsbeq	r2, r8, r5, ror lr
    1a38:	75000001 	strvc	r0, [r0, #-1]
    1a3c:	5f736f63 	svcpl	0x00736f63
    1a40:	682e6969 	stmdavs	lr!, {r0, r3, r5, r6, r8, fp, sp, lr}
    1a44:	00000000 	andeq	r0, r0, r0
    1a48:	02050000 	andeq	r0, r5, #0
    1a4c:	30006350 	andcc	r6, r0, r0, asr r3
    1a50:	31012b03 	tstcc	r1, r3, lsl #22
    1a54:	4c6b312b 	stfmie	f3, [fp], #-172	; 0xffffff54
    1a58:	33302c84 	teqcc	r0, #33792	; 0x8400
    1a5c:	7803a1a0 	stmdavc	r3, {r5, r7, r8, sp, pc}
    1a60:	08630366 	stmdaeq	r3!, {r1, r2, r5, r6, r8, r9}^
    1a64:	4b4c4f3c 	blmi	131575c <MEM_SIZE+0xb1575c>
    1a68:	899e6903 	ldmibhi	lr, {r0, r1, r8, fp, sp, lr}
    1a6c:	0a024b84 	beq	94884 <DISABLE_IRQ+0x94804>
    1a70:	72010100 	andvc	r0, r1, #0
    1a74:	02000000 	andeq	r0, r0, #0
    1a78:	00003d00 	andeq	r3, r0, r0, lsl #26
    1a7c:	fb010200 	blx	42286 <DISABLE_IRQ+0x42206>
    1a80:	01000d0e 	tsteq	r0, lr, lsl #26
    1a84:	00010101 	andeq	r0, r1, r1, lsl #2
    1a88:	00010000 	andeq	r0, r1, r0
    1a8c:	002e0100 	eoreq	r0, lr, r0, lsl #2
    1a90:	73657400 	cmnvc	r5, #0
    1a94:	626d5f74 	rsbvs	r5, sp, #464	; 0x1d0
    1a98:	632e786f 	teqvs	lr, #7274496	; 0x6f0000
    1a9c:	00000000 	andeq	r0, r0, r0
    1aa0:	635f736f 	cmpvs	pc, #-1140850687	; 0xbc000001
    1aa4:	682e7570 	stmdavs	lr!, {r4, r5, r6, r8, sl, ip, sp, lr}
    1aa8:	00000100 	andeq	r0, r0, r0, lsl #2
    1aac:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
    1ab0:	2e69695f 	mcrcs	9, 3, r6, cr9, cr15, {2}
    1ab4:	00000068 	andeq	r0, r0, r8, rrx
    1ab8:	05000000 	streq	r0, [r0]
    1abc:	00645002 	rsbeq	r5, r4, r2
    1ac0:	012f0330 	teqeq	pc, r0, lsr r3
    1ac4:	6b2f2d13 	blvs	bccf18 <MEM_SIZE+0x3ccf18>
    1ac8:	302c684c 	eorcc	r6, ip, ip, asr #16
    1acc:	03a1a033 	undefined instruction 0x03a1a033
    1ad0:	64034a78 	strvs	r4, [r3], #-2680	; 0xa78
    1ad4:	2f6b3c08 	svccs	0x006b3c08
    1ad8:	2f2d2f2d 	svccs	0x002d2f2d
    1adc:	67036730 	smladxvs	r3, r0, r7, r6
    1ae0:	67848ad6 	undefined instruction 0x67848ad6
    1ae4:	01000a02 	tsteq	r0, r2, lsl #20
    1ae8:	00007501 	andeq	r7, r0, r1, lsl #10
    1aec:	3c000200 	sfmcc	f0, 4, [r0], {0}	; (stccc 2, cr0, [r0], {0})
    1af0:	02000000 	andeq	r0, r0, #0
    1af4:	0d0efb01 	vstreq	d15, [lr, #-4]
    1af8:	01010100 	tsteq	r1, r0, lsl #2
    1afc:	00000001 	andeq	r0, r0, r1
    1b00:	01000001 	tsteq	r0, r1
    1b04:	7400002e 	strvc	r0, [r0], #-46	; 0x2e
    1b08:	5f747365 	svcpl	0x00747365
    1b0c:	2e726d74 	mrccs	13, 3, r6, cr2, cr4, {3}
    1b10:	00000063 	andeq	r0, r0, r3, rrx
    1b14:	5f736f00 	svcpl	0x00736f00
    1b18:	2e757063 	cdpcs	0, 7, cr7, cr5, cr3, {3}
    1b1c:	00010068 	andeq	r0, r1, r8, rrx
    1b20:	6f637500 	svcvs	0x00637500
    1b24:	69695f73 	stmdbvs	r9!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1b28:	0000682e 	andeq	r6, r0, lr, lsr #16
    1b2c:	00000000 	andeq	r0, r0, r0
    1b30:	65680205 	strbvs	r0, [r8, #-517]!	; 0x205
    1b34:	0c033000 	stceq	0, cr3, [r3], {0}
    1b38:	312b1501 	teqcc	fp, r1, lsl #10
    1b3c:	821503bc 	andshi	r0, r5, #-268435454	; 0xf0000002
    1b40:	6b312b31 	blvs	c4c80c <MEM_SIZE+0x44c80c>
    1b44:	0809034c 	stmdaeq	r9, {r2, r3, r6, r8, r9}
    1b48:	2e770374 	mrccs	3, 3, r0, cr7, cr4, {3}
    1b4c:	342e0903 	strtcc	r0, [lr], #-2307	; 0x903
    1b50:	667a03a0 	ldrbtvs	r0, [sl], -r0, lsr #7
    1b54:	3c085903 	stccc	9, cr5, [r8], {3}
    1b58:	a5332933 	ldrge	r2, [r3, #-2355]!	; 0x933
    1b5c:	000a0261 	andeq	r0, sl, r1, ror #4
    1b60:	007a0101 	rsbseq	r0, sl, r1, lsl #2
    1b64:	00020000 	andeq	r0, r2, r0
    1b68:	0000003e 	andeq	r0, r0, lr, lsr r0
    1b6c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    1b70:	0101000d 	tsteq	r1, sp
    1b74:	00000101 	andeq	r0, r0, r1, lsl #2
    1b78:	00000100 	andeq	r0, r0, r0, lsl #2
    1b7c:	00002e01 	andeq	r2, r0, r1, lsl #28
    1b80:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
    1b84:	6575715f 	ldrbvs	r7, [r5, #-351]!	; 0x15f
    1b88:	632e6575 	teqvs	lr, #490733568	; 0x1d400000
    1b8c:	00000000 	andeq	r0, r0, r0
    1b90:	635f736f 	cmpvs	pc, #-1140850687	; 0xbc000001
    1b94:	682e7570 	stmdavs	lr!, {r4, r5, r6, r8, sl, ip, sp, lr}
    1b98:	00000100 	andeq	r0, r0, r0, lsl #2
    1b9c:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
    1ba0:	2e69695f 	mcrcs	9, 3, r6, cr9, cr15, {2}
    1ba4:	00000068 	andeq	r0, r0, r8, rrx
    1ba8:	05000000 	streq	r0, [r0]
    1bac:	00667c02 	rsbeq	r7, r6, r2, lsl #24
    1bb0:	01340330 	teqeq	r4, r0, lsr r3
    1bb4:	6d2f2d13 	stcvs	13, cr2, [pc, #-76]!	; 0xffffffb4
    1bb8:	3048302c 	subcc	r3, r8, ip, lsr #32
    1bbc:	33302c30 	teqcc	r0, #12288	; 0x3000
    1bc0:	7803a1a0 	stmdavc	r3, {r5, r7, r8, sp, pc}
    1bc4:	0863034a 	stmdaeq	r3!, {r1, r3, r6, r8, r9}^
    1bc8:	4ba08a3c 	blmi	fe8244c0 <rEINTPEND+0xa8824418>
    1bcc:	2e9e6403 	cdpcs	4, 9, cr6, cr14, cr3, {0}
    1bd0:	0367876c 	cmneq	r7, #28311552	; 0x1b00000
    1bd4:	03342e7a 	teqeq	r4, #1952	; 0x7a0
    1bd8:	02684a7a 	rsbeq	r4, r8, #499712	; 0x7a000
    1bdc:	0101000e 	tsteq	r1, lr
    1be0:	0000007b 	andeq	r0, r0, fp, ror r0
    1be4:	003c0002 	eorseq	r0, ip, r2
    1be8:	01020000 	tsteq	r2, r0
    1bec:	000d0efb 	strdeq	r0, [sp], -fp
    1bf0:	01010101 	tsteq	r1, r1, lsl #2
    1bf4:	01000000 	tsteq	r0, r0
    1bf8:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    1bfc:	65740000 	ldrbvs	r0, [r4]!
    1c00:	6d5f7473 	cfldrdvs	mvd7, [pc, #-460]	; 0xfffffe34
    1c04:	632e6d65 	teqvs	lr, #6464	; 0x1940
    1c08:	00000000 	andeq	r0, r0, r0
    1c0c:	635f736f 	cmpvs	pc, #-1140850687	; 0xbc000001
    1c10:	682e7570 	stmdavs	lr!, {r4, r5, r6, r8, sl, ip, sp, lr}
    1c14:	00000100 	andeq	r0, r0, r0, lsl #2
    1c18:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
    1c1c:	2e69695f 	mcrcs	9, 3, r6, cr9, cr15, {2}
    1c20:	00000068 	andeq	r0, r0, r8, rrx
    1c24:	05000000 	streq	r0, [r0]
    1c28:	0067b002 	rsbeq	fp, r7, r2
    1c2c:	012c0330 	teqeq	ip, r0, lsr r3
    1c30:	03332933 	teqeq	r3, #835584	; 0xcc000
    1c34:	75036610 	strvc	r6, [r3, #-1552]	; 0x610
    1c38:	2e0b032e 	cdpcs	3, 0, cr0, cr11, cr14, {1}
    1c3c:	03827503 	orreq	r7, r2, #12582912	; 0xc00000
    1c40:	03342e0b 	teqeq	r4, #176	; 0xb0
    1c44:	34342e7a 	ldrtcc	r2, [r4], #-3706	; 0xe7a
    1c48:	667a03a0 	ldrbtvs	r0, [sl], -r0, lsr #7
    1c4c:	66f24603 	ldrbtvs	r4, [r2], r3, lsl #12
    1c50:	4c660f03 	stclmi	15, cr0, [r6], #-12
    1c54:	4a74036c 	bmi	1d02a0c <MEM_SIZE+0x1502a0c>
    1c58:	0c025168 	stfeqs	f5, [r2], {104}	; 0x68
    1c5c:	a2010100 	andge	r0, r1, #0
    1c60:	02000000 	andeq	r0, r0, #0
    1c64:	00003800 	andeq	r3, r0, r0, lsl #16
    1c68:	fb010200 	blx	42472 <DISABLE_IRQ+0x423f2>
    1c6c:	01000d0e 	tsteq	r0, lr, lsl #26
    1c70:	00010101 	andeq	r0, r1, r1, lsl #2
    1c74:	00010000 	andeq	r0, r1, r0
    1c78:	002e0100 	eoreq	r0, lr, r0, lsl #2
    1c7c:	726f7000 	rsbvc	r7, pc, #0
    1c80:	00632e74 	rsbeq	r2, r3, r4, ror lr
    1c84:	6f000000 	svcvs	0x00000000
    1c88:	70635f73 	rsbvc	r5, r3, r3, ror pc
    1c8c:	00682e75 	rsbeq	r2, r8, r5, ror lr
    1c90:	75000001 	strvc	r0, [r0, #-1]
    1c94:	5f736f63 	svcpl	0x00736f63
    1c98:	682e6969 	stmdavs	lr!, {r0, r3, r5, r6, r8, fp, sp, lr}
    1c9c:	00000000 	andeq	r0, r0, r0
    1ca0:	02050000 	andeq	r0, r5, #0
    1ca4:	30006894 	mulcc	r0, r4, r8
    1ca8:	35451717 	strbcc	r1, [r5, #-1815]	; 0x717
    1cac:	2f2f2f2f 	svccs	0x002f2f2f
    1cb0:	73032f2f 	movwvc	r2, #16175	; 0x3f2f
    1cb4:	2e0e032e 	cdpcs	3, 0, cr0, cr14, cr14, {1}
    1cb8:	032e7803 	teqeq	lr, #196608	; 0x30000
    1cbc:	032b2e09 	teqeq	fp, #144	; 0x90
    1cc0:	0a032e7a 	beq	cd6b0 <DISABLE_IRQ+0xcd630>
    1cc4:	2e77032e 	cdpcs	3, 7, cr0, cr7, cr14, {1}
    1cc8:	2f2f3034 	svccs	0x002f3034
    1ccc:	032e7703 	teqeq	lr, #786432	; 0xc0000
    1cd0:	78032e09 	stmdavc	r3, {r0, r3, r9, sl, fp, sp}
    1cd4:	2e09032e 	cdpcs	3, 0, cr0, cr9, cr14, {1}
    1cd8:	342e7803 	strtcc	r7, [lr], #-2051	; 0x803
    1cdc:	322f2f29 	eorcc	r2, pc, #164	; 0xa4
    1ce0:	2f2f2a2f 	svccs	0x002f2a2f
    1ce4:	2d2f2f2f 	stccs	15, cr2, [pc, #-188]!	; 0xffffff44
    1ce8:	8a4d4b2f 	bhi	13549ac <MEM_SIZE+0xb549ac>
    1cec:	31013101 	tstcc	r1, r1, lsl #2
    1cf0:	31013101 	tstcc	r1, r1, lsl #2
    1cf4:	31013101 	tstcc	r1, r1, lsl #2
    1cf8:	03013101 	movweq	r3, #4353	; 0x1101
    1cfc:	4b2f2e66 	blmi	bcd69c <MEM_SIZE+0x3cd69c>
    1d00:	01000602 	tsteq	r0, r2, lsl #12
    1d04:	0000bb01 	andeq	fp, r0, r1, lsl #22
    1d08:	7e000200 	cdpvc	2, 0, cr0, cr0, cr0, {0}
    1d0c:	02000000 	andeq	r0, r0, #0
    1d10:	0d0efb01 	vstreq	d15, [lr, #-4]
    1d14:	01010100 	tsteq	r1, r0, lsl #2
    1d18:	00000001 	andeq	r0, r0, r1
    1d1c:	01000001 	tsteq	r0, r1
    1d20:	74706f2f 	ldrbtvc	r6, [r0], #-3887	; 0xf2f
    1d24:	6972462f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r9, sl, lr}^
    1d28:	6c646e65 	stclvs	14, cr6, [r4], #-404	; 0xfffffe6c
    1d2c:	4d524179 	ldfmie	f4, [r2, #-484]	; 0xfffffe1c
    1d30:	6e696d2f 	cdpvs	13, 6, cr6, cr9, cr15, {1}
    1d34:	34343269 	ldrtcc	r3, [r4], #-617	; 0x269
    1d38:	75622f30 	strbvc	r2, [r2, #-3888]!	; 0xf30
    1d3c:	2d646c69 	stclcs	12, cr6, [r4, #-420]!	; 0xfffffe5c
    1d40:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 0xfffffe30
    1d44:	61686373 	smcvs	34355	; 0x8633
    1d48:	772f6e69 	strvc	r6, [pc, -r9, ror #28]!
    1d4c:	696b726f 	stmdbvs	fp!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
    1d50:	732f676e 	teqvc	pc, #28835840	; 0x1b80000
    1d54:	672f6372 	undefined instruction 0x672f6372
    1d58:	342d6363 	strtcc	r6, [sp], #-867	; 0x363
    1d5c:	332e342e 	teqcc	lr, #771751936	; 0x2e000000
    1d60:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    1d64:	2f636367 	svccs	0x00636367
    1d68:	672f2e2e 	strvs	r2, [pc, -lr, lsr #28]!
    1d6c:	632f6363 	teqvs	pc, #-1946157055	; 0x8c000001
    1d70:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    1d74:	72612f67 	rsbvc	r2, r1, #412	; 0x19c
    1d78:	6c00006d 	stcvs	0, cr0, [r0], {109}	; 0x6d
    1d7c:	66316269 	ldrtvs	r6, [r1], -r9, ror #4
    1d80:	73636e75 	cmnvc	r3, #1872	; 0x750
    1d84:	6d73612e 	ldfvse	f6, [r3, #-184]!	; 0xffffff48
    1d88:	00000100 	andeq	r0, r0, r0, lsl #2
    1d8c:	02050000 	andeq	r0, r5, #0
    1d90:	3000698c 	andcc	r6, r0, ip, lsl #19
    1d94:	0106b703 	tsteq	r6, r3, lsl #14
    1d98:	2f2f2f2f 	svccs	0x002f2f2f
    1d9c:	96032f2f 	strls	r2, [r3], -pc, lsr #30
    1da0:	ee032e7d 	mcr	14, 0, r2, cr3, cr13, {3}
    1da4:	013e0202 	teqeq	lr, r2, lsl #4
    1da8:	2f2f302f 	svccs	0x002f302f
    1dac:	2e7dcb03 	vaddcs.f64	d28, d13, d3
    1db0:	0802b903 	stmdaeq	r2, {r0, r1, r8, fp, ip, sp, pc}
    1db4:	03322f90 	teqeq	r2, #576	; 0x240
    1db8:	2f2f9e0b 	svccs	0x002f9e0b
    1dbc:	022f2f2f 	eoreq	r2, pc, #188	; 0xbc
    1dc0:	01010002 	tsteq	r1, r2
    1dc4:	00000097 	muleq	r0, r7, r0
    1dc8:	007e0002 	rsbseq	r0, lr, r2
    1dcc:	01020000 	tsteq	r2, r0
    1dd0:	000d0efb 	strdeq	r0, [sp], -fp
    1dd4:	01010101 	tsteq	r1, r1, lsl #2
    1dd8:	01000000 	tsteq	r0, r0
    1ddc:	2f010000 	svccs	0x00010000
    1de0:	2f74706f 	svccs	0x0074706f
    1de4:	65697246 	strbvs	r7, [r9, #-582]!	; 0x246
    1de8:	796c646e 	stmdbvc	ip!, {r1, r2, r3, r5, r6, sl, sp, lr}^
    1dec:	2f4d5241 	svccs	0x004d5241
    1df0:	696e696d 	stmdbvs	lr!, {r0, r2, r3, r5, r6, r8, fp, sp, lr}^
    1df4:	30343432 	eorscc	r3, r4, r2, lsr r4
    1df8:	6975622f 	ldmdbvs	r5!, {r0, r1, r2, r3, r5, r9, sp, lr}^
    1dfc:	742d646c 	strtvc	r6, [sp], #-1132	; 0x46c
    1e00:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
    1e04:	69616863 	stmdbvs	r1!, {r0, r1, r5, r6, fp, sp, lr}^
    1e08:	6f772f6e 	svcvs	0x00772f6e
    1e0c:	6e696b72 	vmovvs.8	d9[7], r6
    1e10:	72732f67 	rsbsvc	r2, r3, #412	; 0x19c
    1e14:	63672f63 	cmnvs	r7, #396	; 0x18c
    1e18:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    1e1c:	2f332e34 	svccs	0x00332e34
    1e20:	6762696c 	strbvs	r6, [r2, -ip, ror #18]!
    1e24:	2e2f6363 	cdpcs	3, 2, cr6, cr15, cr3, {3}
    1e28:	63672f2e 	cmnvs	r7, #184	; 0xb8
    1e2c:	6f632f63 	svcvs	0x00632f63
    1e30:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    1e34:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    1e38:	696c0000 	stmdbvs	ip!, {}^
    1e3c:	75663162 	strbvc	r3, [r6, #-354]!	; 0x162
    1e40:	2e73636e 	cdpcs	3, 7, cr6, cr3, cr14, {3}
    1e44:	006d7361 	rsbeq	r7, sp, r1, ror #6
    1e48:	00000001 	andeq	r0, r0, r1
    1e4c:	a0020500 	andge	r0, r2, r0, lsl #10
    1e50:	0330006a 	teqeq	r0, #106	; 0x6a
    1e54:	2f0108c2 	svccs	0x000108c2
    1e58:	04022f2f 	streq	r2, [r2], #-3887	; 0xf2f
    1e5c:	Address 0x00001e5c is out of bounds.


Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000051 	andeq	r0, r0, r1, asr r0
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	tsteq	r4, r0
       c:	00000000 	andeq	r0, r0, r0
      10:	30000040 	andcc	r0, r0, r0, asr #32
      14:	300000b0 	strhcc	r0, [r0], -r0
      18:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
      1c:	2f00732e 	svccs	0x0000732e
      20:	656d6f68 	strbvs	r6, [sp, #-3944]!	; 0xf68
      24:	6165722f 	cmnvs	r5, pc, lsr #4
      28:	6c69736c 	stclvs	3, cr7, [r9], #-432	; 0xfffffe50
      2c:	7365442f 	cmnvc	r5, #788529152	; 0x2f000000
      30:	706f746b 	rsbvc	r7, pc, fp, ror #8
      34:	646f632f 	strbtvs	r6, [pc], #815	; 3c <MOD_MASK+0x1d>
      38:	69672f65 	stmdbvs	r7!, {r0, r2, r5, r6, r8, r9, sl, fp, sp}^
      3c:	62756874 	rsbsvs	r6, r5, #7602176	; 0x740000
      40:	6f63752f 	svcvs	0x0063752f
      44:	47003273 	smlsdxmi	r0, r3, r2, r3
      48:	4120554e 	teqmi	r0, lr, asr #10
      4c:	2e322053 	mrccs	0, 1, r2, cr2, cr3, {2}
      50:	01003032 	tsteq	r0, r2, lsr r0
      54:	00005280 	andeq	r5, r0, r0, lsl #5
      58:	14000200 	strne	r0, [r0], #-512	; 0x200
      5c:	04000000 	streq	r0, [r0]
      60:	00004901 	andeq	r4, r0, r1, lsl #18
      64:	00000000 	andeq	r0, r0, r0
      68:	00004030 	andeq	r4, r0, r0, lsr r0
      6c:	61747330 	cmnvs	r4, r0, lsr r3
      70:	732e7472 	teqvc	lr, #1912602624	; 0x72000000
      74:	6f682f00 	svcvs	0x00682f00
      78:	722f656d 	eorvc	r6, pc, #457179136	; 0x1b400000
      7c:	736c6165 	cmnvc	ip, #1073741849	; 0x40000019
      80:	442f6c69 	strtmi	r6, [pc], #3177	; 88 <DISABLE_IRQ+0x8>
      84:	746b7365 	strbtvc	r7, [fp], #-869	; 0x365
      88:	632f706f 	teqvs	pc, #111	; 0x6f
      8c:	2f65646f 	svccs	0x0065646f
      90:	68746967 	ldmdavs	r4!, {r0, r1, r2, r5, r6, r8, fp, sp, lr}^
      94:	752f6275 	strvc	r6, [pc, #-629]!	; fffffe27 <rEINTPEND+0xa9fffd7f>
      98:	32736f63 	rsbscc	r6, r3, #396	; 0x18c
      9c:	554e4700 	strbpl	r4, [lr, #-1792]	; 0x700
      a0:	20534120 	subscs	r4, r3, r0, lsr #2
      a4:	30322e32 	eorscc	r2, r2, r2, lsr lr
      a8:	6c800100 	stfvss	f0, [r0], {0}
      ac:	02000001 	andeq	r0, r0, #1
      b0:	00002800 	andeq	r2, r0, r0, lsl #16
      b4:	8f010400 	svchi	0x00010400
      b8:	01000000 	tsteq	r0, r0
      bc:	0000000b 	andeq	r0, r0, fp
      c0:	00000026 	andeq	r0, r0, r6, lsr #32
      c4:	300000b0 	strhcc	r0, [r0], -r0
      c8:	300001d8 	ldrdcc	r0, [r0], -r8
      cc:	00000087 	andeq	r0, r0, r7, lsl #1
      d0:	62080102 	andvs	r0, r8, #-2147483648	; 0x80000000
      d4:	02000000 	andeq	r0, r0, #0
      d8:	00700702 	rsbseq	r0, r0, r2, lsl #14
      dc:	04020000 	streq	r0, [r2]
      e0:	00007607 	andeq	r7, r0, r7, lsl #12
      e4:	08010200 	stmdaeq	r1, {r9}
      e8:	0000006b 	andeq	r0, r0, fp, rrx
      ec:	04070403 	streq	r0, [r7], #-1027	; 0x403
      f0:	00000012 	andeq	r0, r0, r2, lsl r0
      f4:	004f0501 	subeq	r0, pc, r1, lsl #10
      f8:	04050000 	streq	r0, [r5]
      fc:	00000055 	andeq	r0, r0, r5, asr r0
     100:	01070106 	tsteq	r7, r6, lsl #2
     104:	00000059 	andeq	r0, r0, r9, asr r0
     108:	01011001 	tsteq	r1, r1
     10c:	0000006f 	andeq	r0, r0, pc, rrx
     110:	01007008 	tsteq	r0, r8
     114:	00006f11 	andeq	r6, r0, r1, lsl pc
     118:	04050000 	streq	r0, [r5]
     11c:	00000075 	andeq	r0, r0, r5, ror r0
     120:	00003a09 	andeq	r3, r0, r9, lsl #20
     124:	00010a00 	andeq	r0, r1, r0, lsl #20
     128:	01000000 	tsteq	r0, r0
     12c:	00b00109 	adcseq	r0, r0, r9, lsl #2
     130:	00d43000 	sbcseq	r3, r4, r0
     134:	5d013000 	stcpl	0, cr3, [r1]
     138:	0000009b 	muleq	r0, fp, r0
     13c:	01007008 	tsteq	r0, r8
     140:	00006f0a 	andeq	r6, r0, sl, lsl #30
     144:	570b0000 	strpl	r0, [fp, -r0]
     148:	d4000000 	strle	r0, [r0]
     14c:	f8300000 	undefined instruction 0xf8300000
     150:	01300000 	teqeq	r0, r0
     154:	0000b45d 	andeq	fp, r0, sp, asr r4
     158:	00650c00 	rsbeq	r0, r5, r0, lsl #24
     15c:	0a000000 	beq	164 <DISABLE_IRQ+0xe4>
     160:	00009b01 	andeq	r9, r0, r1, lsl #22
     164:	011c0100 	tsteq	ip, r0, lsl #2
     168:	300000f8 	strdcc	r0, [r0], -r8
     16c:	300000fc 	strdcc	r0, [r0], -ip
     170:	00d95d01 	sbcseq	r5, r9, r1, lsl #26
     174:	730d0000 	movwvc	r0, #53248	; 0xd000
     178:	01006769 	tsteq	r0, r9, ror #14
     17c:	0000d91c 	andeq	sp, r0, ip, lsl r9
     180:	00500100 	subseq	r0, r0, r0, lsl #2
     184:	6905040e 	stmdbvs	r5, {r1, r2, r3, sl}
     188:	0f00746e 	svceq	0x0000746e
     18c:	00004e01 	andeq	r4, r0, r1, lsl #28
     190:	011f0100 	tsteq	pc, r0, lsl #2
     194:	300000fc 	strdcc	r0, [r0], -ip
     198:	3000016c 	andcc	r0, r0, ip, ror #2
     19c:	00000000 	andeq	r0, r0, r0
     1a0:	001c0110 	andseq	r0, ip, r0, lsl r1
     1a4:	35010000 	strcc	r0, [r1]
     1a8:	00016c01 	andeq	r6, r1, r1, lsl #24
     1ac:	0001d830 	andeq	sp, r1, r0, lsr r8
     1b0:	00001f30 	andeq	r1, r0, r0, lsr pc
     1b4:	00013700 	andeq	r3, r1, r0, lsl #14
     1b8:	00690800 	rsbeq	r0, r9, r0, lsl #16
     1bc:	00d93601 	sbcseq	r3, r9, r1, lsl #12
     1c0:	57110000 	ldrpl	r0, [r1, -r0]
     1c4:	9c000000 	stcls	0, cr0, [r0], {0}
     1c8:	b0300001 	eorslt	r0, r0, r1
     1cc:	01300001 	teqeq	r0, r1
     1d0:	019c123c 	orrseq	r1, ip, ip, lsr r2
     1d4:	01b03000 	movseq	r3, r0
     1d8:	650c3000 	strvs	r3, [ip]
     1dc:	00000000 	andeq	r0, r0, r0
     1e0:	44130000 	ldrmi	r0, [r3]
     1e4:	47000000 	strmi	r0, [r0, -r0]
     1e8:	14000001 	strne	r0, [r0], #-1
     1ec:	00000041 	andeq	r0, r0, r1, asr #32
     1f0:	54150001 	ldrpl	r0, [r5], #-1
     1f4:	01000000 	tsteq	r0, r0
     1f8:	00015817 	andeq	r5, r1, r7, lsl r8
     1fc:	b4030500 	strlt	r0, [r3], #-1280	; 0x500
     200:	0930006a 	ldmdbeq	r0!, {r1, r3, r5, r6}
     204:	00000137 	andeq	r0, r0, r7, lsr r1
     208:	00008316 	andeq	r8, r0, r6, lsl r3
     20c:	d9330100 	ldmdble	r3!, {r8}
     210:	01000000 	tsteq	r0, r0
     214:	6ea00305 	cdpvs	3, 10, cr0, cr0, cr5, {0}
     218:	55003000 	strpl	r3, [r0]
     21c:	02000000 	andeq	r0, r0, #0
     220:	00015100 	andeq	r5, r1, r0, lsl #2
     224:	ef010400 	svc	0x00010400
     228:	d8000000 	stmdale	r0, {}
     22c:	6c300001 	ldcvs	0, cr0, [r0], #-4
     230:	61300002 	teqvs	r0, r2
     234:	726f6e62 	rsbvc	r6, pc, #1568	; 0x620
     238:	2e6c616d 	powcsez	f6, f4, #5.0
     23c:	682f0073 	stmdavs	pc!, {r0, r1, r4, r5, r6}
     240:	2f656d6f 	svccs	0x00656d6f
     244:	6c616572 	cfstr64vs	mvdx6, [r1], #-456	; 0xfffffe38
     248:	2f6c6973 	svccs	0x006c6973
     24c:	6b736544 	blvs	1cd9764 <MEM_SIZE+0x14d9764>
     250:	2f706f74 	svccs	0x00706f74
     254:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xf63
     258:	7469672f 	strbtvc	r6, [r9], #-1839	; 0x72f
     25c:	2f627568 	svccs	0x00627568
     260:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
     264:	4e470032 	mcrmi	0, 2, r0, cr7, cr2, {1}
     268:	53412055 	movtpl	r2, #4181	; 0x1055
     26c:	322e3220 	eorcc	r3, lr, #2
     270:	80010030 	andhi	r0, r1, r0, lsr r0
     274:	00000050 	andeq	r0, r0, r0, asr r0
     278:	01650002 	cmneq	r5, r2
     27c:	01040000 	tsteq	r4, r0
     280:	0000014b 	andeq	r0, r0, fp, asr #2
     284:	3000026c 	andcc	r0, r0, ip, ror #4
     288:	30000324 	andcc	r0, r0, r4, lsr #6
     28c:	2e757063 	cdpcs	0, 7, cr7, cr5, cr3, {3}
     290:	682f0073 	stmdavs	pc!, {r0, r1, r4, r5, r6}
     294:	2f656d6f 	svccs	0x00656d6f
     298:	6c616572 	cfstr64vs	mvdx6, [r1], #-456	; 0xfffffe38
     29c:	2f6c6973 	svccs	0x006c6973
     2a0:	6b736544 	blvs	1cd97b8 <MEM_SIZE+0x14d97b8>
     2a4:	2f706f74 	svccs	0x00706f74
     2a8:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xf63
     2ac:	7469672f 	strbtvc	r6, [r9], #-1839	; 0x72f
     2b0:	2f627568 	svccs	0x00627568
     2b4:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
     2b8:	4e470032 	mcrmi	0, 2, r0, cr7, cr2, {1}
     2bc:	53412055 	movtpl	r2, #4181	; 0x1055
     2c0:	322e3220 	eorcc	r3, lr, #2
     2c4:	80010030 	andhi	r0, r1, r0, lsr r0
     2c8:	0000012f 	andeq	r0, r0, pc, lsr #2
     2cc:	01790002 	cmneq	r9, r2
     2d0:	01040000 	tsteq	r4, r0
     2d4:	0000008f 	andeq	r0, r0, pc, lsl #1
     2d8:	0000be01 	andeq	fp, r0, r1, lsl #28
     2dc:	00002600 	andeq	r2, r0, r0, lsl #12
     2e0:	00032400 	andeq	r2, r3, r0, lsl #8
     2e4:	00041030 	andeq	r1, r4, r0, lsr r0
     2e8:	0001a830 	andeq	sl, r1, r0, lsr r8
     2ec:	d4010200 	strle	r0, [r1], #-512	; 0x200
     2f0:	01000000 	tsteq	r0, r0
     2f4:	0043012d 	subeq	r0, r3, sp, lsr #2
     2f8:	43010000 	movwmi	r0, #4096	; 0x1000
     2fc:	03000000 	movweq	r0, #0
     300:	000000e5 	andeq	r0, r0, r5, ror #1
     304:	00432d01 	subeq	r2, r3, r1, lsl #26
     308:	04000000 	streq	r0, [r0]
     30c:	00760704 	rsbseq	r0, r6, r4, lsl #14
     310:	01020000 	tsteq	r2, r0
     314:	000000c4 	andeq	r0, r0, r4, asr #1
     318:	43013201 	movwmi	r3, #4609	; 0x1201
     31c:	01000000 	tsteq	r0, r0
     320:	00000073 	andeq	r0, r0, r3, ror r0
     324:	0000a103 	andeq	sl, r0, r3, lsl #2
     328:	43320100 	teqmi	r2, #0
     32c:	03000000 	movweq	r0, #0
     330:	000000df 	ldrdeq	r0, [r0], -pc
     334:	00433301 	subeq	r3, r3, r1, lsl #6
     338:	05000000 	streq	r0, [r0]
     33c:	0000a701 	andeq	sl, r0, r1, lsl #14
     340:	011a0100 	tsteq	sl, r0, lsl #2
     344:	30000324 	andcc	r0, r0, r4, lsr #6
     348:	30000350 	andcc	r0, r0, r0, asr r3
     34c:	00965d01 	addseq	r5, r6, r1, lsl #26
     350:	74060000 	strvc	r0, [r6]
     354:	01006274 	tsteq	r0, r4, ror r2
     358:	0000431b 	andeq	r4, r0, fp, lsl r3
     35c:	25070000 	strcs	r0, [r7]
     360:	50000000 	andpl	r0, r0, r0
     364:	60300003 	eorsvs	r0, r0, r3
     368:	01300003 	teqeq	r0, r3
     36c:	0000b35d 	andeq	fp, r0, sp, asr r3
     370:	00370800 	eorseq	r0, r7, r0, lsl #16
     374:	003e0000 	eorseq	r0, lr, r0
     378:	07000000 	streq	r0, [r0, -r0]
     37c:	0000004a 	andeq	r0, r0, sl, asr #32
     380:	30000360 	andcc	r0, r0, r0, ror #6
     384:	30000378 	andcc	r0, r0, r8, ror r3
     388:	00d95d01 	sbcseq	r5, r9, r1, lsl #26
     38c:	5c080000 	stcpl	0, cr0, [r8], {0}
     390:	51000000 	tstpl	r0, r0
     394:	08000000 	stmdaeq	r0, {}
     398:	00000067 	andeq	r0, r0, r7, rrx
     39c:	00000064 	andeq	r0, r0, r4, rrx
     3a0:	b1010500 	tstlt	r1, r0, lsl #10
     3a4:	01000000 	tsteq	r0, r0
     3a8:	03780138 	cmneq	r8, #14
     3ac:	04103000 	ldreq	r3, [r0]
     3b0:	5d013000 	stcpl	0, cr3, [r1]
     3b4:	0000012b 	andeq	r0, r0, fp, lsr #2
     3b8:	65747009 	ldrbvs	r7, [r4, #-9]!
     3bc:	43390100 	teqmi	r9, #0
     3c0:	77000000 	strvc	r0, [r0, -r0]
     3c4:	0a000000 	beq	3cc <DISABLE_IRQ+0x34c>
     3c8:	000000cb 	andeq	r0, r0, fp, asr #1
     3cc:	00433a01 	subeq	r3, r3, r1, lsl #20
     3d0:	6a0b0000 	bvs	2c03d8 <DISABLE_IRQ+0x2c0358>
     3d4:	2b3b0100 	blcs	ec07dc <MEM_SIZE+0x6c07dc>
     3d8:	01000001 	tsteq	r0, r1
     3dc:	00250c53 	eoreq	r0, r5, r3, asr ip
     3e0:	03ac0000 	undefined instruction 0x03ac0000
     3e4:	03b43000 	undefined instruction 0x03b43000
     3e8:	47013000 	strmi	r3, [r1, -r0]
     3ec:	0000a90d 	andeq	sl, r0, sp, lsl #18
     3f0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     3f4:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
     3f8:	f7000074 	undefined instruction 0xf7000074
     3fc:	02000003 	andeq	r0, r0, #3
     400:	00024200 	andeq	r4, r2, r0, lsl #4
     404:	8f010400 	svchi	0x00010400
     408:	01000000 	tsteq	r0, r0
     40c:	000000eb 	andeq	r0, r0, fp, ror #1
     410:	00000026 	andeq	r0, r0, r6, lsr #32
     414:	30000410 	andcc	r0, r0, r0, lsl r4
     418:	300009a8 	andcc	r0, r0, r8, lsr #19
     41c:	00000221 	andeq	r0, r0, r1, lsr #4
     420:	62080102 	andvs	r0, r8, #-2147483648	; 0x80000000
     424:	02000000 	andeq	r0, r0, #0
     428:	00700702 	rsbseq	r0, r0, r2, lsl #14
     42c:	04020000 	streq	r0, [r2]
     430:	00007607 	andeq	r7, r0, r7, lsl #12
     434:	08010200 	stmdaeq	r1, {r9}
     438:	0000006b 	andeq	r0, r0, fp, rrx
     43c:	00010d03 	andeq	r0, r1, r3, lsl #26
     440:	330f0200 	movwcc	r0, #61952	; 0xf200
     444:	04000000 	streq	r0, [r0]
     448:	07040504 	streq	r0, [r4, -r4, lsl #10]
     44c:	00011e03 	andeq	r1, r1, r3, lsl #28
     450:	5c040100 	stfpls	f0, [r4], {0}
     454:	06000000 	streq	r0, [r0], -r0
     458:	00003a04 	andeq	r3, r0, r4, lsl #20
     45c:	17010700 	strne	r0, [r1, -r0, lsl #14]
     460:	01000001 	tsteq	r0, r1
     464:	004c014c 	subeq	r0, ip, ip, asr #2
     468:	aa010000 	bge	40470 <DISABLE_IRQ+0x403f0>
     46c:	08000000 	stmdaeq	r0, {}
     470:	00000827 	andeq	r0, r0, r7, lsr #16
     474:	004c4c01 	subeq	r4, ip, r1, lsl #24
     478:	73090000 	movwvc	r0, #36864	; 0x9000
     47c:	01006372 	tsteq	r0, r2, ror r3
     480:	0000aa4c 	andeq	sl, r0, ip, asr #20
     484:	01820800 	orreq	r0, r2, r0, lsl #16
     488:	4c010000 	stcmi	0, cr0, [r1], {0}
     48c:	00000033 	andeq	r0, r0, r3, lsr r0
     490:	706d740a 	rsbvc	r7, sp, sl, lsl #8
     494:	5c4e0100 	stfple	f0, [lr], {0}
     498:	0a000000 	beq	4a0 <DISABLE_IRQ+0x420>
     49c:	4e010073 	mcrmi	0, 0, r0, cr1, cr3, {3}
     4a0:	0000005c 	andeq	r0, r0, ip, asr r0
     4a4:	b0040600 	andlt	r0, r4, r0, lsl #12
     4a8:	0b000000 	bleq	4b0 <DISABLE_IRQ+0x430>
     4ac:	0000620c 	andeq	r6, r0, ip, lsl #4
     4b0:	00041000 	andeq	r1, r4, r0
     4b4:	00043430 	andeq	r3, r4, r0, lsr r4
     4b8:	e65d0130 	undefined instruction 0xe65d0130
     4bc:	0d000000 	stceq	0, cr0, [r0]
     4c0:	00000074 	andeq	r0, r0, r4, ror r0
     4c4:	000000a0 	andeq	r0, r0, r0, lsr #1
     4c8:	00007f0e 	andeq	r7, r0, lr, lsl #30
     4cc:	0e510100 	rdfeqs	f0, f1, f0
     4d0:	0000008a 	andeq	r0, r0, sl, lsl #1
     4d4:	950f5201 	strls	r5, [pc, #-513]	; 2db <DISABLE_IRQ+0x25b>
     4d8:	0f000000 	svceq	0x00000000
     4dc:	000000a0 	andeq	r0, r0, r0, lsr #1
     4e0:	94011000 	strls	r1, [r1]
     4e4:	01000001 	tsteq	r0, r1
     4e8:	005c0154 	subseq	r0, ip, r4, asr r1
     4ec:	04340000 	ldrteq	r0, [r4]
     4f0:	05783000 	ldrbeq	r3, [r8]!
     4f4:	00b33000 	adcseq	r3, r3, r0
     4f8:	017b0000 	cmneq	fp, r0
     4fc:	73110000 	tstvc	r1, #0
     500:	01007274 	tsteq	r0, r4, ror r2
     504:	00005c54 	andeq	r5, r0, r4, asr ip
     508:	0000df00 	andeq	sp, r0, r0, lsl #30
     50c:	756e1100 	strbvc	r1, [lr, #-256]!	; 0x100
     510:	5401006d 	strpl	r0, [r1], #-109	; 0x6d
     514:	0000017b 	andeq	r0, r0, fp, ror r1
     518:	000000fd 	strdeq	r0, [r0], -sp
     51c:	00019b12 	andeq	r9, r1, r2, lsl fp
     520:	7b540100 	blvc	1500928 <MEM_SIZE+0xd00928>
     524:	26000001 	strcs	r0, [r0], -r1
     528:	12000001 	andne	r0, r0, #1
     52c:	00000158 	andeq	r0, r0, r8, asr r1
     530:	00335401 	eorseq	r5, r3, r1, lsl #8
     534:	01440000 	cmpeq	r4, r0
     538:	69130000 	ldmdbvs	r3, {}
     53c:	7b550100 	blvc	1540944 <MEM_SIZE+0xd40944>
     540:	62000001 	andvs	r0, r0, #1
     544:	14000001 	strne	r0, [r0], #-1
     548:	0000017d 	andeq	r0, r0, sp, ror r1
     54c:	017b5601 	cmneq	fp, r1, lsl #12
     550:	7d020000 	stcvc	0, cr0, [r2]
     554:	012c1404 	teqeq	ip, r4, lsl #8
     558:	57010000 	strpl	r0, [r1, -r0]
     55c:	00000182 	andeq	r0, r0, r2, lsl #3
     560:	7f949103 	svcvc	0x00949103
     564:	00000015 	andeq	r0, r0, r5, lsl r0
     568:	01261600 	teqeq	r6, r0, lsl #12
     56c:	5f010000 	svcpl	0x00010000
     570:	0000017b 	andeq	r0, r0, fp, ror r1
     574:	04170000 	ldreq	r0, [r7]
     578:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
     57c:	003a1800 	eorseq	r1, sl, r0, lsl #16
     580:	01920000 	orrseq	r0, r2, r0
     584:	4e190000 	cdpmi	0, 1, cr0, cr9, cr0, {0}
     588:	43000000 	movwmi	r0, #0
     58c:	f3011a00 	vpmax.u8	d1, d1, d0
     590:	01000000 	tsteq	r0, r0
     594:	017b0174 	cmneq	fp, r4, ror r1
     598:	05780000 	ldrbeq	r0, [r8]!
     59c:	07203000 	streq	r3, [r0, -r0]!
     5a0:	5d013000 	stcpl	0, cr3, [r1]
     5a4:	000001d5 	ldrdeq	r0, [r0], -r5
     5a8:	746d6611 	strbtvc	r6, [sp], #-1553	; 0x611
     5ac:	d5740100 	ldrble	r0, [r4, #-256]!	; 0x100
     5b0:	a1000001 	tstge	r0, r1
     5b4:	1b000001 	blne	5c0 <DISABLE_IRQ+0x540>
     5b8:	00000158 	andeq	r0, r0, r8, asr r1
     5bc:	01e07401 	mvneq	r7, r1, lsl #8
     5c0:	51010000 	tstpl	r1, r0
     5c4:	00016316 	andeq	r6, r1, r6, lsl r3
     5c8:	d5750100 	ldrble	r0, [r5, #-256]!	; 0x100
     5cc:	00000001 	andeq	r0, r0, r1
     5d0:	01db0406 	bicseq	r0, fp, r6, lsl #8
     5d4:	3a1c0000 	bcc	7005dc <DISABLE_IRQ+0x70055c>
     5d8:	06000000 	streq	r0, [r0], -r0
     5dc:	00003304 	andeq	r3, r0, r4, lsl #6
     5e0:	69011000 	stmdbvs	r1, {ip}
     5e4:	01000001 	tsteq	r0, r1
     5e8:	017b01b1 	ldrheq	r0, [fp, #-17]!	; 0xffffffef
     5ec:	07200000 	streq	r0, [r0, -r0]!
     5f0:	08c43000 	stmiaeq	r4, {ip, sp}^
     5f4:	02593000 	subseq	r3, r9, #0
     5f8:	02f60000 	rscseq	r0, r6, #0
     5fc:	62110000 	andsvs	r0, r1, #0
     600:	01006675 	tsteq	r0, r5, ror r6
     604:	00005cb1 	undefined instruction 0x00005cb1
     608:	00028400 	andeq	r8, r2, r0, lsl #8
     60c:	0d341200 	lfmeq	f1, 4, [r4]	; (ldceq 2, cr1, [r4])
     610:	b1010000 	tstlt	r1, r0
     614:	0000017b 	andeq	r0, r0, fp, ror r1
     618:	000002a2 	andeq	r0, r0, r2, lsr #5
     61c:	746d6611 	strbtvc	r6, [sp], #-1553	; 0x611
     620:	d5b10100 	ldrle	r0, [r1, #256]!	; 0x100
     624:	c0000001 	andgt	r0, r0, r1
     628:	12000002 	andne	r0, r0, #2
     62c:	0000015e 	andeq	r0, r0, lr, asr r1
     630:	0051b101 	subseq	fp, r1, r1, lsl #2
     634:	02de0000 	sbcseq	r0, lr, #0
     638:	6e130000 	cdpvs	0, 1, cr0, cr3, cr0, {0}
     63c:	01006d75 	tsteq	r0, r5, ror sp
     640:	00017bb2 	undefined instruction 0x00017bb2
     644:	0002fc00 	andeq	pc, r2, r0, lsl #24
     648:	74731d00 	ldrbtvc	r1, [r3], #-3328	; 0xd00
     64c:	b3010072 	movwlt	r0, #4210	; 0x1072
     650:	0000005c 	andeq	r0, r0, ip, asr r0
     654:	651d5901 	ldrvs	r5, [sp, #-2305]	; 0x901
     658:	0100646e 	tsteq	r0, lr, ror #8
     65c:	00005cb3 	undefined instruction 0x00005cb3
     660:	0a560100 	beq	1580a68 <MEM_SIZE+0xd80a68>
     664:	b3010063 	movwlt	r0, #4195	; 0x1063
     668:	0000003a 	andeq	r0, r0, sl, lsr r0
     66c:	01007313 	tsteq	r0, r3, lsl r3
     670:	00005cb3 	undefined instruction 0x00005cb3
     674:	00032500 	andeq	r2, r3, r0, lsl #10
     678:	013f1600 	teqeq	pc, r0, lsl #12
     67c:	b4010000 	strlt	r0, [r1]
     680:	0000017b 	andeq	r0, r0, fp, ror r1
     684:	0001441e 	andeq	r4, r1, lr, lsl r4
     688:	33b50100 	undefined instruction 0x33b50100
     68c:	59000000 	stmdbpl	r0, {}
     690:	15000003 	strne	r0, [r0, #-3]
     694:	00000018 	andeq	r0, r0, r8, lsl r0
     698:	00015016 	andeq	r5, r1, r6, lsl r0
     69c:	d5c00100 	strble	r0, [r0, #256]	; 0x100
     6a0:	1f000001 	svcne	0x00000001
     6a4:	3000077c 	andcc	r0, r0, ip, ror r7
     6a8:	300007b8 	undefined instruction 0x300007b8
     6ac:	00018816 	andeq	r8, r1, r6, lsl r8
     6b0:	7bc60100 	blvc	ff180ab8 <rEINTPEND+0xa9180a10>
     6b4:	20000001 	andcs	r0, r0, r1
     6b8:	00000062 	andeq	r0, r0, r2, rrx
     6bc:	30000794 	mulcc	r0, r4, r7
     6c0:	300007b4 	undefined instruction 0x300007b4
     6c4:	d40dca01 	strle	ip, [sp], #-2561	; 0xa01
     6c8:	91000000 	tstls	r0, r0
     6cc:	21000003 	tstcs	r0, r3
     6d0:	000000cd 	andeq	r0, r0, sp, asr #1
     6d4:	0000c421 	andeq	ip, r0, r1, lsr #8
     6d8:	07941f00 	ldreq	r1, [r4, r0, lsl #30]
     6dc:	07b43000 	ldreq	r3, [r4, r0]!
     6e0:	950f3000 	strls	r3, [pc, #0]	; 6e8 <DISABLE_IRQ+0x668>
     6e4:	0f000000 	svceq	0x00000000
     6e8:	000000a0 	andeq	r0, r0, r0, lsr #1
     6ec:	00000000 	andeq	r0, r0, r0
     6f0:	34012200 	strcc	r2, [r1], #-512	; 0x200
     6f4:	01000001 	tsteq	r0, r1
     6f8:	08c4013c 	stmiaeq	r4, {r2, r3, r4, r5, r8}^
     6fc:	09183000 	ldmdbeq	r8, {ip, sp}
     700:	03af3000 	undefined instruction 0x03af3000
     704:	03370000 	teqeq	r7, #0
     708:	70110000 	andsvc	r0, r1, r0
     70c:	5c3c0100 	ldfpls	f0, [ip]
     710:	ce000000 	cdpgt	0, 0, cr0, cr0, cr0, {0}
     714:	11000003 	tstne	r0, r3
     718:	006d756e 	rsbeq	r7, sp, lr, ror #10
     71c:	017b3c01 	cmneq	fp, r1, lsl #24
     720:	04020000 	streq	r0, [r2]
     724:	8d160000 	ldchi	0, cr0, [r6]
     728:	01000001 	tsteq	r0, r1
     72c:	0000413e 	andeq	r4, r0, lr, lsr r1
     730:	01220000 	teqeq	r2, r0
     734:	00000106 	andeq	r0, r0, r6, lsl #2
     738:	1801f601 	stmdane	r1, {r0, r9, sl, ip, sp, lr, pc}
     73c:	58300009 	ldmdapl	r0!, {r0, r3}
     740:	2b300009 	blcs	c0076c <MEM_SIZE+0x40076c>
     744:	83000004 	movwhi	r0, #4
     748:	23000003 	movwcs	r0, #3
     74c:	00746d66 	rsbseq	r6, r4, r6, ror #26
     750:	01d5f601 	bicseq	pc, r5, r1, lsl #12
     754:	91020000 	tstls	r2, r0
     758:	73142400 	tstvc	r4, #0
     75c:	01000001 	tsteq	r0, r1
     760:	000383f8 	strdeq	r8, [r3], -r8
     764:	f8910300 	undefined instruction 0xf8910300
     768:	015e167d 	cmpeq	lr, sp, ror r6
     76c:	fa010000 	blx	40774 <DISABLE_IRQ+0x406f4>
     770:	00000051 	andeq	r0, r0, r1, asr r0
     774:	0100690a 	tsteq	r0, sl, lsl #18
     778:	000033fb 	strdeq	r3, [r0], -fp
     77c:	3a180000 	bcc	600784 <DISABLE_IRQ+0x600704>
     780:	93000000 	movwls	r0, #0
     784:	19000003 	stmdbne	r0, {r0, r1}
     788:	0000004e 	andeq	r0, r0, lr, asr #32
     78c:	012500ff 	strdeq	r0, [r5, -pc]!
     790:	00000101 	andeq	r0, r0, r1, lsl #2
     794:	01010501 	tsteq	r1, r1, lsl #10
     798:	30000958 	andcc	r0, r0, r8, asr r9
     79c:	300009a8 	andcc	r0, r0, r8, lsr #19
     7a0:	00000463 	andeq	r0, r0, r3, ror #8
     7a4:	000003d6 	ldrdeq	r0, [r0], -r6
     7a8:	01007026 	tsteq	r0, r6, lsr #32
     7ac:	005c0106 	subseq	r0, ip, r6, lsl #2
     7b0:	63260000 	teqvs	r6, #0
     7b4:	01070100 	tsteq	r7, r0, lsl #2
     7b8:	0000003a 	andeq	r0, r0, sl, lsr r0
     7bc:	01006426 	tsteq	r0, r6, lsr #8
     7c0:	017b0108 	cmneq	fp, r8, lsl #2
     7c4:	6b260000 	blvs	9807cc <MEM_SIZE+0x1807cc>
     7c8:	01090100 	tsteq	r9, r0, lsl #2
     7cc:	0000017b 	andeq	r0, r0, fp, ror r1
     7d0:	01492700 	cmpeq	r9, r0, lsl #14
     7d4:	0a010000 	beq	407dc <DISABLE_IRQ+0x4075c>
     7d8:	000001d5 	ldrdeq	r0, [r0], -r5
     7dc:	80030501 	andhi	r0, r3, r1, lsl #10
     7e0:	2730006e 	ldrcs	r0, [r0, -lr, rrx]!
     7e4:	0000012c 	andeq	r0, r0, ip, lsr #2
     7e8:	01820b01 	orreq	r0, r2, r1, lsl #22
     7ec:	05010000 	streq	r0, [r1]
     7f0:	01c6dc03 	biceq	sp, r6, r3, lsl #24
     7f4:	009d0030 	addseq	r0, sp, r0, lsr r0
     7f8:	00020000 	andeq	r0, r2, r0
     7fc:	00000442 	andeq	r0, r0, r2, asr #8
     800:	008f0104 	addeq	r0, pc, r4, lsl #2
     804:	ab010000 	blge	4080c <DISABLE_IRQ+0x4078c>
     808:	26000001 	strcs	r0, [r0], -r1
     80c:	a8000000 	stmdage	r0, {}
     810:	2c300009 	ldccs	0, cr0, [r0], #-36	; 0xffffffdc
     814:	3530000a 	ldrcc	r0, [r0, #-10]!
     818:	02000003 	andeq	r0, r0, #3
     81c:	0001a001 	andeq	sl, r1, r1
     820:	01090100 	tsteq	r9, r0, lsl #2
     824:	300009a8 	andcc	r0, r0, r8, lsr #19
     828:	300009c0 	andcc	r0, r0, r0, asr #19
     82c:	0000048e 	andeq	r0, r0, lr, lsl #9
     830:	01db0102 	bicseq	r0, fp, r2, lsl #2
     834:	12010000 	andne	r0, r1, #0
     838:	0009c001 	andeq	ip, r9, r1
     83c:	0009d830 	andeq	sp, r9, r0, lsr r8
     840:	0004ad30 	andeq	sl, r4, r0, lsr sp
     844:	b7010300 	strlt	r0, [r1, -r0, lsl #6]
     848:	01000001 	tsteq	r0, r1
     84c:	09d8011b 	ldmibeq	r8, {r0, r1, r3, r4, r8}^
     850:	09f03000 	ldmibeq	r0!, {ip, sp}^
     854:	5d013000 	stcpl	0, cr3, [r1]
     858:	00000074 	andeq	r0, r0, r4, ror r0
     85c:	0001c104 	andeq	ip, r1, r4, lsl #2
     860:	741b0100 	ldrvc	r0, [fp], #-256	; 0x100
     864:	01000000 	tsteq	r0, r0
     868:	04050050 	streq	r0, [r5], #-80	; 0x50
     86c:	00007607 	andeq	r7, r0, r7, lsl #12
     870:	c8010600 	stmdagt	r1, {r9, sl}
     874:	01000001 	tsteq	r0, r1
     878:	09f0011f 	ldmibeq	r0!, {r0, r1, r2, r3, r4, r8}^
     87c:	0a2c3000 	beq	b0c884 <MEM_SIZE+0x30c884>
     880:	04cc3000 	strbeq	r3, [ip]
     884:	74070000 	strvc	r0, [r7]
     888:	0100706d 	tsteq	r0, sp, rrx
     88c:	00007420 	andeq	r7, r0, r0, lsr #8
     890:	0004eb00 	andeq	lr, r4, r0, lsl #22
     894:	f2000000 	vhadd.s8	d0, d0, d0
     898:	0200003f 	andeq	r0, r0, #63	; 0x3f
     89c:	0004c000 	andeq	ip, r4, r0
     8a0:	8f010400 	svchi	0x00010400
     8a4:	01000000 	tsteq	r0, r0
     8a8:	00000832 	andeq	r0, r0, r2, lsr r8
     8ac:	00000026 	andeq	r0, r0, r6, lsr #32
     8b0:	30000a2c 	andcc	r0, r0, ip, lsr #20
     8b4:	3000618c 	andcc	r6, r0, ip, lsl #3
     8b8:	0000037f 	andeq	r0, r0, pc, ror r3
     8bc:	000c0d02 	andeq	r0, ip, r2, lsl #26
     8c0:	30090c00 	andcc	r0, r9, r0, lsl #24
     8c4:	03000000 	movweq	r0, #0
     8c8:	00620801 	rsbeq	r0, r2, r1, lsl #16
     8cc:	4b020000 	blmi	808d4 <DISABLE_IRQ+0x80854>
     8d0:	0c000002 	stceq	0, cr0, [r0], {2}
     8d4:	0000420a 	andeq	r4, r0, sl, lsl #4
     8d8:	07020300 	streq	r0, [r2, -r0, lsl #6]
     8dc:	00000070 	andeq	r0, r0, r0, ror r0
     8e0:	000b5202 	andeq	r5, fp, r2, lsl #4
     8e4:	540b0c00 	strpl	r0, [fp], #-3072	; 0xc00
     8e8:	03000000 	movweq	r0, #0
     8ec:	00760704 	rsbseq	r0, r6, r4, lsl #14
     8f0:	02020000 	andeq	r0, r2, #0
     8f4:	0c00000c 	stceq	0, cr0, [r0], {12}
     8f8:	0000660c 	andeq	r6, r0, ip, lsl #12
     8fc:	08010300 	stmdaeq	r1, {r8, r9}
     900:	0000006b 	andeq	r0, r0, fp, rrx
     904:	00010d02 	andeq	r0, r1, r2, lsl #26
     908:	540f0c00 	strpl	r0, [pc], #3072	; 910 <DISABLE_IRQ+0x890>
     90c:	02000000 	andeq	r0, r0, #0
     910:	00000439 	andeq	r0, r0, r9, lsr r4
     914:	0030100c 	eorseq	r1, r0, ip
     918:	d5020000 	strle	r0, [r2]
     91c:	0c00000d 	stceq	0, cr0, [r0], {13}
     920:	00005411 	andeq	r5, r0, r1, lsl r4
     924:	0cb90400 	cfldrseq	mvf0, [r9]
     928:	0d240000 	stceq	0, cr0, [r4]
     92c:	00f60139 	rscseq	r0, r6, r9, lsr r1
     930:	9e050000 	cdpls	0, 0, cr0, cr5, cr0, {0}
     934:	0d000011 	stceq	0, cr0, [r0, #-68]	; 0xffffffbc
     938:	0025013a 	eoreq	r0, r5, sl, lsr r1
     93c:	23020000 	movwcs	r0, #8192	; 0x2000
     940:	10860500 	addne	r0, r6, r0, lsl #10
     944:	3b0d0000 	blcc	34094c <DISABLE_IRQ+0x3408cc>
     948:	0000f601 	andeq	pc, r0, r1, lsl #12
     94c:	04230200 	strteq	r0, [r3], #-512	; 0x200
     950:	0006ff05 	andeq	pc, r6, r5, lsl #30
     954:	013c0d00 	teqeq	ip, r0, lsl #26
     958:	00000037 	andeq	r0, r0, r7, lsr r0
     95c:	05082302 	streq	r2, [r8, #-770]	; 0x302
     960:	00000448 	andeq	r0, r0, r8, asr #8
     964:	25013e0d 	strcs	r3, [r1, #-3597]	; 0xe0d
     968:	02000000 	andeq	r0, r0, #0
     96c:	33050a23 	movwcc	r0, #23075	; 0x5a23
     970:	0d000006 	stceq	0, cr0, [r0, #-24]	; 0xffffffe8
     974:	00f8013f 	rscseq	r0, r8, pc, lsr r1
     978:	23020000 	movwcs	r0, #8192	; 0x2000
     97c:	0ef9050b 	cdpeq	5, 15, cr0, cr9, cr11, {0}
     980:	460d0000 	strmi	r0, [sp], -r0
     984:	00010b01 	andeq	r0, r1, r1, lsl #22
     988:	13230200 	teqne	r3, #0
     98c:	07040600 	streq	r0, [r4, -r0, lsl #12]
     990:	00000025 	andeq	r0, r0, r5, lsr #32
     994:	00000108 	andeq	r0, r0, r8, lsl #2
     998:	00010808 	andeq	r0, r1, r8, lsl #16
     99c:	09000700 	stmdbeq	r0, {r8, r9, sl}
     9a0:	25070704 	strcs	r0, [r7, #-1796]	; 0x704
     9a4:	1b000000 	blne	9ac <DISABLE_IRQ+0x92c>
     9a8:	08000001 	stmdaeq	r0, {r0}
     9ac:	00000108 	andeq	r0, r0, r8, lsl #2
     9b0:	460a000f 	strmi	r0, [sl], -pc
     9b4:	0d000003 	stceq	0, cr0, [r0, #-12]
     9b8:	008e0148 	addeq	r0, lr, r8, asr #2
     9bc:	950a0000 	strls	r0, [sl]
     9c0:	0d000011 	stceq	0, cr0, [r0, #-68]	; 0xffffffbc
     9c4:	00370159 	eorseq	r0, r7, r9, asr r1
     9c8:	c6040000 	strgt	r0, [r4], -r0
     9cc:	1c000009 	stcne	0, cr0, [r0], {9}
     9d0:	7d01610d 	stfvcs	f6, [r1, #-52]	; 0xffffffcc
     9d4:	05000001 	streq	r0, [r0, #-1]
     9d8:	00000565 	andeq	r0, r0, r5, ror #10
     9dc:	2501620d 	strcs	r6, [r1, #-525]	; 0x20d
     9e0:	02000000 	andeq	r0, r0, #0
     9e4:	a4050023 	strge	r0, [r5], #-35	; 0x23
     9e8:	0d000007 	stceq	0, cr0, [r0, #-28]	; 0xffffffe4
     9ec:	00f60163 	rscseq	r0, r6, r3, ror #2
     9f0:	23020000 	movwcs	r0, #8192	; 0x2000
     9f4:	10750504 	rsbsne	r0, r5, r4, lsl #10
     9f8:	640d0000 	strvs	r0, [sp]
     9fc:	00012701 	andeq	r2, r1, r1, lsl #14
     a00:	08230200 	stmdaeq	r3!, {r9}
     a04:	00023505 	andeq	r3, r2, r5, lsl #10
     a08:	01660d00 	cmneq	r6, r0, lsl #26
     a0c:	0000010b 	andeq	r0, r0, fp, lsl #2
     a10:	000a2302 	andeq	r2, sl, r2, lsl #6
     a14:	0012850a 	andseq	r8, r2, sl, lsl #10
     a18:	01680d00 	cmneq	r8, r0, lsl #26
     a1c:	00000133 	andeq	r0, r0, r3, lsr r1
     a20:	000ec004 	andeq	ip, lr, r4
     a24:	6c0d1400 	cfstrsvs	mvf1, [sp], {0}
     a28:	0001f101 	andeq	pc, r1, r1, lsl #2
     a2c:	12a50500 	adcne	r0, r5, #0
     a30:	6d0d0000 	stcvs	0, cr0, [sp]
     a34:	0000f601 	andeq	pc, r0, r1, lsl #12
     a38:	00230200 	eoreq	r0, r3, r0, lsl #4
     a3c:	0002ae05 	andeq	sl, r2, r5, lsl #28
     a40:	016e0d00 	cmneq	lr, r0, lsl #26
     a44:	000000f6 	strdeq	r0, [r0], -r6
     a48:	05042302 	streq	r2, [r4, #-770]	; 0x302
     a4c:	0000048a 	andeq	r0, r0, sl, lsl #9
     a50:	f6016f0d 	undefined instruction 0xf6016f0d
     a54:	02000000 	andeq	r0, r0, #0
     a58:	ec050823 	stc	8, cr0, [r5], {35}	; 0x23
     a5c:	0d000003 	stceq	0, cr0, [r0, #-12]
     a60:	00f60170 	rscseq	r0, r6, r0, ror r1
     a64:	23020000 	movwcs	r0, #8192	; 0x2000
     a68:	0fdb050c 	svceq	0x00db050c
     a6c:	710d0000 	tstvc	sp, r0
     a70:	00012701 	andeq	r2, r1, r1, lsl #14
     a74:	10230200 	eorne	r0, r3, r0, lsl #4
     a78:	00036605 	andeq	r6, r3, r5, lsl #12
     a7c:	01720d00 	cmneq	r2, r0, lsl #26
     a80:	00000025 	andeq	r0, r0, r5, lsr #32
     a84:	00122302 	andseq	r2, r2, r2, lsl #6
     a88:	000f390a 	andeq	r3, pc, sl, lsl #18
     a8c:	01770d00 	cmneq	r7, r0, lsl #26
     a90:	00000189 	andeq	r0, r0, r9, lsl #3
     a94:	0011f804 	andseq	pc, r1, r4, lsl #16
     a98:	820d1000 	andhi	r1, sp, #0
     a9c:	00023801 	andeq	r3, r2, r1, lsl #16
     aa0:	0a730500 	beq	1cc1ea8 <MEM_SIZE+0x14c1ea8>
     aa4:	830d0000 	movwhi	r0, #53248	; 0xd000
     aa8:	0000f601 	andeq	pc, r0, r1, lsl #12
     aac:	00230200 	eoreq	r0, r3, r0, lsl #4
     ab0:	00063305 	andeq	r3, r6, r5, lsl #6
     ab4:	01850d00 	orreq	r0, r5, r0, lsl #26
     ab8:	000000f8 	strdeq	r0, [r0], -r8
     abc:	05042302 	streq	r2, [r4, #-770]	; 0x302
     ac0:	00000448 	andeq	r0, r0, r8, asr #8
     ac4:	2501860d 	strcs	r8, [r1, #-1549]	; 0x60d
     ac8:	02000000 	andeq	r0, r0, #0
     acc:	0a000c23 	beq	3b60 <DISABLE_IRQ+0x3ae0>
     ad0:	00001278 	andeq	r1, r0, r8, ror r2
     ad4:	fd018b0d 	stc2	11, cr8, [r1, #-52]	; 0xffffffcc
     ad8:	04000001 	streq	r0, [r0], #-1
     adc:	000008a9 	andeq	r0, r0, r9, lsr #17
     ae0:	01950d24 	orrseq	r0, r5, r4, lsr #26
     ae4:	000002ac 	andeq	r0, r0, ip, lsr #5
     ae8:	000f6405 	andeq	r6, pc, r5, lsl #8
     aec:	01960d00 	orrseq	r0, r6, r0, lsl #26
     af0:	000000f6 	strdeq	r0, [r0], -r6
     af4:	05002302 	streq	r2, [r0, #-770]	; 0x302
     af8:	00000ccb 	andeq	r0, r0, fp, asr #25
     afc:	f601970d 	undefined instruction 0xf601970d
     b00:	02000000 	andeq	r0, r0, #0
     b04:	d6050423 	strle	r0, [r5], -r3, lsr #8
     b08:	0d000011 	stceq	0, cr0, [r0, #-68]	; 0xffffffbc
     b0c:	00490198 	umaaleq	r0, r9, r8, r1
     b10:	23020000 	movwcs	r0, #8192	; 0x2000
     b14:	129a0508 	addsne	r0, sl, #33554432	; 0x2000000
     b18:	990d0000 	stmdbls	sp, {}
     b1c:	00004901 	andeq	r4, r0, r1, lsl #18
     b20:	0c230200 	sfmeq	f0, 4, [r3]	; (stceq 2, cr0, [r3])
     b24:	00067a05 	andeq	r7, r6, r5, lsl #20
     b28:	019a0d00 	orrseq	r0, sl, r0, lsl #26
     b2c:	00000049 	andeq	r0, r0, r9, asr #32
     b30:	05102302 	ldreq	r2, [r0, #-770]	; 0x302
     b34:	00000d26 	andeq	r0, r0, r6, lsr #26
     b38:	0b019c0d 	bleq	67b74 <DISABLE_IRQ+0x67af4>
     b3c:	02000001 	andeq	r0, r0, #1
     b40:	0a001423 	beq	5bd4 <DISABLE_IRQ+0x5b54>
     b44:	00000807 	andeq	r0, r0, r7, lsl #16
     b48:	44019e0d 	strmi	r9, [r1], #-3597	; 0xe0d
     b4c:	04000002 	streq	r0, [r0], #-2
     b50:	00000fa4 	andeq	r0, r0, r4, lsr #31
     b54:	01a10d18 	undefined instruction 0x01a10d18
     b58:	00000320 	andeq	r0, r0, r0, lsr #6
     b5c:	0005d305 	andeq	sp, r5, r5, lsl #6
     b60:	01a20d00 	undefined instruction 0x01a20d00
     b64:	000000f6 	strdeq	r0, [r0], -r6
     b68:	05002302 	streq	r2, [r0, #-770]	; 0x302
     b6c:	0000110b 	andeq	r1, r0, fp, lsl #2
     b70:	f601a30d 	undefined instruction 0xf601a30d
     b74:	02000000 	andeq	r0, r0, #0
     b78:	6d050423 	cfstrsvs	mvf0, [r5, #-140]	; 0xffffff74
     b7c:	0d000009 	stceq	0, cr0, [r0, #-36]	; 0xffffffdc
     b80:	004901a4 	subeq	r0, r9, r4, lsr #3
     b84:	23020000 	movwcs	r0, #8192	; 0x2000
     b88:	0cef0508 	cfstr64eq	mvdx0, [pc], #32
     b8c:	a50d0000 	strge	r0, [sp]
     b90:	00004901 	andeq	r4, r0, r1, lsl #18
     b94:	0c230200 	sfmeq	f0, 4, [r3]	; (stceq 2, cr0, [r3])
     b98:	0011b705 	andseq	fp, r1, r5, lsl #14
     b9c:	01a60d00 	undefined instruction 0x01a60d00
     ba0:	00000049 	andeq	r0, r0, r9, asr #32
     ba4:	05102302 	ldreq	r2, [r0, #-770]	; 0x302
     ba8:	00000588 	andeq	r0, r0, r8, lsl #11
     bac:	4901a70d 	stmdbmi	r1, {r0, r2, r3, r8, r9, sl, sp, pc}
     bb0:	02000000 	andeq	r0, r0, #0
     bb4:	0a001423 	beq	5c48 <DISABLE_IRQ+0x5bc8>
     bb8:	00000dad 	andeq	r0, r0, sp, lsr #27
     bbc:	b801a80d 	stmdalt	r1, {r0, r2, r3, fp, sp, pc}
     bc0:	04000002 	streq	r0, [r0], #-2
     bc4:	0000083c 	andeq	r0, r0, ip, lsr r8
     bc8:	01b30d0c 	undefined instruction 0x01b30d0c
     bcc:	00000385 	andeq	r0, r0, r5, lsl #7
     bd0:	00063305 	andeq	r3, r6, r5, lsl #6
     bd4:	01b50d00 	undefined instruction 0x01b50d00
     bd8:	000000f8 	strdeq	r0, [r0], -r8
     bdc:	05002302 	streq	r2, [r0, #-770]	; 0x302
     be0:	00000448 	andeq	r0, r0, r8, asr #8
     be4:	2501b60d 	strcs	fp, [r1, #-1549]	; 0x60d
     be8:	02000000 	andeq	r0, r0, #0
     bec:	ee050823 	cdp	8, 0, cr0, cr5, cr3, {1}
     bf0:	0d000008 	stceq	0, cr0, [r0, #-32]	; 0xffffffe0
     bf4:	002501bb 	undefined instruction 0x002501bb
     bf8:	23020000 	movwcs	r0, #8192	; 0x2000
     bfc:	10ff0509 	rscsne	r0, pc, r9, lsl #10
     c00:	bc0d0000 	stclt	0, cr0, [sp], {0}
     c04:	00002501 	andeq	r2, r0, r1, lsl #10
     c08:	0a230200 	beq	8c1410 <MEM_SIZE+0xc1410>
     c0c:	00118a05 	andseq	r8, r1, r5, lsl #20
     c10:	01bd0d00 	undefined instruction 0x01bd0d00
     c14:	00000025 	andeq	r0, r0, r5, lsr #32
     c18:	000b2302 	andeq	r2, fp, r2, lsl #6
     c1c:	000b020a 	andeq	r0, fp, sl, lsl #4
     c20:	01be0d00 	undefined instruction 0x01be0d00
     c24:	0000032c 	andeq	r0, r0, ip, lsr #6
     c28:	000b9e04 	andeq	r9, fp, r4, lsl #28
     c2c:	c80d1800 	stmdagt	sp, {fp, ip}
     c30:	00040801 	andeq	r0, r4, r1, lsl #16
     c34:	0b800500 	bleq	fe00203c <rEINTPEND+0xa8001f94>
     c38:	c90d0000 	stmdbgt	sp, {}
     c3c:	00040801 	andeq	r0, r4, r1, lsl #16
     c40:	00230200 	eoreq	r0, r3, r0, lsl #4
     c44:	000c1305 	andeq	r1, ip, r5, lsl #6
     c48:	01ca0d00 	biceq	r0, sl, r0, lsl #26
     c4c:	0000040e 	andeq	r0, r0, lr, lsl #8
     c50:	05042302 	streq	r2, [r4, #-770]	; 0x302
     c54:	00000fce 	andeq	r0, r0, lr, asr #31
     c58:	0e01cb0d 	vmlaeq.f64	d12, d1, d13
     c5c:	02000004 	andeq	r0, r0, #4
     c60:	2c050823 	stccs	8, cr0, [r5], {35}	; 0x23
     c64:	0d000008 	stceq	0, cr0, [r0, #-32]	; 0xffffffe0
     c68:	040e01cc 	streq	r0, [lr], #-460	; 0x1cc
     c6c:	23020000 	movwcs	r0, #8192	; 0x2000
     c70:	0616050c 	ldreq	r0, [r6], -ip, lsl #10
     c74:	cd0d0000 	stcgt	0, cr0, [sp]
     c78:	00040e01 	andeq	r0, r4, r1, lsl #28
     c7c:	10230200 	eorne	r0, r3, r0, lsl #4
     c80:	00053c05 	andeq	r3, r5, r5, lsl #24
     c84:	01ce0d00 	biceq	r0, lr, r0, lsl #26
     c88:	00000037 	andeq	r0, r0, r7, lsr r0
     c8c:	05142302 	ldreq	r2, [r4, #-770]	; 0x302
     c90:	00000252 	andeq	r0, r0, r2, asr r2
     c94:	3701cf0d 	strcc	ip, [r1, -sp, lsl #30]
     c98:	02000000 	andeq	r0, r0, #0
     c9c:	0b001623 	bleq	6530 <DISABLE_IRQ+0x64b0>
     ca0:	00039104 	andeq	r9, r3, r4, lsl #2
     ca4:	f6040b00 	undefined instruction 0xf6040b00
     ca8:	0a000000 	beq	cb0 <DISABLE_IRQ+0xc30>
     cac:	000008e2 	andeq	r0, r0, r2, ror #17
     cb0:	9101d00d 	tstls	r1, sp
     cb4:	04000003 	streq	r0, [r0], #-3
     cb8:	00000ee5 	andeq	r0, r0, r5, ror #29
     cbc:	01d30d14 	bicseq	r0, r3, r4, lsl sp
     cc0:	00000479 	andeq	r0, r0, r9, ror r4
     cc4:	000a7305 	andeq	r7, sl, r5, lsl #6
     cc8:	01d40d00 	bicseq	r0, r4, r0, lsl #26
     ccc:	000000f6 	strdeq	r0, [r0], -r6
     cd0:	05002302 	streq	r2, [r0, #-770]	; 0x302
     cd4:	00000aa9 	andeq	r0, r0, r9, lsr #21
     cd8:	3701d50d 	strcc	sp, [r1, -sp, lsl #10]
     cdc:	02000000 	andeq	r0, r0, #0
     ce0:	3c050423 	cfstrscc	mvf0, [r5], {35}	; 0x23
     ce4:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
     ce8:	003701d6 	ldrsbteq	r0, [r7], -r6
     cec:	23020000 	movwcs	r0, #8192	; 0x2000
     cf0:	06330506 	ldrteq	r0, [r3], -r6, lsl #10
     cf4:	d80d0000 	stmdale	sp, {}
     cf8:	0000f801 	andeq	pc, r0, r1, lsl #16
     cfc:	08230200 	stmdaeq	r3!, {r9}
     d00:	00044805 	andeq	r4, r4, r5, lsl #16
     d04:	01d90d00 	bicseq	r0, r9, r0, lsl #26
     d08:	00000025 	andeq	r0, r0, r5, lsr #32
     d0c:	00102302 	andseq	r2, r0, r2, lsl #6
     d10:	0007b30a 	andeq	fp, r7, sl, lsl #6
     d14:	01de0d00 	bicseq	r0, lr, r0, lsl #26
     d18:	00000420 	andeq	r0, r0, r0, lsr #8
     d1c:	00120504 	andseq	r0, r2, r4, lsl #10
     d20:	e80d0c00 	stmda	sp, {sl, fp}
     d24:	0004c001 	andeq	ip, r4, r1
     d28:	05da0500 	ldrbeq	r0, [sl, #1280]	; 0x500
     d2c:	e90d0000 	stmdb	sp, {}
     d30:	00003701 	andeq	r3, r0, r1, lsl #14
     d34:	00230200 	eoreq	r0, r3, r0, lsl #4
     d38:	00063305 	andeq	r3, r6, r5, lsl #6
     d3c:	01eb0d00 	mvneq	r0, r0, lsl #26
     d40:	000000f8 	strdeq	r0, [r0], -r8
     d44:	05022302 	streq	r2, [r2, #-770]	; 0x302
     d48:	00000448 	andeq	r0, r0, r8, asr #8
     d4c:	2501ec0d 	strcs	lr, [r1, #-3085]	; 0xc0d
     d50:	02000000 	andeq	r0, r0, #0
     d54:	0a000a23 	beq	35e8 <DISABLE_IRQ+0x3568>
     d58:	00001036 	andeq	r1, r0, r6, lsr r0
     d5c:	8501f10d 	strhi	pc, [r1, #-269]	; 0x10d
     d60:	04000004 	streq	r0, [r0], #-4
     d64:	0000126c 	andeq	r1, r0, ip, ror #4
     d68:	01fb0d08 	mvnseq	r0, r8, lsl #26
     d6c:	000004f8 	strdeq	r0, [r0], -r8
     d70:	000e3905 	andeq	r3, lr, r5, lsl #18
     d74:	01fc0d00 	mvnseq	r0, r0, lsl #26
     d78:	00000049 	andeq	r0, r0, r9, asr #32
     d7c:	05002302 	streq	r2, [r0, #-770]	; 0x302
     d80:	00000f26 	andeq	r0, r0, r6, lsr #30
     d84:	4901fd0d 	stmdbmi	r1, {r0, r2, r3, r8, sl, fp, ip, sp, lr, pc}
     d88:	02000000 	andeq	r0, r0, #0
     d8c:	0a000423 	beq	1e20 <DISABLE_IRQ+0x1da0>
     d90:	0000021b 	andeq	r0, r0, fp, lsl r2
     d94:	cc01fe0d 	stcgt	14, cr15, [r1], {13}
     d98:	04000004 	streq	r0, [r0], #-4
     d9c:	000001ed 	andeq	r0, r0, sp, ror #3
     da0:	02080d58 	andeq	r0, r8, #5632	; 0x1600
     da4:	000006a7 	andeq	r0, r0, r7, lsr #13
     da8:	00033205 	andeq	r3, r3, r5, lsl #4
     dac:	02090d00 	andeq	r0, r9, #0
     db0:	000006a7 	andeq	r0, r0, r7, lsr #13
     db4:	05002302 	streq	r2, [r0, #-770]	; 0x302
     db8:	00000a04 	andeq	r0, r0, r4, lsl #20
     dbc:	f6020c0d 	undefined instruction 0xf6020c0d
     dc0:	02000000 	andeq	r0, r0, #0
     dc4:	44050423 	strmi	r0, [r5], #-1059	; 0x423
     dc8:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
     dcc:	06a7020d 	strteq	r0, [r7], sp, lsl #4
     dd0:	23020000 	movwcs	r0, #8192	; 0x2000
     dd4:	0b1c0508 	bleq	7021fc <DISABLE_IRQ+0x70217c>
     dd8:	0e0d0000 	cdpeq	0, 0, cr0, cr13, cr0, {0}
     ddc:	00004902 	andeq	r4, r0, r2, lsl #18
     de0:	0c230200 	sfmeq	f0, 4, [r3]	; (stceq 2, cr0, [r3])
     de4:	00117a05 	andseq	r7, r1, r5, lsl #20
     de8:	020f0d00 	andeq	r0, pc, #0
     dec:	00000037 	andeq	r0, r0, r7, lsr r0
     df0:	05102302 	ldreq	r2, [r0, #-770]	; 0x302
     df4:	000005f4 	strdeq	r0, [r0], -r4
     df8:	3702100d 	strcc	r1, [r2, -sp]
     dfc:	02000000 	andeq	r0, r0, #0
     e00:	d8051223 	stmdale	r5, {r0, r1, r5, r9, ip}
     e04:	0d000008 	stceq	0, cr0, [r0, #-32]	; 0xffffffe0
     e08:	06ad0213 	ssateq	r0, #14, r3, lsl #4
     e0c:	23020000 	movwcs	r0, #8192	; 0x2000
     e10:	09970514 	ldmibeq	r7, {r2, r4, r8, sl}
     e14:	140d0000 	strne	r0, [sp]
     e18:	0006ad02 	andeq	sl, r6, r2, lsl #26
     e1c:	18230200 	stmdane	r3!, {r9}
     e20:	000e4005 	andeq	r4, lr, r5
     e24:	02170d00 	andseq	r0, r7, #0
     e28:	000006b3 	undefined instruction 0x000006b3
     e2c:	051c2302 	ldreq	r2, [ip, #-770]	; 0x302
     e30:	000006a8 	andeq	r0, r0, r8, lsr #13
     e34:	f6021b0d 	undefined instruction 0xf6021b0d
     e38:	02000000 	andeq	r0, r0, #0
     e3c:	e3052023 	movw	r2, #20515	; 0x5023
     e40:	0d000002 	stceq	0, cr0, [r0, #-8]
     e44:	06b90220 	ldrteq	r0, [r9], r0, lsr #4
     e48:	23020000 	movwcs	r0, #8192	; 0x2000
     e4c:	0b440524 	bleq	11022e4 <MEM_SIZE+0x9022e4>
     e50:	220d0000 	andcs	r0, sp, #0
     e54:	00012702 	andeq	r2, r1, r2, lsl #14
     e58:	28230200 	stmdacs	r3!, {r9}
     e5c:	00066805 	andeq	r6, r6, r5, lsl #16
     e60:	02250d00 	eoreq	r0, r5, #0
     e64:	00000037 	andeq	r0, r0, r7, lsr r0
     e68:	052a2302 	streq	r2, [sl, #-770]!	; 0x302
     e6c:	00000e25 	andeq	r0, r0, r5, lsr #28
     e70:	2502260d 	strcs	r2, [r2, #-1549]	; 0x60d
     e74:	02000000 	andeq	r0, r0, #0
     e78:	7d052c23 	stcvc	12, cr2, [r5, #-140]	; 0xffffff74
     e7c:	0d000002 	stceq	0, cr0, [r0, #-8]
     e80:	00780227 	rsbseq	r0, r8, r7, lsr #4
     e84:	23020000 	movwcs	r0, #8192	; 0x2000
     e88:	0dfc052d 	cfldr64eq	mvdx0, [ip, #180]!	; 0xb4
     e8c:	280d0000 	stmdacs	sp, {}
     e90:	00002502 	andeq	r2, r0, r2, lsl #10
     e94:	2e230200 	cdpcs	2, 2, cr0, cr3, cr0, {0}
     e98:	00105105 	andseq	r5, r0, r5, lsl #2
     e9c:	022a0d00 	eoreq	r0, sl, #0
     ea0:	00000025 	andeq	r0, r0, r5, lsr #32
     ea4:	052f2302 	streq	r2, [pc, #-770]!	; baa <DISABLE_IRQ+0xb2a>
     ea8:	00001058 	andeq	r1, r0, r8, asr r0
     eac:	25022b0d 	strcs	r2, [r2, #-2829]	; 0xb0d
     eb0:	02000000 	andeq	r0, r0, #0
     eb4:	12053023 	andne	r3, r5, #35	; 0x23
     eb8:	0d00000f 	stceq	0, cr0, [r0, #-60]	; 0xffffffc4
     ebc:	0025022d 	eoreq	r0, r5, sp, lsr #4
     ec0:	23020000 	movwcs	r0, #8192	; 0x2000
     ec4:	0f1c0531 	svceq	0x001c0531
     ec8:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
     ecc:	00002502 	andeq	r2, r0, r2, lsl #10
     ed0:	32230200 	eorcc	r0, r3, #0
     ed4:	000ce305 	andeq	lr, ip, r5, lsl #6
     ed8:	02350d00 	eorseq	r0, r5, #0
     edc:	00000025 	andeq	r0, r0, r5, lsr #32
     ee0:	05332302 	ldreq	r2, [r3, #-770]!	; 0x302
     ee4:	00000ca4 	andeq	r0, r0, r4, lsr #25
     ee8:	4902390d 	stmdbmi	r2, {r0, r2, r3, r8, fp, ip, sp}
     eec:	02000000 	andeq	r0, r0, #0
     ef0:	d2053423 	andle	r3, r5, #587202560	; 0x23000000
     ef4:	0d000003 	stceq	0, cr0, [r0, #-12]
     ef8:	0049023a 	subeq	r0, r9, sl, lsr r2
     efc:	23020000 	movwcs	r0, #8192	; 0x2000
     f00:	07e90538 	undefined instruction 0x07e90538
     f04:	3b0d0000 	blcc	340f0c <DISABLE_IRQ+0x340e8c>
     f08:	00004902 	andeq	r4, r0, r2, lsl #18
     f0c:	3c230200 	sfmcc	f0, 4, [r3]	; (stccc 2, cr0, [r3])
     f10:	0003ab05 	andeq	sl, r3, r5, lsl #22
     f14:	023c0d00 	eorseq	r0, ip, #0
     f18:	000006a7 	andeq	r0, r0, r7, lsr #13
     f1c:	05402302 	strbeq	r2, [r0, #-770]	; 0x302
     f20:	000006f2 	strdeq	r0, [r0], -r2
     f24:	49023d0d 	stmdbmi	r2, {r0, r2, r3, r8, sl, fp, ip, sp}
     f28:	02000000 	andeq	r0, r0, #0
     f2c:	86054423 	strhi	r4, [r5], -r3, lsr #8
     f30:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
     f34:	010b0241 	tsteq	fp, r1, asr #4
     f38:	23020000 	movwcs	r0, #8192	; 0x2000
     f3c:	040b0048 	streq	r0, [fp], #-72	; 0x48
     f40:	00000083 	andeq	r0, r0, r3, lsl #1
     f44:	0504040b 	streq	r0, [r4, #-1035]	; 0x40b
     f48:	040b0000 	streq	r0, [fp]
     f4c:	0000011b 	andeq	r0, r0, fp, lsl r1
     f50:	01f1040b 	mvnseq	r0, fp, lsl #8
     f54:	5b0a0000 	blpl	280f5c <DISABLE_IRQ+0x280edc>
     f58:	0d000012 	stceq	0, cr0, [r0, #-72]	; 0xffffffb8
     f5c:	05040243 	streq	r0, [r4, #-579]	; 0x243
     f60:	4f0a0000 	svcmi	0x000a0000
     f64:	0d000003 	stceq	0, cr0, [r0, #-12]
     f68:	06d7024d 	ldrbeq	r0, [r7], sp, asr #4
     f6c:	040b0000 	streq	r0, [fp]
     f70:	000006dd 	ldrdeq	r0, [r0], -sp
     f74:	06ee010c 	strbteq	r0, [lr], ip, lsl #2
     f78:	f60d0000 	undefined instruction 0xf60d0000
     f7c:	0d000000 	stceq	0, cr0, [r0]
     f80:	000000f6 	strdeq	r0, [r0], -r6
     f84:	0d9c0400 	cfldrseq	mvf0, [ip]
     f88:	0d340000 	ldceq	0, cr0, [r4]
     f8c:	07a10251 	sbfxeq	r0, r1, #4, #2
     f90:	6b050000 	blvs	140f98 <DISABLE_IRQ+0x140f18>
     f94:	0d000010 	stceq	0, cr0, [r0, #-64]	; 0xffffffc0
     f98:	00250252 	eoreq	r0, r5, r2, asr r2
     f9c:	23020000 	movwcs	r0, #8192	; 0x2000
     fa0:	08760500 	ldmdaeq	r6!, {r8, sl}^
     fa4:	530d0000 	movwpl	r0, #53248	; 0xd000
     fa8:	0006cb02 	andeq	ip, r6, r2, lsl #22
     fac:	04230200 	strteq	r0, [r3], #-512	; 0x200
     fb0:	000ecd05 	andeq	ip, lr, r5, lsl #26
     fb4:	02540d00 	subseq	r0, r4, #0
     fb8:	000000f6 	strdeq	r0, [r0], -r6
     fbc:	05082302 	streq	r2, [r8, #-770]	; 0x302
     fc0:	00000428 	andeq	r0, r0, r8, lsr #8
     fc4:	f602550d 	undefined instruction 0xf602550d
     fc8:	02000000 	andeq	r0, r0, #0
     fcc:	1b050c23 	blne	144060 <DISABLE_IRQ+0x143fe0>
     fd0:	0d000012 	stceq	0, cr0, [r0, #-72]	; 0xffffffb8
     fd4:	00f60256 	rscseq	r0, r6, r6, asr r2
     fd8:	23020000 	movwcs	r0, #8192	; 0x2000
     fdc:	10e60510 	rscne	r0, r6, r0, lsl r5
     fe0:	570d0000 	strpl	r0, [sp, -r0]
     fe4:	00004902 	andeq	r4, r0, r2, lsl #18
     fe8:	14230200 	strtne	r0, [r3], #-512	; 0x200
     fec:	00074505 	andeq	r4, r7, r5, lsl #10
     ff0:	02580d00 	subseq	r0, r8, #0
     ff4:	00000049 	andeq	r0, r0, r9, asr #32
     ff8:	05182302 	ldreq	r2, [r8, #-770]	; 0x302
     ffc:	00000399 	muleq	r0, r9, r3
    1000:	4902590d 	stmdbmi	r2, {r0, r2, r3, r8, fp, ip, lr}
    1004:	02000000 	andeq	r0, r0, #0
    1008:	1c051c23 	stcne	12, cr1, [r5], {35}	; 0x23
    100c:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    1010:	010b025b 	tsteq	fp, fp, asr r2
    1014:	23020000 	movwcs	r0, #8192	; 0x2000
    1018:	0e610520 	cdpeq	5, 6, cr0, cr1, cr0, {1}
    101c:	5d0d0000 	stcpl	0, cr0, [sp]
    1020:	00002502 	andeq	r2, r0, r2, lsl #10
    1024:	30230200 	eorcc	r0, r3, r0, lsl #4
    1028:	00076d05 	andeq	r6, r7, r5, lsl #26
    102c:	025e0d00 	subseq	r0, lr, #0
    1030:	00000025 	andeq	r0, r0, r5, lsr #32
    1034:	00312302 	eorseq	r2, r1, r2, lsl #6
    1038:	000cb20a 	andeq	fp, ip, sl, lsl #4
    103c:	02620d00 	rsbeq	r0, r2, #0
    1040:	000006ee 	andeq	r0, r0, lr, ror #13
    1044:	0012e104 	andseq	lr, r2, r4, lsl #2
    1048:	660d0800 	strvs	r0, [sp], -r0, lsl #16
    104c:	0007d902 	andeq	sp, r7, r2, lsl #18
    1050:	05310500 	ldreq	r0, [r1, #-1280]!	; 0x500
    1054:	670d0000 	strvs	r0, [sp, -r0]
    1058:	0007d902 	andeq	sp, r7, r2, lsl #18
    105c:	00230200 	eoreq	r0, r3, r0, lsl #4
    1060:	0010a905 	andseq	sl, r0, r5, lsl #18
    1064:	02680d00 	rsbeq	r0, r8, #0
    1068:	00000037 	andeq	r0, r0, r7, lsr r0
    106c:	00042302 	andeq	r2, r4, r2, lsl #6
    1070:	07a1040b 	streq	r0, [r1, fp, lsl #8]!
    1074:	590a0000 	stmdbpl	sl, {}
    1078:	0d00000b 	stceq	0, cr0, [r0, #-44]	; 0xffffffd4
    107c:	07ad0269 	streq	r0, [sp, r9, ror #4]!
    1080:	010e0000 	tsteq	lr, r0
    1084:	00001211 	andeq	r1, r0, r1, lsl r2
    1088:	01046e01 	tsteq	r4, r1, lsl #28
    108c:	00081301 	andeq	r1, r8, r1, lsl #6
    1090:	08260f00 	stmdaeq	r6!, {r8, r9, sl, fp}
    1094:	6e010000 	cdpvs	0, 0, cr0, cr1, cr0, {0}
    1098:	00081304 	andeq	r1, r8, r4, lsl #6
    109c:	0d340f00 	ldceq	15, cr0, [r4]
    10a0:	6e010000 	cdpvs	0, 0, cr0, cr1, cr0, {0}
    10a4:	00003704 	andeq	r3, r0, r4, lsl #14
    10a8:	040b0000 	streq	r0, [fp]
    10ac:	00000025 	andeq	r0, r0, r5, lsr #32
    10b0:	101d010e 	andsne	r0, sp, lr, lsl #2
    10b4:	61020000 	tstvs	r2, r0
    10b8:	65010104 	strvs	r0, [r1, #-260]	; 0x104
    10bc:	0f000008 	svceq	0x00000008
    10c0:	000002fc 	strdeq	r0, [r0], -ip
    10c4:	b9046102 	stmdblt	r4, {r1, r8, sp, lr}
    10c8:	10000006 	andne	r0, r0, r6
    10cc:	00000fba 	undefined instruction 0x00000fba
    10d0:	65046402 	strvs	r6, [r4, #-1026]	; 0x402
    10d4:	10000008 	andne	r0, r0, r8
    10d8:	00000c9f 	muleq	r0, pc, ip
    10dc:	6b046602 	blvs	11a8ec <DISABLE_IRQ+0x11a86c>
    10e0:	10000008 	andne	r0, r0, r8
    10e4:	00000210 	andeq	r0, r0, r0, lsl r2
    10e8:	b9046702 	stmdblt	r4, {r1, r8, r9, sl, sp, lr}
    10ec:	10000006 	andne	r0, r0, r6
    10f0:	00001136 	andeq	r1, r0, r6, lsr r1
    10f4:	b9046802 	stmdblt	r4, {r1, fp, sp, lr}
    10f8:	00000006 	andeq	r0, r0, r6
    10fc:	06bf040b 	ldrteq	r0, [pc], fp, lsl #8
    1100:	040b0000 	streq	r0, [fp]
    1104:	0000017d 	andeq	r0, r0, sp, ror r1
    1108:	0bde010e 	bleq	ff781548 <rEINTPEND+0xa97814a0>
    110c:	8e010000 	cdphi	0, 0, cr0, cr1, cr0, {0}
    1110:	a5010104 	strge	r0, [r1, #-260]	; 0x104
    1114:	0f000008 	svceq	0x00000008
    1118:	00000826 	andeq	r0, r0, r6, lsr #16
    111c:	13048e01 	movwne	r8, #19969	; 0x4e01
    1120:	0f000008 	svceq	0x00000008
    1124:	00000bd1 	ldrdeq	r0, [r0], -r1
    1128:	13048e01 	movwne	r8, #19969	; 0x4e01
    112c:	0f000008 	svceq	0x00000008
    1130:	00000d34 	andeq	r0, r0, r4, lsr sp
    1134:	37048e01 	strcc	r8, [r4, -r1, lsl #28]
    1138:	00000000 	andeq	r0, r0, r0
    113c:	081c0111 	ldmdaeq	ip, {r0, r4, r8}
    1140:	22010000 	andcs	r0, r1, #0
    1144:	00250105 	eoreq	r0, r5, r5, lsl #2
    1148:	d1010000 	tstle	r1, r0
    114c:	0f000008 	svceq	0x00000008
    1150:	00000bd1 	ldrdeq	r0, [r0], -r1
    1154:	13052201 	movwne	r2, #20993	; 0x5201
    1158:	12000008 	andne	r0, r0, #8
    115c:	006e656c 	rsbeq	r6, lr, ip, ror #10
    1160:	25052401 	strcs	r2, [r5, #-1025]	; 0x401
    1164:	00000000 	andeq	r0, r0, r0
    1168:	06b90111 	ssateq	r0, #26, r1, lsl #2
    116c:	02010000 	andeq	r0, r1, #0
    1170:	00250105 	eoreq	r0, r5, r5, lsl #2
    1174:	09010000 	stmdbeq	r1, {}
    1178:	0f000009 	svceq	0x00000009
    117c:	00000826 	andeq	r0, r0, r6, lsr #16
    1180:	13050201 	movwne	r0, #20993	; 0x5201
    1184:	0f000008 	svceq	0x00000008
    1188:	00000bd1 	ldrdeq	r0, [r0], -r1
    118c:	13050201 	movwne	r0, #20993	; 0x5201
    1190:	12000008 	andne	r0, r0, #8
    1194:	006e656c 	rsbeq	r6, lr, ip, ror #10
    1198:	25050401 	strcs	r0, [r5, #-1025]	; 0x401
    119c:	00000000 	andeq	r0, r0, r0
    11a0:	09dd010e 	ldmibeq	sp, {r1, r2, r3, r8}^
    11a4:	1a010000 	bne	411ac <DISABLE_IRQ+0x4112c>
    11a8:	3b010103 	blcc	415bc <DISABLE_IRQ+0x4153c>
    11ac:	0f000009 	svceq	0x00000009
    11b0:	0000035f 	andeq	r0, r0, pc, asr r3
    11b4:	b3031a01 	movwlt	r1, #14849	; 0x3a01
    11b8:	10000006 	andne	r0, r0, r6
    11bc:	00000714 	andeq	r0, r0, r4, lsl r7
    11c0:	13031d01 	movwne	r1, #15617	; 0x3d01
    11c4:	12000008 	andne	r0, r0, #8
    11c8:	21010069 	tstcs	r1, r9, rrx
    11cc:	00002503 	andeq	r2, r0, r3, lsl #10
    11d0:	93130000 	tstls	r3, #0
    11d4:	0100000c 	tsteq	r0, ip
    11d8:	010104d2 	ldrdeq	r0, [r1, -r2]
    11dc:	00000954 	andeq	r0, r0, r4, asr r9
    11e0:	01007912 	tsteq	r0, r2, lsl r9
    11e4:	002504d5 	ldrdeq	r0, [r5], -r5
    11e8:	14000000 	strne	r0, [r0]
    11ec:	00067101 	andeq	r7, r6, r1, lsl #2
    11f0:	02750100 	rsbseq	r0, r5, #0
    11f4:	010e0101 	tsteq	lr, r1, lsl #2
    11f8:	00000c33 	andeq	r0, r0, r3, lsr ip
    11fc:	01040105 	tsteq	r4, r5, lsl #2
    1200:	00099301 	andeq	r9, r9, r1, lsl #6
    1204:	09c10f00 	stmibeq	r1, {r8, r9, sl, fp}^
    1208:	01050000 	tsteq	r5, r0
    120c:	0006a704 	andeq	sl, r6, r4, lsl #14
    1210:	0d340f00 	ldceq	15, cr0, [r4]
    1214:	01050000 	tsteq	r5, r0
    1218:	00004904 	andeq	r4, r0, r4, lsl #18
    121c:	706f1500 	rsbvc	r1, pc, r0, lsl #10
    1220:	01050074 	tsteq	r5, r4, ror r0
    1224:	00003704 	andeq	r3, r0, r4, lsl #14
    1228:	0b130000 	bleq	4c1230 <DISABLE_IRQ+0x4c11b0>
    122c:	06000009 	streq	r0, [r0], -r9
    1230:	01010362 	tsteq	r1, r2, ror #6
    1234:	000009ae 	andeq	r0, r0, lr, lsr #19
    1238:	72726512 	rsbsvc	r6, r2, #75497472	; 0x4800000
    123c:	03650600 	cmneq	r5, #0
    1240:	00000025 	andeq	r0, r0, r5, lsr #32
    1244:	6c010e00 	stcvs	14, cr0, [r1], {0}
    1248:	01000004 	tsteq	r0, r4
    124c:	010102dd 	ldrdeq	r0, [r1, -sp]
    1250:	000009d4 	ldrdeq	r0, [r0], -r4
    1254:	00035f0f 	andeq	r5, r3, pc, lsl #30
    1258:	02dd0100 	sbcseq	r0, sp, #0
    125c:	000006b3 	undefined instruction 0x000006b3
    1260:	01007912 	tsteq	r0, r2, lsl r9
    1264:	002502df 	ldrdeq	r0, [r5], -pc
    1268:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    126c:	00038301 	andeq	r8, r3, r1, lsl #6
    1270:	02fc0100 	rscseq	r0, ip, #0
    1274:	09fa0101 	ldmibeq	sl!, {r0, r8}^
    1278:	5f0f0000 	svcpl	0x000f0000
    127c:	01000003 	tsteq	r0, r3
    1280:	06b302fc 	undefined instruction 0x06b302fc
    1284:	79120000 	ldmdbvc	r2, {}
    1288:	02fe0100 	rscseq	r0, lr, #0
    128c:	00000025 	andeq	r0, r0, r5, lsr #32
    1290:	08c01300 	stmiaeq	r0, {r8, r9, ip}^
    1294:	f3060000 	vhadd.u8	d0, d6, d0
    1298:	15010102 	strne	r0, [r1, #-258]	; 0x102
    129c:	0f00000a 	svceq	0x0000000a
    12a0:	000009d8 	ldrdeq	r0, [r0], -r8
    12a4:	d902f306 	stmdble	r2, {r1, r2, r8, r9, ip, sp, lr, pc}
    12a8:	00000007 	andeq	r0, r0, r7
    12ac:	000b1016 	andeq	r1, fp, r6, lsl r0
    12b0:	02d30600 	sbcseq	r0, r3, #0
    12b4:	0007d901 	andeq	sp, r7, r1, lsl #18
    12b8:	0a340100 	beq	d016c0 <MEM_SIZE+0x5016c0>
    12bc:	d8100000 	ldmdale	r0, {}
    12c0:	06000009 	streq	r0, [r0], -r9
    12c4:	07d902d5 	undefined instruction 0x07d902d5
    12c8:	13000000 	movwne	r0, #0
    12cc:	00000c4b 	andeq	r0, r0, fp, asr #24
    12d0:	0102960a 	tsteq	r2, sl, lsl #12
    12d4:	000a6501 	andeq	r6, sl, r1, lsl #10
    12d8:	0fba0f00 	svceq	0x00ba0f00
    12dc:	960a0000 	strls	r0, [sl], -r0
    12e0:	00086502 	andeq	r6, r8, r2, lsl #10
    12e4:	0e850f00 	cdpeq	15, 8, cr0, cr5, cr0, {0}
    12e8:	960a0000 	strls	r0, [sl], -r0
    12ec:	00002502 	andeq	r2, r0, r2, lsl #10
    12f0:	00791200 	rsbseq	r1, r9, r0, lsl #4
    12f4:	2502980a 	strcs	r9, [r2, #-2058]	; 0x80a
    12f8:	00000000 	andeq	r0, r0, r0
    12fc:	00105f17 	andseq	r5, r0, r7, lsl pc
    1300:	03700100 	cmneq	r0, #0
    1304:	fa130101 	blx	4c1710 <DISABLE_IRQ+0x4c1690>
    1308:	01000004 	tsteq	r0, r4
    130c:	01010394 	undefined instruction 0x01010394
    1310:	00000a94 	muleq	r0, r4, sl
    1314:	01006912 	tsteq	r0, r2, lsl r9
    1318:	00250396 	mlaeq	r5, r6, r3, r0
    131c:	65100000 	ldrvs	r0, [r0]
    1320:	01000009 	tsteq	r0, r9
    1324:	08130398 	ldmdaeq	r3, {r3, r4, r7, r8, r9}
    1328:	13000000 	movwne	r0, #0
    132c:	00000bc2 	andeq	r0, r0, r2, asr #23
    1330:	01043d01 	tsteq	r4, r1, lsl #26
    1334:	000ac501 	andeq	ip, sl, r1, lsl #10
    1338:	00691200 	rsbeq	r1, r9, r0, lsl #4
    133c:	25043f01 	strcs	r3, [r4, #-3841]	; 0xf01
    1340:	10000000 	andne	r0, r0, r0
    1344:	00000be9 	andeq	r0, r0, r9, ror #23
    1348:	65044001 	strvs	r4, [r4, #-1]
    134c:	10000008 	andne	r0, r0, r8
    1350:	00000bef 	andeq	r0, r0, pc, ror #23
    1354:	65044101 	strvs	r4, [r4, #-257]	; 0x101
    1358:	00000008 	andeq	r0, r0, r8
    135c:	00088913 	andeq	r8, r8, r3, lsl r9
    1360:	033a0100 	teqeq	sl, #0
    1364:	0af60101 	beq	ffd81770 <rEINTPEND+0xa9d816c8>
    1368:	69120000 	ldmdbvs	r2, {}
    136c:	033e0100 	teqeq	lr, #0
    1370:	00000037 	andeq	r0, r0, r7, lsr r0
    1374:	000a2e10 	andeq	r2, sl, r0, lsl lr
    1378:	033f0100 	teqeq	pc, #0
    137c:	000006b3 	undefined instruction 0x000006b3
    1380:	000a3610 	andeq	r3, sl, r0, lsl r6
    1384:	03400100 	movteq	r0, #256	; 0x100
    1388:	000006b3 	undefined instruction 0x000006b3
    138c:	08b01300 	ldmeq	r0!, {r8, r9, ip}
    1390:	b9010000 	stmdblt	r1, {}
    1394:	11010103 	tstne	r1, r3, lsl #2
    1398:	1200000b 	andne	r0, r0, #11
    139c:	00727265 	rsbseq	r7, r2, r5, ror #4
    13a0:	2503bc01 	strcs	fp, [r3, #-3073]	; 0xc01
    13a4:	00000000 	andeq	r0, r0, r0
    13a8:	000f8e13 	andeq	r8, pc, r3, lsl lr
    13ac:	03fb0100 	mvnseq	r0, #0
    13b0:	0b2c0101 	bleq	b017bc <MEM_SIZE+0x3017bc>
    13b4:	65120000 	ldrvs	r0, [r2]
    13b8:	01007272 	tsteq	r0, r2, ror r2
    13bc:	002503fe 	strdeq	r0, [r5], -lr
    13c0:	18000000 	stmdane	r0, {}
    13c4:	00054401 	andeq	r4, r5, r1, lsl #8
    13c8:	01d70700 	bicseq	r0, r7, r0, lsl #14
    13cc:	000b4601 	andeq	r4, fp, r1, lsl #12
    13d0:	04c81900 	strbeq	r1, [r8], #2304	; 0x900
    13d4:	d9070000 	stmdble	r7, {}
    13d8:	000000f6 	strdeq	r0, [r0], -r6
    13dc:	e1011a00 	tst	r1, r0, lsl #20
    13e0:	01000003 	tsteq	r0, r3
    13e4:	2c01012a 	stfcss	f0, [r1], {42}	; 0x2a
    13e8:	5c30000a 	ldcpl	0, cr0, [r0], #-40	; 0xffffffd8
    13ec:	0130000a 	teqeq	r0, sl
    13f0:	33011b5d 	movwcc	r1, #7005	; 0x1b5d
    13f4:	01000012 	tsteq	r0, r2, lsl r0
    13f8:	37010262 	strcc	r0, [r1, -r2, ror #4]
    13fc:	5c000000 	stcpl	0, cr0, [r0], {0}
    1400:	6830000a 	ldmdavs	r0!, {r1, r3}
    1404:	0130000a 	teqeq	r0, sl
    1408:	09541c5d 	ldmdbeq	r4, {r0, r2, r3, r4, r6, sl, fp, ip}^
    140c:	0a680000 	beq	1a01414 <MEM_SIZE+0x1201414>
    1410:	0a6c3000 	beq	1b0d418 <MEM_SIZE+0x130d418>
    1414:	5d013000 	stcpl	0, cr3, [r1]
    1418:	100d011d 	andne	r0, sp, sp, lsl r1
    141c:	91010000 	tstls	r1, r0
    1420:	00250102 	eoreq	r0, r5, r2, lsl #2
    1424:	0a6c0000 	beq	1b0142c <MEM_SIZE+0x130142c>
    1428:	0b2c3000 	bleq	b0d430 <MEM_SIZE+0x30d430>
    142c:	04fe3000 	ldrbteq	r3, [lr]
    1430:	0c280000 	stceq	0, cr0, [r8]
    1434:	5f1e0000 	svcpl	0x001e0000
    1438:	01000003 	tsteq	r0, r3
    143c:	06b30291 	ssateq	r0, #20, r1, lsl #5
    1440:	051d0000 	ldreq	r0, [sp]
    1444:	6d1f0000 	ldcvs	0, cr0, [pc]
    1448:	01006773 	tsteq	r0, r3, ror r7
    144c:	00f60291 	smlalseq	r0, r6, r1, r2
    1450:	053b0000 	ldreq	r0, [fp]!
    1454:	6d1f0000 	ldcvs	0, cr0, [pc]
    1458:	01006b73 	tsteq	r0, r3, ror fp
    145c:	00250291 	mlaeq	r5, r1, r2, r0
    1460:	05590000 	ldrbeq	r0, [r9]
    1464:	ba200000 	blt	80146c <MEM_SIZE+0x146c>
    1468:	0100000f 	tsteq	r0, pc
    146c:	08650293 	stmdaeq	r5!, {r0, r1, r4, r7, r9}^
    1470:	056c0000 	strbeq	r0, [ip]!
    1474:	78210000 	stmdavc	r1!, {}
    1478:	02940100 	addseq	r0, r4, #0
    147c:	00000025 	andeq	r0, r0, r5, lsr #32
    1480:	0000058a 	andeq	r0, r0, sl, lsl #11
    1484:	01007912 	tsteq	r0, r2, lsl r9
    1488:	00250295 	mlaeq	r5, r5, r2, r0
    148c:	85200000 	strhi	r0, [r0]!
    1490:	0100000e 	tsteq	r0, lr
    1494:	00250296 	mlaeq	r5, r6, r2, r0
    1498:	059d0000 	ldreq	r0, [sp]
    149c:	52200000 	eorpl	r0, r0, #0
    14a0:	0100000a 	tsteq	r0, sl
    14a4:	00250298 	mlaeq	r5, r8, r2, r0
    14a8:	05b00000 	ldreq	r0, [r0]!
    14ac:	57200000 	strpl	r0, [r0, -r0]!
    14b0:	0100000a 	tsteq	r0, sl
    14b4:	00250299 	mlaeq	r5, r9, r2, r0
    14b8:	05ce0000 	strbeq	r0, [lr]
    14bc:	22000000 	andcs	r0, r0, #0
    14c0:	000009ae 	andeq	r0, r0, lr, lsr #19
    14c4:	30000b2c 	andcc	r0, r0, ip, lsr #22
    14c8:	30000bac 	andcc	r0, r0, ip, lsr #23
    14cc:	000005ec 	andeq	r0, r0, ip, ror #11
    14d0:	00000c4a 	andeq	r0, r0, sl, asr #24
    14d4:	0009bd23 	andeq	fp, r9, r3, lsr #26
    14d8:	24500100 	ldrbcs	r0, [r0], #-256	; 0x100
    14dc:	000009c9 	andeq	r0, r0, r9, asr #19
    14e0:	09d42500 	ldmibeq	r4, {r8, sl, sp}^
    14e4:	0bac0000 	bleq	feb014ec <rEINTPEND+0xa8b01444>
    14e8:	0bfc3000 	bleq	fff0d4f0 <rEINTPEND+0xa9f0d448>
    14ec:	5d013000 	stcpl	0, cr3, [r1]
    14f0:	00000c6a 	andeq	r0, r0, sl, ror #24
    14f4:	0009e323 	andeq	lr, r9, r3, lsr #6
    14f8:	24500100 	ldrbcs	r0, [r0], #-256	; 0x100
    14fc:	000009ef 	andeq	r0, r0, pc, ror #19
    1500:	09092500 	stmdbeq	r9, {r8, sl, sp}
    1504:	0bfc0000 	bleq	fff0150c <rEINTPEND+0xa9f01464>
    1508:	0c203000 	stceq	0, cr3, [r0]
    150c:	5d013000 	stcpl	0, cr3, [r1]
    1510:	00000c93 	muleq	r0, r3, ip
    1514:	00091826 	andeq	r1, r9, r6, lsr #16
    1518:	00060b00 	andeq	r0, r6, r0, lsl #22
    151c:	09242700 	stmdbeq	r4!, {r8, r9, sl, sp}
    1520:	50010000 	andpl	r0, r1, r0
    1524:	00093024 	andeq	r3, r9, r4, lsr #32
    1528:	eb250000 	bl	941530 <MEM_SIZE+0x141530>
    152c:	20000007 	andcs	r0, r0, r7
    1530:	5430000c 	ldrtpl	r0, [r0], #-12
    1534:	0130000c 	teqeq	r0, ip
    1538:	000cb75d 	andeq	fp, ip, sp, asr r7
    153c:	07fa2300 	ldrbeq	r2, [sl, r0, lsl #6]!
    1540:	50010000 	andpl	r0, r1, r0
    1544:	00080626 	andeq	r0, r8, r6, lsr #12
    1548:	00061e00 	andeq	r1, r6, r0, lsl #28
    154c:	71250000 	teqvc	r5, r0
    1550:	54000008 	strpl	r0, [r0], #-8
    1554:	8830000c 	ldmdahi	r0!, {r2, r3}
    1558:	0130000c 	teqeq	r0, ip
    155c:	000ce25d 	andeq	lr, ip, sp, asr r2
    1560:	08802300 	stmeq	r0, {r8, r9, sp}
    1564:	50010000 	andpl	r0, r1, r0
    1568:	00088c23 	andeq	r8, r8, r3, lsr #24
    156c:	26510100 	ldrbcs	r0, [r1], -r0, lsl #2
    1570:	00000898 	muleq	r0, r8, r8
    1574:	00000631 	andeq	r0, r0, r1, lsr r6
    1578:	08d12500 	ldmeq	r1, {r8, sl, sp}^
    157c:	0c880000 	stceq	0, cr0, [r8], {0}
    1580:	0cc43000 	stcleq	0, cr3, [r4], {0}
    1584:	5d013000 	stcpl	0, cr3, [r1]
    1588:	00000d11 	andeq	r0, r0, r1, lsl sp
    158c:	0008e426 	andeq	lr, r8, r6, lsr #8
    1590:	00064400 	andeq	r4, r6, r0, lsl #8
    1594:	08f02600 	ldmeq	r0!, {r9, sl, sp}^
    1598:	06620000 	strbteq	r0, [r2], -r0
    159c:	fc280000 	stc2	0, cr0, [r8]
    15a0:	80000008 	andhi	r0, r0, r8
    15a4:	00000006 	andeq	r0, r0, r6
    15a8:	0008a525 	andeq	sl, r8, r5, lsr #10
    15ac:	000cc400 	andeq	ip, ip, r0, lsl #8
    15b0:	000cf430 	andeq	pc, ip, r0, lsr r4
    15b4:	375d0130 	smmlarcc	sp, r0, r1, r0
    15b8:	2600000d 	strcs	r0, [r0], -sp
    15bc:	000008b8 	undefined instruction 0x000008b8
    15c0:	0000069e 	muleq	r0, lr, r6
    15c4:	0008c428 	andeq	ip, r8, r8, lsr #8
    15c8:	0006bc00 	andeq	fp, r6, r0, lsl #24
    15cc:	05290000 	streq	r0, [r9]!
    15d0:	0200000f 	andeq	r0, r0, #15
    15d4:	f40103c3 	vst2.<illegal width 64>	{d0-d3}, [r1], r3
    15d8:	9030000c 	eorsls	r0, r0, ip
    15dc:	da30000d 	ble	c01618 <MEM_SIZE+0x401618>
    15e0:	bb000006 	bllt	1600 <DISABLE_IRQ+0x1580>
    15e4:	1e00000d 	cdpne	0, 0, cr0, cr0, cr13, {0}
    15e8:	00000c9f 	muleq	r0, pc, ip
    15ec:	6b03c302 	blvs	f21fc <DISABLE_IRQ+0xf217c>
    15f0:	f9000008 	undefined instruction 0xf9000008
    15f4:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
    15f8:	000002fc 	strdeq	r0, [r0], -ip
    15fc:	b903c302 	stmdblt	r3, {r1, r8, r9, lr, pc}
    1600:	0c000006 	stceq	0, cr0, [r0], {6}
    1604:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
    1608:	00000158 	andeq	r0, r0, r8, asr r1
    160c:	2703c302 	strcs	ip, [r3, -r2, lsl #6]
    1610:	1f000001 	svcne	0x00000001
    1614:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
    1618:	0000098d 	andeq	r0, r0, sp, lsl #19
    161c:	2503c302 	strcs	ip, [r3, #-770]	; 0x302
    1620:	32000000 	andcc	r0, r0, #0
    1624:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
    1628:	000010b6 	strheq	r1, [r0], -r6
    162c:	3703c302 	strcc	ip, [r3, -r2, lsl #6]
    1630:	45000000 	strmi	r0, [r0]
    1634:	20000007 	andcs	r0, r0, r7
    1638:	00001136 	andeq	r1, r0, r6, lsr r1
    163c:	b903c502 	stmdblt	r3, {r1, r8, sl, lr, pc}
    1640:	64000006 	strvs	r0, [r0], #-6
    1644:	12000007 	andne	r0, r0, #7
    1648:	c6020079 	undefined instruction 0xc6020079
    164c:	00002503 	andeq	r2, r0, r3, lsl #10
    1650:	012a0000 	teqeq	sl, r0
    1654:	0000085c 	andeq	r0, r0, ip, asr r8
    1658:	0103f302 	tstpeq	r3, r2, lsl #6
    165c:	30000d90 	mulcc	r0, r0, sp
    1660:	30000e10 	andcc	r0, r0, r0, lsl lr
    1664:	00000777 	andeq	r0, r0, r7, ror r7
    1668:	00000e17 	andeq	r0, r0, r7, lsl lr
    166c:	02006912 	andeq	r6, r0, #294912	; 0x48000
    1670:	00370401 	eorseq	r0, r7, r1, lsl #8
    1674:	3d100000 	ldccc	0, cr0, [r0]
    1678:	02000012 	andeq	r0, r0, #18
    167c:	086b0402 	stmdaeq	fp!, {r1, sl}^
    1680:	43200000 	teqmi	r0, #0
    1684:	02000012 	andeq	r0, r0, #18
    1688:	086b0403 	stmdaeq	fp!, {r0, r1, sl}^
    168c:	07960000 	ldreq	r0, [r6, r0]
    1690:	eb2b0000 	bl	ac1698 <MEM_SIZE+0x2c1698>
    1694:	9c000007 	stcls	0, cr0, [r0], {7}
    1698:	3030000d 	eorscc	r0, r0, sp
    169c:	02000000 	andeq	r0, r0, #0
    16a0:	ad2c0406 	cfstrsge	mvf0, [ip, #-24]!	; 0xffffffe8
    16a4:	2c00000c 	stccs	0, cr0, [r0], {12}
    16a8:	00000ca6 	andeq	r0, r0, r6, lsr #25
    16ac:	422d0000 	eormi	r0, sp, #0
    16b0:	02000010 	andeq	r0, r0, #16
    16b4:	78010435 	stmdavc	r1, {r0, r2, r4, r5, sl}
    16b8:	10000000 	andne	r0, r0, r0
    16bc:	c430000e 	ldrtgt	r0, [r0], #-14
    16c0:	a930000e 	ldmdbge	r0!, {r1, r2, r3}
    16c4:	ab000007 	blge	16e8 <DISABLE_IRQ+0x1668>
    16c8:	1e00000e 	cdpne	0, 0, cr0, cr0, cr14, {0}
    16cc:	000002fc 	strdeq	r0, [r0], -ip
    16d0:	b9043502 	stmdblt	r4, {r1, r8, sl, ip, sp}
    16d4:	c8000006 	stmdagt	r0, {r1, r2}
    16d8:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
    16dc:	00000b66 	andeq	r0, r0, r6, ror #22
    16e0:	27043502 	strcs	r3, [r4, -r2, lsl #10]
    16e4:	f1000001 	cps	#1
    16e8:	20000007 	andcs	r0, r0, r7
    16ec:	00000fba 	undefined instruction 0x00000fba
    16f0:	65043702 	strvs	r3, [r4, #-1794]	; 0x702
    16f4:	0f000008 	svceq	0x00000008
    16f8:	20000008 	andcs	r0, r0, r8
    16fc:	000010e0 	andeq	r1, r0, r0, ror #1
    1700:	78043802 	stmdavc	r4, {r1, fp, ip, sp}
    1704:	2d000000 	stccs	0, cr0, [r0]
    1708:	2b000008 	blcs	1730 <DISABLE_IRQ+0x16b0>
    170c:	00000819 	andeq	r0, r0, r9, lsl r8
    1710:	30000e74 	andcc	r0, r0, r4, ror lr
    1714:	00000048 	andeq	r0, r0, r8, asr #32
    1718:	2c044702 	stccs	7, cr4, [r4], {2}
    171c:	00000828 	andeq	r0, r0, r8, lsr #16
    1720:	0000602e 	andeq	r6, r0, lr, lsr #32
    1724:	08342400 	ldmdaeq	r4!, {sl, sp}
    1728:	40240000 	eormi	r0, r4, r0
    172c:	27000008 	strcs	r0, [r0, -r8]
    1730:	0000084c 	andeq	r0, r0, ip, asr #16
    1734:	58285101 	stmdapl	r8!, {r0, r8, ip, lr}
    1738:	56000008 	strpl	r0, [r0], -r8
    173c:	00000008 	andeq	r0, r0, r8
    1740:	19250000 	stmdbne	r5!, {}
    1744:	c4000008 	strgt	r0, [r0], #-8
    1748:	0830000e 	ldmdaeq	r0!, {r1, r2, r3}
    174c:	0130000f 	teqeq	r0, pc
    1750:	000ee25d 	andeq	lr, lr, sp, asr r2
    1754:	08282300 	stmdaeq	r8!, {r8, r9, sp}
    1758:	50010000 	andpl	r0, r1, r0
    175c:	00083424 	andeq	r3, r8, r4, lsr #8
    1760:	08402400 	stmdaeq	r0, {sl, sp}^
    1764:	4c280000 	stcmi	0, cr0, [r8]
    1768:	74000008 	strvc	r0, [r0], #-8
    176c:	28000008 	stmdacs	r0, {r3}
    1770:	00000858 	andeq	r0, r0, r8, asr r8
    1774:	00000892 	muleq	r0, r2, r8
    1778:	26012a00 	strcs	r2, [r1], -r0, lsl #20
    177c:	03000005 	movweq	r0, #5
    1780:	08010187 	stmdaeq	r1, {r0, r1, r2, r7, r8}
    1784:	8030000f 	eorshi	r0, r0, pc
    1788:	b030000f 	eorslt	r0, r0, pc
    178c:	2e000008 	cdpcs	0, 0, cr0, cr0, cr8, {0}
    1790:	1000000f 	andne	r0, r0, pc
    1794:	00000498 	muleq	r0, r8, r4
    1798:	2e019303 	cdpcs	3, 0, cr9, cr1, cr3, {0}
    179c:	1200000f 	andne	r0, r0, #15
    17a0:	94030069 	strls	r0, [r3], #-105	; 0x69
    17a4:	00003701 	andeq	r3, r0, r1, lsl #14
    17a8:	07eb2b00 	strbeq	r2, [fp, r0, lsl #22]!
    17ac:	0f140000 	svceq	0x00140000
    17b0:	00783000 	rsbseq	r3, r8, r0
    17b4:	97030000 	strls	r0, [r3, -r0]
    17b8:	0cad2c01 	stceq	12, cr2, [sp], #4
    17bc:	a62c0000 	strtge	r0, [ip], -r0
    17c0:	0000000c 	andeq	r0, r0, ip
    17c4:	ac040b00 	stcge	11, cr0, [r4], {0}
    17c8:	2f000002 	svccs	0x00000002
    17cc:	000a1001 	andeq	r1, sl, r1
    17d0:	02ea0400 	rsceq	r0, sl, #0
    17d4:	000f8001 	andeq	r8, pc, r1
    17d8:	000fd430 	andeq	sp, pc, r0, lsr r4
    17dc:	8a5d0130 	bhi	1741ca4 <MEM_SIZE+0xf41ca4>
    17e0:	1200000f 	andne	r0, r0, #15
    17e4:	f2040069 	vhadd.s8	q0, q2, <illegal reg q12.5>
    17e8:	00003702 	andeq	r3, r0, r2, lsl #14
    17ec:	71701200 	cmnvc	r0, r0, lsl #4
    17f0:	f3040031 	vqadd.u8	d0, d4, d17
    17f4:	000f8a02 	andeq	r8, pc, r2, lsl #20
    17f8:	71701200 	cmnvc	r0, r0, lsl #4
    17fc:	f4040032 	vst4.8	{d0-d3}, [r4, :256], r2
    1800:	000f8a02 	andeq	r8, pc, r2, lsl #20
    1804:	07eb3000 	strbeq	r3, [fp, r0]!
    1808:	0f880000 	svceq	0x00880000
    180c:	0fa03000 	svceq	0x00a03000
    1810:	f8043000 	undefined instruction 0xf8043000
    1814:	0cad2c02 	stceq	12, cr2, [sp], #8
    1818:	a62c0000 	strtge	r0, [ip], -r0
    181c:	0000000c 	andeq	r0, r0, ip
    1820:	14040b00 	strne	r0, [r4], #-2816	; 0xb00
    1824:	25000004 	strcs	r0, [r0, #-4]
    1828:	0000095f 	andeq	r0, r0, pc, asr r9
    182c:	30000fd4 	ldrdcc	r0, [r0], -r4
    1830:	30001008 	andcc	r1, r0, r8
    1834:	0fbb5d01 	svceq	0x00bb5d01
    1838:	6e230000 	cdpvs	0, 2, cr0, cr3, cr0, {0}
    183c:	01000009 	tsteq	r0, r9
    1840:	097a2350 	ldmdbeq	sl!, {r4, r6, r8, r9, sp}^
    1844:	51010000 	tstpl	r1, r0
    1848:	00098626 	andeq	r8, r9, r6, lsr #12
    184c:	0008cf00 	andeq	ip, r8, r0, lsl #30
    1850:	75290000 	strvc	r0, [r9]!
    1854:	0600000b 	streq	r0, [r0], -fp
    1858:	080103aa 	stmdaeq	r1, {r1, r3, r5, r7, r8, r9}
    185c:	a4300010 	ldrtge	r0, [r0], #-16
    1860:	e2300010 	eors	r0, r0, #16
    1864:	1b000008 	blne	188c <DISABLE_IRQ+0x180c>
    1868:	31000010 	tstcc	r0, r0, lsl r0
    186c:	000009d8 	ldrdeq	r0, [r0], -r8
    1870:	d903aa06 	stmdble	r3, {r1, r2, r9, fp, sp, pc}
    1874:	01000007 	tsteq	r0, r7
    1878:	09921e50 	ldmibeq	r2, {r4, r6, r9, sl, fp, ip}
    187c:	aa060000 	bge	181884 <DISABLE_IRQ+0x181804>
    1880:	00002503 	andeq	r2, r0, r3, lsl #10
    1884:	00090100 	andeq	r0, r9, r0, lsl #2
    1888:	0c271000 	stceq	0, cr1, [r7]
    188c:	ac060000 	stcge	0, cr0, [r6], {0}
    1890:	0007d903 	andeq	sp, r7, r3, lsl #18
    1894:	13072000 	movwne	r2, #28672	; 0x7000
    1898:	ad060000 	stcge	0, cr0, [r6]
    189c:	00101b03 	andseq	r1, r0, r3, lsl #22
    18a0:	00091f00 	andeq	r1, r9, r0, lsl #30
    18a4:	13081000 	movwne	r1, #32768	; 0x8000
    18a8:	ae060000 	cdpge	0, 0, cr0, cr6, cr0, {0}
    18ac:	00003703 	andeq	r3, r0, r3, lsl #14
    18b0:	040b0000 	streq	r0, [fp]
    18b4:	000007df 	ldrdeq	r0, [r0], -pc
    18b8:	000a5c32 	andeq	r5, sl, r2, lsr ip
    18bc:	03db0600 	bicseq	r0, fp, #0
    18c0:	0010a401 	andseq	sl, r0, r1, lsl #8
    18c4:	00111430 	andseq	r1, r1, r0, lsr r4
    18c8:	815d0130 	cmphi	sp, r0, lsr r1
    18cc:	31000010 	tstcc	r0, r0, lsl r0
    18d0:	000009d8 	ldrdeq	r0, [r0], -r8
    18d4:	d903db06 	stmdble	r3, {r1, r2, r8, r9, fp, ip, lr, pc}
    18d8:	01000007 	tsteq	r0, r7
    18dc:	0c272050 	stceq	0, cr2, [r7], #-320	; 0xfffffec0
    18e0:	dd060000 	stcle	0, cr0, [r6]
    18e4:	0007d903 	andeq	sp, r7, r3, lsl #18
    18e8:	00093200 	andeq	r3, r9, r0, lsl #4
    18ec:	0c2d2000 	stceq	0, cr2, [sp]
    18f0:	de060000 	cdple	0, 0, cr0, cr6, cr0, {0}
    18f4:	0007d903 	andeq	sp, r7, r3, lsl #18
    18f8:	00095b00 	andeq	r5, r9, r0, lsl #22
    18fc:	13073300 	movwne	r3, #29440	; 0x7300
    1900:	df060000 	svcle	0x00060000
    1904:	00101b03 	andseq	r1, r0, r3, lsl #22
    1908:	10510100 	subsne	r0, r1, r0, lsl #2
    190c:	00001308 	andeq	r1, r0, r8, lsl #6
    1910:	3703e006 	strcc	lr, [r3, -r6]
    1914:	00000000 	andeq	r0, r0, r0
    1918:	000b2c25 	andeq	r2, fp, r5, lsr #24
    191c:	00111400 	andseq	r1, r1, r0, lsl #8
    1920:	00111830 	andseq	r1, r1, r0, lsr r8
    1924:	9a5d0130 	bls	1741dec <MEM_SIZE+0xf41dec>
    1928:	24000010 	strcs	r0, [r0], #-16
    192c:	00000b3a 	andeq	r0, r0, sl, lsr fp
    1930:	ab013400 	blge	4e938 <DISABLE_IRQ+0x4e8b8>
    1934:	08000004 	stmdaeq	r0, {r2}
    1938:	111801f1 	undefined instruction 0x111801f1
    193c:	113c3000 	teqne	ip, r0
    1940:	096e3000 	stmdbeq	lr!, {ip, sp}^
    1944:	10ce0000 	sbcne	r0, lr, r0
    1948:	3b350000 	blcc	d41950 <MEM_SIZE+0x541950>
    194c:	08000009 	stmdaeq	r0, {r0, r3}
    1950:	000049f1 	strdeq	r4, [r0], -r1
    1954:	00098d00 	andeq	r8, r9, r0, lsl #26
    1958:	018d1900 	orreq	r1, sp, r0, lsl #18
    195c:	f4080000 	vst4.8	{d0-d3}, [r8], r0
    1960:	0000006d 	andeq	r0, r0, sp, rrx
    1964:	f8013600 	undefined instruction 0xf8013600
    1968:	0800000a 	stmdaeq	r0, {r1, r3}
    196c:	004901d4 	ldrdeq	r0, [r9], #-20	; 0xffffffec
    1970:	113c0000 	teqne	ip, r0
    1974:	11603000 	cmnne	r0, r0
    1978:	09ab3000 	stmibeq	fp!, {ip, sp}
    197c:	11040000 	tstne	r4, r0
    1980:	3b370000 	blcc	dc1988 <MEM_SIZE+0x5c1988>
    1984:	08000009 	stmdaeq	r0, {r0, r3}
    1988:	000049d6 	ldrdeq	r4, [r0], -r6
    198c:	19540100 	ldmdbne	r4, {r8}^
    1990:	0000018d 	andeq	r0, r0, sp, lsl #3
    1994:	006dd808 	rsbeq	sp, sp, r8, lsl #16
    1998:	1d000000 	stcne	0, cr0, [r0]
    199c:	00132601 	andseq	r2, r3, r1, lsl #12
    19a0:	03c30500 	biceq	r0, r3, #0
    19a4:	00002501 	andeq	r2, r0, r1, lsl #10
    19a8:	00116000 	andseq	r6, r1, r0
    19ac:	00120430 	andseq	r0, r2, r0, lsr r4
    19b0:	0009ca30 	andeq	ip, r9, r0, lsr sl
    19b4:	00118100 	andseq	r8, r1, r0, lsl #2
    19b8:	0e851e00 	cdpeq	14, 8, cr1, cr5, cr0, {0}
    19bc:	c3050000 	movwgt	r0, #20480	; 0x5000
    19c0:	00002503 	andeq	r2, r0, r3, lsl #10
    19c4:	0009e900 	andeq	lr, r9, r0, lsl #18
    19c8:	04531e00 	ldrbeq	r1, [r3], #-3584	; 0xe00
    19cc:	c3050000 	movwgt	r0, #20480	; 0x5000
    19d0:	00086503 	andeq	r6, r8, r3, lsl #10
    19d4:	000a0700 	andeq	r0, sl, r0, lsl #14
    19d8:	0fba2000 	svceq	0x00ba2000
    19dc:	c5050000 	strgt	r0, [r5]
    19e0:	00086503 	andeq	r6, r8, r3, lsl #10
    19e4:	000a2500 	andeq	r2, sl, r0, lsl #10
    19e8:	018d3300 	orreq	r3, sp, r0, lsl #6
    19ec:	c7050000 	strgt	r0, [r5, -r0]
    19f0:	00006d03 	andeq	r6, r0, r3, lsl #26
    19f4:	30500100 	subscc	r0, r0, r0, lsl #2
    19f8:	00000871 	andeq	r0, r0, r1, ror r8
    19fc:	300011c4 	andcc	r1, r0, r4, asr #3
    1a00:	300011d8 	ldrdcc	r1, [r0], -r8
    1a04:	2c03e405 	cfstrscs	mvf14, [r3], {5}
    1a08:	00000cd8 	ldrdeq	r0, [r0], -r8
    1a0c:	000cd12c 	andeq	sp, ip, ip, lsr #2
    1a10:	0cca2c00 	stcleq	12, cr2, [sl], {0}
    1a14:	00000000 	andeq	r0, r0, r0
    1a18:	0f81011d 	svceq	0x0081011d
    1a1c:	26050000 	strcs	r0, [r5], -r0
    1a20:	00250103 	eoreq	r0, r5, r3, lsl #2
    1a24:	12040000 	andne	r0, r4, #0
    1a28:	12e43000 	rscne	r3, r4, #0
    1a2c:	0a4e3000 	beq	138da34 <MEM_SIZE+0xb8da34>
    1a30:	120e0000 	andne	r0, lr, #0
    1a34:	851e0000 	ldrhi	r0, [lr]
    1a38:	0500000e 	streq	r0, [r0, #-14]
    1a3c:	00250326 	eoreq	r0, r5, r6, lsr #6
    1a40:	0a6d0000 	beq	1b41a48 <MEM_SIZE+0x1341a48>
    1a44:	a31e0000 	tstge	lr, #0
    1a48:	05000002 	streq	r0, [r0, #-2]
    1a4c:	120e0326 	andne	r0, lr, #-1744830464	; 0x98000000
    1a50:	0a8b0000 	beq	fe2c1a58 <rEINTPEND+0xa82c19b0>
    1a54:	ba200000 	blt	801a5c <MEM_SIZE+0x1a5c>
    1a58:	0500000f 	streq	r0, [r0, #-15]
    1a5c:	08650328 	stmdaeq	r5!, {r3, r5, r8, r9}^
    1a60:	0aa90000 	beq	fea41a68 <rEINTPEND+0xa8a419c0>
    1a64:	a1200000 	teqge	r0, r0
    1a68:	05000009 	streq	r0, [r0, #-9]
    1a6c:	06a70329 	strteq	r0, [r7], r9, lsr #6
    1a70:	0ad20000 	beq	ff481a78 <rEINTPEND+0xa94819d0>
    1a74:	84200000 	strthi	r0, [r0]
    1a78:	05000008 	streq	r0, [r0, #-8]
    1a7c:	0049032a 	subeq	r0, r9, sl, lsr #6
    1a80:	0af00000 	beq	ffc01a88 <rEINTPEND+0xa9c019e0>
    1a84:	34200000 	strtcc	r0, [r0]
    1a88:	0500000d 	streq	r0, [r0, #-13]
    1a8c:	0049032b 	subeq	r0, r9, fp, lsr #6
    1a90:	0b030000 	bleq	c1a98 <DISABLE_IRQ+0xc1a18>
    1a94:	8d330000 	ldchi	0, cr0, [r3]
    1a98:	05000001 	streq	r0, [r0, #-1]
    1a9c:	006d032d 	rsbeq	r0, sp, sp, lsr #6
    1aa0:	50010000 	andpl	r0, r1, r0
    1aa4:	f8040b00 	undefined instruction 0xf8040b00
    1aa8:	2a000004 	bcs	1ac0 <DISABLE_IRQ+0x1a40>
    1aac:	000dc301 	andeq	ip, sp, r1, lsl #6
    1ab0:	05a60100 	streq	r0, [r6, #256]!	; 0x100
    1ab4:	0012e401 	andseq	lr, r2, r1, lsl #8
    1ab8:	00136030 	andseq	r6, r3, r0, lsr r0
    1abc:	000b2130 	andeq	r2, fp, r0, lsr r1
    1ac0:	00126a00 	andseq	r6, r2, r0, lsl #20
    1ac4:	0fba2000 	svceq	0x00ba2000
    1ac8:	a8010000 	stmdage	r1, {}
    1acc:	00086505 	andeq	r6, r8, r5, lsl #10
    1ad0:	000b4c00 	andeq	r4, fp, r0, lsl #24
    1ad4:	02a53300 	adceq	r3, r5, #0
    1ad8:	a9010000 	stmdbge	r1, {}
    1adc:	0004f805 	andeq	pc, r4, r5, lsl #16
    1ae0:	60910200 	addsvs	r0, r1, r0, lsl #4
    1ae4:	72726512 	rsbsvc	r6, r2, #75497472	; 0x4800000
    1ae8:	05aa0100 	streq	r0, [sl, #256]!	; 0x100
    1aec:	00000025 	andeq	r0, r0, r5, lsr #32
    1af0:	000e8520 	andeq	r8, lr, r0, lsr #10
    1af4:	05ab0100 	streq	r0, [fp, #256]!	; 0x100
    1af8:	00000025 	andeq	r0, r0, r5, lsr #32
    1afc:	00000b6a 	andeq	r0, r0, sl, ror #22
    1b00:	f8012a00 	undefined instruction 0xf8012a00
    1b04:	0500000f 	streq	r0, [r0, #-15]
    1b08:	6001029d 	mulvs	r1, sp, r2
    1b0c:	58300013 	ldmdapl	r0!, {r0, r1, r4}
    1b10:	88300014 	ldmdahi	r0!, {r2, r4}
    1b14:	3600000b 	strcc	r0, [r0], -fp
    1b18:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
    1b1c:	00000e85 	andeq	r0, r0, r5, lsl #29
    1b20:	25029d05 	strcs	r9, [r2, #-3333]	; 0xd05
    1b24:	a7000000 	strge	r0, [r0, -r0]
    1b28:	1e00000b 	cdpne	0, 0, cr0, cr0, cr11, {0}
    1b2c:	000003a5 	andeq	r0, r0, r5, lsr #7
    1b30:	13029d05 	movwne	r9, #11525	; 0x2d05
    1b34:	fc000008 	stc2	0, cr0, [r0], {8}
    1b38:	1f00000b 	svcne	0x0000000b
    1b3c:	00727265 	rsbseq	r7, r2, r5, ror #4
    1b40:	13029d05 	movwne	r9, #11525	; 0x2d05
    1b44:	25000008 	strcs	r0, [r0, #-8]
    1b48:	2100000c 	tstcs	r0, ip
    1b4c:	006e656c 	rsbeq	r6, lr, ip, ror #10
    1b50:	25029f05 	strcs	r9, [r2, #-3845]	; 0xf05
    1b54:	43000000 	movwmi	r0, #0
    1b58:	2000000c 	andcs	r0, r0, ip
    1b5c:	00000fba 	undefined instruction 0x00000fba
    1b60:	6502a005 	strvs	sl, [r2, #-5]
    1b64:	6c000008 	stcvs	0, cr0, [r0], {8}
    1b68:	3300000c 	movwcc	r0, #12
    1b6c:	0000018d 	andeq	r0, r0, sp, lsl #3
    1b70:	6d02a205 	sfmvs	f2, 1, [r2, #-20]	; (stcvs 2, cr10, [r2, #-20])	; 0xffffffec
    1b74:	01000000 	tsteq	r0, r0
    1b78:	08a53850 	stmiaeq	r5!, {r4, r6, fp, ip, sp}
    1b7c:	13d00000 	bicsne	r0, r0, #0
    1b80:	00903000 	addseq	r3, r0, r0
    1b84:	c5050000 	strgt	r0, [r5]
    1b88:	00130702 	andseq	r0, r3, r2, lsl #14
    1b8c:	0d242c00 	stceq	12, cr2, [r4]
    1b90:	a82e0000 	stmdage	lr!, {}
    1b94:	24000000 	strcs	r0, [r0]
    1b98:	000008c4 	andeq	r0, r0, r4, asr #17
    1b9c:	d1300000 	teqle	r0, r0
    1ba0:	04000008 	streq	r0, [r0], #-8
    1ba4:	1c300014 	ldcne	0, cr0, [r0], #-80	; 0xffffffb0
    1ba8:	05300014 	ldreq	r0, [r0, #-20]!
    1bac:	fe2c02cb 	cdp2	2, 2, cr0, cr12, cr11, {6}
    1bb0:	2600000c 	strcs	r0, [r0], -ip
    1bb4:	00000cf5 	strdeq	r0, [r0], -r5
    1bb8:	00000ca0 	andeq	r0, r0, r0, lsr #25
    1bbc:	00140439 	andseq	r0, r4, r9, lsr r4
    1bc0:	00141c30 	andseq	r1, r4, r0, lsr ip
    1bc4:	08fc2430 	ldmeq	ip!, {r4, r5, sl, sp}^
    1bc8:	00000000 	andeq	r0, r0, r0
    1bcc:	d1011d00 	tstle	r1, r0, lsl #26
    1bd0:	05000006 	streq	r0, [r0, #-6]
    1bd4:	25010253 	strcs	r0, [r1, #-595]	; 0x253
    1bd8:	58000000 	stmdapl	r0, {}
    1bdc:	48300014 	ldmdami	r0!, {r2, r4}
    1be0:	c9300015 	ldmdbgt	r0!, {r0, r2, r4}
    1be4:	dd00000c 	stcle	0, cr0, [r0, #-48]	; 0xffffffd0
    1be8:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
    1bec:	00000e85 	andeq	r0, r0, r5, lsl #29
    1bf0:	25025305 	strcs	r5, [r2, #-773]	; 0x305
    1bf4:	e8000000 	stmda	r0, {}
    1bf8:	1e00000c 	cdpne	0, 0, cr0, cr0, cr12, {0}
    1bfc:	000003a5 	andeq	r0, r0, r5, lsr #7
    1c00:	13025305 	movwne	r5, #8965	; 0x2305
    1c04:	27000008 	strcs	r0, [r0, -r8]
    1c08:	1f00000d 	svcne	0x0000000d
    1c0c:	00727265 	rsbseq	r7, r2, r5, ror #4
    1c10:	13025305 	movwne	r5, #8965	; 0x2305
    1c14:	45000008 	strmi	r0, [r0, #-8]
    1c18:	2000000d 	andcs	r0, r0, sp
    1c1c:	00000fba 	undefined instruction 0x00000fba
    1c20:	65025505 	strvs	r5, [r2, #-1285]	; 0x505
    1c24:	63000008 	movwvs	r0, #8
    1c28:	2100000d 	tstcs	r0, sp
    1c2c:	006e656c 	rsbeq	r6, lr, ip, ror #10
    1c30:	25025605 	strcs	r5, [r2, #-1541]	; 0x605
    1c34:	97000000 	strls	r0, [r0, -r0]
    1c38:	3300000d 	movwcc	r0, #13
    1c3c:	0000018d 	andeq	r0, r0, sp, lsl #3
    1c40:	6d025805 	stcvs	8, cr5, [r2, #-20]	; 0xffffffec
    1c44:	01000000 	tsteq	r0, r0
    1c48:	08d13050 	ldmeq	r1, {r4, r6, ip, sp}^
    1c4c:	14d80000 	ldrbne	r0, [r8]
    1c50:	15103000 	ldrne	r3, [r0]
    1c54:	7b053000 	blvc	14dc5c <DISABLE_IRQ+0x14dbdc>
    1c58:	0cfe2c02 	ldcleq	12, cr2, [lr], #8
    1c5c:	f52c0000 	undefined instruction 0xf52c0000
    1c60:	3900000c 	stmdbcc	r0, {r2, r3}
    1c64:	300014d8 	ldrdcc	r1, [r0], -r8
    1c68:	30001510 	andcc	r1, r0, r0, lsl r5
    1c6c:	0008fc24 	andeq	pc, r8, r4, lsr #24
    1c70:	00000000 	andeq	r0, r0, r0
    1c74:	0724011d 	undefined instruction 0x0724011d
    1c78:	11050000 	tstne	r5, r0
    1c7c:	00250102 	eoreq	r0, r5, r2, lsl #2
    1c80:	15480000 	strbne	r0, [r8]
    1c84:	15e43000 	strbne	r3, [r4]!
    1c88:	0dcb3000 	stcleq	0, cr3, [fp]
    1c8c:	14360000 	ldrtne	r0, [r6]
    1c90:	851e0000 	ldrhi	r0, [lr]
    1c94:	0500000e 	streq	r0, [r0, #-14]
    1c98:	00250211 	eoreq	r0, r5, r1, lsl r2
    1c9c:	0dea0000 	stcleq	0, cr0, [sl]
    1ca0:	4e330000 	cdpmi	0, 3, cr0, cr3, cr0, {0}
    1ca4:	05000007 	streq	r0, [r0, #-7]
    1ca8:	00250213 	eoreq	r0, r5, r3, lsl r2
    1cac:	54010000 	strpl	r0, [r1]
    1cb0:	000fba20 	andeq	fp, pc, r0, lsr #20
    1cb4:	02140500 	andseq	r0, r4, #0
    1cb8:	00000865 	andeq	r0, r0, r5, ror #16
    1cbc:	00000e3f 	andeq	r0, r0, pc, lsr lr
    1cc0:	00018d10 	andeq	r8, r1, r0, lsl sp
    1cc4:	02160500 	andseq	r0, r6, #0
    1cc8:	0000006d 	andeq	r0, r0, sp, rrx
    1ccc:	c7012a00 	strgt	r2, [r1, -r0, lsl #20]
    1cd0:	09000002 	stmdbeq	r0, {r1}
    1cd4:	e40101cd 	str	r0, [r1], #-461	; 0x1cd
    1cd8:	68300015 	ldmdavs	r0!, {r0, r2, r4}
    1cdc:	68300016 	ldmdavs	r0!, {r1, r2, r4}
    1ce0:	8d00000e 	stchi	0, cr0, [r0, #-56]	; 0xffffffc8
    1ce4:	1e000014 	mcrne	0, 0, r0, cr0, cr4, {0}
    1ce8:	0000035f 	andeq	r0, r0, pc, asr r3
    1cec:	b301cd09 	movwlt	ip, #7433	; 0x1d09
    1cf0:	93000006 	movwls	r0, #6
    1cf4:	1f00000e 	svcne	0x0000000e
    1cf8:	00746e63 	rsbseq	r6, r4, r3, ror #28
    1cfc:	3701cd09 	strcc	ip, [r1, -r9, lsl #26]
    1d00:	dd000000 	stcle	0, cr0, [r0]
    1d04:	1f00000e 	svcne	0x0000000e
    1d08:	00727265 	rsbseq	r7, r2, r5, ror #4
    1d0c:	1301cd09 	movwne	ip, #7433	; 0x1d09
    1d10:	fb000008 	blx	1d3a <DISABLE_IRQ+0x1cba>
    1d14:	1000000e 	andne	r0, r0, lr
    1d18:	0000018d 	andeq	r0, r0, sp, lsl #3
    1d1c:	6d01d009 	stcvs	0, cr13, [r1, #-36]	; 0xffffffdc
    1d20:	00000000 	andeq	r0, r0, r0
    1d24:	10c8011d 	sbcne	r0, r8, sp, lsl r1
    1d28:	8b090000 	blhi	241d30 <DISABLE_IRQ+0x241cb0>
    1d2c:	00250101 	eoreq	r0, r5, r1, lsl #2
    1d30:	16680000 	strbtne	r0, [r8], -r0
    1d34:	16ec3000 	strbtne	r3, [ip], r0
    1d38:	0f193000 	svceq	0x00193000
    1d3c:	15020000 	strne	r0, [r2]
    1d40:	5f1e0000 	svcpl	0x001e0000
    1d44:	09000003 	stmdbeq	r0, {r0, r1}
    1d48:	06b3018b 	ldrteq	r0, [r3], fp, lsl #3
    1d4c:	0f440000 	svceq	0x00440000
    1d50:	f71e0000 	undefined instruction 0xf71e0000
    1d54:	0900000c 	stmdbeq	r0, {r2, r3}
    1d58:	1502018b 	strne	r0, [r2, #-395]	; 0x18b
    1d5c:	0f620000 	svceq	0x00620000
    1d60:	d1200000 	teqle	r0, r0
    1d64:	0900000b 	stmdbeq	r0, {r0, r1, r3}
    1d68:	0813018e 	ldmdaeq	r3, {r1, r2, r3, r7, r8}
    1d6c:	0f800000 	svceq	0x00800000
    1d70:	26200000 	strtcs	r0, [r0], -r0
    1d74:	09000008 	stmdbeq	r0, {r3}
    1d78:	0813018f 	ldmdaeq	r3, {r0, r1, r2, r3, r7, r8}
    1d7c:	0f930000 	svceq	0x00930000
    1d80:	69120000 	ldmdbvs	r2, {}
    1d84:	01940900 	orrseq	r0, r4, r0, lsl #18
    1d88:	00000025 	andeq	r0, r0, r5, lsr #32
    1d8c:	00018d10 	andeq	r8, r1, r0, lsl sp
    1d90:	01960900 	orrseq	r0, r6, r0, lsl #18
    1d94:	0000006d 	andeq	r0, r0, sp, rrx
    1d98:	c0040b00 	andgt	r0, r4, r0, lsl #22
    1d9c:	36000004 	strcc	r0, [r0], -r4
    1da0:	0009b501 	andeq	fp, r9, r1, lsl #10
    1da4:	01550900 	cmpeq	r5, r0, lsl #18
    1da8:	000006b3 	undefined instruction 0x000006b3
    1dac:	300016ec 	andcc	r1, r0, ip, ror #13
    1db0:	30001784 	andcc	r1, r0, r4, lsl #15
    1db4:	00000fa6 	andeq	r0, r0, r6, lsr #31
    1db8:	00001576 	andeq	r1, r0, r6, ror r5
    1dbc:	746e633a 	strbtvc	r6, [lr], #-826	; 0x33a
    1dc0:	37550900 	ldrbcc	r0, [r5, -r0, lsl #18]
    1dc4:	c5000000 	strgt	r0, [r0]
    1dc8:	3700000f 	strcc	r0, [r0, -pc]
    1dcc:	0000035f 	andeq	r0, r0, pc, asr r3
    1dd0:	06b35709 	ldrteq	r5, [r3], r9, lsl #14
    1dd4:	54010000 	strpl	r0, [r1]
    1dd8:	00018d19 	andeq	r8, r1, r9, lsl sp
    1ddc:	6d590900 	ldclvs	9, cr0, [r9]
    1de0:	3b000000 	blcc	1de8 <DISABLE_IRQ+0x1d68>
    1de4:	00000909 	andeq	r0, r0, r9, lsl #18
    1de8:	30001744 	andcc	r1, r0, r4, asr #14
    1dec:	000000c0 	andeq	r0, r0, r0, asr #1
    1df0:	7d2c6f09 	stcvc	15, cr6, [ip, #-36]!	; 0xffffffdc
    1df4:	2e00000c 	cdpcs	0, 0, cr0, cr0, cr12, {0}
    1df8:	000000d8 	ldrdeq	r0, [r0], -r8
    1dfc:	00092428 	andeq	r2, r9, r8, lsr #8
    1e00:	000fe300 	andeq	lr, pc, r0, lsl #6
    1e04:	09302400 	ldmdbeq	r0!, {sl, sp}
    1e08:	00000000 	andeq	r0, r0, r0
    1e0c:	29013600 	stmdbcs	r1, {r9, sl, ip, sp}
    1e10:	0900000b 	stmdbeq	r0, {r0, r1, r3}
    1e14:	00370128 	eorseq	r0, r7, r8, lsr #2
    1e18:	17840000 	strne	r0, [r4, r0]
    1e1c:	17c83000 	strbne	r3, [r8, r0]
    1e20:	10013000 	andne	r3, r1, r0
    1e24:	15bd0000 	ldrne	r0, [sp]!
    1e28:	5f350000 	svcpl	0x00350000
    1e2c:	09000003 	stmdbeq	r0, {r0, r1}
    1e30:	0006b328 	andeq	fp, r6, r8, lsr #6
    1e34:	00102000 	andseq	r2, r0, r0
    1e38:	6e633c00 	cdpvs	12, 6, cr3, cr3, cr0, {0}
    1e3c:	2a090074 	bcs	242014 <DISABLE_IRQ+0x241f94>
    1e40:	00000037 	andeq	r0, r0, r7, lsr r0
    1e44:	0000103e 	andeq	r1, r0, lr, lsr r0
    1e48:	00018d19 	andeq	r8, r1, r9, lsl sp
    1e4c:	6d2c0900 	stcvs	9, cr0, [ip]
    1e50:	00000000 	andeq	r0, r0, r0
    1e54:	09fb011d 	ldmibeq	fp!, {r0, r2, r3, r4, r8}^
    1e58:	aa040000 	bge	101e60 <DISABLE_IRQ+0x101de0>
    1e5c:	00250102 	eoreq	r0, r5, r2, lsl #2
    1e60:	17c80000 	strbne	r0, [r8, r0]
    1e64:	186c3000 	stmdane	ip!, {ip, sp}^
    1e68:	105c3000 	subsne	r3, ip, r0
    1e6c:	16410000 	strbne	r0, [r1], -r0
    1e70:	5f1e0000 	svcpl	0x001e0000
    1e74:	04000003 	streq	r0, [r0], #-3
    1e78:	06b302aa 	ldrteq	r0, [r3], sl, lsr #5
    1e7c:	10870000 	addne	r0, r7, r0
    1e80:	311e0000 	tstcc	lr, r0
    1e84:	04000007 	streq	r0, [r0], #-7
    1e88:	164102aa 	strbne	r0, [r1], -sl, lsr #5
    1e8c:	10a50000 	adcne	r0, r5, r0
    1e90:	70210000 	eorvc	r0, r1, r0
    1e94:	ac040071 	stcge	0, cr0, [r4], {113}	; 0x71
    1e98:	000f8a02 	andeq	r8, pc, r2, lsl #20
    1e9c:	0010c300 	andseq	ip, r0, r0, lsl #6
    1ea0:	00691200 	rsbeq	r1, r9, r0, lsl #4
    1ea4:	2502ad04 	strcs	sl, [r2, #-3332]	; 0xd04
    1ea8:	20000000 	andcs	r0, r0, r0
    1eac:	00000bd1 	ldrdeq	r0, [r0], -r1
    1eb0:	1302af04 	movwne	sl, #12036	; 0x2f04
    1eb4:	d6000008 	strle	r0, [r0], -r8
    1eb8:	20000010 	andcs	r0, r0, r0, lsl r0
    1ebc:	00000826 	andeq	r0, r0, r6, lsr #16
    1ec0:	1302b004 	movwne	fp, #8196	; 0x2004
    1ec4:	e9000008 	stmdb	r0, {r3}
    1ec8:	10000010 	andne	r0, r0, r0, lsl r0
    1ecc:	0000018d 	andeq	r0, r0, sp, lsl #3
    1ed0:	6d02b604 	stcvs	6, cr11, [r2, #-16]
    1ed4:	00000000 	andeq	r0, r0, r0
    1ed8:	0479040b 	ldrbteq	r0, [r9], #-1035	; 0x40b
    1edc:	011d0000 	tsteq	sp, r0
    1ee0:	00000a94 	muleq	r0, r4, sl
    1ee4:	01013c04 	tsteq	r1, r4, lsl #24
    1ee8:	00000025 	andeq	r0, r0, r5, lsr #32
    1eec:	3000186c 	andcc	r1, r0, ip, ror #16
    1ef0:	300018bc 	undefined instruction 0x300018bc
    1ef4:	000010fc 	strdeq	r1, [r0], -ip
    1ef8:	00001691 	muleq	r0, r1, r6
    1efc:	00035f1e 	andeq	r5, r3, lr, lsl pc
    1f00:	013c0400 	teqeq	ip, r0, lsl #8
    1f04:	000006b3 	undefined instruction 0x000006b3
    1f08:	0000111b 	andeq	r1, r0, fp, lsl r1
    1f0c:	00717021 	rsbseq	r7, r1, r1, lsr #32
    1f10:	8a013e04 	bhi	51728 <DISABLE_IRQ+0x516a8>
    1f14:	3900000f 	stmdbcc	r0, {r0, r1, r2, r3}
    1f18:	10000011 	andne	r0, r0, r1, lsl r0
    1f1c:	0000018d 	andeq	r0, r0, sp, lsl #3
    1f20:	6d014004 	stcvs	0, cr4, [r1, #-16]
    1f24:	00000000 	andeq	r0, r0, r0
    1f28:	06590136 	undefined instruction 0x06590136
    1f2c:	71040000 	tstvc	r4, r0
    1f30:	0006b301 	andeq	fp, r6, r1, lsl #6
    1f34:	0018bc00 	andseq	fp, r8, r0, lsl #24
    1f38:	0019b030 	andseq	fp, r9, r0, lsr r0
    1f3c:	00114c30 	andseq	r4, r1, r0, lsr ip
    1f40:	00171c00 	andseq	r1, r7, r0, lsl #24
    1f44:	01633500 	cmneq	r3, r0, lsl #10
    1f48:	71040000 	tstvc	r4, r0
    1f4c:	0000040e 	andeq	r0, r0, lr, lsl #8
    1f50:	0000116b 	andeq	r1, r0, fp, ror #2
    1f54:	000d3435 	andeq	r3, sp, r5, lsr r4
    1f58:	37710400 	ldrbcc	r0, [r1, -r0, lsl #8]!
    1f5c:	89000000 	stmdbhi	r0, {}
    1f60:	37000011 	smladcc	r0, r1, r0, r0
    1f64:	0000035f 	andeq	r0, r0, pc, asr r3
    1f68:	06b37304 	ldrteq	r7, [r3], r4, lsl #6
    1f6c:	56010000 	strpl	r0, [r1], -r0
    1f70:	0071703c 	rsbseq	r7, r1, ip, lsr r0
    1f74:	0f8a7404 	svceq	0x008a7404
    1f78:	11a70000 	undefined instruction 0x11a70000
    1f7c:	8d190000 	ldchi	0, cr0, [r9]
    1f80:	04000001 	streq	r0, [r0], #-1
    1f84:	00006d76 	andeq	r6, r0, r6, ror sp
    1f88:	09093b00 	stmdbeq	r9, {r8, r9, fp, ip, sp}
    1f8c:	19540000 	ldmdbne	r4, {}^
    1f90:	00f03000 	rscseq	r3, r0, r0
    1f94:	97040000 	strls	r0, [r4, -r0]
    1f98:	000c7d2c 	andeq	r7, ip, ip, lsr #26
    1f9c:	01102e00 	tsteq	r0, r0, lsl #28
    1fa0:	24280000 	strtcs	r0, [r8]
    1fa4:	d0000009 	andle	r0, r0, r9
    1fa8:	24000011 	strcs	r0, [r0], #-17
    1fac:	00000930 	andeq	r0, r0, r0, lsr r9
    1fb0:	36000000 	strcc	r0, [r0], -r0
    1fb4:	000c4101 	andeq	r4, ip, r1, lsl #2
    1fb8:	01350400 	teqeq	r5, r0, lsl #8
    1fbc:	000000f6 	strdeq	r0, [r0], -r6
    1fc0:	300019b0 	undefined instruction 0x300019b0
    1fc4:	30001a4c 	andcc	r1, r0, ip, asr #20
    1fc8:	000011ee 	andeq	r1, r0, lr, ror #3
    1fcc:	0000177e 	andeq	r1, r0, lr, ror r7
    1fd0:	00035f35 	andeq	r5, r3, r5, lsr pc
    1fd4:	b3350400 	teqlt	r5, #0
    1fd8:	0d000006 	stceq	0, cr0, [r0, #-24]	; 0xffffffe8
    1fdc:	3a000012 	bcc	202c <DISABLE_IRQ+0x1fac>
    1fe0:	00727265 	rsbseq	r7, r2, r5, ror #4
    1fe4:	08133504 	ldmdaeq	r3, {r2, r8, sl, ip, sp}
    1fe8:	12570000 	subsne	r0, r7, #0
    1fec:	6d3d0000 	ldcvs	0, cr0, [sp]
    1ff0:	04006773 	streq	r6, [r0], #-1907	; 0x773
    1ff4:	0000f637 	andeq	pc, r0, r7, lsr r6
    1ff8:	3c540100 	ldfcce	f0, [r4], {0}
    1ffc:	04007170 	streq	r7, [r0], #-368	; 0x170
    2000:	000f8a38 	andeq	r8, pc, r8, lsr sl
    2004:	00127500 	andseq	r7, r2, r0, lsl #10
    2008:	018d1900 	orreq	r1, sp, r0, lsl #18
    200c:	3a040000 	bcc	102014 <DISABLE_IRQ+0x101f94>
    2010:	0000006d 	andeq	r0, r0, sp, rrx
    2014:	4d011d00 	stcmi	13, cr1, [r1]
    2018:	0a000009 	beq	2044 <DISABLE_IRQ+0x1fc4>
    201c:	25010256 	strcs	r0, [r1, #-598]	; 0x256
    2020:	4c000000 	stcmi	0, cr0, [r0], {0}
    2024:	0430001a 	ldrteq	r0, [r0], #-26
    2028:	9330001b 	teqls	r0, #27
    202c:	ef000012 	svc	0x00000012
    2030:	1e000017 	mcrne	0, 0, r0, cr0, cr7, {0}
    2034:	0000035f 	andeq	r0, r0, pc, asr r3
    2038:	b302560a 	movwlt	r5, #9738	; 0x260a
    203c:	be000006 	cdplt	0, 0, cr0, cr0, cr6, {0}
    2040:	1e000012 	mcrne	0, 0, r0, cr0, cr2, {0}
    2044:	0000078b 	andeq	r0, r0, fp, lsl #15
    2048:	ef02560a 	svc	0x0002560a
    204c:	dc000017 	stcle	0, cr0, [r0], {23}
    2050:	12000012 	andne	r0, r0, #18
    2054:	580a0069 	stmdapl	sl, {r0, r3, r5, r6}
    2058:	00002502 	andeq	r2, r0, r2, lsl #10
    205c:	0bd12000 	bleq	ff44a064 <rEINTPEND+0xa9449fbc>
    2060:	5a0a0000 	bpl	282068 <DISABLE_IRQ+0x281fe8>
    2064:	00081302 	andeq	r1, r8, r2, lsl #6
    2068:	0012fa00 	andseq	pc, r2, r0, lsl #20
    206c:	08261000 	stmdaeq	r6!, {ip}
    2070:	5b0a0000 	blpl	282078 <DISABLE_IRQ+0x281ff8>
    2074:	00081302 	andeq	r1, r8, r2, lsl #6
    2078:	018d1000 	orreq	r1, sp, r0
    207c:	610a0000 	tstvs	sl, r0
    2080:	00006d02 	andeq	r6, r0, r2, lsl #26
    2084:	040b0000 	streq	r0, [fp]
    2088:	00000385 	andeq	r0, r0, r5, lsl #7
    208c:	069a0136 	undefined instruction 0x069a0136
    2090:	9e0a0000 	cdpls	0, 0, cr0, cr10, cr0, {0}
    2094:	0006b301 	andeq	fp, r6, r1, lsl #6
    2098:	001b0400 	andseq	r0, fp, r0, lsl #8
    209c:	001c0830 	andseq	r0, ip, r0, lsr r8
    20a0:	00131830 	andseq	r1, r3, r0, lsr r8
    20a4:	00187400 	andseq	r7, r8, r0, lsl #8
    20a8:	0e853500 	cdpeq	5, 8, cr3, cr5, cr0, {0}
    20ac:	9e0a0000 	cdpls	0, 0, cr0, cr10, cr0, {0}
    20b0:	00000025 	andeq	r0, r0, r5, lsr #32
    20b4:	00001337 	andeq	r1, r0, r7, lsr r3
    20b8:	7272653a 	rsbsvc	r6, r2, #243269632	; 0xe800000
    20bc:	139e0a00 	orrsne	r0, lr, #0
    20c0:	76000008 	strvc	r0, [r0], -r8
    20c4:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
    20c8:	0000035f 	andeq	r0, r0, pc, asr r3
    20cc:	06b3a00a 	ldrteq	sl, [r3], sl
    20d0:	13940000 	orrsne	r0, r4, #0
    20d4:	8d190000 	ldchi	0, cr0, [r9]
    20d8:	0a000001 	beq	20e4 <DISABLE_IRQ+0x2064>
    20dc:	00006da2 	andeq	r6, r0, r2, lsr #27
    20e0:	09093b00 	stmdbeq	r9, {r8, r9, fp, ip, sp}
    20e4:	1b980000 	blne	fe6020ec <rEINTPEND+0xa8602044>
    20e8:	01303000 	teqeq	r0, r0
    20ec:	cb0a0000 	blgt	2820f4 <DISABLE_IRQ+0x282074>
    20f0:	000c7d2c 	andeq	r7, ip, ip, lsr #26
    20f4:	01482e00 	cmpeq	r8, r0, lsl #28
    20f8:	24280000 	strtcs	r0, [r8]
    20fc:	b2000009 	andlt	r0, r0, #9
    2100:	24000013 	strcs	r0, [r0], #-19
    2104:	00000930 	andeq	r0, r0, r0, lsr r9
    2108:	36000000 	strcc	r0, [r0], -r0
    210c:	00049d01 	andeq	r9, r4, r1, lsl #26
    2110:	014c0a00 	cmpeq	ip, r0, lsl #20
    2114:	00000025 	andeq	r0, r0, r5, lsr #32
    2118:	30001c08 	andcc	r1, r0, r8, lsl #24
    211c:	30001ce8 	andcc	r1, r0, r8, ror #25
    2120:	000013c5 	andeq	r1, r0, r5, asr #7
    2124:	000018c6 	andeq	r1, r0, r6, asr #17
    2128:	00035f35 	andeq	r5, r3, r5, lsr pc
    212c:	b34c0a00 	movtlt	r0, #51712	; 0xca00
    2130:	e4000006 	str	r0, [r0], #-6
    2134:	3a000013 	bcc	2188 <DISABLE_IRQ+0x2108>
    2138:	00727265 	rsbseq	r7, r2, r5, ror #4
    213c:	08134c0a 	ldmdaeq	r3, {r1, r3, sl, fp, lr}
    2140:	14020000 	strne	r0, [r2]
    2144:	703f0000 	eorsvc	r0, pc, r0
    2148:	0a007069 	beq	1e2f4 <DISABLE_IRQ+0x1e274>
    214c:	0000254e 	andeq	r2, r0, lr, asr #10
    2150:	018d1900 	orreq	r1, sp, r0, lsl #18
    2154:	500a0000 	andpl	r0, sl, r0
    2158:	0000006d 	andeq	r0, r0, sp, rrx
    215c:	98011d00 	stmdals	r1, {r8, sl, fp, ip}
    2160:	03000002 	movweq	r0, #2
    2164:	2501015c 	strcs	r0, [r1, #-348]	; 0x15c
    2168:	e8000000 	stmda	r0, {}
    216c:	5430001c 	ldrtpl	r0, [r0], #-28
    2170:	2030001d 	eorscs	r0, r0, sp, lsl r0
    2174:	11000014 	tstne	r0, r4, lsl r0
    2178:	1e000019 	mcrne	0, 0, r0, cr0, cr9, {0}
    217c:	00000498 	muleq	r0, r8, r4
    2180:	2e015c03 	cdpcs	12, 0, cr5, cr1, cr3, {0}
    2184:	3f00000f 	svccc	0x0000000f
    2188:	1e000014 	mcrne	0, 0, r0, cr0, cr4, {0}
    218c:	00000e56 	andeq	r0, r0, r6, asr lr
    2190:	11015c03 	tstne	r1, r3, lsl #24
    2194:	5d000019 	stcpl	0, cr0, [r0, #-100]	; 0xffffff9c
    2198:	10000014 	andne	r0, r0, r4, lsl r0
    219c:	0000018d 	andeq	r0, r0, sp, lsl #3
    21a0:	6d015f03 	stcvs	15, cr5, [r1, #-12]
    21a4:	00000000 	andeq	r0, r0, r0
    21a8:	0320040b 	teqeq	r0, #184549376	; 0xb000000
    21ac:	011d0000 	tsteq	sp, r0
    21b0:	00000902 	andeq	r0, r0, r2, lsl #18
    21b4:	01012d03 	tsteq	r1, r3, lsl #26
    21b8:	00000025 	andeq	r0, r0, r5, lsr #32
    21bc:	30001d54 	andcc	r1, r0, r4, asr sp
    21c0:	30001db8 	undefined instruction 0x30001db8
    21c4:	00001491 	muleq	r0, r1, r4
    21c8:	00001962 	andeq	r1, r0, r2, ror #18
    21cc:	0004981e 	andeq	r9, r4, lr, lsl r8
    21d0:	012d0300 	teqeq	sp, r0, lsl #6
    21d4:	00000f2e 	andeq	r0, r0, lr, lsr #30
    21d8:	000014b0 	undefined instruction 0x000014b0
    21dc:	0006631e 	andeq	r6, r6, lr, lsl r3
    21e0:	012d0300 	teqeq	sp, r0, lsl #6
    21e4:	000000f6 	strdeq	r0, [r0], -r6
    21e8:	000014ce 	andeq	r1, r0, lr, asr #9
    21ec:	00018d10 	andeq	r8, r1, r0, lsl sp
    21f0:	01300300 	teqeq	r0, r0, lsl #6
    21f4:	0000006d 	andeq	r0, r0, sp, rrx
    21f8:	aa013400 	bge	4f200 <DISABLE_IRQ+0x4f180>
    21fc:	03000011 	movweq	r0, #17
    2200:	1db801f4 	ldfnes	f0, [r8, #976]!	; 0x3d0
    2204:	1e8c3000 	cdpne	0, 8, cr3, cr12, cr0, {0}
    2208:	15023000 	strne	r3, [r2]
    220c:	1a1a0000 	bne	682214 <DISABLE_IRQ+0x682194>
    2210:	98350000 	ldmdals	r5!, {}
    2214:	03000004 	movweq	r0, #4
    2218:	000f2ef4 	strdeq	r2, [pc], -r4
    221c:	00152100 	andseq	r2, r5, r0, lsl #2
    2220:	03a53500 	undefined instruction 0x03a53500
    2224:	f4030000 	vst4.8	{d0-d3}, [r3], r0
    2228:	00000813 	andeq	r0, r0, r3, lsl r8
    222c:	00001560 	andeq	r1, r0, r0, ror #10
    2230:	7272653a 	rsbsvc	r6, r2, #243269632	; 0xe800000
    2234:	13f40300 	mvnsne	r0, #0
    2238:	94000008 	strls	r0, [r0], #-8
    223c:	3c000015 	stccc	0, cr0, [r0], {21}
    2240:	006e656c 	rsbeq	r6, lr, ip, ror #10
    2244:	0025f603 	eoreq	pc, r5, r3, lsl #12
    2248:	15b20000 	ldrne	r0, [r2]!
    224c:	8d3e0000 	ldchi	0, cr0, [lr]
    2250:	03000001 	movweq	r0, #1
    2254:	00006df8 	strdeq	r6, [r0], -r8
    2258:	0015e600 	andseq	lr, r5, r0, lsl #12
    225c:	08a53800 	stmiaeq	r5!, {fp, ip, sp}
    2260:	1de80000 	stclne	0, cr0, [r8]
    2264:	01603000 	cmneq	r0, r0
    2268:	0e030000 	cdpeq	0, 0, cr0, cr3, cr0, {0}
    226c:	0019eb01 	andseq	lr, r9, r1, lsl #22
    2270:	0d242c00 	stceq	12, cr2, [r4]
    2274:	782e0000 	stmdavc	lr!, {}
    2278:	24000001 	strcs	r0, [r0], #-1
    227c:	000008c4 	andeq	r0, r0, r4, asr #17
    2280:	d1300000 	teqle	r0, r0
    2284:	1c000008 	stcne	0, cr0, [r0], {8}
    2288:	3430001e 	ldrtcc	r0, [r0], #-30
    228c:	0330001e 	teqeq	r0, #30
    2290:	fe2c0114 	mcr2	1, 1, r0, cr12, cr4, {0}
    2294:	2600000c 	strcs	r0, [r0], -ip
    2298:	00000cf5 	strdeq	r0, [r0], -r5
    229c:	00001625 	andeq	r1, r0, r5, lsr #12
    22a0:	001e1c39 	andseq	r1, lr, r9, lsr ip
    22a4:	001e3430 	andseq	r3, lr, r0, lsr r4
    22a8:	08fc2430 	ldmeq	ip!, {r4, r5, sl, sp}^
    22ac:	00000000 	andeq	r0, r0, r0
    22b0:	99013600 	stmdbls	r1, {r9, sl, ip, sp}
    22b4:	0300000e 	movweq	r0, #14
    22b8:	002501bc 	undefined instruction 0x002501bc
    22bc:	1e8c0000 	cdpne	0, 8, cr0, cr12, cr0, {0}
    22c0:	1f3c3000 	svcne	0x003c3000
    22c4:	16433000 	strbne	r3, [r3], -r0
    22c8:	1aac0000 	bne	feb022d0 <rEINTPEND+0xa8b02228>
    22cc:	98350000 	ldmdals	r5!, {}
    22d0:	03000004 	movweq	r0, #4
    22d4:	000f2ebc 	undefined instruction 0x000f2ebc
    22d8:	00166200 	andseq	r6, r6, r0, lsl #4
    22dc:	03a53500 	undefined instruction 0x03a53500
    22e0:	bc030000 	stclt	0, cr0, [r3], {0}
    22e4:	00000813 	andeq	r0, r0, r3, lsl r8
    22e8:	000016a1 	andeq	r1, r0, r1, lsr #13
    22ec:	7272653a 	rsbsvc	r6, r2, #243269632	; 0xe800000
    22f0:	13bc0300 	undefined instruction 0x13bc0300
    22f4:	bf000008 	svclt	0x00000008
    22f8:	3c000016 	stccc	0, cr0, [r0], {22}
    22fc:	006e656c 	rsbeq	r6, lr, ip, ror #10
    2300:	0025be03 	eoreq	fp, r5, r3, lsl #28
    2304:	16dd0000 	ldrbne	r0, [sp], r0
    2308:	8d3e0000 	ldchi	0, cr0, [lr]
    230c:	03000001 	movweq	r0, #1
    2310:	00006dc0 	andeq	r6, r0, r0, asr #27
    2314:	00171100 	andseq	r1, r7, r0, lsl #2
    2318:	08d14000 	ldmeq	r1, {lr}^
    231c:	1ebc0000 	cdpne	0, 11, cr0, cr12, cr0, {0}
    2320:	1ef43000 	cdpne	0, 15, cr3, cr4, cr0, {0}
    2324:	d6033000 	strle	r3, [r3], -r0
    2328:	000cfe2c 	andeq	pc, ip, ip, lsr #28
    232c:	0cf52c00 	ldcleq	12, cr2, [r5]
    2330:	bc390000 	ldclt	0, cr0, [r9]
    2334:	f430001e 	undefined instruction 0xf430001e
    2338:	2430001e 	ldrtcs	r0, [r0], #-30
    233c:	000008fc 	strdeq	r0, [r0], -ip
    2340:	36000000 	strcc	r0, [r0], -r0
    2344:	000d5301 	andeq	r5, sp, r1, lsl #6
    2348:	01870300 	orreq	r0, r7, r0, lsl #6
    234c:	000000f6 	strdeq	r0, [r0], -r6
    2350:	30001f3c 	andcc	r1, r0, ip, lsr pc
    2354:	30001fb4 	undefined instruction 0x30001fb4
    2358:	00001745 	andeq	r1, r0, r5, asr #14
    235c:	00001b00 	andeq	r1, r0, r0, lsl #22
    2360:	00049835 	andeq	r9, r4, r5, lsr r8
    2364:	2e870300 	cdpcs	3, 8, cr0, cr7, cr0, {0}
    2368:	6400000f 	strvs	r0, [r0], #-15
    236c:	3a000017 	bcc	23d0 <DISABLE_IRQ+0x2350>
    2370:	00727265 	rsbseq	r7, r2, r5, ror #4
    2374:	08138703 	ldmdaeq	r3, {r0, r1, r8, r9, sl, pc}
    2378:	17980000 	ldrne	r0, [r8, r0]
    237c:	63370000 	teqvs	r7, #0
    2380:	03000006 	movweq	r0, #6
    2384:	0000f689 	andeq	pc, r0, r9, lsl #13
    2388:	19550100 	ldmdbne	r5, {r8}^
    238c:	0000018d 	andeq	r0, r0, sp, lsl #3
    2390:	006d8b03 	rsbeq	r8, sp, r3, lsl #22
    2394:	36000000 	strcc	r0, [r0], -r0
    2398:	000eb401 	andeq	fp, lr, r1, lsl #8
    239c:	01330300 	teqeq	r3, r0, lsl #6
    23a0:	00000f2e 	andeq	r0, r0, lr, lsr #30
    23a4:	30001fb4 	undefined instruction 0x30001fb4
    23a8:	300020a8 	andcc	r2, r0, r8, lsr #1
    23ac:	000017b6 	undefined instruction 0x000017b6
    23b0:	00001b9f 	muleq	r0, pc, fp
    23b4:	0000cf35 	andeq	ip, r0, r5, lsr pc
    23b8:	f6330300 	undefined instruction 0xf6330300
    23bc:	d5000000 	strle	r0, [r0]
    23c0:	35000017 	strcc	r0, [r0, #-23]
    23c4:	000006ec 	andeq	r0, r0, ip, ror #13
    23c8:	00493303 	subeq	r3, r9, r3, lsl #6
    23cc:	181f0000 	ldmdane	pc, {}
    23d0:	bd350000 	ldclt	0, cr0, [r5]
    23d4:	03000007 	movweq	r0, #7
    23d8:	00004933 	andeq	r4, r0, r3, lsr r9
    23dc:	00186900 	andseq	r6, r8, r0, lsl #18
    23e0:	72653a00 	rsbvc	r3, r5, #0
    23e4:	33030072 	movwcc	r0, #12402	; 0x3072
    23e8:	00000813 	andeq	r0, r0, r3, lsl r8
    23ec:	000018b3 	undefined instruction 0x000018b3
    23f0:	0004983e 	andeq	r9, r4, lr, lsr r8
    23f4:	2e350300 	cdpcs	3, 3, cr0, cr5, cr0, {0}
    23f8:	d100000f 	tstle	r0, pc
    23fc:	3e000018 	mcrcc	0, 0, r0, cr0, cr8, {0}
    2400:	00000663 	andeq	r0, r0, r3, ror #12
    2404:	08133603 	ldmdaeq	r3, {r0, r1, r9, sl, ip, sp}
    2408:	18ef0000 	stmiane	pc!, {}^
    240c:	5f3e0000 	svcpl	0x003e0000
    2410:	03000005 	movweq	r0, #5
    2414:	00040e37 	andeq	r0, r4, r7, lsr lr
    2418:	00190200 	andseq	r0, r9, r0, lsl #4
    241c:	00693c00 	rsbeq	r3, r9, r0, lsl #24
    2420:	00493803 	subeq	r3, r9, r3, lsl #16
    2424:	19150000 	ldmdbne	r5, {}
    2428:	8d190000 	ldchi	0, cr0, [r9]
    242c:	03000001 	movweq	r0, #1
    2430:	00006d3a 	andeq	r6, r0, sl, lsr sp
    2434:	011d0000 	tsteq	sp, r0
    2438:	000012ee 	andeq	r1, r0, lr, ror #5
    243c:	0101df0b 	tsteq	r1, fp, lsl #30
    2440:	00000025 	andeq	r0, r0, r5, lsr #32
    2444:	300020a8 	andcc	r2, r0, r8, lsr #1
    2448:	3000212c 	andcc	r2, r0, ip, lsr #2
    244c:	00001928 	andeq	r1, r0, r8, lsr #18
    2450:	00001c14 	andeq	r1, r0, r4, lsl ip
    2454:	00035f1e 	andeq	r5, r3, lr, lsl pc
    2458:	01df0b00 	bicseq	r0, pc, r0, lsl #22
    245c:	000006b3 	undefined instruction 0x000006b3
    2460:	00001953 	andeq	r1, r0, r3, asr r9
    2464:	000df01e 	andeq	pc, sp, lr, lsl r0
    2468:	01df0b00 	bicseq	r0, pc, r0, lsl #22
    246c:	00001c14 	andeq	r1, r0, r4, lsl ip
    2470:	00001971 	andeq	r1, r0, r1, ror r9
    2474:	0b006912 	bleq	1c8c4 <DISABLE_IRQ+0x1c844>
    2478:	002501e1 	eoreq	r0, r5, r1, ror #3
    247c:	d1200000 	teqle	r0, r0
    2480:	0b00000b 	bleq	24b4 <DISABLE_IRQ+0x2434>
    2484:	081301e3 	ldmdaeq	r3, {r0, r1, r5, r6, r7, r8}
    2488:	198f0000 	stmibne	pc, {}
    248c:	26200000 	strtcs	r0, [r0], -r0
    2490:	0b000008 	bleq	24b8 <DISABLE_IRQ+0x2438>
    2494:	081301e4 	ldmdaeq	r3, {r2, r5, r6, r7, r8}
    2498:	19a20000 	stmibne	r2!, {}
    249c:	8d100000 	ldchi	0, cr0, [r0]
    24a0:	0b000001 	bleq	24ac <DISABLE_IRQ+0x242c>
    24a4:	006d01ea 	rsbeq	r0, sp, sl, ror #3
    24a8:	0b000000 	bleq	24b0 <DISABLE_IRQ+0x2430>
    24ac:	00023804 	andeq	r3, r2, r4, lsl #16
    24b0:	77013600 	strvc	r3, [r1, -r0, lsl #12]
    24b4:	0b000009 	bleq	24e0 <DISABLE_IRQ+0x2460>
    24b8:	06b30150 	ssateq	r0, #20, r0, asr #2
    24bc:	212c0000 	teqcs	ip, r0
    24c0:	21c43000 	biccs	r3, r4, r0
    24c4:	19b53000 	ldmibne	r5!, {ip, sp}
    24c8:	1c880000 	stcne	0, cr0, [r8], {0}
    24cc:	6d3a0000 	ldcvs	0, cr0, [sl]
    24d0:	0b006773 	bleq	1c2a4 <DISABLE_IRQ+0x1c224>
    24d4:	0000f650 	andeq	pc, r0, r0, asr r6
    24d8:	0019d400 	andseq	sp, r9, r0, lsl #8
    24dc:	035f3700 	cmpeq	pc, #0
    24e0:	520b0000 	andpl	r0, fp, #0
    24e4:	000006b3 	undefined instruction 0x000006b3
    24e8:	8d195401 	cfldrshi	mvf5, [r9, #-4]
    24ec:	0b000001 	bleq	24f8 <DISABLE_IRQ+0x2478>
    24f0:	00006d54 	andeq	r6, r0, r4, asr sp
    24f4:	09093b00 	stmdbeq	r9, {r8, r9, fp, ip, sp}
    24f8:	21840000 	orrcs	r0, r4, r0
    24fc:	01903000 	orrseq	r3, r0, r0
    2500:	6a0b0000 	bvs	2c2508 <DISABLE_IRQ+0x2c2488>
    2504:	000c7d2c 	andeq	r7, ip, ip, lsr #26
    2508:	01a82e00 	undefined instruction 0x01a82e00
    250c:	24280000 	strtcs	r0, [r8]
    2510:	f2000009 	vhadd.s8	d0, d0, d9
    2514:	24000019 	strcs	r0, [r0], #-25
    2518:	00000930 	andeq	r0, r0, r0, lsr r9
    251c:	36000000 	strcc	r0, [r0], -r0
    2520:	000d7701 	andeq	r7, sp, r1, lsl #14
    2524:	01270b00 	teqeq	r7, r0, lsl #22
    2528:	000000f6 	strdeq	r0, [r0], -r6
    252c:	300021c4 	andcc	r2, r0, r4, asr #3
    2530:	30002204 	andcc	r2, r0, r4, lsl #4
    2534:	00001a10 	andeq	r1, r0, r0, lsl sl
    2538:	00001ccf 	andeq	r1, r0, pc, asr #25
    253c:	00035f35 	andeq	r5, r3, r5, lsr pc
    2540:	b3270b00 	teqlt	r7, #0
    2544:	2f000006 	svccs	0x00000006
    2548:	3c00001a 	stccc	0, cr0, [r0], {26}
    254c:	0067736d 	rsbeq	r7, r7, sp, ror #6
    2550:	00f6290b 	rscseq	r2, r6, fp, lsl #18
    2554:	1a4d0000 	bne	134255c <MEM_SIZE+0xb4255c>
    2558:	8d190000 	ldchi	0, cr0, [r9]
    255c:	0b000001 	bleq	2568 <DISABLE_IRQ+0x24e8>
    2560:	00006d2b 	andeq	r6, r0, fp, lsr #26
    2564:	011d0000 	tsteq	sp, r0
    2568:	00000a9d 	muleq	r0, sp, sl
    256c:	01037f02 	tsteq	r3, r2, lsl #30
    2570:	00000127 	andeq	r0, r0, r7, lsr #2
    2574:	30002204 	andcc	r2, r0, r4, lsl #4
    2578:	30002264 	andcc	r2, r0, r4, ror #4
    257c:	00001a6b 	andeq	r1, r0, fp, ror #20
    2580:	00001d28 	andeq	r1, r0, r8, lsr #26
    2584:	000c9f1e 	andeq	r9, ip, lr, lsl pc
    2588:	037f0200 	cmneq	pc, #0
    258c:	0000086b 	andeq	r0, r0, fp, ror #16
    2590:	00001a8a 	andeq	r1, r0, sl, lsl #21
    2594:	7272651f 	rsbsvc	r6, r2, #130023424	; 0x7c00000
    2598:	037f0200 	cmneq	pc, #0
    259c:	00000813 	andeq	r0, r0, r3, lsl r8
    25a0:	00001ad4 	ldrdeq	r1, [r0], -r4
    25a4:	00015833 	andeq	r5, r1, r3, lsr r8
    25a8:	03810200 	orreq	r0, r1, #0
    25ac:	00000127 	andeq	r0, r0, r7, lsr #2
    25b0:	8d105401 	cfldrshi	mvf5, [r0, #-4]
    25b4:	02000001 	andeq	r0, r0, #1
    25b8:	006d0383 	rsbeq	r0, sp, r3, lsl #7
    25bc:	1d000000 	stcne	0, cr0, [r0]
    25c0:	00115201 	andseq	r5, r1, r1, lsl #4
    25c4:	02c90200 	sbceq	r0, r9, #0
    25c8:	00012701 	andeq	r2, r1, r1, lsl #14
    25cc:	00226400 	eoreq	r6, r2, r0, lsl #8
    25d0:	00228c30 	eoreq	r8, r2, r0, lsr ip
    25d4:	001af230 	andseq	pc, sl, r0, lsr r2
    25d8:	001d6100 	andseq	r6, sp, r0, lsl #2
    25dc:	01583300 	cmpeq	r8, r0, lsl #6
    25e0:	cb020000 	blgt	825e8 <DISABLE_IRQ+0x82568>
    25e4:	00012702 	andeq	r2, r1, r2, lsl #14
    25e8:	10540100 	subsne	r0, r4, r0, lsl #2
    25ec:	0000018d 	andeq	r0, r0, sp, lsl #3
    25f0:	6d02cd02 	stcvs	13, cr12, [r2, #-8]
    25f4:	00000000 	andeq	r0, r0, r0
    25f8:	0302012a 	movweq	r0, #8490	; 0x212a
    25fc:	c1020000 	tstgt	r2, r0
    2600:	228c0101 	addcs	r0, ip, #1073741824	; 0x40000000
    2604:	237c3000 	cmncs	ip, #0
    2608:	1b113000 	blne	44e610 <DISABLE_IRQ+0x44e590>
    260c:	1e1f0000 	cdpne	0, 1, cr0, cr15, cr0, {0}
    2610:	9f1e0000 	svcls	0x001e0000
    2614:	0200000c 	andeq	r0, r0, #12
    2618:	086b01c1 	stmdaeq	fp!, {r0, r6, r7, r8}^
    261c:	1b300000 	blne	c02624 <MEM_SIZE+0x402624>
    2620:	a51e0000 	ldrge	r0, [lr]
    2624:	02000003 	andeq	r0, r0, #3
    2628:	081301c1 	ldmdaeq	r3, {r0, r6, r7, r8}
    262c:	1b6f0000 	blne	1bc2634 <MEM_SIZE+0x13c2634>
    2630:	651f0000 	ldrvs	r0, [pc, #0]	; 2638 <DISABLE_IRQ+0x25b8>
    2634:	02007272 	andeq	r7, r0, #536870919	; 0x20000007
    2638:	081301c1 	ldmdaeq	r3, {r0, r6, r7, r8}
    263c:	1ba30000 	blne	fe8c2644 <rEINTPEND+0xa88c259c>
    2640:	6c210000 	stcvs	0, cr0, [r1]
    2644:	02006e65 	andeq	r6, r0, #1616	; 0x650
    2648:	002501c3 	eoreq	r0, r5, r3, asr #3
    264c:	1bc10000 	blne	ff042654 <rEINTPEND+0xa90425ac>
    2650:	8d200000 	stchi	0, cr0, [r0]
    2654:	02000001 	andeq	r0, r0, #1
    2658:	006d01c5 	rsbeq	r0, sp, r5, asr #3
    265c:	1bf50000 	blne	ffd42664 <rEINTPEND+0xa9d425bc>
    2660:	a5380000 	ldrge	r0, [r8]!
    2664:	c8000008 	stmdagt	r0, {r3}
    2668:	c0300022 	eorsgt	r0, r0, r2, lsr #32
    266c:	02000001 	andeq	r0, r0, #1
    2670:	1df001e0 	ldfnee	f0, [r0, #896]!	; 0x380
    2674:	242c0000 	strtcs	r0, [ip]
    2678:	2e00000d 	cdpcs	0, 0, cr0, cr0, cr13, {0}
    267c:	000001d8 	ldrdeq	r0, [r0], -r8
    2680:	0008c424 	andeq	ip, r8, r4, lsr #8
    2684:	30000000 	andcc	r0, r0, r0
    2688:	000008d1 	ldrdeq	r0, [r0], -r1
    268c:	300022fc 	strdcc	r2, [r0], -ip
    2690:	30002314 	andcc	r2, r0, r4, lsl r3
    2694:	2c01e602 	stccs	6, cr14, [r1], {2}
    2698:	00000cfe 	strdeq	r0, [r0], -lr
    269c:	000cf526 	andeq	pc, ip, r6, lsr #10
    26a0:	001c3f00 	andseq	r3, ip, r0, lsl #30
    26a4:	22fc3900 	rscscs	r3, ip, #0
    26a8:	23143000 	tstcs	r4, #0
    26ac:	fc243000 	stc2	0, cr3, [r4]
    26b0:	00000008 	andeq	r0, r0, r8
    26b4:	011d0000 	tsteq	sp, r0
    26b8:	00000ea6 	andeq	r0, r0, r6, lsr #29
    26bc:	01018302 	tsteq	r1, r2, lsl #6
    26c0:	00000025 	andeq	r0, r0, r5, lsr #32
    26c4:	3000237c 	andcc	r2, r0, ip, ror r3
    26c8:	3000244c 	andcc	r2, r0, ip, asr #8
    26cc:	00001c68 	andeq	r1, r0, r8, ror #24
    26d0:	00001eb8 	undefined instruction 0x00001eb8
    26d4:	000c9f1e 	andeq	r9, ip, lr, lsl pc
    26d8:	01830200 	orreq	r0, r3, r0, lsl #4
    26dc:	0000086b 	andeq	r0, r0, fp, ror #16
    26e0:	00001c87 	andeq	r1, r0, r7, lsl #25
    26e4:	0003a51e 	andeq	sl, r3, lr, lsl r5
    26e8:	01830200 	orreq	r0, r3, r0, lsl #4
    26ec:	00000813 	andeq	r0, r0, r3, lsl r8
    26f0:	00001cd1 	ldrdeq	r1, [r0], -r1
    26f4:	7272651f 	rsbsvc	r6, r2, #130023424	; 0x7c00000
    26f8:	01830200 	orreq	r0, r3, r0, lsl #4
    26fc:	00000813 	andeq	r0, r0, r3, lsl r8
    2700:	00001cef 	andeq	r1, r0, pc, ror #25
    2704:	6e656c21 	cdpvs	12, 6, cr6, cr5, cr1, {1}
    2708:	01850200 	orreq	r0, r5, r0, lsl #4
    270c:	00000025 	andeq	r0, r0, r5, lsr #32
    2710:	00001d0d 	andeq	r1, r0, sp, lsl #26
    2714:	00018d20 	andeq	r8, r1, r0, lsr #26
    2718:	01870200 	orreq	r0, r7, r0, lsl #4
    271c:	0000006d 	andeq	r0, r0, sp, rrx
    2720:	00001d4c 	andeq	r1, r0, ip, asr #26
    2724:	0008d130 	andeq	sp, r8, r0, lsr r1
    2728:	0023b800 	eoreq	fp, r3, r0, lsl #16
    272c:	0023f030 	eoreq	pc, r3, r0, lsr r0
    2730:	01a20230 	undefined instruction 0x01a20230
    2734:	000cfe2c 	andeq	pc, ip, ip, lsr #28
    2738:	0cf52c00 	ldcleq	12, cr2, [r5]
    273c:	b8390000 	ldmdalt	r9!, {}
    2740:	f0300023 	undefined instruction 0xf0300023
    2744:	24300023 	ldrtcs	r0, [r0], #-35	; 0x23
    2748:	000008fc 	strdeq	r0, [r0], -ip
    274c:	36000000 	strcc	r0, [r0], -r0
    2750:	00032501 	andeq	r2, r3, r1, lsl #10
    2754:	01c80200 	biceq	r0, r8, r0, lsl #4
    2758:	0000086b 	andeq	r0, r0, fp, ror #16
    275c:	3000244c 	andcc	r2, r0, ip, asr #8
    2760:	300024e0 	andcc	r2, r0, r0, ror #9
    2764:	00001d8b 	andeq	r1, r0, fp, lsl #27
    2768:	00001f0c 	andeq	r1, r0, ip, lsl #30
    276c:	00015835 	andeq	r5, r1, r5, lsr r8
    2770:	27c80200 	strbcs	r0, [r8, r0, lsl #4]
    2774:	aa000001 	bge	2780 <DISABLE_IRQ+0x2700>
    2778:	3a00001d 	bcc	27f4 <DISABLE_IRQ+0x2774>
    277c:	00727265 	rsbseq	r7, r2, r5, ror #4
    2780:	0813c802 	ldmdaeq	r3, {r1, fp, lr, pc}
    2784:	1dc80000 	stclne	0, cr0, [r8]
    2788:	9f370000 	svcls	0x00370000
    278c:	0200000c 	andeq	r0, r0, #12
    2790:	00086bca 	andeq	r6, r8, sl, asr #23
    2794:	19540100 	ldmdbne	r4, {r8}^
    2798:	0000018d 	andeq	r0, r0, sp, lsl #3
    279c:	006dcc02 	rsbeq	ip, sp, r2, lsl #24
    27a0:	36000000 	strcc	r0, [r0], -r0
    27a4:	0007dc01 	andeq	sp, r7, r1, lsl #24
    27a8:	01540200 	cmpeq	r4, r0, lsl #4
    27ac:	00000127 	andeq	r0, r0, r7, lsr #2
    27b0:	300024e0 	andcc	r2, r0, r0, ror #9
    27b4:	30002614 	andcc	r2, r0, r4, lsl r6
    27b8:	00001de6 	andeq	r1, r0, r6, ror #27
    27bc:	00001f9c 	muleq	r0, ip, pc
    27c0:	000c9f35 	andeq	r9, ip, r5, lsr pc
    27c4:	6b540200 	blvs	1502fcc <MEM_SIZE+0xd02fcc>
    27c8:	05000008 	streq	r0, [r0, #-8]
    27cc:	3500001e 	strcc	r0, [r0, #-30]
    27d0:	00000158 	andeq	r0, r0, r8, asr r1
    27d4:	01275402 	teqeq	r7, r2, lsl #8
    27d8:	1e4f0000 	cdpne	0, 4, cr0, cr15, cr0, {0}
    27dc:	8d350000 	ldchi	0, cr0, [r5]
    27e0:	02000009 	andeq	r0, r0, #9
    27e4:	00002554 	andeq	r2, r0, r4, asr r5
    27e8:	001e6d00 	andseq	r6, lr, r0, lsl #26
    27ec:	72653a00 	rsbvc	r3, r5, #0
    27f0:	54020072 	strpl	r0, [r2], #-114	; 0x72
    27f4:	00000813 	andeq	r0, r0, r3, lsl r8
    27f8:	00001eb7 	undefined instruction 0x00001eb7
    27fc:	000b663e 	andeq	r6, fp, lr, lsr r6
    2800:	27560200 	ldrbcs	r0, [r6, -r0, lsl #4]
    2804:	d5000001 	strle	r0, [r0, #-1]
    2808:	1900001e 	stmdbne	r0, {r1, r2, r3, r4}
    280c:	0000063e 	andeq	r0, r0, lr, lsr r6
    2810:	00255702 	eoreq	r5, r5, r2, lsl #14
    2814:	fc3e0000 	ldc2	0, cr0, [lr]
    2818:	02000005 	andeq	r0, r0, #5
    281c:	00007858 	andeq	r7, r0, r8, asr r8
    2820:	001f1f00 	andseq	r1, pc, r0, lsl #30
    2824:	018d3700 	orreq	r3, sp, r0, lsl #14
    2828:	5a020000 	bpl	82830 <DISABLE_IRQ+0x827b0>
    282c:	0000006d 	andeq	r0, r0, sp, rrx
    2830:	2a005001 	bcs	1683c <DISABLE_IRQ+0x167bc>
    2834:	000f2d01 	andeq	r2, pc, r1, lsl #26
    2838:	01750100 	cmneq	r5, r0, lsl #2
    283c:	00261401 	eoreq	r1, r6, r1, lsl #8
    2840:	00266c30 	eoreq	r6, r6, r0, lsr ip
    2844:	001f3d30 	andseq	r3, pc, r0, lsr sp
    2848:	001fc300 	andseq	ip, pc, r0, lsl #6
    284c:	018d1000 	orreq	r1, sp, r0
    2850:	78010000 	stmdavc	r1, {}
    2854:	00006d01 	andeq	r6, r0, r1, lsl #26
    2858:	01340000 	teqeq	r4, r0
    285c:	00000b35 	andeq	r0, r0, r5, lsr fp
    2860:	6c01a901 	stcvs	9, cr10, [r1], {1}
    2864:	30300026 	eorscc	r0, r0, r6, lsr #32
    2868:	5c300027 	ldcpl	0, cr0, [r0], #-156	; 0xffffff64
    286c:	7b00001f 	blvc	28f0 <DISABLE_IRQ+0x2870>
    2870:	35000020 	strcc	r0, [r0, #-32]
    2874:	0000035f 	andeq	r0, r0, pc, asr r3
    2878:	06b3a901 	ldrteq	sl, [r3], r1, lsl #18
    287c:	1f7b0000 	svcne	0x007b0000
    2880:	a5350000 	ldrge	r0, [r5]!
    2884:	01000003 	tsteq	r0, r3
    2888:	000813a9 	andeq	r1, r8, r9, lsr #7
    288c:	001fc500 	andseq	ip, pc, r0, lsl #10
    2890:	72653a00 	rsbvc	r3, r5, #0
    2894:	a9010072 	stmdbge	r1, {r1, r4, r5, r6}
    2898:	00000813 	andeq	r0, r0, r3, lsl r8
    289c:	0000201a 	andeq	r2, r0, sl, lsl r0
    28a0:	6e656c3c 	mcrvs	12, 3, r6, cr5, cr12, {1}
    28a4:	25ab0100 	strcs	r0, [fp, #256]!	; 0x100
    28a8:	38000000 	stmdacc	r0, {}
    28ac:	37000020 	strcc	r0, [r0, -r0, lsr #32]
    28b0:	0000018d 	andeq	r0, r0, sp, lsl #3
    28b4:	006dad01 	rsbeq	sl, sp, r1, lsl #26
    28b8:	50010000 	andpl	r0, r1, r0
    28bc:	0008a541 	andeq	sl, r8, r1, asr #10
    28c0:	0026bc00 	eoreq	fp, r6, r0, lsl #24
    28c4:	0026e430 	eoreq	lr, r6, r0, lsr r4
    28c8:	4dcb0130 	stfmie	f0, [fp, #192]	; 0xc0
    28cc:	2c000020 	stccs	0, cr0, [r0], {32}
    28d0:	00000d24 	andeq	r0, r0, r4, lsr #26
    28d4:	0026bc39 	eoreq	fp, r6, r9, lsr ip
    28d8:	0026e430 	eoreq	lr, r6, r0, lsr r4
    28dc:	08c42430 	stmiaeq	r4, {r4, r5, sl, sp}^
    28e0:	00000000 	andeq	r0, r0, r0
    28e4:	0008d140 	andeq	sp, r8, r0, asr #2
    28e8:	0026f000 	eoreq	pc, r6, r0
    28ec:	00270830 	eoreq	r0, r7, r0, lsr r8
    28f0:	2cd10130 	ldfcse	f0, [r1], {48}	; 0x30
    28f4:	00000cfe 	strdeq	r0, [r0], -lr
    28f8:	000cf526 	andeq	pc, ip, r6, lsr #10
    28fc:	00206100 	eoreq	r6, r0, r0, lsl #2
    2900:	26f03900 	ldrbtcs	r3, [r0], r0, lsl #18
    2904:	27083000 	strcs	r3, [r8, -r0]
    2908:	fc243000 	stc2	0, cr3, [r4]
    290c:	00000008 	andeq	r0, r0, r8
    2910:	01360000 	teqeq	r6, r0
    2914:	00000fbf 	undefined instruction 0x00000fbf
    2918:	25016401 	strcs	r6, [r1, #-1025]	; 0x401
    291c:	30000000 	andcc	r0, r0, r0
    2920:	d8300027 	ldmdale	r0!, {r0, r1, r2, r5}
    2924:	7f300027 	svcvc	0x00300027
    2928:	09000020 	stmdbeq	r0, {r5}
    292c:	35000021 	strcc	r0, [r0, #-33]	; 0x21
    2930:	0000035f 	andeq	r0, r0, pc, asr r3
    2934:	06b36401 	ldrteq	r6, [r3], r1, lsl #8
    2938:	209e0000 	addscs	r0, lr, r0
    293c:	a5350000 	ldrge	r0, [r5]!
    2940:	01000003 	tsteq	r0, r3
    2944:	00081364 	andeq	r1, r8, r4, ror #6
    2948:	0020f300 	eoreq	pc, r0, r0, lsl #6
    294c:	72653a00 	rsbvc	r3, r5, #0
    2950:	64010072 	strvs	r0, [r1], #-114	; 0x72
    2954:	00000813 	andeq	r0, r0, r3, lsl r8
    2958:	00002127 	andeq	r2, r0, r7, lsr #2
    295c:	6e656c3c 	mcrvs	12, 3, r6, cr5, cr12, {1}
    2960:	25660100 	strbcs	r0, [r6, #-256]!	; 0x100
    2964:	45000000 	strmi	r0, [r0]
    2968:	19000021 	stmdbne	r0, {r0, r5}
    296c:	0000018d 	andeq	r0, r0, sp, lsl #3
    2970:	006d6801 	rsbeq	r6, sp, r1, lsl #16
    2974:	d1400000 	cmple	r0, r0
    2978:	8c000008 	stchi	0, cr0, [r0], {8}
    297c:	c4300027 	ldrtgt	r0, [r0], #-39	; 0x27
    2980:	01300027 	teqeq	r0, r7, lsr #32
    2984:	0cfe2c86 	ldcleq	12, cr2, [lr], #536	; 0x218
    2988:	f52c0000 	undefined instruction 0xf52c0000
    298c:	3900000c 	stmdbcc	r0, {r2, r3}
    2990:	3000278c 	andcc	r2, r0, ip, lsl #15
    2994:	300027c4 	andcc	r2, r0, r4, asr #15
    2998:	0008fc24 	andeq	pc, r8, r4, lsr #24
    299c:	00000000 	andeq	r0, r0, r0
    29a0:	0a23011d 	beq	8c2e1c <MEM_SIZE+0xc2e1c>
    29a4:	ee010000 	cdp	0, 0, cr0, cr1, cr0, {0}
    29a8:	00250105 	eoreq	r0, r5, r5, lsl #2
    29ac:	27d80000 	ldrbcs	r0, [r8, r0]
    29b0:	293c3000 	ldmdbcs	ip!, {ip, sp}
    29b4:	21633000 	cmncs	r3, r0
    29b8:	21af0000 	undefined instruction 0x21af0000
    29bc:	851e0000 	ldrhi	r0, [lr]
    29c0:	0100000e 	tsteq	r0, lr
    29c4:	002505ee 	eoreq	r0, r5, lr, ror #11
    29c8:	21820000 	orrcs	r0, r2, r0
    29cc:	081e0000 	ldmdaeq	lr, {}
    29d0:	0100000c 	tsteq	r0, ip
    29d4:	06a705ee 	strteq	r0, [r7], lr, ror #11
    29d8:	21ab0000 	undefined instruction 0x21ab0000
    29dc:	c11e0000 	tstgt	lr, r0
    29e0:	01000009 	tsteq	r0, r9
    29e4:	06a705ee 	strteq	r0, [r7], lr, ror #11
    29e8:	21c90000 	biccs	r0, r9, r0
    29ec:	691f0000 	ldmdbvs	pc, {}
    29f0:	ee010064 	cdp	0, 0, cr0, cr1, cr4, {3}
    29f4:	00003705 	andeq	r3, r0, r5, lsl #14
    29f8:	0021e700 	eoreq	lr, r1, r0, lsl #14
    29fc:	0d303100 	ldfeqs	f3, [r0]
    2a00:	ee010000 	cdp	0, 0, cr0, cr1, cr0, {0}
    2a04:	00004905 	andeq	r4, r0, r5, lsl #18
    2a08:	00910200 	addseq	r0, r1, r0, lsl #4
    2a0c:	00061d31 	andeq	r1, r6, r1, lsr sp
    2a10:	05ee0100 	strbeq	r0, [lr, #256]!	; 0x100
    2a14:	000000f6 	strdeq	r0, [r0], -r6
    2a18:	1f049102 	svcne	0x00049102
    2a1c:	0074706f 	rsbseq	r7, r4, pc, rrx
    2a20:	3705ee01 	strcc	lr, [r5, -r1, lsl #28]
    2a24:	05000000 	streq	r0, [r0]
    2a28:	33000022 	movwcc	r0, #34	; 0x22
    2a2c:	00000fba 	undefined instruction 0x00000fba
    2a30:	6505f001 	strvs	pc, [r5, #-1]
    2a34:	01000008 	tsteq	r0, r8
    2a38:	018d1057 	orreq	r1, sp, r7, asr r0
    2a3c:	f2010000 	vhadd.s8	d0, d1, d0
    2a40:	00006d05 	andeq	r6, r0, r5, lsl #26
    2a44:	012a0000 	teqeq	sl, r0
    2a48:	00000941 	andeq	r0, r0, r1, asr #18
    2a4c:	01054501 	tsteq	r5, r1, lsl #10
    2a50:	3000293c 	andcc	r2, r0, ip, lsr r9
    2a54:	30002964 	andcc	r2, r0, r4, ror #18
    2a58:	00002224 	andeq	r2, r0, r4, lsr #4
    2a5c:	000021e6 	andeq	r2, r0, r6, ror #3
    2a60:	000f9e1e 	andeq	r9, pc, lr, lsl lr
    2a64:	05450100 	strbeq	r0, [r5, #-256]	; 0x100
    2a68:	000000f6 	strdeq	r0, [r0], -r6
    2a6c:	00002243 	andeq	r2, r0, r3, asr #4
    2a70:	00018d10 	andeq	r8, r1, r0, lsl sp
    2a74:	05480100 	strbeq	r0, [r8, #-256]	; 0x100
    2a78:	0000006d 	andeq	r0, r0, sp, rrx
    2a7c:	c5012a00 	strgt	r2, [r1, #-2560]	; 0xa00
    2a80:	01000007 	tsteq	r0, r7
    2a84:	640104a7 	strvs	r0, [r1], #-1191	; 0x4a7
    2a88:	34300029 	ldrtcc	r0, [r0], #-41	; 0x29
    2a8c:	5630002a 	ldrtpl	r0, [r0], -sl, lsr #32
    2a90:	2d000022 	stccs	0, cr0, [r0, #-136]	; 0xffffff78
    2a94:	10000022 	andne	r0, r0, r2, lsr #32
    2a98:	0000018d 	andeq	r0, r0, sp, lsl #3
    2a9c:	6d04aa01 	vstrvs	s20, [r4, #-4]
    2aa0:	2b000000 	blcs	2aa8 <DISABLE_IRQ+0x2a28>
    2aa4:	0000093b 	andeq	r0, r0, fp, lsr r9
    2aa8:	30002990 	mulcc	r0, r0, r9
    2aac:	000001f0 	strdeq	r0, [r0], -r0
    2ab0:	2e04b201 	cdpcs	2, 0, cr11, cr4, cr1, {0}
    2ab4:	00000218 	andeq	r0, r0, r8, lsl r2
    2ab8:	00094928 	andeq	r4, r9, r8, lsr #18
    2abc:	00227500 	eoreq	r7, r2, r0, lsl #10
    2ac0:	00000000 	andeq	r0, r0, r0
    2ac4:	0d670136 	stfeqe	f0, [r7, #-216]!	; 0xffffff28
    2ac8:	98080000 	stmdals	r8, {}
    2acc:	00002501 	andeq	r2, r0, r1, lsl #10
    2ad0:	002a3400 	eoreq	r3, sl, r0, lsl #8
    2ad4:	002b1830 	eoreq	r1, fp, r0, lsr r8
    2ad8:	00228830 	eoreq	r8, r2, r0, lsr r8
    2adc:	00227800 	eoreq	r7, r2, r0, lsl #16
    2ae0:	0e853500 	cdpeq	5, 8, cr3, cr5, cr0, {0}
    2ae4:	98080000 	stmdals	r8, {}
    2ae8:	00000025 	andeq	r0, r0, r5, lsr #32
    2aec:	000022a7 	andeq	r2, r0, r7, lsr #5
    2af0:	000fba3e 	andeq	fp, pc, lr, lsr sl
    2af4:	659a0800 	ldrvs	r0, [sl, #2048]	; 0x800
    2af8:	d0000008 	andle	r0, r0, r8
    2afc:	3e000022 	cdpcc	0, 0, cr0, cr0, cr2, {1}
    2b00:	0000018d 	andeq	r0, r0, sp, lsl #3
    2b04:	006d9c08 	rsbeq	r9, sp, r8, lsl #24
    2b08:	23040000 	movwcs	r0, #16384	; 0x4000
    2b0c:	34000000 	strcc	r0, [r0]
    2b10:	0002bd01 	andeq	fp, r2, r1, lsl #26
    2b14:	01240800 	teqeq	r4, r0, lsl #16
    2b18:	30002b18 	andcc	r2, r0, r8, lsl fp
    2b1c:	30002b84 	andcc	r2, r0, r4, lsl #23
    2b20:	00002338 	andeq	r2, r0, r8, lsr r3
    2b24:	000022b5 	undefined instruction 0x000022b5
    2b28:	00093b35 	andeq	r3, r9, r5, lsr fp
    2b2c:	37240800 	strcc	r0, [r4, -r0, lsl #16]!
    2b30:	57000000 	strpl	r0, [r0, -r0]
    2b34:	3f000023 	svccc	0x00000023
    2b38:	26080079 	undefined instruction 0x26080079
    2b3c:	00000025 	andeq	r0, r0, r5, lsr #32
    2b40:	00018d19 	andeq	r8, r1, r9, lsl sp
    2b44:	6d280800 	stcvs	8, cr0, [r8]
    2b48:	00000000 	andeq	r0, r0, r0
    2b4c:	0d020136 	stfeqs	f0, [r2, #-216]	; 0xffffff28
    2b50:	54080000 	strpl	r0, [r8]
    2b54:	00002501 	andeq	r2, r0, r1, lsl #10
    2b58:	002b8400 	eoreq	r8, fp, r0, lsl #8
    2b5c:	002c6030 	eoreq	r6, ip, r0, lsr r0
    2b60:	00237530 	eoreq	r7, r3, r0, lsr r5
    2b64:	00232d00 	eoreq	r2, r3, r0, lsl #26
    2b68:	041a3500 	ldreq	r3, [sl], #-1280	; 0x500
    2b6c:	54080000 	strpl	r0, [r8]
    2b70:	00000025 	andeq	r0, r0, r5, lsr #32
    2b74:	00002394 	muleq	r0, r4, r3
    2b78:	000e4e35 	andeq	r4, lr, r5, lsr lr
    2b7c:	25540800 	ldrbcs	r0, [r4, #-2048]	; 0x800
    2b80:	c8000000 	stmdagt	r0, {}
    2b84:	35000023 	strcc	r0, [r0, #-35]	; 0x23
    2b88:	00000bd6 	ldrdeq	r0, [r0], -r6
    2b8c:	00255408 	eoreq	r5, r5, r8, lsl #8
    2b90:	23db0000 	bicscs	r0, fp, #0
    2b94:	b2350000 	eorslt	r0, r5, #0
    2b98:	0800000b 	stmdaeq	r0, {r0, r1, r3}
    2b9c:	00003754 	andeq	r3, r0, r4, asr r7
    2ba0:	0023ee00 	eoreq	lr, r3, r0, lsl #28
    2ba4:	093b3e00 	ldmdbeq	fp!, {r9, sl, fp, ip, sp}
    2ba8:	56080000 	strpl	r0, [r8], -r0
    2bac:	00000049 	andeq	r0, r0, r9, asr #32
    2bb0:	00002401 	andeq	r2, r0, r1, lsl #8
    2bb4:	00109b3e 	andseq	r9, r0, lr, lsr fp
    2bb8:	37570800 	ldrbcc	r0, [r7, -r0, lsl #16]
    2bbc:	14000000 	strne	r0, [r0]
    2bc0:	00000024 	andeq	r0, r0, r4, lsr #32
    2bc4:	08f6012a 	ldmeq	r6!, {r1, r3, r5, r8}^
    2bc8:	6f010000 	svcvs	0x00010000
    2bcc:	2c600105 	stfcse	f0, [r0], #-20	; 0xffffffec
    2bd0:	2d203000 	stccs	0, cr3, [r0]
    2bd4:	243d3000 	ldrtcs	r3, [sp]
    2bd8:	238e0000 	orrcs	r0, lr, #0
    2bdc:	9e1e0000 	cdpls	0, 1, cr0, cr14, cr0, {0}
    2be0:	0100000f 	tsteq	r0, pc
    2be4:	00f6056f 	rscseq	r0, r6, pc, ror #10
    2be8:	245c0000 	ldrbcs	r0, [ip]
    2bec:	72420000 	subvc	r0, r2, #0
    2bf0:	01006e75 	tsteq	r0, r5, ror lr
    2bf4:	00490571 	subeq	r0, r9, r1, ror r5
    2bf8:	5b010000 	blpl	42c00 <DISABLE_IRQ+0x42b80>
    2bfc:	78616d21 	stmdavc	r1!, {r0, r5, r8, sl, fp, sp, lr}^
    2c00:	05720100 	ldrbeq	r0, [r2, #-256]!	; 0x100
    2c04:	00000049 	andeq	r0, r0, r9, asr #32
    2c08:	0000247a 	andeq	r2, r0, sl, ror r4
    2c0c:	0009d210 	andeq	sp, r9, r0, lsl r2
    2c10:	05730100 	ldrbeq	r0, [r3, #-256]!	; 0x100
    2c14:	0000005b 	andeq	r0, r0, fp, asr r0
    2c18:	00018d10 	andeq	r8, r1, r0, lsl sp
    2c1c:	05750100 	ldrbeq	r0, [r5, #-256]!	; 0x100
    2c20:	0000006d 	andeq	r0, r0, sp, rrx
    2c24:	0e012a00 	vmlaeq.f32	s4, s2, s0
    2c28:	01000013 	tsteq	r0, r3, lsl r0
    2c2c:	200101ec 	andcs	r0, r1, ip, ror #3
    2c30:	7c30002d 	ldcvc	0, cr0, [r0], #-180	; 0xffffff4c
    2c34:	9830002d 	ldmdals	r0!, {r0, r2, r3, r5}
    2c38:	b5000024 	strlt	r0, [r0, #-36]	; 0x24
    2c3c:	10000023 	andne	r0, r0, r3, lsr #32
    2c40:	0000018d 	andeq	r0, r0, sp, lsl #3
    2c44:	6d01ef01 	stcvs	15, cr14, [r1, #-4]
    2c48:	00000000 	andeq	r0, r0, r0
    2c4c:	10f1011d 	rscsne	r0, r1, sp, lsl r1
    2c50:	7a050000 	bvc	142c58 <DISABLE_IRQ+0x142bd8>
    2c54:	00250103 	eoreq	r0, r5, r3, lsl #2
    2c58:	2d7c0000 	ldclcs	0, cr0, [ip]
    2c5c:	2e7c3000 	cdpcs	0, 7, cr3, cr12, cr0, {0}
    2c60:	24b73000 	ldrtcs	r3, [r7]
    2c64:	241c0000 	ldrcs	r0, [ip]
    2c68:	851e0000 	ldrhi	r0, [lr]
    2c6c:	0500000e 	streq	r0, [r0, #-14]
    2c70:	0025037a 	eoreq	r0, r5, sl, ror r3
    2c74:	24d60000 	ldrbcs	r0, [r6]
    2c78:	d0200000 	eorle	r0, r0, r0
    2c7c:	05000002 	streq	r0, [r0, #-2]
    2c80:	0078037c 	rsbseq	r0, r8, ip, ror r3
    2c84:	25150000 	ldrcs	r0, [r5]
    2c88:	ba200000 	blt	802c90 <MEM_SIZE+0x2c90>
    2c8c:	0500000f 	streq	r0, [r0, #-15]
    2c90:	0865037d 	stmdaeq	r5!, {r0, r2, r3, r4, r5, r6, r8, r9}^
    2c94:	253e0000 	ldrcs	r0, [lr]!
    2c98:	79120000 	ldmdbvc	r2, {}
    2c9c:	037e0500 	cmneq	lr, #0
    2ca0:	00000025 	andeq	r0, r0, r5, lsr #32
    2ca4:	00018d33 	andeq	r8, r1, r3, lsr sp
    2ca8:	03800500 	orreq	r0, r0, #0
    2cac:	0000006d 	andeq	r0, r0, sp, rrx
    2cb0:	1d005001 	stcne	0, cr5, [r0, #-4]
    2cb4:	00045f01 	andeq	r5, r4, r1, lsl #30
    2cb8:	02e50500 	rsceq	r0, r5, #0
    2cbc:	00002501 	andeq	r2, r0, r1, lsl #10
    2cc0:	002e7c00 	eoreq	r7, lr, r0, lsl #24
    2cc4:	002f6030 	eoreq	r6, pc, r0, lsr r0
    2cc8:	00256730 	eoreq	r6, r5, r0, lsr r7
    2ccc:	00246700 	eoreq	r6, r4, r0, lsl #14
    2cd0:	0e851e00 	cdpeq	14, 8, cr1, cr5, cr0, {0}
    2cd4:	e5050000 	str	r0, [r5]
    2cd8:	00002502 	andeq	r2, r0, r2, lsl #10
    2cdc:	00258600 	eoreq	r8, r5, r0, lsl #12
    2ce0:	0fba2000 	svceq	0x00ba2000
    2ce4:	e7050000 	str	r0, [r5, -r0]
    2ce8:	00086502 	andeq	r6, r8, r2, lsl #10
    2cec:	0025af00 	eoreq	sl, r5, r0, lsl #30
    2cf0:	018d1000 	orreq	r1, sp, r0
    2cf4:	e9050000 	stmdb	r5, {}
    2cf8:	00006d02 	andeq	r6, r0, r2, lsl #26
    2cfc:	011d0000 	tsteq	sp, r0
    2d00:	00000f6e 	andeq	r0, r0, lr, ror #30
    2d04:	01017e05 	tsteq	r1, r5, lsl #28
    2d08:	00000025 	andeq	r0, r0, r5, lsr #32
    2d0c:	30002f60 	andcc	r2, r0, r0, ror #30
    2d10:	30003184 	andcc	r3, r0, r4, lsl #3
    2d14:	000025f9 	strdeq	r2, [r0], -r9
    2d18:	00002516 	andeq	r2, r0, r6, lsl r5
    2d1c:	000e851e 	andeq	r8, lr, lr, lsl r5
    2d20:	017e0500 	cmneq	lr, r0, lsl #10
    2d24:	00000025 	andeq	r0, r0, r5, lsr #32
    2d28:	00002618 	andeq	r2, r0, r8, lsl r6
    2d2c:	00035f20 	andeq	r5, r3, r0, lsr #30
    2d30:	01810500 	orreq	r0, r1, r0, lsl #10
    2d34:	000006b3 	undefined instruction 0x000006b3
    2d38:	00002641 	andeq	r2, r0, r1, asr #12
    2d3c:	0002fc20 	andeq	pc, r2, r0, lsr #24
    2d40:	01840500 	orreq	r0, r4, r0, lsl #10
    2d44:	000006b9 	undefined instruction 0x000006b9
    2d48:	0000265f 	andeq	r2, r0, pc, asr r6
    2d4c:	000fba20 	andeq	fp, pc, r0, lsr #20
    2d50:	01860500 	orreq	r0, r6, r0, lsl #10
    2d54:	00000865 	andeq	r0, r0, r5, ror #16
    2d58:	00002688 	andeq	r2, r0, r8, lsl #13
    2d5c:	05007912 	streq	r7, [r0, #-2322]	; 0x912
    2d60:	00250187 	eoreq	r0, r5, r7, lsl #3
    2d64:	8d330000 	ldchi	0, cr0, [r3]
    2d68:	05000001 	streq	r0, [r0, #-1]
    2d6c:	006d0189 	rsbeq	r0, sp, r9, lsl #3
    2d70:	50010000 	andpl	r0, r1, r0
    2d74:	0008192b 	andeq	r1, r8, fp, lsr #18
    2d78:	00304000 	eorseq	r4, r0, r0
    2d7c:	00024030 	andeq	r4, r2, r0, lsr r0
    2d80:	01bc0500 	undefined instruction 0x01bc0500
    2d84:	000ebe2c 	andeq	fp, lr, ip, lsr #28
    2d88:	02582e00 	subseq	r2, r8, #0
    2d8c:	34240000 	strtcc	r0, [r4]
    2d90:	24000008 	strcs	r0, [r0], #-8
    2d94:	00000840 	andeq	r0, r0, r0, asr #16
    2d98:	00084c28 	andeq	r4, r8, r8, lsr #24
    2d9c:	0026b100 	eoreq	fp, r6, r0, lsl #2
    2da0:	08582800 	ldmdaeq	r8, {fp, sp}^
    2da4:	26cf0000 	strbcs	r0, [pc], r0
    2da8:	00000000 	andeq	r0, r0, r0
    2dac:	6e011d00 	cdpvs	13, 0, cr1, cr1, cr0, {0}
    2db0:	0500000c 	streq	r0, [r0, #-12]
    2db4:	25010124 	strcs	r0, [r1, #-292]	; 0x124
    2db8:	84000000 	strhi	r0, [r0]
    2dbc:	c0300031 	eorsgt	r0, r0, r1, lsr r0
    2dc0:	ed300032 	ldc	0, cr0, [r0, #-200]!	; 0xffffff38
    2dc4:	0e000026 	cdpeq	0, 0, cr0, cr0, cr6, {1}
    2dc8:	1e000026 	cdpne	0, 0, cr0, cr0, cr6, {1}
    2dcc:	000014b1 	undefined instruction 0x000014b1
    2dd0:	1a012405 	bne	4bdec <DISABLE_IRQ+0x4bd6c>
    2dd4:	19000026 	stmdbne	r0, {r1, r2, r5}
    2dd8:	1e000027 	cdpne	0, 0, cr0, cr0, cr7, {1}
    2ddc:	00000f9e 	muleq	r0, lr, pc
    2de0:	f6012505 	undefined instruction 0xf6012505
    2de4:	37000000 	strcc	r0, [r0, -r0]
    2de8:	1e000027 	cdpne	0, 0, cr0, cr0, cr7, {1}
    2dec:	00000c08 	andeq	r0, r0, r8, lsl #24
    2df0:	a7012605 	strge	r2, [r1, -r5, lsl #12]
    2df4:	55000006 	strpl	r0, [r0, #-6]
    2df8:	1e000027 	cdpne	0, 0, cr0, cr0, cr7, {1}
    2dfc:	00000e85 	andeq	r0, r0, r5, lsl #29
    2e00:	25012705 	strcs	r2, [r1, #-1797]	; 0x705
    2e04:	73000000 	movwvc	r0, #0
    2e08:	1f000027 	svcne	0x00000027
    2e0c:	05006469 	streq	r6, [r0, #-1129]	; 0x469
    2e10:	00370128 	eorseq	r0, r7, r8, lsr #2
    2e14:	27910000 	ldrcs	r0, [r1, r0]
    2e18:	c11e0000 	tstgt	lr, r0
    2e1c:	05000009 	streq	r0, [r0, #-9]
    2e20:	06a70129 	strteq	r0, [r7], r9, lsr #2
    2e24:	27b00000 	ldrcs	r0, [r0, r0]!
    2e28:	301e0000 	andscc	r0, lr, r0
    2e2c:	0500000d 	streq	r0, [r0, #-13]
    2e30:	0049012a 	subeq	r0, r9, sl, lsr #2
    2e34:	27cf0000 	strbcs	r0, [pc, r0]
    2e38:	1d1e0000 	ldcne	0, cr0, [lr]
    2e3c:	05000006 	streq	r0, [r0, #-6]
    2e40:	00f6012b 	rscseq	r0, r6, fp, lsr #2
    2e44:	28120000 	ldmdacs	r2, {}
    2e48:	6f1f0000 	svcvs	0x001f0000
    2e4c:	05007470 	streq	r7, [r0, #-1136]	; 0x470
    2e50:	0037012c 	eorseq	r0, r7, ip, lsr #2
    2e54:	28320000 	ldmdacs	r2!, {}
    2e58:	70210000 	eorvc	r0, r1, r0
    2e5c:	05007073 	streq	r7, [r0, #-115]	; 0x73
    2e60:	06a7012e 	strteq	r0, [r7], lr, lsr #2
    2e64:	285c0000 	ldmdacs	ip, {}^
    2e68:	65420000 	strbvs	r0, [r2]
    2e6c:	05007272 	streq	r7, [r0, #-626]	; 0x272
    2e70:	0025012f 	eoreq	r0, r5, pc, lsr #2
    2e74:	55010000 	strpl	r0, [r1]
    2e78:	00018d10 	andeq	r8, r1, r0, lsl sp
    2e7c:	01310500 	teqeq	r1, r0, lsl #10
    2e80:	0000006d 	andeq	r0, r0, sp, rrx
    2e84:	00095f30 	andeq	r5, r9, r0, lsr pc
    2e88:	00321000 	eorseq	r1, r2, r0
    2e8c:	00324430 	eorseq	r4, r2, r0, lsr r4
    2e90:	01450530 	cmpeq	r5, r0, lsr r5
    2e94:	000fb12c 	andeq	fp, pc, ip, lsr #2
    2e98:	0faa2c00 	svceq	0x00aa2c00
    2e9c:	a32c0000 	teqge	ip, #0
    2ea0:	0000000f 	andeq	r0, r0, pc
    2ea4:	1a010c00 	bne	45eac <DISABLE_IRQ+0x45e2c>
    2ea8:	0d000026 	stceq	0, cr0, [r0, #-152]	; 0xffffff68
    2eac:	000000f6 	strdeq	r0, [r0], -r6
    2eb0:	0e040b00 	vmlaeq.f64	d0, d4, d0
    2eb4:	2a000026 	bcs	2f54 <DISABLE_IRQ+0x2ed4>
    2eb8:	000f4601 	andeq	r4, pc, r1, lsl #12
    2ebc:	03180600 	tsteq	r8, #0
    2ec0:	0032c001 	eorseq	ip, r2, r1
    2ec4:	00344c30 	eorseq	r4, r4, r0, lsr ip
    2ec8:	00286f30 	eoreq	r6, r8, r0, lsr pc
    2ecc:	0026d100 	eoreq	sp, r6, r0, lsl #2
    2ed0:	72654200 	rsbvc	r4, r5, #0
    2ed4:	1b060072 	blne	1830a4 <DISABLE_IRQ+0x183024>
    2ed8:	00002503 	andeq	r2, r0, r3, lsl #10
    2edc:	67910200 	ldrvs	r0, [r1, r0, lsl #4]
    2ee0:	06006912 	undefined instruction 0x06006912
    2ee4:	0037031d 	eorseq	r0, r7, sp, lsl r3
    2ee8:	27100000 	ldrcs	r0, [r0, -r0]
    2eec:	0600000c 	streq	r0, [r0], -ip
    2ef0:	07d9031e 	bfieq	r0, lr, #6, #20
    2ef4:	2d200000 	stccs	0, cr0, [r0]
    2ef8:	0600000c 	streq	r0, [r0], -ip
    2efc:	07d9031f 	bfceq	r0, #6, #20
    2f00:	289a0000 	ldmcs	sl, {}
    2f04:	eb430000 	bl	10c2f0c <MEM_SIZE+0x8c2f0c>
    2f08:	d0000007 	andle	r0, r0, r7
    2f0c:	ec300032 	ldc	0, cr0, [r0], #-200	; 0xffffff38
    2f10:	06300032 	undefined instruction 0x06300032
    2f14:	268e0322 	strcs	r0, [lr], r2, lsr #6
    2f18:	ad2c0000 	stcge	0, cr0, [ip]
    2f1c:	2c00000c 	stccs	0, cr0, [r0], {12}
    2f20:	00000ca6 	andeq	r0, r0, r6, lsr #25
    2f24:	07eb3800 	strbeq	r3, [fp, r0, lsl #16]!
    2f28:	32ec0000 	rsccc	r0, ip, #0
    2f2c:	02703000 	rsbseq	r3, r0, #0
    2f30:	23060000 	movwcs	r0, #24576	; 0x6000
    2f34:	0026ad03 	eoreq	sl, r6, r3, lsl #26
    2f38:	0cad2c00 	stceq	12, cr2, [sp]
    2f3c:	a62c0000 	strtge	r0, [ip], -r0
    2f40:	0000000c 	andeq	r0, r0, ip
    2f44:	00099330 	andeq	r9, r9, r0, lsr r3
    2f48:	0033bc00 	eorseq	fp, r3, r0, lsl #24
    2f4c:	00340430 	eorseq	r0, r4, r0, lsr r4
    2f50:	03500630 	cmpeq	r0, #50331648	; 0x3000000
    2f54:	0033bc39 	eorseq	fp, r3, r9, lsr ip
    2f58:	00340430 	eorseq	r0, r4, r0, lsr r4
    2f5c:	09a12730 	stmibeq	r1!, {r4, r5, r8, r9, sl, sp}
    2f60:	91020000 	tstls	r2, r0
    2f64:	00000066 	andeq	r0, r0, r6, rrx
    2f68:	01f40136 	mvnseq	r0, r6, lsr r1
    2f6c:	b3050000 	movwlt	r0, #20480	; 0x5000
    2f70:	00002501 	andeq	r2, r0, r1, lsl #10
    2f74:	00344c00 	eorseq	r4, r4, r0, lsl #24
    2f78:	00353830 	eorseq	r3, r5, r0, lsr r8
    2f7c:	0028ad30 	eoreq	sl, r8, r0, lsr sp
    2f80:	00275200 	eoreq	r5, r7, r0, lsl #4
    2f84:	14b13500 	ldrtne	r3, [r1], #1280	; 0x500
    2f88:	b3050000 	movwlt	r0, #20480	; 0x5000
    2f8c:	0000261a 	andeq	r2, r0, sl, lsl r6
    2f90:	000028d8 	ldrdeq	r2, [r0], -r8
    2f94:	000f9e35 	andeq	r9, pc, r5, lsr lr
    2f98:	f6b30500 	undefined instruction 0xf6b30500
    2f9c:	01000000 	tsteq	r0, r0
    2fa0:	35000029 	strcc	r0, [r0, #-41]	; 0x29
    2fa4:	00000c08 	andeq	r0, r0, r8, lsl #24
    2fa8:	06a7b305 	strteq	fp, [r7], r5, lsl #6
    2fac:	291f0000 	ldmdbcs	pc, {}
    2fb0:	85350000 	ldrhi	r0, [r5]!
    2fb4:	0500000e 	streq	r0, [r0, #-14]
    2fb8:	000025b3 	undefined instruction 0x000025b3
    2fbc:	00293d00 	eoreq	r3, r9, r0, lsl #26
    2fc0:	73703c00 	cmnvc	r0, #0
    2fc4:	b5050070 	strlt	r0, [r5, #-112]	; 0x70
    2fc8:	000006a7 	andeq	r0, r0, r7, lsr #13
    2fcc:	0000295b 	andeq	r2, r0, fp, asr r9
    2fd0:	7272653d 	rsbsvc	r6, r2, #255852544	; 0xf400000
    2fd4:	25b60500 	ldrcs	r0, [r6, #1280]!	; 0x500
    2fd8:	01000000 	tsteq	r0, r0
    2fdc:	018d1957 	orreq	r1, sp, r7, asr r9
    2fe0:	b8050000 	stmdalt	r5, {}
    2fe4:	0000006d 	andeq	r0, r0, sp, rrx
    2fe8:	41013600 	tstmi	r1, r0, lsl #12
    2fec:	05000011 	streq	r0, [r0, #-17]
    2ff0:	0025012b 	eoreq	r0, r5, fp, lsr #2
    2ff4:	35380000 	ldrcc	r0, [r8]!
    2ff8:	36e03000 	strbtcc	r3, [r0], r0
    2ffc:	296e3000 	stmdbcs	lr!, {ip, sp}^
    3000:	27fe0000 	ldrbcs	r0, [lr, r0]!
    3004:	82350000 	eorshi	r0, r5, #0
    3008:	0500000e 	streq	r0, [r0, #-14]
    300c:	0000252b 	andeq	r2, r0, fp, lsr #10
    3010:	00298d00 	eoreq	r8, r9, r0, lsl #26
    3014:	06b13500 	ldrteq	r3, [r1], r0, lsl #10
    3018:	2b050000 	blcs	143020 <DISABLE_IRQ+0x142fa0>
    301c:	00000025 	andeq	r0, r0, r5, lsr #32
    3020:	000029cc 	andeq	r2, r0, ip, asr #19
    3024:	00035f3e 	andeq	r5, r3, lr, lsr pc
    3028:	b32e0500 	teqlt	lr, #0
    302c:	ea000006 	b	304c <DISABLE_IRQ+0x2fcc>
    3030:	3e000029 	cdpcc	0, 0, cr0, cr0, cr9, {1}
    3034:	00000fba 	undefined instruction 0x00000fba
    3038:	08653005 	stmdaeq	r5!, {r0, r2, ip, sp}^
    303c:	2a080000 	bcs	203044 <DISABLE_IRQ+0x202fc4>
    3040:	783c0000 	ldmdavc	ip!, {}
    3044:	25310500 	ldrcs	r0, [r1, #-1280]!	; 0x500
    3048:	31000000 	tstcc	r0, r0
    304c:	3c00002a 	stccc	0, cr0, [r0], {42}	; 0x2a
    3050:	32050079 	andcc	r0, r5, #121	; 0x79
    3054:	00000025 	andeq	r0, r0, r5, lsr #32
    3058:	00002a4f 	andeq	r2, r0, pc, asr #20
    305c:	000a523e 	andeq	r5, sl, lr, lsr r2
    3060:	25340500 	ldrcs	r0, [r4, #-1280]!	; 0x500
    3064:	6d000000 	stcvs	0, cr0, [r0]
    3068:	3e00002a 	cdpcc	0, 0, cr0, cr0, cr10, {1}
    306c:	00000a57 	andeq	r0, r0, r7, asr sl
    3070:	00253505 	eoreq	r3, r5, r5, lsl #10
    3074:	2a8b0000 	bcs	fe2c307c <rEINTPEND+0xa82c2fd4>
    3078:	ea190000 	b	643080 <DISABLE_IRQ+0x643000>
    307c:	0500000d 	streq	r0, [r0, #-13]
    3080:	0000253a 	andeq	r2, r0, sl, lsr r5
    3084:	018d3e00 	orreq	r3, sp, r0, lsl #28
    3088:	3c050000 	stccc	0, cr0, [r5], {0}
    308c:	0000006d 	andeq	r0, r0, sp, rrx
    3090:	00002aa9 	andeq	r2, r0, r9, lsr #21
    3094:	b5011d00 	strlt	r1, [r1, #-3328]	; 0xd00
    3098:	09000004 	stmdbeq	r0, {r2}
    309c:	25010157 	strcs	r0, [r1, #-343]	; 0x157
    30a0:	e0000000 	and	r0, r0, r0
    30a4:	74300036 	ldrtvc	r0, [r0], #-54	; 0x36
    30a8:	dd300037 	ldcle	0, cr0, [r0, #-220]!	; 0xffffff24
    30ac:	3900002a 	stmdbcc	r0, {r1, r3, r5}
    30b0:	1e000028 	cdpne	0, 0, cr0, cr0, cr8, {1}
    30b4:	0000035f 	andeq	r0, r0, pc, asr r3
    30b8:	b3015709 	movwlt	r5, #5897	; 0x1709
    30bc:	fc000006 	stc2	0, cr0, [r0], {6}
    30c0:	1000002a 	andne	r0, r0, sl, lsr #32
    30c4:	0000018d 	andeq	r0, r0, sp, lsl #3
    30c8:	6d015a09 	vstrvs	s10, [r1, #-36]	; 0xffffffdc
    30cc:	00000000 	andeq	r0, r0, r0
    30d0:	00047d44 	andeq	r7, r4, r4, asr #26
    30d4:	04160600 	ldreq	r0, [r6], #-1536	; 0x600
    30d8:	00377401 	eorseq	r7, r7, r1, lsl #8
    30dc:	00378430 	eorseq	r8, r7, r0, lsr r4
    30e0:	455d0130 	ldrbmi	r0, [sp, #-304]	; 0x130
    30e4:	00064d01 	andeq	r4, r6, r1, lsl #26
    30e8:	02bb0600 	adcseq	r0, fp, #0
    30ec:	00002501 	andeq	r2, r0, r1, lsl #10
    30f0:	00378400 	eorseq	r8, r7, r0, lsl #8
    30f4:	00379430 	eorseq	r9, r7, r0, lsr r4
    30f8:	755d0130 	ldrbvc	r0, [sp, #-304]	; 0x130
    30fc:	12000028 	andne	r0, r0, #40	; 0x28
    3100:	00727265 	rsbseq	r7, r2, r5, ror #4
    3104:	2502bd06 	strcs	fp, [r2, #-3334]	; 0xd06
    3108:	00000000 	andeq	r0, r0, r0
    310c:	10be012a 	adcsne	r0, lr, sl, lsr #2
    3110:	0e090000 	cdpeq	0, 0, cr0, cr9, cr0, {0}
    3114:	37940101 	ldrcc	r0, [r4, r1, lsl #2]
    3118:	39543000 	ldmdbcc	r4, {ip, sp}^
    311c:	2b1a3000 	blcs	68f124 <DISABLE_IRQ+0x68f0a4>
    3120:	291a0000 	ldmdbcs	sl, {}
    3124:	5f1e0000 	svcpl	0x001e0000
    3128:	09000003 	stmdbeq	r0, {r0, r1}
    312c:	06b3010e 	ldrteq	r0, [r3], lr, lsl #2
    3130:	2b450000 	blcs	1143138 <MEM_SIZE+0x943138>
    3134:	b61e0000 	ldrlt	r0, [lr], -r0
    3138:	09000010 	stmdbeq	r0, {r4}
    313c:	0037010e 	eorseq	r0, r7, lr, lsl #2
    3140:	2b9a0000 	blcs	fe683148 <rEINTPEND+0xa86830a0>
    3144:	651f0000 	ldrvs	r0, [pc, #0]	; 314c <DISABLE_IRQ+0x30cc>
    3148:	09007272 	stmdbeq	r0, {r1, r4, r5, r6, r9, ip, sp, lr}
    314c:	0813010e 	ldmdaeq	r3, {r1, r2, r3, r8}
    3150:	2bb80000 	blcs	fee03158 <rEINTPEND+0xa8e030b0>
    3154:	8d200000 	stchi	0, cr0, [r0]
    3158:	09000001 	stmdbeq	r0, {r0}
    315c:	006d0111 	rsbeq	r0, sp, r1, lsl r1
    3160:	2bd60000 	blcs	ff583168 <rEINTPEND+0xa95830c0>
    3164:	ae380000 	cdpge	0, 3, cr0, cr8, cr0, {0}
    3168:	28000009 	stmdacs	r0, {r0, r3}
    316c:	88300038 	ldmdahi	r0!, {r3, r4, r5}
    3170:	09000002 	stmdbeq	r0, {r1}
    3174:	28f40136 	ldmcs	r4!, {r1, r2, r4, r5, r8}^
    3178:	3d2c0000 	stccc	0, cr0, [ip]
    317c:	2e00000c 	cdpcs	0, 0, cr0, cr0, cr12, {0}
    3180:	000002b0 	undefined instruction 0x000002b0
    3184:	0009c924 	andeq	ip, r9, r4, lsr #18
    3188:	30000000 	andcc	r0, r0, r0
    318c:	000009d4 	ldrdeq	r0, [r0], -r4
    3190:	300038d8 	ldrdcc	r3, [r0], -r8
    3194:	30003918 	andcc	r3, r0, r8, lsl r9
    3198:	2c013b09 	stccs	11, cr3, [r1], {9}
    319c:	00000c5d 	andeq	r0, r0, sp, asr ip
    31a0:	0038d839 	eorseq	sp, r8, r9, lsr r8
    31a4:	00391830 	eorseq	r1, r9, r0, lsr r8
    31a8:	09ef2430 	stmibeq	pc!, {r4, r5, sl, sp}^
    31ac:	00000000 	andeq	r0, r0, r0
    31b0:	03c72900 	biceq	r2, r7, #0
    31b4:	09060000 	stmdbeq	r6, {}
    31b8:	39540104 	ldmdbcc	r4, {r2, r8}^
    31bc:	39803000 	stmibcc	r0, {ip, sp}
    31c0:	2c0a3000 	stccs	0, cr3, [sl], {0}
    31c4:	29430000 	stmdbcs	r3, {}^
    31c8:	65420000 	strbvs	r0, [r2]
    31cc:	06007272 	undefined instruction 0x06007272
    31d0:	0025040b 	eoreq	r0, r5, fp, lsl #8
    31d4:	91020000 	tstls	r2, r0
    31d8:	011d0077 	tsteq	sp, r7, ror r0
    31dc:	000005e0 	andeq	r0, r0, r0, ror #11
    31e0:	01025b06 	tsteq	r2, r6, lsl #22
    31e4:	00000078 	andeq	r0, r0, r8, ror r0
    31e8:	30003980 	andcc	r3, r0, r0, lsl #19
    31ec:	30003b04 	andcc	r3, r0, r4, lsl #22
    31f0:	00002c35 	andeq	r2, r0, r5, lsr ip
    31f4:	000029b2 	undefined instruction 0x000029b2
    31f8:	0009d81e 	andeq	sp, r9, lr, lsl r8
    31fc:	025b0600 	subseq	r0, fp, #0
    3200:	000007d9 	ldrdeq	r0, [r0], -r9
    3204:	00002c60 	andeq	r2, r0, r0, ror #24
    3208:	74706f1f 	ldrbtvc	r6, [r0], #-3871	; 0xf1f
    320c:	025c0600 	subseq	r0, ip, #0
    3210:	00000025 	andeq	r0, r0, r5, lsr #32
    3214:	00002c89 	andeq	r2, r0, r9, lsl #25
    3218:	0010d31e 	andseq	sp, r0, lr, lsl r3
    321c:	025d0600 	subseq	r0, sp, #0
    3220:	000000f6 	strdeq	r0, [r0], -r6
    3224:	00002cd3 	ldrdeq	r2, [r0], -r3
    3228:	0010811e 	andseq	r8, r0, lr, lsl r1
    322c:	025e0600 	subseq	r0, lr, #0
    3230:	00000813 	andeq	r0, r0, r3, lsl r8
    3234:	00002cf1 	strdeq	r2, [r0], -r1
    3238:	0001e720 	andeq	lr, r1, r0, lsr #14
    323c:	02600600 	rsbeq	r0, r0, #0
    3240:	000006cb 	andeq	r0, r0, fp, asr #13
    3244:	00002d0f 	andeq	r2, r0, pc, lsl #26
    3248:	39011d00 	stmdbcc	r1, {r8, sl, fp, ip}
    324c:	0600000d 	streq	r0, [r0], -sp
    3250:	78010204 	stmdavc	r1, {r2, r9}
    3254:	04000000 	streq	r0, [r0]
    3258:	e030003b 	eors	r0, r0, fp, lsr r0
    325c:	4330003b 	teqmi	r0, #59	; 0x3b
    3260:	f100002d 	undefined instruction 0xf100002d
    3264:	1e000029 	cdpne	0, 0, cr0, cr0, cr9, {1}
    3268:	000009d8 	ldrdeq	r0, [r0], -r8
    326c:	d9020406 	stmdble	r2, {r1, r2, sl}
    3270:	62000007 	andvs	r0, r0, #7
    3274:	1e00002d 	cdpne	0, 0, cr0, cr0, cr13, {1}
    3278:	00001081 	andeq	r1, r0, r1, lsl #1
    327c:	13020506 	movwne	r0, #9478	; 0x2506
    3280:	80000008 	andhi	r0, r0, r8
    3284:	0000002d 	andeq	r0, r0, sp, lsr #32
    3288:	11bf011d 	undefined instruction 0x11bf011d
    328c:	c3060000 	movwgt	r0, #24576	; 0x6000
    3290:	00250101 	eoreq	r0, r5, r1, lsl #2
    3294:	3be00000 	blcc	ff80329c <rEINTPEND+0xa98031f4>
    3298:	3c783000 	ldclcc	0, cr3, [r8]
    329c:	2d9e3000 	ldccs	0, cr3, [lr]
    32a0:	2a400000 	bcs	10032a8 <MEM_SIZE+0x8032a8>
    32a4:	d81e0000 	ldmdale	lr, {}
    32a8:	06000009 	streq	r0, [r0], -r9
    32ac:	07d901c3 	ldrbeq	r0, [r9, r3, asr #3]
    32b0:	2dc90000 	stclcs	0, cr0, [r9]
    32b4:	811e0000 	tsthi	lr, r0
    32b8:	06000010 	undefined instruction 0x06000010
    32bc:	081301c4 	ldmdaeq	r3, {r2, r6, r7, r8}
    32c0:	2dfd0000 	ldclcs	0, cr0, [sp]
    32c4:	16200000 	strtne	r0, [r0], -r0
    32c8:	06000011 	undefined instruction 0x06000011
    32cc:	002501c6 	eoreq	r0, r5, r6, asr #3
    32d0:	2e1b0000 	cdpcs	0, 1, cr0, cr11, cr0, {0}
    32d4:	1d000000 	stcne	0, cr0, [r0]
    32d8:	00089a01 	andeq	r9, r8, r1, lsl #20
    32dc:	01630600 	cmneq	r3, r0, lsl #12
    32e0:	00004901 	andeq	r4, r0, r1, lsl #18
    32e4:	003c7800 	eorseq	r7, ip, r0, lsl #16
    32e8:	003da830 	eorseq	sl, sp, r0, lsr r8
    32ec:	002e4430 	eoreq	r4, lr, r0, lsr r4
    32f0:	002a8f00 	eoreq	r8, sl, r0, lsl #30
    32f4:	09d81e00 	ldmibeq	r8, {r9, sl, fp, ip}^
    32f8:	63060000 	movwvs	r0, #24576	; 0x6000
    32fc:	0007d901 	andeq	sp, r7, r1, lsl #18
    3300:	002e6f00 	eoreq	r6, lr, r0, lsl #30
    3304:	10811e00 	addne	r1, r1, r0, lsl #28
    3308:	64060000 	strvs	r0, [r6]
    330c:	00081301 	andeq	r1, r8, r1, lsl #6
    3310:	002ecf00 	eoreq	ip, lr, r0, lsl #30
    3314:	08e72000 	stmiaeq	r7!, {sp}^
    3318:	66060000 	strvs	r0, [r6], -r0
    331c:	00004901 	andeq	r4, r0, r1, lsl #18
    3320:	002eed00 	eoreq	lr, lr, r0, lsl #26
    3324:	011d0000 	tsteq	sp, r0
    3328:	000005bc 	undefined instruction 0x000005bc
    332c:	01011806 	tsteq	r1, r6, lsl #16
    3330:	00000025 	andeq	r0, r0, r5, lsr #32
    3334:	30003da8 	andcc	r3, r0, r8, lsr #27
    3338:	30003eb8 	undefined instruction 0x30003eb8
    333c:	00002f16 	andeq	r2, r0, r6, lsl pc
    3340:	00002b18 	andeq	r2, r0, r8, lsl fp
    3344:	0009d81e 	andeq	sp, r9, lr, lsl r8
    3348:	01180600 	tsteq	r8, r0, lsl #12
    334c:	000007d9 	ldrdeq	r0, [r0], -r9
    3350:	00002f41 	andeq	r2, r0, r1, asr #30
    3354:	0008261e 	andeq	r2, r8, lr, lsl r6
    3358:	01190600 	tsteq	r9, r0, lsl #12
    335c:	00000813 	andeq	r0, r0, r3, lsl r8
    3360:	00002f96 	muleq	r0, r6, pc
    3364:	0010811e 	andseq	r8, r0, lr, lsl r1
    3368:	011a0600 	tsteq	sl, r0, lsl #12
    336c:	00000813 	andeq	r0, r0, r3, lsl r8
    3370:	00002fb4 	undefined instruction 0x00002fb4
    3374:	6e656c21 	cdpvs	12, 6, cr6, cr5, cr1, {1}
    3378:	011c0600 	tsteq	ip, r0, lsl #12
    337c:	00000025 	andeq	r0, r0, r5, lsr #32
    3380:	00002fd2 	ldrdeq	r2, [r0], -r2
    3384:	0008d130 	andeq	sp, r8, r0, lsr r1
    3388:	003e5400 	eorseq	r5, lr, r0, lsl #8
    338c:	003e8c30 	eorseq	r8, lr, r0, lsr ip
    3390:	01390630 	teqeq	r9, r0, lsr r6
    3394:	000cfe2c 	andeq	pc, ip, ip, lsr #28
    3398:	0cf52c00 	ldcleq	12, cr2, [r5]
    339c:	54390000 	ldrtpl	r0, [r9]
    33a0:	8c30003e 	ldchi	0, cr0, [r0], #-248	; 0xffffff08
    33a4:	2430003e 	ldrtcs	r0, [r0], #-62	; 0x3e
    33a8:	000008fc 	strdeq	r0, [r0], -ip
    33ac:	36000000 	strcc	r0, [r0], -r0
    33b0:	00098401 	andeq	r8, r9, r1, lsl #8
    33b4:	01cd0600 	biceq	r0, sp, r0, lsl #12
    33b8:	00000078 	andeq	r0, r0, r8, ror r0
    33bc:	30003eb8 	undefined instruction 0x30003eb8
    33c0:	30003fec 	andcc	r3, r0, ip, ror #31
    33c4:	0000301c 	andeq	r3, r0, ip, lsl r0
    33c8:	00002b69 	andeq	r2, r0, r9, ror #22
    33cc:	0009d835 	andeq	sp, r9, r5, lsr r8
    33d0:	d9cd0600 	stmible	sp, {r9, sl}^
    33d4:	3b000007 	blcc	33f8 <DISABLE_IRQ+0x3378>
    33d8:	35000030 	strcc	r0, [r0, #-48]	; 0x30
    33dc:	00001081 	andeq	r1, r0, r1, lsl #1
    33e0:	0813ce06 	ldmdaeq	r3, {r1, r2, r9, sl, fp, lr, pc}
    33e4:	30590000 	subscc	r0, r9, r0
    33e8:	fa400000 	blx	10033f0 <MEM_SIZE+0x8033f0>
    33ec:	48000009 	stmdami	r0, {r0, r3}
    33f0:	a430003f 	ldrtge	r0, [r0], #-63	; 0x3f
    33f4:	0630003f 	undefined instruction 0x0630003f
    33f8:	0a082cec 	beq	20e7b0 <DISABLE_IRQ+0x20e730>
    33fc:	00000000 	andeq	r0, r0, r0
    3400:	084a0136 	stmdaeq	sl, {r1, r2, r4, r5, r8}^
    3404:	69060000 	stmdbvs	r6, {}
    3408:	0007d901 	andeq	sp, r7, r1, lsl #18
    340c:	003fec00 	eorseq	lr, pc, r0, lsl #24
    3410:	00418c30 	subeq	r8, r1, r0, lsr ip
    3414:	00307730 	eorseq	r7, r0, r0, lsr r7
    3418:	002c8000 	eoreq	r8, ip, r0
    341c:	6c643a00 	stclvs	10, cr3, [r4]
    3420:	69060079 	stmdbvs	r6, {r0, r3, r4, r5, r6}
    3424:	00000049 	andeq	r0, r0, r9, asr #32
    3428:	00003096 	muleq	r0, r6, r0
    342c:	00118335 	andseq	r8, r1, r5, lsr r3
    3430:	496a0600 	stmdbmi	sl!, {r9, sl}^
    3434:	e0000000 	and	r0, r0, r0
    3438:	3a000030 	bcc	3500 <DISABLE_IRQ+0x3480>
    343c:	0074706f 	rsbseq	r7, r4, pc, rrx
    3440:	00256b06 	eoreq	r6, r5, r6, lsl #22
    3444:	30fe0000 	rscscc	r0, lr, r0
    3448:	25350000 	ldrcs	r0, [r5]!
    344c:	06000011 	undefined instruction 0x06000011
    3450:	0006cb6c 	andeq	ip, r6, ip, ror #22
    3454:	00315e00 	eorseq	r5, r1, r0, lsl #28
    3458:	10d33500 	sbcsne	r3, r3, r0, lsl #10
    345c:	6d060000 	stcvs	0, cr0, [r6]
    3460:	000000f6 	strdeq	r0, [r0], -r6
    3464:	00003187 	andeq	r3, r0, r7, lsl #3
    3468:	0003a535 	andeq	sl, r3, r5, lsr r5
    346c:	136e0600 	cmnne	lr, #0
    3470:	e2000008 	and	r0, r0, #8
    3474:	35000031 	strcc	r0, [r0, #-49]	; 0x31
    3478:	00001081 	andeq	r1, r0, r1, lsl #1
    347c:	08136f06 	ldmdaeq	r3, {r1, r2, r8, r9, sl, fp, sp, lr}
    3480:	32460000 	subcc	r0, r6, #0
    3484:	d8370000 	ldmdale	r7!, {}
    3488:	06000009 	streq	r0, [r0], -r9
    348c:	0007d971 	andeq	sp, r7, r1, ror r9
    3490:	3c580100 	ldfcce	f0, [r8], {0}
    3494:	006e656c 	rsbeq	r6, lr, ip, ror #10
    3498:	00257306 	eoreq	r7, r5, r6, lsl #6
    349c:	32650000 	rsbcc	r0, r5, #0
    34a0:	15460000 	strbne	r0, [r6]
    34a4:	7000000a 	andvc	r0, r0, sl
    34a8:	d8300040 	ldmdale	r0!, {r6}
    34ac:	06000002 	streq	r0, [r0], -r2
    34b0:	002c2a94 	mlaeq	ip, r4, sl, r2
    34b4:	02f82e00 	rscseq	r2, r8, #0
    34b8:	27240000 	strcs	r0, [r4, -r0]!
    34bc:	0000000a 	andeq	r0, r0, sl
    34c0:	08a54100 	stmiaeq	r5!, {r8, lr}
    34c4:	40d80000 	sbcsmi	r0, r8, r0
    34c8:	40fc3000 	rscsmi	r3, ip, r0
    34cc:	a2063000 	andge	r3, r6, #0
    34d0:	00002c52 	andeq	r2, r0, r2, asr ip
    34d4:	000d242c 	andeq	r2, sp, ip, lsr #8
    34d8:	40d83900 	sbcsmi	r3, r8, r0, lsl #18
    34dc:	40fc3000 	rscsmi	r3, ip, r0
    34e0:	c4243000 	strtgt	r3, [r4]
    34e4:	00000008 	andeq	r0, r0, r8
    34e8:	08d14000 	ldmeq	r1, {lr}^
    34ec:	41080000 	tstmi	r8, r0
    34f0:	41203000 	teqmi	r0, r0
    34f4:	a4063000 	strge	r3, [r6]
    34f8:	000cfe2c 	andeq	pc, ip, ip, lsr #28
    34fc:	0cf52600 	ldcleq	6, cr2, [r5]
    3500:	328e0000 	addcc	r0, lr, #0
    3504:	08390000 	ldmdaeq	r9!, {}
    3508:	20300041 	eorscs	r0, r0, r1, asr #32
    350c:	24300041 	ldrtcs	r0, [r0], #-65	; 0x41
    3510:	000008fc 	strdeq	r0, [r0], -ip
    3514:	29000000 	stmdbcs	r0, {}
    3518:	00000c1c 	andeq	r0, r0, ip, lsl ip
    351c:	01042a06 	tsteq	r4, r6, lsl #20
    3520:	3000418c 	andcc	r4, r0, ip, lsl #3
    3524:	30004254 	andcc	r4, r0, r4, asr r2
    3528:	000032ac 	andeq	r3, r0, ip, lsr #5
    352c:	00002cfd 	strdeq	r2, [r0], -sp
    3530:	000f9e1e 	andeq	r9, pc, lr, lsl lr
    3534:	042a0600 	strteq	r0, [sl], #-1536	; 0x600
    3538:	000000f6 	strdeq	r0, [r0], -r6
    353c:	000032d7 	ldrdeq	r3, [r0], -r7
    3540:	72726542 	rsbsvc	r6, r2, #276824064	; 0x10800000
    3544:	042c0600 	strteq	r0, [ip], #-1536	; 0x600
    3548:	00000025 	andeq	r0, r0, r5, lsr #32
    354c:	335f9102 	cmpcc	pc, #-2147483648	; 0x80000000
    3550:	000009d8 	ldrdeq	r0, [r0], -r8
    3554:	d9042d06 	stmdble	r4, {r1, r2, r8, sl, fp, sp}
    3558:	01000007 	tsteq	r0, r7
    355c:	0a19335a 	beq	6502cc <DISABLE_IRQ+0x65024c>
    3560:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
    3564:	0007d904 	andeq	sp, r7, r4, lsl #18
    3568:	20590100 	subscs	r0, r9, r0, lsl #2
    356c:	000001e7 	andeq	r0, r0, r7, ror #3
    3570:	cb042f06 	blgt	10f190 <DISABLE_IRQ+0x10f110>
    3574:	ea000006 	b	3594 <DISABLE_IRQ+0x3514>
    3578:	10000032 	andne	r0, r0, r2, lsr r0
    357c:	00001307 	andeq	r1, r0, r7, lsl #6
    3580:	1b043006 	blne	10f5a0 <DISABLE_IRQ+0x10f520>
    3584:	10000010 	andne	r0, r0, r0, lsl r0
    3588:	00001308 	andeq	r1, r0, r8, lsl #6
    358c:	37043106 	strcc	r3, [r4, -r6, lsl #2]
    3590:	00000000 	andeq	r0, r0, r0
    3594:	0f780136 	svceq	0x00780136
    3598:	9b090000 	blls	2435a0 <DISABLE_IRQ+0x243520>
    359c:	0006b301 	andeq	fp, r6, r1, lsl #6
    35a0:	00425400 	subeq	r5, r2, r0, lsl #8
    35a4:	0043b430 	subeq	fp, r3, r0, lsr r4
    35a8:	00330830 	eorseq	r0, r3, r0, lsr r8
    35ac:	002d6d00 	eoreq	r6, sp, r0, lsl #26
    35b0:	035f3500 	cmpeq	pc, #0
    35b4:	9b090000 	blls	2435bc <DISABLE_IRQ+0x24353c>
    35b8:	000006b3 	undefined instruction 0x000006b3
    35bc:	00003333 	andeq	r3, r0, r3, lsr r3
    35c0:	74706f3a 	ldrbtvc	r6, [r0], #-3898	; 0xf3a
    35c4:	259b0900 	ldrcs	r0, [fp, #2304]	; 0x900
    35c8:	88000000 	stmdahi	r0, {}
    35cc:	3a000033 	bcc	36a0 <DISABLE_IRQ+0x3620>
    35d0:	00727265 	rsbseq	r7, r2, r5, ror #4
    35d4:	08139b09 	ldmdaeq	r3, {r0, r3, r8, r9, fp, ip, pc}
    35d8:	33d20000 	bicscc	r0, r2, #0
    35dc:	74190000 	ldrvc	r0, [r9]
    35e0:	0900000e 	stmdbeq	r0, {r1, r2, r3}
    35e4:	0000789d 	muleq	r0, sp, r8
    35e8:	12b41900 	adcsne	r1, r4, #0
    35ec:	9e090000 	cdpls	0, 0, cr0, cr9, cr0, {0}
    35f0:	000006b3 	undefined instruction 0x000006b3
    35f4:	00018d3e 	andeq	r8, r1, lr, lsr sp
    35f8:	6da00900 	stcvs	9, cr0, [r0]
    35fc:	f0000000 	undefined instruction 0xf0000000
    3600:	00000033 	andeq	r0, r0, r3, lsr r0
    3604:	0d84011d 	stfeqs	f0, [r4, #116]	; 0x74
    3608:	60040000 	andvs	r0, r4, r0
    360c:	00250102 	eoreq	r0, r5, r2, lsl #2
    3610:	43b40000 	undefined instruction 0x43b40000
    3614:	44d43000 	ldrbmi	r3, [r4]
    3618:	340e3000 	strcc	r3, [lr]
    361c:	2ddb0000 	ldclcs	0, cr0, [fp]
    3620:	5f1e0000 	svcpl	0x001e0000
    3624:	04000003 	streq	r0, [r0], #-3
    3628:	06b30260 	ldrteq	r0, [r3], r0, ror #4
    362c:	342d0000 	strtcc	r0, [sp]
    3630:	6d1f0000 	ldcvs	0, cr0, [pc]
    3634:	04006773 	streq	r6, [r0], #-1907	; 0x773
    3638:	00f60260 	rscseq	r0, r6, r0, ror #4
    363c:	344b0000 	strbcc	r0, [fp]
    3640:	6f1f0000 	svcvs	0x001f0000
    3644:	04007470 	streq	r7, [r0], #-1136	; 0x470
    3648:	00250260 	eoreq	r0, r5, r0, ror #4
    364c:	34690000 	strbtcc	r0, [r9]
    3650:	70210000 	eorvc	r0, r1, r0
    3654:	62040071 	andvs	r0, r4, #113	; 0x71
    3658:	000f8a02 	andeq	r8, pc, r2, lsl #20
    365c:	00349d00 	eorseq	r9, r4, r0, lsl #26
    3660:	018d2000 	orreq	r2, sp, r0
    3664:	64040000 	strvs	r0, [r4]
    3668:	00006d02 	andeq	r6, r0, r2, lsl #26
    366c:	0034c600 	eorseq	ip, r4, r0, lsl #12
    3670:	011d0000 	tsteq	sp, r0
    3674:	00000519 	andeq	r0, r0, r9, lsl r5
    3678:	01020d04 	tsteq	r2, r4, lsl #26
    367c:	00000025 	andeq	r0, r0, r5, lsr #32
    3680:	300044d4 	ldrdcc	r4, [r0], -r4
    3684:	30004598 	mulcc	r0, r8, r5
    3688:	000034e4 	andeq	r3, r0, r4, ror #9
    368c:	00002e39 	andeq	r2, r0, r9, lsr lr
    3690:	00035f1e 	andeq	r5, r3, lr, lsl pc
    3694:	020d0400 	andeq	r0, sp, #0
    3698:	000006b3 	undefined instruction 0x000006b3
    369c:	0000350f 	andeq	r3, r0, pc, lsl #10
    36a0:	67736d1f 	undefined instruction 0x67736d1f
    36a4:	020d0400 	andeq	r0, sp, #0
    36a8:	000000f6 	strdeq	r0, [r0], -r6
    36ac:	0000352d 	andeq	r3, r0, sp, lsr #10
    36b0:	00717021 	rsbseq	r7, r1, r1, lsr #32
    36b4:	8a020f04 	bhi	872cc <DISABLE_IRQ+0x8724c>
    36b8:	4b00000f 	blmi	36fc <DISABLE_IRQ+0x367c>
    36bc:	20000035 	andcs	r0, r0, r5, lsr r0
    36c0:	0000018d 	andeq	r0, r0, sp, lsl #3
    36c4:	6d021104 	stfvss	f1, [r2, #-16]
    36c8:	69000000 	stmdbvs	r0, {}
    36cc:	00000035 	andeq	r0, r0, r5, lsr r0
    36d0:	0928011d 	stmdbeq	r8!, {r0, r2, r3, r4, r8}
    36d4:	d0040000 	andle	r0, r4, r0
    36d8:	00250101 	eoreq	r0, r5, r1, lsl #2
    36dc:	45980000 	ldrmi	r0, [r8]
    36e0:	46583000 	ldrbmi	r3, [r8], -r0
    36e4:	35873000 	strcc	r3, [r7]
    36e8:	2e970000 	cdpcs	0, 9, cr0, cr7, cr0, {0}
    36ec:	5f1e0000 	svcpl	0x001e0000
    36f0:	04000003 	streq	r0, [r0], #-3
    36f4:	06b301d0 	ssateq	r0, #20, r0, asr #3
    36f8:	35b20000 	ldrcc	r0, [r2]!
    36fc:	6d1f0000 	ldcvs	0, cr0, [pc]
    3700:	04006773 	streq	r6, [r0], #-1907	; 0x773
    3704:	00f601d0 	ldrsbteq	r0, [r6], #16
    3708:	35d00000 	ldrbcc	r0, [r0]
    370c:	70210000 	eorvc	r0, r1, r0
    3710:	d2040071 	andle	r0, r4, #113	; 0x71
    3714:	000f8a01 	andeq	r8, pc, r1, lsl #20
    3718:	0035ee00 	eorseq	lr, r5, r0, lsl #28
    371c:	018d2000 	orreq	r2, sp, r0
    3720:	d4040000 	strle	r0, [r4]
    3724:	00006d01 	andeq	r6, r0, r1, lsl #26
    3728:	00360c00 	eorseq	r0, r6, r0, lsl #24
    372c:	011d0000 	tsteq	sp, r0
    3730:	0000033e 	andeq	r0, r0, lr, lsr r3
    3734:	01017b04 	tsteq	r1, r4, lsl #22
    3738:	000000f6 	strdeq	r0, [r0], -r6
    373c:	30004658 	andcc	r4, r0, r8, asr r6
    3740:	30004840 	andcc	r4, r0, r0, asr #16
    3744:	0000362a 	andeq	r3, r0, sl, lsr #12
    3748:	00002f5f 	andeq	r2, r0, pc, asr pc
    374c:	00035f1e 	andeq	r5, r3, lr, lsl pc
    3750:	017b0400 	cmneq	fp, r0, lsl #8
    3754:	000006b3 	undefined instruction 0x000006b3
    3758:	00003649 	andeq	r3, r0, r9, asr #12
    375c:	0010b61e 	andseq	fp, r0, lr, lsl r6
    3760:	017b0400 	cmneq	fp, r0, lsl #8
    3764:	00000037 	andeq	r0, r0, r7, lsr r0
    3768:	0000369e 	muleq	r0, lr, r6
    376c:	7272651f 	rsbsvc	r6, r2, #130023424	; 0x7c00000
    3770:	017b0400 	cmneq	fp, r0, lsl #8
    3774:	00000813 	andeq	r0, r0, r3, lsl r8
    3778:	000036c7 	andeq	r3, r0, r7, asr #13
    377c:	67736d21 	ldrbvs	r6, [r3, -r1, lsr #26]!
    3780:	017d0400 	cmneq	sp, r0, lsl #8
    3784:	000000f6 	strdeq	r0, [r0], -r6
    3788:	000036e5 	andeq	r3, r0, r5, ror #13
    378c:	00717021 	rsbseq	r7, r1, r1, lsr #32
    3790:	8a017e04 	bhi	62fa8 <DISABLE_IRQ+0x62f28>
    3794:	f800000f 	undefined instruction 0xf800000f
    3798:	20000036 	andcs	r0, r0, r6, lsr r0
    379c:	0000018d 	andeq	r0, r0, sp, lsl #3
    37a0:	6d018004 	stcvs	0, cr8, [r1, #-16]
    37a4:	16000000 	strne	r0, [r0], -r0
    37a8:	38000037 	stmdacc	r0, {r0, r1, r2, r4, r5}
    37ac:	000009ae 	andeq	r0, r0, lr, lsr #19
    37b0:	30004720 	andcc	r4, r0, r0, lsr #14
    37b4:	00000318 	andeq	r0, r0, r8, lsl r3
    37b8:	3901a904 	stmdbcc	r1, {r2, r8, fp, sp, pc}
    37bc:	2c00002f 	stccs	0, cr0, [r0], {47}	; 0x2f
    37c0:	00000c3d 	andeq	r0, r0, sp, lsr ip
    37c4:	0003382e 	andeq	r3, r3, lr, lsr #16
    37c8:	09c92400 	stmibeq	r9, {sl, sp}^
    37cc:	00000000 	andeq	r0, r0, r0
    37d0:	0009d430 	andeq	sp, r9, r0, lsr r4
    37d4:	0047d800 	subeq	sp, r7, r0, lsl #16
    37d8:	00481830 	subeq	r1, r8, r0, lsr r8
    37dc:	01ae0430 	undefined instruction 0x01ae0430
    37e0:	000c5d2c 	andeq	r5, ip, ip, lsr #26
    37e4:	47d83900 	ldrbmi	r3, [r8, r0, lsl #18]
    37e8:	48183000 	ldmdami	r8, {ip, sp}
    37ec:	ef243000 	svc	0x00243000
    37f0:	00000009 	andeq	r0, r0, r9
    37f4:	01360000 	teqeq	r6, r0
    37f8:	00001006 	andeq	r1, r0, r6
    37fc:	b301cc04 	movwlt	ip, #7172	; 0x1c04
    3800:	40000006 	andmi	r0, r0, r6
    3804:	cc300048 	ldcgt	0, cr0, [r0], #-288	; 0xfffffee0
    3808:	34300049 	ldrtcc	r0, [r0], #-73	; 0x49
    380c:	dd000037 	stcle	0, cr0, [r0, #-220]	; 0xffffff24
    3810:	3500002f 	strcc	r0, [r0, #-47]	; 0x2f
    3814:	0000035f 	andeq	r0, r0, pc, asr r3
    3818:	06b3cc04 	ldrteq	ip, [r3], r4, lsl #24
    381c:	375f0000 	ldrbcc	r0, [pc, -r0]
    3820:	6f3a0000 	svcvs	0x003a0000
    3824:	04007470 	streq	r7, [r0], #-1136	; 0x470
    3828:	000025cc 	andeq	r2, r0, ip, asr #11
    382c:	0037b400 	eorseq	fp, r7, r0, lsl #8
    3830:	72653a00 	rsbvc	r3, r5, #0
    3834:	cc040072 	stcgt	0, cr0, [r4], {114}	; 0x72
    3838:	00000813 	andeq	r0, r0, r3, lsl r8
    383c:	000037fe 	strdeq	r3, [r0], -lr
    3840:	000e7419 	andeq	r7, lr, r9, lsl r4
    3844:	78ce0400 	stmiavc	lr, {sl}^
    3848:	19000000 	stmdbne	r0, {}
    384c:	000012b4 	undefined instruction 0x000012b4
    3850:	06b3cf04 	ldrteq	ip, [r3], r4, lsl #30
    3854:	703c0000 	eorsvc	r0, ip, r0
    3858:	d0040071 	andle	r0, r4, r1, ror r0
    385c:	00000f8a 	andeq	r0, r0, sl, lsl #31
    3860:	0000381c 	andeq	r3, r0, ip, lsl r8
    3864:	00018d3e 	andeq	r8, r1, lr, lsr sp
    3868:	6dd20400 	cfldrdvs	mvd0, [r2]
    386c:	3a000000 	bcc	3874 <DISABLE_IRQ+0x37f4>
    3870:	00000038 	andeq	r0, r0, r8, lsr r0
    3874:	0798011d 	undefined instruction 0x0798011d
    3878:	0d0a0000 	stceq	0, cr0, [sl]
    387c:	00250102 	eoreq	r0, r5, r2, lsl #2
    3880:	49cc0000 	stmibmi	ip, {}^
    3884:	4b803000 	blmi	fe00f88c <rEINTPEND+0xa800f7e4>
    3888:	38583000 	ldmdacc	r8, {ip, sp}^
    388c:	30620000 	rsbcc	r0, r2, r0
    3890:	5f1e0000 	svcpl	0x001e0000
    3894:	0a000003 	beq	38a8 <DISABLE_IRQ+0x3828>
    3898:	06b3020d 	ldrteq	r0, [r3], sp, lsl #4
    389c:	38770000 	ldmdacc	r7!, {}^
    38a0:	70210000 	eorvc	r0, r1, r0
    38a4:	0a007069 	beq	1fa50 <DISABLE_IRQ+0x1f9d0>
    38a8:	0025020f 	eoreq	r0, r5, pc, lsl #4
    38ac:	38950000 	ldmcc	r5, {}
    38b0:	85200000 	strhi	r0, [r0]!
    38b4:	0a00000e 	beq	38f4 <DISABLE_IRQ+0x3874>
    38b8:	00250210 	eoreq	r0, r5, r0, lsl r2
    38bc:	38b30000 	ldmcc	r3!, {}
    38c0:	8d200000 	stchi	0, cr0, [r0]
    38c4:	0a000001 	beq	38d0 <DISABLE_IRQ+0x3850>
    38c8:	006d0212 	rsbeq	r0, sp, r2, lsl r2
    38cc:	38dc0000 	ldmcc	ip, {}^
    38d0:	342b0000 	strtcc	r0, [fp]
    38d4:	c800000a 	stmdagt	r0, {r1, r3}
    38d8:	5830004a 	ldmdapl	r0!, {r1, r3, r6}
    38dc:	0a000003 	beq	38f0 <DISABLE_IRQ+0x3870>
    38e0:	4e2c022a 	cdpmi	2, 2, cr0, cr12, cr10, {1}
    38e4:	2c00000a 	stccs	0, cr0, [r0], {10}
    38e8:	00000a42 	andeq	r0, r0, r2, asr #20
    38ec:	0003702e 	andeq	r7, r3, lr, lsr #32
    38f0:	0a5a2400 	beq	168c8f8 <MEM_SIZE+0xe8c8f8>
    38f4:	00000000 	andeq	r0, r0, r0
    38f8:	87012a00 	strhi	r2, [r1, -r0, lsl #20]
    38fc:	0a00000c 	beq	3934 <DISABLE_IRQ+0x38b4>
    3900:	80010183 	andhi	r0, r1, r3, lsl #3
    3904:	f830004b 	undefined instruction 0xf830004b
    3908:	fa30004e 	blx	c03a48 <MEM_SIZE+0x403a48>
    390c:	59000038 	stmdbpl	r0, {r3, r4, r5}
    3910:	1e000031 	mcrne	0, 0, r0, cr0, cr1, {1}
    3914:	0000035f 	andeq	r0, r0, pc, asr r3
    3918:	b301830a 	movwlt	r8, #4874	; 0x130a
    391c:	25000006 	strcs	r0, [r0, #-6]
    3920:	1e000039 	mcrne	0, 0, r0, cr0, cr9, {1}
    3924:	000010b6 	strheq	r1, [r0], -r6
    3928:	3701830a 	strcc	r8, [r1, -sl, lsl #6]
    392c:	7a000000 	bvc	3934 <DISABLE_IRQ+0x38b4>
    3930:	1f000039 	svcne	0x00000039
    3934:	00727265 	rsbseq	r7, r2, r5, ror #4
    3938:	1301830a 	movwne	r8, #4874	; 0x130a
    393c:	98000008 	stmdals	r0, {r3}
    3940:	21000039 	tstcs	r0, r9, lsr r0
    3944:	00706970 	rsbseq	r6, r0, r0, ror r9
    3948:	2501850a 	strcs	r8, [r1, #-1290]	; 0x50a
    394c:	b6000000 	strlt	r0, [r0], -r0
    3950:	10000039 	andne	r0, r0, r9, lsr r0
    3954:	00000fd5 	ldrdeq	r0, [r0], -r5
    3958:	2501860a 	strcs	r8, [r1, #-1546]	; 0x60a
    395c:	12000000 	andne	r0, r0, #0
    3960:	00796472 	rsbseq	r6, r9, r2, ror r4
    3964:	7801870a 	stmdavc	r1, {r1, r3, r8, r9, sl, pc}
    3968:	20000000 	andcs	r0, r0, r0
    396c:	00000fba 	undefined instruction 0x00000fba
    3970:	6501880a 	strvs	r8, [r1, #-2058]	; 0x80a
    3974:	ea000008 	b	399c <DISABLE_IRQ+0x391c>
    3978:	20000039 	andcs	r0, r0, r9, lsr r0
    397c:	00000a36 	andeq	r0, r0, r6, lsr sl
    3980:	b301890a 	movwlt	r8, #6410	; 0x190a
    3984:	08000006 	stmdaeq	r0, {r1, r2}
    3988:	1200003a 	andne	r0, r0, #58	; 0x3a
    398c:	8a0a0079 	bhi	283b78 <DISABLE_IRQ+0x283af8>
    3990:	00002501 	andeq	r2, r0, r1, lsl #10
    3994:	018d2000 	orreq	r2, sp, r0
    3998:	8c0a0000 	stchi	0, cr0, [sl], {0}
    399c:	00006d01 	andeq	r6, r0, r1, lsl #26
    39a0:	003a2600 	eorseq	r2, sl, r0, lsl #12
    39a4:	09ae3800 	stmibeq	lr!, {fp, ip, sp}
    39a8:	4d040000 	stcmi	0, cr0, [r4]
    39ac:	03883000 	orreq	r3, r8, #0
    39b0:	e60a0000 	str	r0, [sl], -r0
    39b4:	00313301 	eorseq	r3, r1, r1, lsl #6
    39b8:	0c3d2c00 	ldceq	12, cr2, [sp]
    39bc:	a82e0000 	stmdage	lr!, {}
    39c0:	24000003 	strcs	r0, [r0], #-3
    39c4:	000009c9 	andeq	r0, r0, r9, asr #19
    39c8:	d4300000 	ldrtle	r0, [r0]
    39cc:	8c000009 	stchi	0, cr0, [r0], {9}
    39d0:	cc30004d 	ldcgt	0, cr0, [r0], #-308	; 0xfffffecc
    39d4:	0a30004d 	beq	c03b10 <MEM_SIZE+0x403b10>
    39d8:	5d2c01eb 	stfpls	f0, [ip, #-940]!	; 0xfffffc54
    39dc:	3900000c 	stmdbcc	r0, {r2, r3}
    39e0:	30004d8c 	andcc	r4, r0, ip, lsl #27
    39e4:	30004dcc 	andcc	r4, r0, ip, asr #27
    39e8:	0009ef24 	andeq	lr, r9, r4, lsr #30
    39ec:	00000000 	andeq	r0, r0, r0
    39f0:	02400136 	subeq	r0, r0, #-2147483635	; 0x8000000d
    39f4:	fa0a0000 	blx	2839fc <DISABLE_IRQ+0x28397c>
    39f8:	0006b301 	andeq	fp, r6, r1, lsl #6
    39fc:	004ef800 	subeq	pc, lr, r0, lsl #16
    3a00:	00513430 	subseq	r3, r1, r0, lsr r4
    3a04:	003a6530 	eorseq	r6, sl, r0, lsr r5
    3a08:	00321a00 	eorseq	r1, r2, r0, lsl #20
    3a0c:	035f3500 	cmpeq	pc, #0
    3a10:	fa0a0000 	blx	283a18 <DISABLE_IRQ+0x283998>
    3a14:	000006b3 	undefined instruction 0x000006b3
    3a18:	00003a90 	muleq	r0, r0, sl
    3a1c:	74706f3a 	ldrbtvc	r6, [r0], #-3898	; 0xf3a
    3a20:	25fa0a00 	ldrbcs	r0, [sl, #2560]!	; 0xa00
    3a24:	b9000000 	stmdblt	r0, {}
    3a28:	3a00003a 	bcc	3b18 <DISABLE_IRQ+0x3a98>
    3a2c:	00727265 	rsbseq	r7, r2, r5, ror #4
    3a30:	0813fa0a 	ldmdaeq	r3, {r1, r3, r9, fp, ip, sp, lr, pc}
    3a34:	3af80000 	bcc	ffe03a3c <rEINTPEND+0xa9e03994>
    3a38:	74190000 	ldrvc	r0, [r9]
    3a3c:	0a00000e 	beq	3a7c <DISABLE_IRQ+0x39fc>
    3a40:	000078fc 	strdeq	r7, [r0], -ip
    3a44:	12b41900 	adcsne	r1, r4, #0
    3a48:	fd0a0000 	stc2	0, cr0, [sl]
    3a4c:	000006b3 	undefined instruction 0x000006b3
    3a50:	7069703f 	rsbvc	r7, r9, pc, lsr r0
    3a54:	25fe0a00 	ldrbcs	r0, [lr, #2560]!	; 0xa00
    3a58:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    3a5c:	00000e85 	andeq	r0, r0, r5, lsl #29
    3a60:	0025ff0a 	eoreq	pc, r5, sl, lsl #30
    3a64:	3b160000 	blcc	583a6c <DISABLE_IRQ+0x5839ec>
    3a68:	ba200000 	blt	803a70 <MEM_SIZE+0x3a70>
    3a6c:	0a00000f 	beq	3ab0 <DISABLE_IRQ+0x3a30>
    3a70:	08650100 	stmdaeq	r5!, {r8}^
    3a74:	3b3f0000 	blcc	fc3a7c <MEM_SIZE+0x7c3a7c>
    3a78:	8d200000 	stchi	0, cr0, [r0]
    3a7c:	0a000001 	beq	3a88 <DISABLE_IRQ+0x3a08>
    3a80:	006d0102 	rsbeq	r0, sp, r2, lsl #2
    3a84:	3b680000 	blcc	1a03a8c <MEM_SIZE+0x1203a8c>
    3a88:	342b0000 	strtcc	r0, [fp]
    3a8c:	8400000a 	strhi	r0, [r0], #-10
    3a90:	c8300050 	ldmdagt	r0!, {r4, r6}
    3a94:	0a000003 	beq	3aa8 <DISABLE_IRQ+0x3a28>
    3a98:	4e2c013b 	mcrmi	1, 1, r0, cr12, cr11, {1}
    3a9c:	2c00000a 	stccs	0, cr0, [r0], {10}
    3aa0:	00000a42 	andeq	r0, r0, r2, asr #20
    3aa4:	0003e02e 	andeq	lr, r3, lr, lsr #32
    3aa8:	0a5a2400 	beq	168cab0 <MEM_SIZE+0xe8cab0>
    3aac:	00000000 	andeq	r0, r0, r0
    3ab0:	0e011d00 	cdpeq	13, 0, cr1, cr1, cr0, {0}
    3ab4:	0b000008 	bleq	3adc <DISABLE_IRQ+0x3a5c>
    3ab8:	2501019f 	strcs	r0, [r1, #-415]	; 0x19f
    3abc:	34000000 	strcc	r0, [r0]
    3ac0:	04300051 	ldrteq	r0, [r0], #-81	; 0x51
    3ac4:	86300052 	undefined instruction 0x86300052
    3ac8:	7900003b 	stmdbvc	r0, {r0, r1, r3, r4, r5}
    3acc:	1e000032 	mcrne	0, 0, r0, cr0, cr2, {1}
    3ad0:	0000035f 	andeq	r0, r0, pc, asr r3
    3ad4:	b3019f0b 	movwlt	r9, #7947	; 0x1f0b
    3ad8:	a5000006 	strge	r0, [r0, #-6]
    3adc:	1f00003b 	svcne	0x0000003b
    3ae0:	0067736d 	rsbeq	r7, r7, sp, ror #6
    3ae4:	f6019f0b 	undefined instruction 0xf6019f0b
    3ae8:	c3000000 	movwgt	r0, #0
    3aec:	1f00003b 	svcne	0x0000003b
    3af0:	0074706f 	rsbseq	r7, r4, pc, rrx
    3af4:	25019f0b 	strcs	r9, [r1, #-3851]	; 0xf0b
    3af8:	0d000000 	stceq	0, cr0, [r0]
    3afc:	2000003c 	andcs	r0, r0, ip, lsr r0
    3b00:	0000018d 	andeq	r0, r0, sp, lsl #3
    3b04:	6d01a20b 	sfmvs	f2, 1, [r1, #-44]	; (stcvs 2, cr10, [r1, #-44])	; 0xffffffd4
    3b08:	41000000 	tstmi	r0, r0
    3b0c:	0000003c 	andeq	r0, r0, ip, lsr r0
    3b10:	1249011d 	subne	r0, r9, #1073741831	; 0x40000007
    3b14:	5b0b0000 	blpl	2c3b1c <DISABLE_IRQ+0x2c3a9c>
    3b18:	00250101 	eoreq	r0, r5, r1, lsl #2
    3b1c:	52040000 	andpl	r0, r4, #0
    3b20:	52a43000 	adcpl	r3, r4, #0
    3b24:	3c5f3000 	mracc	r3, pc, acc0
    3b28:	32c40000 	sbccc	r0, r4, #0
    3b2c:	5f1e0000 	svcpl	0x001e0000
    3b30:	0b000003 	bleq	3b44 <DISABLE_IRQ+0x3ac4>
    3b34:	06b3015b 	ssateq	r0, #20, fp, asr #2
    3b38:	3c8a0000 	stccc	0, cr0, [sl], {0}
    3b3c:	6d1f0000 	ldcvs	0, cr0, [pc]
    3b40:	0b006773 	bleq	1d914 <DISABLE_IRQ+0x1d894>
    3b44:	00f6015b 	rscseq	r0, r6, fp, asr r1
    3b48:	3ca80000 	stccc	0, cr0, [r8]
    3b4c:	8d100000 	ldchi	0, cr0, [r0]
    3b50:	0b000001 	bleq	3b5c <DISABLE_IRQ+0x3adc>
    3b54:	006d015e 	rsbeq	r0, sp, lr, asr r1
    3b58:	1d000000 	stcne	0, cr0, [r0]
    3b5c:	00071901 	andeq	r1, r7, r1, lsl #18
    3b60:	01080b00 	tsteq	r8, r0, lsl #22
    3b64:	0000f601 	andeq	pc, r0, r1, lsl #12
    3b68:	0052a400 	subseq	sl, r2, r0, lsl #8
    3b6c:	00547030 	subseq	r7, r4, r0, lsr r0
    3b70:	003cc630 	eorseq	ip, ip, r0, lsr r6
    3b74:	00337d00 	eorseq	r7, r3, r0, lsl #26
    3b78:	035f1e00 	cmpeq	pc, #0
    3b7c:	080b0000 	stmdaeq	fp, {}
    3b80:	0006b301 	andeq	fp, r6, r1, lsl #6
    3b84:	003ce500 	eorseq	lr, ip, r0, lsl #10
    3b88:	10b61e00 	adcsne	r1, r6, r0, lsl #28
    3b8c:	080b0000 	stmdaeq	fp, {}
    3b90:	00003701 	andeq	r3, r0, r1, lsl #14
    3b94:	003d2400 	eorseq	r2, sp, r0, lsl #8
    3b98:	72651f00 	rsbvc	r1, r5, #0
    3b9c:	080b0072 	stmdaeq	fp, {r1, r4, r5, r6}
    3ba0:	00081301 	andeq	r1, r8, r1, lsl #6
    3ba4:	003d4200 	eorseq	r4, sp, r0, lsl #4
    3ba8:	736d2100 	cmnvc	sp, #0
    3bac:	0a0b0067 	beq	2c3d50 <DISABLE_IRQ+0x2c3cd0>
    3bb0:	0000f601 	andeq	pc, r0, r1, lsl #12
    3bb4:	003d6000 	eorseq	r6, sp, r0
    3bb8:	018d2000 	orreq	r2, sp, r0
    3bbc:	0c0b0000 	stceq	0, cr0, [fp], {0}
    3bc0:	00006d01 	andeq	r6, r0, r1, lsl #26
    3bc4:	003d7e00 	eorseq	r7, sp, r0, lsl #28
    3bc8:	09ae3800 	stmibeq	lr!, {fp, ip, sp}
    3bcc:	534c0000 	movtpl	r0, #49152	; 0xc000
    3bd0:	03f83000 	mvnseq	r3, #0
    3bd4:	310b0000 	tstcc	fp, r0
    3bd8:	00335701 	eorseq	r5, r3, r1, lsl #14
    3bdc:	0c3d2c00 	ldceq	12, cr2, [sp]
    3be0:	202e0000 	eorcs	r0, lr, r0
    3be4:	24000004 	strcs	r0, [r0], #-4
    3be8:	000009c9 	andeq	r0, r0, r9, asr #19
    3bec:	d4300000 	ldrtle	r0, [r0]
    3bf0:	08000009 	stmdaeq	r0, {r0, r3}
    3bf4:	48300054 	ldmdami	r0!, {r2, r4, r6}
    3bf8:	0b300054 	bleq	c03d50 <MEM_SIZE+0x403d50>
    3bfc:	5d2c0136 	stfpls	f0, [ip, #-216]!	; 0xffffff28
    3c00:	3900000c 	stmdbcc	r0, {r2, r3}
    3c04:	30005408 	andcc	r5, r0, r8, lsl #8
    3c08:	30005448 	andcc	r5, r0, r8, asr #8
    3c0c:	0009ef24 	andeq	lr, r9, r4, lsr #30
    3c10:	00000000 	andeq	r0, r0, r0
    3c14:	10910136 	addsne	r0, r1, r6, lsr r1
    3c18:	940b0000 	strls	r0, [fp]
    3c1c:	0006b301 	andeq	fp, r6, r1, lsl #6
    3c20:	00547000 	subseq	r7, r4, r0
    3c24:	0055d030 	subseq	sp, r5, r0, lsr r0
    3c28:	003db230 	eorseq	fp, sp, r0, lsr r2
    3c2c:	0033ed00 	eorseq	lr, r3, r0, lsl #26
    3c30:	035f3500 	cmpeq	pc, #0
    3c34:	940b0000 	strls	r0, [fp]
    3c38:	000006b3 	undefined instruction 0x000006b3
    3c3c:	00003ddd 	ldrdeq	r3, [r0], -sp
    3c40:	74706f3a 	ldrbtvc	r6, [r0], #-3898	; 0xf3a
    3c44:	25940b00 	ldrcs	r0, [r4, #2816]	; 0xb00
    3c48:	32000000 	andcc	r0, r0, #0
    3c4c:	3a00003e 	bcc	3d4c <DISABLE_IRQ+0x3ccc>
    3c50:	00727265 	rsbseq	r7, r2, r5, ror #4
    3c54:	0813940b 	ldmdaeq	r3, {r0, r1, r3, sl, ip, pc}
    3c58:	3e7c0000 	cdpcc	0, 7, cr0, cr12, cr0, {0}
    3c5c:	74190000 	ldrvc	r0, [r9]
    3c60:	0b00000e 	bleq	3ca0 <DISABLE_IRQ+0x3c20>
    3c64:	00007896 	muleq	r0, r6, r8
    3c68:	12b41900 	adcsne	r1, r4, #0
    3c6c:	970b0000 	strls	r0, [fp, -r0]
    3c70:	000006b3 	undefined instruction 0x000006b3
    3c74:	00018d3e 	andeq	r8, r1, lr, lsr sp
    3c78:	6d990b00 	vldrvs	d0, [r9]
    3c7c:	9a000000 	bls	3c84 <DISABLE_IRQ+0x3c04>
    3c80:	0000003e 	andeq	r0, r0, lr, lsr r0
    3c84:	02f1011d 	rscseq	r0, r1, #1073741831	; 0x40000007
    3c88:	02020000 	andeq	r0, r2, #0
    3c8c:	01270103 	teqeq	r7, r3, lsl #2
    3c90:	55d00000 	ldrbpl	r0, [r0]
    3c94:	576c3000 	strbpl	r3, [ip, -r0]!
    3c98:	3eb83000 	cdpcc	0, 11, cr3, cr8, cr0, {0}
    3c9c:	34a60000 	strtcc	r0, [r6]
    3ca0:	9f1e0000 	svcls	0x001e0000
    3ca4:	0200000c 	andeq	r0, r0, #12
    3ca8:	086b0302 	stmdaeq	fp!, {r1, r8, r9}^
    3cac:	3ee30000 	cdpcc	0, 14, cr0, cr3, cr0, {0}
    3cb0:	581e0000 	ldmdapl	lr, {}
    3cb4:	02000001 	andeq	r0, r0, #1
    3cb8:	01270302 	teqeq	r7, r2, lsl #6
    3cbc:	3f430000 	svccc	0x00430000
    3cc0:	6f1f0000 	svcvs	0x001f0000
    3cc4:	02007470 	andeq	r7, r0, #1879048192	; 0x70000000
    3cc8:	00250302 	eoreq	r0, r5, r2, lsl #6
    3ccc:	3f6c0000 	svccc	0x006c0000
    3cd0:	651f0000 	ldrvs	r0, [pc, #0]	; 3cd8 <DISABLE_IRQ+0x3c58>
    3cd4:	02007272 	andeq	r7, r0, #536870919	; 0x20000007
    3cd8:	08130302 	ldmdaeq	r3, {r1, r8, r9}
    3cdc:	3fb60000 	svccc	0x00b60000
    3ce0:	fc200000 	stc2	0, cr0, [r0]
    3ce4:	02000002 	andeq	r0, r0, #2
    3ce8:	06b90304 	ldrteq	r0, [r9], r4, lsl #6
    3cec:	3fd40000 	svccc	0x00d40000
    3cf0:	e0200000 	eor	r0, r0, r0
    3cf4:	02000010 	andeq	r0, r0, #16
    3cf8:	00780305 	rsbseq	r0, r8, r5, lsl #6
    3cfc:	3ffd0000 	svccc	0x00fd0000
    3d00:	6a330000 	bvs	cc3d08 <MEM_SIZE+0x4c3d08>
    3d04:	0200000e 	andeq	r0, r0, #14
    3d08:	01270306 	teqeq	r7, r6, lsl #6
    3d0c:	54010000 	strpl	r0, [r1]
    3d10:	000b6620 	andeq	r6, fp, r0, lsr #12
    3d14:	03070200 	movweq	r0, #29184	; 0x7200
    3d18:	00000127 	andeq	r0, r0, r7, lsr #2
    3d1c:	00004026 	andeq	r4, r0, r6, lsr #32
    3d20:	79647212 	stmdbvc	r4!, {r1, r4, r9, ip, sp, lr}^
    3d24:	03080200 	movweq	r0, #33280	; 0x8200
    3d28:	00000078 	andeq	r0, r0, r8, ror r0
    3d2c:	00018d20 	andeq	r8, r1, r0, lsr #26
    3d30:	030a0200 	movweq	r0, #41472	; 0xa200
    3d34:	0000006d 	andeq	r0, r0, sp, rrx
    3d38:	0000407b 	andeq	r4, r0, fp, ror r0
    3d3c:	2b011d00 	blcs	4b144 <DISABLE_IRQ+0x4b0c4>
    3d40:	02000010 	andeq	r0, r0, #16
    3d44:	27010223 	strcs	r0, [r1, -r3, lsr #4]
    3d48:	6c000001 	stcvs	0, cr0, [r0], {1}
    3d4c:	58300057 	ldmdapl	r0!, {r0, r1, r2, r4, r6}
    3d50:	9930005a 	ldmdbls	r0!, {r1, r3, r4, r6}
    3d54:	98000040 	stmdals	r0, {r6}
    3d58:	1e000035 	mcrne	0, 0, r0, cr0, cr5, {1}
    3d5c:	00000c9f 	muleq	r0, pc, ip
    3d60:	6b022302 	blvs	8c970 <DISABLE_IRQ+0x8c8f0>
    3d64:	c5000008 	strgt	r0, [r0, #-8]
    3d68:	1e000040 	cdpne	0, 0, cr0, cr0, cr0, {2}
    3d6c:	00000158 	andeq	r0, r0, r8, asr r1
    3d70:	27022302 	strcs	r2, [r2, -r2, lsl #6]
    3d74:	0f000001 	svceq	0x00000001
    3d78:	1e000041 	cdpne	0, 0, cr0, cr0, cr1, {2}
    3d7c:	0000098d 	andeq	r0, r0, sp, lsl #19
    3d80:	25022302 	strcs	r2, [r2, #-770]	; 0x302
    3d84:	7a000000 	bvc	3d8c <DISABLE_IRQ+0x3d0c>
    3d88:	1e000041 	cdpne	0, 0, cr0, cr0, cr1, {2}
    3d8c:	000010b6 	strheq	r1, [r0], -r6
    3d90:	37022302 	strcc	r2, [r2, -r2, lsl #6]
    3d94:	98000000 	stmdals	r0, {}
    3d98:	1f000041 	svcne	0x00000041
    3d9c:	00727265 	rsbseq	r7, r2, r5, ror #4
    3da0:	13022302 	movwne	r2, #8962	; 0x2302
    3da4:	b6000008 	strlt	r0, [r0], -r8
    3da8:	33000041 	movwcc	r0, #65	; 0x41
    3dac:	00000ec8 	andeq	r0, r0, r8, asr #29
    3db0:	f1022502 	undefined instruction 0xf1022502
    3db4:	02000001 	andeq	r0, r0, #1
    3db8:	66204c91 	undefined instruction 0x66204c91
    3dbc:	0200000b 	andeq	r0, r0, #11
    3dc0:	01270226 	teqeq	r7, r6, lsr #4
    3dc4:	41d50000 	bicsmi	r0, r5, r0
    3dc8:	3e100000 	cdpcc	0, 1, cr0, cr0, cr0, {0}
    3dcc:	02000006 	andeq	r0, r0, #6
    3dd0:	00250227 	eoreq	r0, r5, r7, lsr #4
    3dd4:	fc200000 	stc2	0, cr0, [r0]
    3dd8:	02000005 	andeq	r0, r0, #5
    3ddc:	00780228 	rsbseq	r0, r8, r8, lsr #4
    3de0:	41fe0000 	mvnsmi	r0, r0
    3de4:	8d200000 	stchi	0, cr0, [r0]
    3de8:	02000001 	andeq	r0, r0, #1
    3dec:	006d022a 	rsbeq	r0, sp, sl, lsr #4
    3df0:	421c0000 	andsmi	r0, ip, #0
    3df4:	192b0000 	stmdbne	fp!, {}
    3df8:	b0000008 	andlt	r0, r0, r8
    3dfc:	48300059 	ldmdami	r0!, {r0, r3, r4, r6}
    3e00:	02000004 	andeq	r0, r0, #4
    3e04:	be2c029a 	mcrlt	2, 1, r0, cr12, cr10, {4}
    3e08:	2e00000e 	cdpcs	0, 0, cr0, cr0, cr14, {0}
    3e0c:	00000468 	andeq	r0, r0, r8, ror #8
    3e10:	00083424 	andeq	r3, r8, r4, lsr #8
    3e14:	08402400 	stmdaeq	r0, {sl, sp}^
    3e18:	4c280000 	stcmi	0, cr0, [r8]
    3e1c:	3a000008 	bcc	3e44 <DISABLE_IRQ+0x3dc4>
    3e20:	28000042 	stmdacs	r0, {r1, r6}
    3e24:	00000858 	andeq	r0, r0, r8, asr r8
    3e28:	00004258 	andeq	r4, r0, r8, asr r2
    3e2c:	1d000000 	stcne	0, cr0, [r0]
    3e30:	000a6901 	andeq	r6, sl, r1, lsl #18
    3e34:	01150200 	tsteq	r5, r0, lsl #4
    3e38:	00086b01 	andeq	r6, r8, r1, lsl #22
    3e3c:	005a5800 	subseq	r5, sl, r0, lsl #16
    3e40:	005bb430 	subseq	fp, fp, r0, lsr r4
    3e44:	00427630 	subeq	r7, r2, r0, lsr r6
    3e48:	00361f00 	eorseq	r1, r6, r0, lsl #30
    3e4c:	0c9f1e00 	ldceq	14, cr1, [pc], {0}
    3e50:	15020000 	strne	r0, [r2]
    3e54:	00086b01 	andeq	r6, r8, r1, lsl #22
    3e58:	0042a100 	subeq	sl, r2, r0, lsl #2
    3e5c:	706f1f00 	rsbvc	r1, pc, r0, lsl #30
    3e60:	15020074 	strne	r0, [r2, #-116]	; 0x74
    3e64:	00002501 	andeq	r2, r0, r1, lsl #10
    3e68:	0042f600 	subeq	pc, r2, r0, lsl #12
    3e6c:	72651f00 	rsbvc	r1, r5, #0
    3e70:	15020072 	strne	r0, [r2, #-114]	; 0x72
    3e74:	00081301 	andeq	r1, r8, r1, lsl #6
    3e78:	00434000 	subeq	r4, r3, r0
    3e7c:	0e741000 	cdpeq	0, 7, cr1, cr4, cr0, {0}
    3e80:	17020000 	strne	r0, [r2, -r0]
    3e84:	00007801 	andeq	r7, r0, r1, lsl #16
    3e88:	02fc2000 	rscseq	r2, ip, #0
    3e8c:	18020000 	stmdane	r2, {}
    3e90:	0006b901 	andeq	fp, r6, r1, lsl #18
    3e94:	00435e00 	subeq	r5, r3, r0, lsl #28
    3e98:	11ec1000 	mvnne	r1, r0
    3e9c:	19020000 	stmdbne	r2, {}
    3ea0:	00086b01 	andeq	r6, r8, r1, lsl #22
    3ea4:	018d2000 	orreq	r2, sp, r0
    3ea8:	1b020000 	blne	83eb0 <DISABLE_IRQ+0x83e30>
    3eac:	00006d01 	andeq	r6, r0, r1, lsl #26
    3eb0:	00438700 	subeq	r8, r3, r0, lsl #14
    3eb4:	012a0000 	teqeq	sl, r0
    3eb8:	000002d5 	ldrdeq	r0, [r0], -r5
    3ebc:	01019a01 	tsteq	r1, r1, lsl #20
    3ec0:	30005bb4 	undefined instruction 0x30005bb4
    3ec4:	30005c28 	andcc	r5, r0, r8, lsr #24
    3ec8:	000043a5 	andeq	r4, r0, r5, lsr #7
    3ecc:	00003646 	andeq	r3, r0, r6, asr #12
    3ed0:	00018d10 	andeq	r8, r1, r0, lsl sp
    3ed4:	019d0100 	orrseq	r0, sp, r0, lsl #2
    3ed8:	0000006d 	andeq	r0, r0, sp, rrx
    3edc:	30012a00 	andcc	r2, r1, r0, lsl #20
    3ee0:	01000009 	tsteq	r0, r9
    3ee4:	2801020e 	stmdacs	r1, {r1, r2, r3, r9}
    3ee8:	3c30005c 	ldccc	0, cr0, [r0], #-368	; 0xfffffe90
    3eec:	c430005d 	ldrtgt	r0, [r0], #-93	; 0x5d
    3ef0:	89000043 	stmdbhi	r0, {r0, r1, r6}
    3ef4:	20000036 	andcs	r0, r0, r6, lsr r0
    3ef8:	00000fba 	undefined instruction 0x00000fba
    3efc:	65021001 	strvs	r1, [r2, #-1]
    3f00:	e3000008 	movw	r0, #8
    3f04:	10000043 	andne	r0, r0, r3, asr #32
    3f08:	00000b70 	andeq	r0, r0, r0, ror fp
    3f0c:	78021201 	stmdavc	r2, {r0, r9, ip}
    3f10:	10000000 	andne	r0, r0, r0
    3f14:	0000018d 	andeq	r0, r0, sp, lsl #3
    3f18:	6d021501 	cfstr32vs	mvfx1, [r2, #-4]
    3f1c:	00000000 	andeq	r0, r0, r0
    3f20:	10a1012a 	adcne	r0, r1, sl, lsr #2
    3f24:	cc010000 	stcgt	0, cr0, [r1], {0}
    3f28:	5d3c0101 	ldfpls	f0, [ip, #-4]!
    3f2c:	5dcc3000 	stclpl	0, cr3, [ip]
    3f30:	44013000 	strmi	r3, [r1]
    3f34:	36c40000 	strbcc	r0, [r4], r0
    3f38:	3b2b0000 	blcc	ac3f40 <MEM_SIZE+0x2c3f40>
    3f3c:	50000009 	andpl	r0, r0, r9
    3f40:	8830005d 	ldmdahi	r0!, {r0, r2, r3, r4, r6}
    3f44:	01000004 	tsteq	r0, r4
    3f48:	a82e01cf 	stmdage	lr!, {r0, r1, r2, r3, r6, r7, r8}
    3f4c:	28000004 	stmdacs	r0, {r2}
    3f50:	00000949 	andeq	r0, r0, r9, asr #18
    3f54:	00004420 	andeq	r4, r0, r0, lsr #8
    3f58:	2a000000 	bcs	3f60 <DISABLE_IRQ+0x3ee0>
    3f5c:	00031b01 	andeq	r1, r3, r1, lsl #22
    3f60:	01460100 	cmpeq	r6, r0, lsl #2
    3f64:	005dcc01 	subseq	ip, sp, r1, lsl #24
    3f68:	005ecc30 	subseq	ip, lr, r0, lsr ip
    3f6c:	00443330 	subeq	r3, r4, r0, lsr r3
    3f70:	00370b00 	eorseq	r0, r7, r0, lsl #22
    3f74:	018d1000 	orreq	r1, sp, r0
    3f78:	49010000 	stmdbmi	r1, {}
    3f7c:	00006d01 	andeq	r6, r0, r1, lsl #26
    3f80:	093b2b00 	ldmdbeq	fp!, {r8, r9, fp, sp}
    3f84:	5e300000 	cdppl	0, 3, cr0, cr0, cr0, {0}
    3f88:	04c83000 	strbeq	r3, [r8]
    3f8c:	55010000 	strpl	r0, [r1]
    3f90:	04f02e01 	ldrbteq	r2, [r0], #3585	; 0xe01
    3f94:	49280000 	stmdbmi	r8!, {}
    3f98:	52000009 	andpl	r0, r0, #9
    3f9c:	00000044 	andeq	r0, r0, r4, asr #32
    3fa0:	01340000 	teqeq	r4, r0
    3fa4:	00000432 	andeq	r0, r0, r2, lsr r4
    3fa8:	cc01e501 	cfstr32gt	mvfx14, [r1], {1}
    3fac:	8c30005e 	ldchi	0, cr0, [r0], #-376	; 0xfffffe88
    3fb0:	65300061 	ldrvs	r0, [r0, #-97]!	; 0x61
    3fb4:	58000044 	stmdapl	r0, {r2, r6}
    3fb8:	47000038 	smladxmi	r0, r8, r0, r0
    3fbc:	00000a65 	andeq	r0, r0, r5, ror #20
    3fc0:	30005ed8 	ldrdcc	r5, [r0], -r8
    3fc4:	00000518 	andeq	r0, r0, r8, lsl r5
    3fc8:	6f46eb01 	svcvs	0x0046eb01
    3fcc:	f400000a 	vst4.8	{d0-d3}, [r0], sl
    3fd0:	3030005e 	eorscc	r0, r0, lr, asr r0
    3fd4:	01000005 	tsteq	r0, r5
    3fd8:	003757ed 	eorseq	r5, r7, sp, ror #15
    3fdc:	05482e00 	strbeq	r2, [r8, #-3584]	; 0xe00
    3fe0:	7d240000 	stcvc	0, cr0, [r4]
    3fe4:	2400000a 	strcs	r0, [r0], #-10
    3fe8:	00000a87 	andeq	r0, r0, r7, lsl #21
    3fec:	94410000 	strbls	r0, [r1]
    3ff0:	7c00000a 	stcvc	0, cr0, [r0], {10}
    3ff4:	fc30005f 	ldc2	0, cr0, [r0], #-380	; 0xfffffe84
    3ff8:	0130005f 	teqeq	r0, pc, asr r0
    3ffc:	0037c2ef 	eorseq	ip, r7, pc, ror #5
    4000:	5f7c3900 	svcpl	0x007c3900
    4004:	5ffc3000 	svcpl	0x00fc3000
    4008:	a2243000 	eorge	r3, r4, #0
    400c:	2400000a 	strcs	r0, [r0], #-10
    4010:	00000aac 	andeq	r0, r0, ip, lsr #21
    4014:	000ab828 	andeq	fp, sl, r8, lsr #16
    4018:	00449000 	subeq	r9, r4, r0
    401c:	07eb4300 	strbeq	r4, [fp, r0, lsl #6]!
    4020:	5f7c0000 	svcpl	0x007c0000
    4024:	5f943000 	svcpl	0x00943000
    4028:	44013000 	strmi	r3, [r1]
    402c:	0037a504 	eorseq	sl, r7, r4, lsl #10
    4030:	0cad2c00 	stceq	12, cr2, [sp]
    4034:	a62c0000 	strtge	r0, [ip], -r0
    4038:	0000000c 	andeq	r0, r0, ip
    403c:	0007eb30 	andeq	lr, r7, r0, lsr fp
    4040:	005f9400 	subseq	r9, pc, r0, lsl #8
    4044:	005fb030 	subseq	fp, pc, r0, lsr r0
    4048:	04450130 	strbeq	r0, [r5], #-304	; 0x130
    404c:	000cad2c 	andeq	sl, ip, ip, lsr #26
    4050:	0ca62c00 	stceq	12, cr2, [r6]
    4054:	00000000 	andeq	r0, r0, r0
    4058:	0ac54100 	beq	ff154460 <rEINTPEND+0xa91543b8>
    405c:	5ffc0000 	svcpl	0x00fc0000
    4060:	605c3000 	subsvs	r3, ip, r0
    4064:	f1013000 	undefined instruction 0xf1013000
    4068:	0000380e 	andeq	r3, r0, lr, lsl #16
    406c:	005ffc39 	subseq	pc, pc, r9, lsr ip
    4070:	00605c30 	rsbeq	r5, r0, r0, lsr ip
    4074:	0ad32430 	beq	ff4cd13c <rEINTPEND+0xa94cd094>
    4078:	dd240000 	stcle	0, cr0, [r4]
    407c:	2800000a 	stmdacs	r0, {r1, r3}
    4080:	00000ae9 	andeq	r0, r0, r9, ror #21
    4084:	000044a3 	andeq	r4, r0, r3, lsr #9
    4088:	0007eb2b 	andeq	lr, r7, fp, lsr #22
    408c:	005ffc00 	subseq	pc, pc, r0, lsl #24
    4090:	00056030 	andeq	r6, r5, r0, lsr r0
    4094:	03430100 	movteq	r0, #12544	; 0x3100
    4098:	000cad2c 	andeq	sl, ip, ip, lsr #26
    409c:	0ca62c00 	stceq	12, cr2, [r6]
    40a0:	00000000 	andeq	r0, r0, r0
    40a4:	0af64100 	beq	ffd944ac <rEINTPEND+0xa9d94404>
    40a8:	60680000 	rsbvs	r0, r8, r0
    40ac:	60b43000 	adcsvs	r3, r4, r0
    40b0:	ff013000 	undefined instruction 0xff013000
    40b4:	00003834 	andeq	r3, r0, r4, lsr r8
    40b8:	00606839 	rsbeq	r6, r0, r9, lsr r8
    40bc:	0060b430 	rsbeq	fp, r0, r0, lsr r4
    40c0:	0b042730 	bleq	10dd88 <DISABLE_IRQ+0x10dd08>
    40c4:	91020000 	tstls	r2, r0
    40c8:	30000067 	andcc	r0, r0, r7, rrx
    40cc:	00000b11 	andeq	r0, r0, r1, lsl fp
    40d0:	300060b4 	strhcc	r6, [r0], -r4
    40d4:	300060f4 	strdcc	r6, [r0], -r4
    40d8:	39010101 	stmdbcc	r1, {r0, r8}
    40dc:	300060b4 	strhcc	r6, [r0], -r4
    40e0:	300060f4 	strdcc	r6, [r0], -r4
    40e4:	000b1f27 	andeq	r1, fp, r7, lsr #30
    40e8:	67910200 	ldrvs	r0, [r1, r0, lsl #4]
    40ec:	48000000 	stmdami	r0, {}
    40f0:	0000038e 	andeq	r0, r0, lr, lsl #7
    40f4:	4902730d 	stmdbmi	r2, {r0, r2, r3, r8, r9, ip, sp, lr}
    40f8:	01000000 	tsteq	r0, r0
    40fc:	ce040305 	cdpgt	3, 0, cr0, cr4, cr5, {0}
    4100:	09483001 	stmdbeq	r8, {r0, ip, sp}^
    4104:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    4108:	06b30276 	undefined instruction 0x06b30276
    410c:	05010000 	streq	r0, [r1]
    4110:	01d09003 	bicseq	r9, r0, r3
    4114:	011b0730 	tsteq	fp, r0, lsr r7
    4118:	388e0000 	stmcc	lr, {}
    411c:	08080000 	stmdaeq	r8, {}
    4120:	09000001 	stmdbeq	r0, {r0}
    4124:	06334800 	ldrteq	r4, [r3], -r0, lsl #16
    4128:	770d0000 	strvc	r0, [sp, -r0]
    412c:	00387e02 	eorseq	r7, r8, r2, lsl #28
    4130:	03050100 	movweq	r0, #20736	; 0x5100
    4134:	3001d2a8 	andcc	sp, r1, r8, lsr #5
    4138:	00017d07 	andeq	r7, r1, r7, lsl #26
    413c:	0038b100 	eorseq	fp, r8, r0, lsl #2
    4140:	01080800 	tsteq	r8, r0, lsl #16
    4144:	00040000 	andeq	r0, r4, r0
    4148:	000e2f48 	andeq	r2, lr, r8, asr #30
    414c:	027b0d00 	rsbseq	r0, fp, #0
    4150:	000038a1 	andeq	r3, r0, r1, lsr #17
    4154:	78030501 	stmdavc	r3, {r0, r8, sl}
    4158:	483001c7 	ldmdami	r0!, {r0, r1, r2, r6, r7, r8}
    415c:	00000ac5 	andeq	r0, r0, r5, asr #21
    4160:	6b027c0d 	blvs	a319c <DISABLE_IRQ+0xa311c>
    4164:	01000008 	tsteq	r0, r8
    4168:	dba00305 	blle	fe804d84 <rEINTPEND+0xa8804cdc>
    416c:	3a483001 	bcc	1210178 <MEM_SIZE+0xa10178>
    4170:	0d000007 	stceq	0, cr0, [r0, #-28]	; 0xffffffe4
    4174:	005b0280 	subseq	r0, fp, r0, lsl #5
    4178:	05010000 	streq	r0, [r1]
    417c:	01ce1403 	biceq	r1, lr, r3, lsl #8
    4180:	13194830 	tstne	r9, #3145728	; 0x300000
    4184:	810d0000 	tsthi	sp, r0
    4188:	00004902 	andeq	r4, r0, r2, lsl #18
    418c:	03050100 	movweq	r0, #20736	; 0x5100
    4190:	3001ce0c 	andcc	ip, r1, ip, lsl #28
    4194:	0006df48 	andeq	sp, r6, r8, asr #30
    4198:	02820d00 	addeq	r0, r2, #0
    419c:	00000049 	andeq	r0, r0, r9, asr #32
    41a0:	a8030501 	stmdage	r3, {r0, r8, sl}
    41a4:	483001dc 	ldmdami	r0!, {r2, r3, r4, r6, r7, r8}
    41a8:	00000da3 	andeq	r0, r0, r3, lsr #27
    41ac:	7802830d 	stmdavc	r2, {r0, r2, r3, r8, r9, pc}
    41b0:	01000000 	tsteq	r0, r0
    41b4:	dba40305 	blle	fe904dd0 <rEINTPEND+0xa8904d28>
    41b8:	83073001 	movwhi	r3, #28673	; 0x7001
    41bc:	33000000 	movwcc	r0, #0
    41c0:	08000039 	stmdaeq	r0, {r0, r3, r4, r5}
    41c4:	00000108 	andeq	r0, r0, r8, lsl #2
    41c8:	ec48007f 	mcrr	0, 7, r0, r8, cr15
    41cc:	0d000004 	stceq	0, cr0, [r0, #-16]
    41d0:	39230284 	stmdbcc	r3!, {r2, r7, r9}
    41d4:	05010000 	streq	r0, [r1]
    41d8:	01cc0403 	biceq	r0, ip, r3, lsl #8
    41dc:	12fa4830 	rscsne	r4, sl, #3145728	; 0x300000
    41e0:	870d0000 	strhi	r0, [sp, -r0]
    41e4:	00002502 	andeq	r2, r0, r2, lsl #10
    41e8:	03050100 	movweq	r0, #20736	; 0x5100
    41ec:	3001d094 	mulcc	r1, r4, r0
    41f0:	00091a48 	andeq	r1, r9, r8, asr #20
    41f4:	02890d00 	addeq	r0, r9, #0
    41f8:	00000025 	andeq	r0, r0, r5, lsr #32
    41fc:	64030501 	strvs	r0, [r3], #-1281	; 0x501
    4200:	483001c7 	ldmdami	r0!, {r0, r1, r2, r6, r7, r8}
    4204:	00000753 	andeq	r0, r0, r3, asr r7
    4208:	25028b0d 	strcs	r8, [r2, #-2829]	; 0xb0d
    420c:	01000000 	tsteq	r0, r0
    4210:	cb440305 	blgt	1104e2c <MEM_SIZE+0x904e2c>
    4214:	27483001 	strbcs	r3, [r8, -r1]
    4218:	0d000002 	stceq	0, cr0, [r0, #-8]
    421c:	0025028c 	eoreq	r0, r5, ip, lsl #5
    4220:	05010000 	streq	r0, [r1]
    4224:	01c77603 	biceq	r7, r7, r3, lsl #12
    4228:	04bf4830 	ldrteq	r4, [pc], #2096	; 4230 <DISABLE_IRQ+0x41b0>
    422c:	8f0d0000 	svchi	0x000d0000
    4230:	00002502 	andeq	r2, r0, r2, lsl #10
    4234:	03050100 	movweq	r0, #20736	; 0x5100
    4238:	3001ce84 	andcc	ip, r1, r4, lsl #29
    423c:	00111c48 	andseq	r1, r1, r8, asr #24
    4240:	02900d00 	addseq	r0, r0, #0
    4244:	000000f8 	strdeq	r0, [r0], -r8
    4248:	88030501 	stmdahi	r3, {r0, r8, sl}
    424c:	483001ce 	ldmdami	r0!, {r1, r2, r3, r6, r7, r8}
    4250:	00000ad4 	ldrdeq	r0, [r0], -r4
    4254:	7802960d 	stmdavc	r2, {r0, r2, r3, r9, sl, ip, pc}
    4258:	01000000 	tsteq	r0, r0
    425c:	c76c0305 	strbgt	r0, [ip, -r5, lsl #6]!
    4260:	ea483001 	b	121026c <MEM_SIZE+0xa1026c>
    4264:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    4268:	00250298 	mlaeq	r5, r8, r2, r0
    426c:	05010000 	streq	r0, [r1]
    4270:	01ce1503 	biceq	r1, lr, r3, lsl #10
    4274:	0b944830 	bleq	fe51633c <rEINTPEND+0xa8516294>
    4278:	9a0d0000 	bls	344280 <DISABLE_IRQ+0x344200>
    427c:	0039f102 	eorseq	pc, r9, r2, lsl #2
    4280:	03050100 	movweq	r0, #20736	; 0x5100
    4284:	3001c770 	andcc	ip, r1, r0, ror r7
    4288:	00004949 	andeq	r4, r0, r9, asr #18
    428c:	08684800 	stmdaeq	r8!, {fp, lr}^
    4290:	9c0d0000 	stcls	0, cr0, [sp], {0}
    4294:	00392302 	eorseq	r2, r9, r2, lsl #6
    4298:	03050100 	movweq	r0, #20736	; 0x5100
    429c:	3001d0a8 	andcc	sp, r1, r8, lsr #1
    42a0:	0011e348 	andseq	lr, r1, r8, asr #6
    42a4:	029f0d00 	addseq	r0, pc, #0
    42a8:	00000865 	andeq	r0, r0, r5, ror #16
    42ac:	98030501 	stmdals	r3, {r0, r8, sl}
    42b0:	483001d0 	ldmdami	r0!, {r4, r6, r7, r8}
    42b4:	00001225 	andeq	r1, r0, r5, lsr #4
    42b8:	6502a00d 	strvs	sl, [r2, #-13]
    42bc:	01000008 	tsteq	r0, r8
    42c0:	ce100305 	cdpgt	3, 1, cr0, cr0, cr5, {0}
    42c4:	18483001 	stmdane	r8, {r0, ip, sp}^
    42c8:	0d00000e 	stceq	0, cr0, [r0, #-56]	; 0xffffffc8
    42cc:	086502a1 	stmdaeq	r5!, {r0, r5, r7, r9}^
    42d0:	05010000 	streq	r0, [r1]
    42d4:	01ce7c03 	biceq	r7, lr, r3, lsl #24
    42d8:	0a3e4830 	beq	f963a0 <MEM_SIZE+0x7963a0>
    42dc:	a20d0000 	andge	r0, sp, #0
    42e0:	00086502 	andeq	r6, r8, r2, lsl #10
    42e4:	03050100 	movweq	r0, #20736	; 0x5100
    42e8:	3001cb48 	andcc	ip, r1, r8, asr #22
    42ec:	00086507 	andeq	r6, r8, r7, lsl #10
    42f0:	003a6500 	eorseq	r6, sl, r0, lsl #10
    42f4:	01080800 	tsteq	r8, r0, lsl #16
    42f8:	003f0000 	eorseq	r0, pc, r0
    42fc:	000bf548 	andeq	pc, fp, r8, asr #10
    4300:	02a30d00 	adceq	r0, r3, #0
    4304:	00003a55 	andeq	r3, r0, r5, asr sl
    4308:	a8030501 	stmdage	r3, {r0, r8, sl}
    430c:	073001db 	undefined instruction 0x073001db
    4310:	000006bf 	undefined instruction 0x000006bf
    4314:	00003a88 	andeq	r3, r0, r8, lsl #21
    4318:	00010808 	andeq	r0, r1, r8, lsl #16
    431c:	48001500 	stmdami	r0, {r8, sl, ip}
    4320:	000011cd 	andeq	r1, r0, sp, asr #3
    4324:	7802a40d 	stmdavc	r2, {r0, r2, r3, sl, sp, pc}
    4328:	0100003a 	tsteq	r0, sl, lsr r0
    432c:	d4100305 	ldrle	r0, [r0], #-773	; 0x305
    4330:	5d483001 	stclpl	0, cr3, [r8, #-4]
    4334:	0d000007 	stceq	0, cr0, [r0, #-28]	; 0xffffffe4
    4338:	002502a7 	eoreq	r0, r5, r7, lsr #5
    433c:	05010000 	streq	r0, [r1]
    4340:	01cb4c03 	biceq	r4, fp, r3, lsl #24
    4344:	0ccb4830 	stcleq	8, cr4, [fp], {48}	; 0x30
    4348:	ab0d0000 	blge	344350 <DISABLE_IRQ+0x3442d0>
    434c:	000f2e02 	andeq	r2, pc, r2, lsl #28
    4350:	03050100 	movweq	r0, #20736	; 0x5100
    4354:	3001ce18 	andcc	ip, r1, r8, lsl lr
    4358:	0002ac07 	andeq	sl, r2, r7, lsl #24
    435c:	003ad100 	eorseq	sp, sl, r0, lsl #2
    4360:	01080800 	tsteq	r8, r0, lsl #16
    4364:	00040000 	andeq	r0, r4, r0
    4368:	000c7e48 	andeq	r7, ip, r8, asr #28
    436c:	02ac0d00 	adceq	r0, ip, #0
    4370:	00003ac1 	andeq	r3, r0, r1, asr #21
    4374:	50030501 	andpl	r0, r3, r1, lsl #10
    4378:	483001cb 	ldmdami	r0!, {r0, r1, r3, r6, r7, r8}
    437c:	000004ce 	andeq	r0, r0, lr, asr #9
    4380:	8a02b00d 	bhi	b03bc <DISABLE_IRQ+0xb033c>
    4384:	0100000f 	tsteq	r0, pc
    4388:	ce800305 	cdpgt	3, 8, cr0, cr0, cr5, {0}
    438c:	14073001 	strne	r3, [r7], #-1
    4390:	07000004 	streq	r0, [r0, -r4]
    4394:	0800003b 	stmdaeq	r0, {r0, r1, r3, r4, r5}
    4398:	00000108 	andeq	r0, r0, r8, lsl #2
    439c:	54480003 	strbpl	r0, [r8], #-3
    43a0:	0d000012 	stceq	0, cr0, [r0, #-72]	; 0xffffffb8
    43a4:	3af702b1 	bcc	ffdc4e70 <rEINTPEND+0xa9dc4dc8>
    43a8:	05010000 	streq	r0, [r1]
    43ac:	01ce1c03 	biceq	r1, lr, r3, lsl #24
    43b0:	0ede4830 	mrceq	8, 6, r4, cr14, cr0, {1}
    43b4:	b50d0000 	strlt	r0, [sp]
    43b8:	0039f102 	eorseq	pc, r9, r2, lsl #2
    43bc:	03050100 	movweq	r0, #20736	; 0x5100
    43c0:	3001d0a0 	andcc	sp, r1, r0, lsr #1
    43c4:	00068548 	andeq	r8, r6, r8, asr #10
    43c8:	02b90d00 	adcseq	r0, r9, #0
    43cc:	00000037 	andeq	r0, r0, r7, lsr r0
    43d0:	08030501 	stmdaeq	r3, {r0, r8, sl}
    43d4:	483001ce 	ldmdami	r0!, {r1, r2, r3, r6, r7, r8}
    43d8:	00000781 	andeq	r0, r0, r1, lsl #15
    43dc:	3702ba0d 	strcc	fp, [r2, -sp, lsl #20]
    43e0:	01000000 	tsteq	r0, r0
    43e4:	c7740305 	ldrbgt	r0, [r4, -r5, lsl #6]!
    43e8:	0a483001 	beq	12103f4 <MEM_SIZE+0xa103f4>
    43ec:	0d000007 	stceq	0, cr0, [r0, #-28]	; 0xffffffe4
    43f0:	004902bb 	strheq	r0, [r9], #-43	; 0xffffffd5
    43f4:	05010000 	streq	r0, [r1]
    43f8:	01d09c03 	bicseq	r9, r0, r3, lsl #24
    43fc:	09f24830 	ldmibeq	r2!, {r4, r5, fp, lr}^
    4400:	bd0d0000 	stclt	0, cr0, [sp]
    4404:	0006b302 	andeq	fp, r6, r2, lsl #6
    4408:	03050100 	movweq	r0, #20736	; 0x5100
    440c:	3001d0a4 	andcc	sp, r1, r4, lsr #1
    4410:	00028948 	andeq	r8, r2, r8, asr #18
    4414:	02be0d00 	adcseq	r0, lr, #0
    4418:	000006b3 	undefined instruction 0x000006b3
    441c:	68030501 	stmdavs	r3, {r0, r8, sl}
    4420:	073001c7 	ldreq	r0, [r0, -r7, asr #3]!
    4424:	000007a1 	andeq	r0, r0, r1, lsr #15
    4428:	00003b9c 	muleq	r0, ip, fp
    442c:	00010808 	andeq	r0, r1, r8, lsl #16
    4430:	48000f00 	stmdami	r0, {r8, r9, sl, fp}
    4434:	00001291 	muleq	r0, r1, r2
    4438:	8c02c00d 	stchi	0, cr12, [r2], {13}
    443c:	0100003b 	tsteq	r0, fp, lsr r0
    4440:	c8040305 	stmdagt	r4, {r0, r2, r8, r9}
    4444:	dc483001 	mcrrle	0, 0, r3, r8, cr1
    4448:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    444c:	07d902c1 	ldrbeq	r0, [r9, r1, asr #5]
    4450:	05010000 	streq	r0, [r1]
    4454:	01c72003 	biceq	r2, r7, r3
    4458:	08cb4830 	stmiaeq	fp, {r4, r5, fp, lr}^
    445c:	c20d0000 	andgt	r0, sp, #0
    4460:	00392302 	eorseq	r2, r9, r2, lsl #6
    4464:	03050100 	movweq	r0, #20736	; 0x5100
    4468:	3001ce90 	mulcc	r1, r0, lr
    446c:	0007df07 	andeq	sp, r7, r7, lsl #30
    4470:	003be500 	eorseq	lr, fp, r0, lsl #10
    4474:	01080800 	tsteq	r8, r0, lsl #16
    4478:	00070000 	andeq	r0, r7, r0
    447c:	0005ae48 	andeq	sl, r5, r8, asr #28
    4480:	02c40d00 	sbceq	r0, r4, #0
    4484:	00003bd5 	ldrdeq	r3, [r0], -r5
    4488:	24030501 	strcs	r0, [r3], #-1281	; 0x501
    448c:	073001c7 	ldreq	r0, [r0, -r7, asr #3]!
    4490:	00000025 	andeq	r0, r0, r5, lsr #32
    4494:	00003c08 	andeq	r3, r0, r8, lsl #24
    4498:	00010808 	andeq	r0, r1, r8, lsl #16
    449c:	4a00ff00 	bmi	440a4 <DISABLE_IRQ+0x44024>
    44a0:	0000068f 	andeq	r0, r0, pc, lsl #13
    44a4:	3c1a1e01 	ldccc	14, cr1, [sl], {1}
    44a8:	05010000 	streq	r0, [r1]
    44ac:	006abc03 	rsbeq	fp, sl, r3, lsl #24
    44b0:	3bf84b30 	blcc	ffe17178 <rEINTPEND+0xa9e170d0>
    44b4:	b04a0000 	sublt	r0, sl, r0
    44b8:	0700000f 	streq	r0, [r0, -pc]
    44bc:	003c3118 	eorseq	r3, ip, r8, lsl r1
    44c0:	03050100 	movweq	r0, #20736	; 0x5100
    44c4:	30006bbc 	undefined instruction 0x30006bbc
    44c8:	0000374b 	andeq	r3, r0, fp, asr #14
    44cc:	06224a00 	strteq	r4, [r2], -r0, lsl #20
    44d0:	1c070000 	stcne	0, cr0, [r7], {0}
    44d4:	00003c48 	andeq	r3, r0, r8, asr #24
    44d8:	c0030501 	andgt	r0, r3, r1, lsl #10
    44dc:	4b30006b 	blmi	c04690 <MEM_SIZE+0x404690>
    44e0:	00000049 	andeq	r0, r0, r9, asr #32
    44e4:	000cd94a 	andeq	sp, ip, sl, asr #18
    44e8:	311e0700 	tstcc	lr, r0, lsl #14
    44ec:	0100003c 	tsteq	r0, ip, lsr r0
    44f0:	6bc40305 	blvs	ff10510c <rEINTPEND+0xa9105064>
    44f4:	5a4a3000 	bpl	12904fc <MEM_SIZE+0xa904fc>
    44f8:	07000009 	streq	r0, [r0, -r9]
    44fc:	003c311f 	eorseq	r3, ip, pc, lsl r1
    4500:	03050100 	movweq	r0, #20736	; 0x5100
    4504:	30006bc6 	andcc	r6, r0, r6, asr #23
    4508:	00026d4a 	andeq	r6, r2, sl, asr #26
    450c:	31200700 	teqcc	r0, r0, lsl #14
    4510:	0100003c 	tsteq	r0, ip, lsr r0
    4514:	6bc80305 	blvs	ff205130 <rEINTPEND+0xa9205088>
    4518:	104a3000 	subne	r3, sl, r0
    451c:	0700000d 	streq	r0, [r0, -sp]
    4520:	003c3122 	eorseq	r3, ip, r2, lsr #2
    4524:	03050100 	movweq	r0, #20736	; 0x5100
    4528:	30006bca 	andcc	r6, r0, sl, asr #23
    452c:	0005504a 	andeq	r5, r5, sl, asr #32
    4530:	31230700 	teqcc	r3, r0, lsl #14
    4534:	0100003c 	tsteq	r0, ip, lsr r0
    4538:	6bcc0305 	blvs	ff305154 <rEINTPEND+0xa93050ac>
    453c:	c24a3000 	subgt	r3, sl, #0
    4540:	0700000c 	streq	r0, [r0, -ip]
    4544:	003c3129 	eorseq	r3, ip, r9, lsr #2
    4548:	03050100 	movweq	r0, #20736	; 0x5100
    454c:	30006bce 	andcc	r6, r0, lr, asr #23
    4550:	000aea4a 	andeq	lr, sl, sl, asr #20
    4554:	312b0700 	teqcc	fp, r0, lsl #14
    4558:	0100003c 	tsteq	r0, ip, lsr r0
    455c:	6bd00305 	blvs	ff405178 <rEINTPEND+0xa94050d0>
    4560:	a34a3000 	movtge	r3, #40960	; 0xa000
    4564:	0700000b 	streq	r0, [r0, -fp]
    4568:	003c312c 	eorseq	r3, ip, ip, lsr #2
    456c:	03050100 	movweq	r0, #20736	; 0x5100
    4570:	30006bd2 	ldrdcc	r6, [r0], -r2
    4574:	0005904a 	andeq	r9, r5, sl, asr #32
    4578:	312d0700 	teqcc	sp, r0, lsl #14
    457c:	0100003c 	tsteq	r0, ip, lsr r0
    4580:	6bd40305 	blvs	ff50519c <rEINTPEND+0xa95050f4>
    4584:	c94a3000 	stmdbgt	sl, {ip, sp}^
    4588:	07000005 	streq	r0, [r0, -r5]
    458c:	003c3133 	eorseq	r3, ip, r3, lsr r1
    4590:	03050100 	movweq	r0, #20736	; 0x5100
    4594:	30006bd6 	ldrdcc	r6, [r0], -r6
    4598:	0005794a 	andeq	r7, r5, sl, asr #18
    459c:	31340700 	teqcc	r4, r0, lsl #14
    45a0:	0100003c 	tsteq	r0, ip, lsr r0
    45a4:	6bd80305 	blvs	ff6051c0 <rEINTPEND+0xa9605118>
    45a8:	794a3000 	stmdbvc	sl, {ip, sp}^
    45ac:	0700000a 	streq	r0, [r0, -sl]
    45b0:	003c3136 	eorseq	r3, ip, r6, lsr r1
    45b4:	03050100 	movweq	r0, #20736	; 0x5100
    45b8:	30006bda 	ldrdcc	r6, [r0], -sl
    45bc:	0005704a 	andeq	r7, r5, sl, asr #32
    45c0:	31380700 	teqcc	r8, r0, lsl #14
    45c4:	0100003c 	tsteq	r0, ip, lsr r0
    45c8:	6bdc0305 	blvs	ff7051e4 <rEINTPEND+0xa970513c>
    45cc:	2e4a3000 	cdpcs	0, 4, cr3, cr10, cr0, {0}
    45d0:	07000011 	smladeq	r0, r1, r0, r0
    45d4:	003c313a 	eorseq	r3, ip, sl, lsr r1
    45d8:	03050100 	movweq	r0, #20736	; 0x5100
    45dc:	30006bde 	ldrdcc	r6, [r0], -lr
    45e0:	0007784a 	andeq	r7, r7, sl, asr #16
    45e4:	313b0700 	teqcc	fp, r0, lsl #14
    45e8:	0100003c 	tsteq	r0, ip, lsr r0
    45ec:	6be00305 	blvs	ff805208 <rEINTPEND+0xa9805160>
    45f0:	ce4a3000 	cdpgt	0, 4, cr3, cr10, cr0, {0}
    45f4:	07000007 	streq	r0, [r0, -r7]
    45f8:	003c313c 	eorseq	r3, ip, ip, lsr r1
    45fc:	03050100 	movweq	r0, #20736	; 0x5100
    4600:	30006be2 	andcc	r6, r0, r2, ror #23
    4604:	000a484a 	andeq	r4, sl, sl, asr #16
    4608:	313e0700 	teqcc	lr, r0, lsl #14
    460c:	0100003c 	tsteq	r0, ip, lsr r0
    4610:	6be40305 	blvs	ff90522c <rEINTPEND+0xa9905184>
    4614:	874a3000 	strbhi	r3, [sl, -r0]
    4618:	0700000b 	streq	r0, [r0, -fp]
    461c:	003c313f 	eorseq	r3, ip, pc, lsr r1
    4620:	03050100 	movweq	r0, #20736	; 0x5100
    4624:	30006be6 	andcc	r6, r0, r6, ror #23
    4628:	000db94a 	andeq	fp, sp, sl, asr #18
    462c:	31440700 	cmpcc	r4, r0, lsl #14
    4630:	0100003c 	tsteq	r0, ip, lsr r0
    4634:	6be80305 	blvs	ffa05250 <rEINTPEND+0xa9a051a8>
    4638:	b84a3000 	stmdalt	sl, {ip, sp}^
    463c:	0700000b 	streq	r0, [r0, -fp]
    4640:	003c3146 	eorseq	r3, ip, r6, asr #2
    4644:	03050100 	movweq	r0, #20736	; 0x5100
    4648:	30006bea 	andcc	r6, r0, sl, ror #23
    464c:	0008564a 	andeq	r5, r8, sl, asr #12
    4650:	31480700 	cmpcc	r8, r0, lsl #14
    4654:	0100003c 	tsteq	r0, ip, lsr r0
    4658:	6bec0305 	blvs	ffb05274 <rEINTPEND+0xa9b051cc>
    465c:	414a3000 	cmpmi	sl, r0
    4660:	07000004 	streq	r0, [r0, -r4]
    4664:	003c3149 	eorseq	r3, ip, r9, asr #2
    4668:	03050100 	movweq	r0, #20736	; 0x5100
    466c:	30006bee 	andcc	r6, r0, lr, ror #23
    4670:	00053c4a 	andeq	r3, r5, sl, asr #24
    4674:	314b0700 	cmpcc	fp, r0, lsl #14
    4678:	0100003c 	tsteq	r0, ip, lsr r0
    467c:	6bf00305 	blvs	ffc05298 <rEINTPEND+0xa9c051f0>
    4680:	eb4a3000 	bl	1290688 <MEM_SIZE+0xa90688>
    4684:	0700000f 	streq	r0, [r0, -pc]
    4688:	003c3150 	eorseq	r3, ip, r0, asr r1
    468c:	03050100 	movweq	r0, #20736	; 0x5100
    4690:	30006bf2 	strdcc	r6, [r0], -r2
    4694:	0004204a 	andeq	r2, r4, sl, asr #32
    4698:	31520700 	cmpcc	r2, r0, lsl #14
    469c:	0100003c 	tsteq	r0, ip, lsr r0
    46a0:	6bf40305 	blvs	ffd052bc <rEINTPEND+0xa9d05214>
    46a4:	104a3000 	subne	r3, sl, r0
    46a8:	07000003 	streq	r0, [r0, -r3]
    46ac:	003c3154 	eorseq	r3, ip, r4, asr r1
    46b0:	03050100 	movweq	r0, #20736	; 0x5100
    46b4:	30006bf6 	strdcc	r6, [r0], -r6
    46b8:	0003b84a 	andeq	fp, r3, sl, asr #16
    46bc:	31560700 	cmpcc	r6, r0, lsl #14
    46c0:	0100003c 	tsteq	r0, ip, lsr r0
    46c4:	6bf80305 	blvs	ffe052e0 <rEINTPEND+0xa9e05238>
    46c8:	044a3000 	strbeq	r3, [sl]
    46cc:	07000006 	streq	r0, [r0, -r6]
    46d0:	003c3157 	eorseq	r3, ip, r7, asr r1
    46d4:	03050100 	movweq	r0, #20736	; 0x5100
    46d8:	30006bfa 	strdcc	r6, [r0], -sl
    46dc:	0003fe4a 	andeq	pc, r3, sl, asr #28
    46e0:	31580700 	cmpcc	r8, r0, lsl #14
    46e4:	0100003c 	tsteq	r0, ip, lsr r0
    46e8:	6bfc0305 	blvs	fff05304 <rEINTPEND+0xa9f0525c>
    46ec:	684a3000 	stmdavs	sl, {ip, sp}^
    46f0:	07000011 	smladeq	r0, r1, r0, r0
    46f4:	003c3159 	eorseq	r3, ip, r9, asr r1
    46f8:	03050100 	movweq	r0, #20736	; 0x5100
    46fc:	30006bfe 	strdcc	r6, [r0], -lr
    4700:	00025d4a 	andeq	r5, r2, sl, asr #26
    4704:	315a0700 	cmpcc	sl, r0, lsl #14
    4708:	0100003c 	tsteq	r0, ip, lsr r0
    470c:	6c000305 	stcvs	3, cr0, [r0], {5}
    4710:	794a3000 	stmdbvc	sl, {ip, sp}^
    4714:	07000003 	streq	r0, [r0, -r3]
    4718:	003c315b 	eorseq	r3, ip, fp, asr r1
    471c:	03050100 	movweq	r0, #20736	; 0x5100
    4720:	30006c02 	andcc	r6, r0, r2, lsl #24
    4724:	0009a64a 	andeq	sl, r9, sl, asr #12
    4728:	315c0700 	cmpcc	ip, r0, lsl #14
    472c:	0100003c 	tsteq	r0, ip, lsr r0
    4730:	6c040305 	stcvs	3, cr0, [r4], {5}
    4734:	8f4a3000 	svchi	0x004a3000
    4738:	0700000d 	streq	r0, [r0, -sp]
    473c:	003c315d 	eorseq	r3, ip, sp, asr r1
    4740:	03050100 	movweq	r0, #20736	; 0x5100
    4744:	30006c06 	andcc	r6, r0, r6, lsl #24
    4748:	000e064a 	andeq	r0, lr, sl, asr #12
    474c:	315e0700 	cmpcc	lr, r0, lsl #14
    4750:	0100003c 	tsteq	r0, ip, lsr r0
    4754:	6c080305 	stcvs	3, cr0, [r8], {5}
    4758:	514a3000 	cmppl	sl, r0
    475c:	0700000f 	streq	r0, [r0, -pc]
    4760:	003c315f 	eorseq	r3, ip, pc, asr r1
    4764:	03050100 	movweq	r0, #20736	; 0x5100
    4768:	30006c0a 	andcc	r6, r0, sl, lsl #24
    476c:	0002014a 	andeq	r0, r2, sl, asr #2
    4770:	31600700 	cmncc	r0, r0, lsl #14
    4774:	0100003c 	tsteq	r0, ip, lsr r0
    4778:	6c0c0305 	stcvs	3, cr0, [ip], {5}
    477c:	0a4a3000 	beq	1290784 <MEM_SIZE+0xa90784>
    4780:	07000004 	streq	r0, [r0, -r4]
    4784:	003c3162 	eorseq	r3, ip, r2, ror #2
    4788:	03050100 	movweq	r0, #20736	; 0x5100
    478c:	30006c0e 	andcc	r6, r0, lr, lsl #24
    4790:	0012624a 	andseq	r6, r2, sl, asr #4
    4794:	31630700 	cmncc	r3, r0, lsl #14
    4798:	0100003c 	tsteq	r0, ip, lsr r0
    479c:	6c100305 	ldcvs	3, cr0, [r0], {5}
    47a0:	c24a3000 	subgt	r3, sl, #0
    47a4:	07000012 	smladeq	r0, r2, r0, r0
    47a8:	003c3164 	eorseq	r3, ip, r4, ror #2
    47ac:	03050100 	movweq	r0, #20736	; 0x5100
    47b0:	30006c12 	andcc	r6, r0, r2, lsl ip
    47b4:	000c5d4a 	andeq	r5, ip, sl, asr #26
    47b8:	31650700 	cmncc	r5, r0, lsl #14
    47bc:	0100003c 	tsteq	r0, ip, lsr r0
    47c0:	6c140305 	ldcvs	3, cr0, [r4], {5}
    47c4:	c44a3000 	strbgt	r3, [sl]
    47c8:	07000006 	streq	r0, [r0, -r6]
    47cc:	003c3166 	eorseq	r3, ip, r6, ror #2
    47d0:	03050100 	movweq	r0, #20736	; 0x5100
    47d4:	30006c16 	andcc	r6, r0, r6, lsl ip
    47d8:	0006454a 	andeq	r4, r6, sl, asr #10
    47dc:	31680700 	cmncc	r8, r0, lsl #14
    47e0:	0100003c 	tsteq	r0, ip, lsr r0
    47e4:	6c180305 	ldcvs	3, cr0, [r8], {5}
    47e8:	de4a3000 	cdple	0, 4, cr3, cr10, cr0, {0}
    47ec:	0700000a 	streq	r0, [r0, -sl]
    47f0:	003c3169 	eorseq	r3, ip, r9, ror #2
    47f4:	03050100 	movweq	r0, #20736	; 0x5100
    47f8:	30006c1a 	andcc	r6, r0, sl, lsl ip
    47fc:	0012d04a 	andseq	sp, r2, sl, asr #32
    4800:	316a0700 	cmncc	sl, r0, lsl #14
    4804:	0100003c 	tsteq	r0, ip, lsr r0
    4808:	6c1c0305 	ldcvs	3, cr0, [ip], {5}
    480c:	9c4a3000 	marls	acc0, r3, sl
    4810:	07000005 	streq	r0, [r0, -r5]
    4814:	003c316b 	eorseq	r3, ip, fp, ror #2
    4818:	03050100 	movweq	r0, #20736	; 0x5100
    481c:	30006c1e 	andcc	r6, r0, lr, lsl ip
    4820:	000ab14a 	andeq	fp, sl, sl, asr #2
    4824:	316c0700 	cmncc	ip, r0, lsl #14
    4828:	0100003c 	tsteq	r0, ip, lsr r0
    482c:	6c200305 	stcvs	3, cr0, [r0], #-20	; 0xffffffec
    4830:	ef4a3000 	svc	0x004a3000
    4834:	0700000e 	streq	r0, [r0, -lr]
    4838:	003c316f 	eorseq	r3, ip, pc, ror #2
    483c:	03050100 	movweq	r0, #20736	; 0x5100
    4840:	30006c22 	andcc	r6, r0, r2, lsr #24
    4844:	0007fa4a 	andeq	pc, r7, sl, asr #20
    4848:	31700700 	cmncc	r0, r0, lsl #14
    484c:	0100003c 	tsteq	r0, ip, lsr r0
    4850:	6c240305 	stcvs	3, cr0, [r4], #-20	; 0xffffffec
    4854:	8a4a3000 	bhi	129085c <MEM_SIZE+0xa9085c>
    4858:	0700000e 	streq	r0, [r0, -lr]
    485c:	003c3171 	eorseq	r3, ip, r1, ror r1
    4860:	03050100 	movweq	r0, #20736	; 0x5100
    4864:	30006c26 	andcc	r6, r0, r6, lsr #24
    4868:	0004da4a 	andeq	sp, r4, sl, asr #20
    486c:	31720700 	cmncc	r2, r0, lsl #14
    4870:	0100003c 	tsteq	r0, ip, lsr r0
    4874:	6c280305 	stcvs	3, cr0, [r8], #-20	; 0xffffffec
    4878:	5c4a3000 	marpl	acc0, r3, sl
    487c:	0700000d 	streq	r0, [r0, -sp]
    4880:	003c3185 	eorseq	r3, ip, r5, lsl #3
    4884:	03050100 	movweq	r0, #20736	; 0x5100
    4888:	30006c2a 	andcc	r6, r0, sl, lsr #24
    488c:	00013200 	andeq	r3, r1, r0, lsl #4
    4890:	1e000200 	cdpne	2, 0, cr0, cr0, cr0, {0}
    4894:	04000009 	streq	r0, [r0], #-9
    4898:	00008f01 	andeq	r8, r0, r1, lsl #30
    489c:	134b0100 	movtne	r0, #45312	; 0xb100
    48a0:	00260000 	eoreq	r0, r6, r0
    48a4:	618c0000 	orrvs	r0, ip, r0
    48a8:	625c3000 	subsvs	r3, ip, #0
    48ac:	192e3000 	stmdbne	lr!, {ip, sp}
    48b0:	01020000 	tsteq	r2, r0
    48b4:	00006208 	andeq	r6, r0, r8, lsl #4
    48b8:	07020200 	streq	r0, [r2, -r0, lsl #4]
    48bc:	00000070 	andeq	r0, r0, r0, ror r0
    48c0:	76070402 	strvc	r0, [r7], -r2, lsl #8
    48c4:	02000000 	andeq	r0, r0, #0
    48c8:	006b0801 	rsbeq	r0, fp, r1, lsl #16
    48cc:	d5030000 	strle	r0, [r3]
    48d0:	0200000d 	andeq	r0, r0, #13
    48d4:	00003311 	andeq	r3, r0, r1, lsl r3
    48d8:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    48dc:	01060704 	tsteq	r6, r4, lsl #14
    48e0:	00001332 	andeq	r1, r0, r2, lsr r3
    48e4:	618c2f01 	orrvs	r2, ip, r1, lsl #30
    48e8:	62083000 	andvs	r3, r8, #0
    48ec:	44b63000 	ldrtmi	r3, [r6]
    48f0:	6d070000 	stcvs	0, cr0, [r7]
    48f4:	01000013 	tsteq	r0, r3, lsl r0
    48f8:	62080123 	andvs	r0, r8, #-1073741816	; 0xc0000008
    48fc:	62243000 	eorvs	r3, r4, #0
    4900:	44d53000 	ldrbmi	r3, [r5]
    4904:	008d0000 	addeq	r0, sp, r0
    4908:	9e080000 	cdpls	0, 0, cr0, cr8, cr0, {0}
    490c:	0100000f 	tsteq	r0, pc
    4910:	00004c23 	andeq	r4, r0, r3, lsr #24
    4914:	0044f400 	subeq	pc, r4, r0, lsl #8
    4918:	62070000 	andvs	r0, r7, #0
    491c:	01000013 	tsteq	r0, r3, lsl r0
    4920:	62240117 	eorvs	r0, r4, #-1073741819	; 0xc0000005
    4924:	62403000 	subvs	r3, r0, #0
    4928:	45073000 	strmi	r3, [r7]
    492c:	00b50000 	adcseq	r0, r5, r0
    4930:	9e080000 	cdpls	0, 0, cr0, cr8, cr0, {0}
    4934:	0100000f 	tsteq	r0, pc
    4938:	00004c17 	andeq	r4, r0, r7, lsl ip
    493c:	00452600 	subeq	r2, r5, r0, lsl #12
    4940:	57070000 	strpl	r0, [r7, -r0]
    4944:	01000013 	tsteq	r0, r3, lsl r0
    4948:	6240010c 	subvs	r0, r0, #3
    494c:	625c3000 	subsvs	r3, ip, #0
    4950:	45393000 	ldrmi	r3, [r9]!
    4954:	00dd0000 	sbcseq	r0, sp, r0
    4958:	9e080000 	cdpls	0, 0, cr0, cr8, cr0, {0}
    495c:	0100000f 	tsteq	r0, pc
    4960:	00004c0c 	andeq	r4, r0, ip, lsl #24
    4964:	00455800 	subeq	r5, r5, r0, lsl #16
    4968:	41090000 	tstmi	r9, r0
    496c:	ee000000 	cdp	0, 0, cr0, cr0, cr0, {0}
    4970:	0a000000 	beq	4978 <DISABLE_IRQ+0x48f8>
    4974:	0000004e 	andeq	r0, r0, lr, asr #32
    4978:	0b0003ff 	bleq	597c <DISABLE_IRQ+0x58fc>
    497c:	0000133c 	andeq	r1, r0, ip, lsr r3
    4980:	00dd0801 	sbcseq	r0, sp, r1, lsl #16
    4984:	03050000 	movweq	r0, #20480	; 0x5000
    4988:	30006ea4 	andcc	r6, r0, r4, lsr #29
    498c:	0013410b 	andseq	r4, r3, fp, lsl #2
    4990:	dd090100 	stfles	f0, [r9]
    4994:	05000000 	streq	r0, [r0]
    4998:	007ea403 	rsbseq	sl, lr, r3, lsl #8
    499c:	13460b30 	movtne	r0, #27440	; 0x6b30
    49a0:	0a010000 	beq	449a8 <DISABLE_IRQ+0x44928>
    49a4:	000000dd 	ldrdeq	r0, [r0], -sp
    49a8:	8ea40305 	cdphi	3, 10, cr0, cr4, cr5, {0}
    49ac:	830c3000 	movwhi	r3, #49152	; 0xc000
    49b0:	01000000 	tsteq	r0, r0
    49b4:	00012e04 	andeq	r2, r1, r4, lsl #28
    49b8:	0d010100 	stfeqs	f0, [r1]
    49bc:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    49c0:	c8000074 	stmdagt	r0, {r2, r4, r5, r6}
    49c4:	02000001 	andeq	r0, r0, #1
    49c8:	0009ce00 	andeq	ip, r9, r0, lsl #28
    49cc:	8f010400 	svchi	0x00010400
    49d0:	01000000 	tsteq	r0, r0
    49d4:	00001378 	andeq	r1, r0, r8, ror r3
    49d8:	00000026 	andeq	r0, r0, r6, lsr #32
    49dc:	3000625c 	andcc	r6, r0, ip, asr r2
    49e0:	30006350 	andcc	r6, r0, r0, asr r3
    49e4:	00001991 	muleq	r0, r1, r9
    49e8:	000c0d02 	andeq	r0, ip, r2, lsl #26
    49ec:	30090200 	andcc	r0, r9, r0, lsl #4
    49f0:	03000000 	movweq	r0, #0
    49f4:	00620801 	rsbeq	r0, r2, r1, lsl #16
    49f8:	4b020000 	blmi	84a00 <DISABLE_IRQ+0x84980>
    49fc:	02000002 	andeq	r0, r0, #2
    4a00:	0000420a 	andeq	r4, r0, sl, lsl #4
    4a04:	07020300 	streq	r0, [r2, -r0, lsl #6]
    4a08:	00000070 	andeq	r0, r0, r0, ror r0
    4a0c:	76070403 	strvc	r0, [r7], -r3, lsl #8
    4a10:	03000000 	movweq	r0, #0
    4a14:	006b0801 	rsbeq	r0, fp, r1, lsl #16
    4a18:	d5020000 	strle	r0, [r2]
    4a1c:	0200000d 	andeq	r0, r0, #13
    4a20:	00004911 	andeq	r4, r0, r1, lsl r9
    4a24:	0cb90400 	cfldrseq	mvf0, [r9]
    4a28:	03240000 	teqeq	r4, #0
    4a2c:	00ca0139 	sbceq	r0, sl, r9, lsr r1
    4a30:	9e050000 	cdpls	0, 0, cr0, cr5, cr0, {0}
    4a34:	03000011 	movweq	r0, #17
    4a38:	0025013a 	eoreq	r0, r5, sl, lsr r1
    4a3c:	23020000 	movwcs	r0, #8192	; 0x2000
    4a40:	10860500 	addne	r0, r6, r0, lsl #10
    4a44:	3b030000 	blcc	c4a4c <DISABLE_IRQ+0xc49cc>
    4a48:	0000ca01 	andeq	ip, r0, r1, lsl #20
    4a4c:	04230200 	strteq	r0, [r3], #-512	; 0x200
    4a50:	0006ff05 	andeq	pc, r6, r5, lsl #30
    4a54:	013c0300 	teqeq	ip, r0, lsl #6
    4a58:	00000037 	andeq	r0, r0, r7, lsr r0
    4a5c:	05082302 	streq	r2, [r8, #-770]	; 0x302
    4a60:	00000448 	andeq	r0, r0, r8, asr #8
    4a64:	25013e03 	strcs	r3, [r1, #-3587]	; 0xe03
    4a68:	02000000 	andeq	r0, r0, #0
    4a6c:	33050a23 	movwcc	r0, #23075	; 0x5a23
    4a70:	03000006 	movweq	r0, #6
    4a74:	00cc013f 	sbceq	r0, ip, pc, lsr r1
    4a78:	23020000 	movwcs	r0, #8192	; 0x2000
    4a7c:	0ef9050b 	cdpeq	5, 15, cr0, cr9, cr11, {0}
    4a80:	46030000 	strmi	r0, [r3], -r0
    4a84:	0000df01 	andeq	sp, r0, r1, lsl #30
    4a88:	13230200 	teqne	r3, #0
    4a8c:	07040600 	streq	r0, [r4, -r0, lsl #12]
    4a90:	00000025 	andeq	r0, r0, r5, lsr #32
    4a94:	000000dc 	ldrdeq	r0, [r0], -ip
    4a98:	0000dc08 	andeq	sp, r0, r8, lsl #24
    4a9c:	09000700 	stmdbeq	r0, {r8, r9, sl}
    4aa0:	25070704 	strcs	r0, [r7, #-1796]	; 0x704
    4aa4:	ef000000 	svc	0x00000000
    4aa8:	08000000 	stmdaeq	r0, {}
    4aac:	000000dc 	ldrdeq	r0, [r0], -ip
    4ab0:	460a000f 	strmi	r0, [sl], -pc
    4ab4:	03000003 	movweq	r0, #3
    4ab8:	00620148 	rsbeq	r0, r2, r8, asr #2
    4abc:	040b0000 	streq	r0, [fp]
    4ac0:	000000ef 	andeq	r0, r0, pc, ror #1
    4ac4:	1383010c 	orrne	r0, r3, #3
    4ac8:	2c010000 	stccs	0, cr0, [r1], {0}
    4acc:	3000625c 	andcc	r6, r0, ip, asr r2
    4ad0:	300062e8 	andcc	r6, r0, r8, ror #5
    4ad4:	0000456b 	andeq	r4, r0, fp, ror #10
    4ad8:	0013620d 	andseq	r6, r3, sp, lsl #4
    4adc:	011d0100 	tsteq	sp, r0, lsl #2
    4ae0:	300062e8 	andcc	r6, r0, r8, ror #5
    4ae4:	30006314 	andcc	r6, r0, r4, lsl r3
    4ae8:	0000458a 	andeq	r4, r0, sl, lsl #11
    4aec:	0000013d 	andeq	r0, r0, sp, lsr r1
    4af0:	000f9e0e 	andeq	r9, pc, lr, lsl #28
    4af4:	ca1d0100 	bgt	744efc <DISABLE_IRQ+0x744e7c>
    4af8:	a9000000 	stmdbge	r0, {}
    4afc:	00000045 	andeq	r0, r0, r5, asr #32
    4b00:	0013570d 	andseq	r5, r3, sp, lsl #14
    4b04:	010e0100 	tsteq	lr, r0, lsl #2
    4b08:	30006314 	andcc	r6, r0, r4, lsl r3
    4b0c:	30006350 	andcc	r6, r0, r0, asr r3
    4b10:	000045bc 	undefined instruction 0x000045bc
    4b14:	00000173 	andeq	r0, r0, r3, ror r1
    4b18:	000f9e0e 	andeq	r9, pc, lr, lsl #28
    4b1c:	ca0e0100 	bgt	384f24 <DISABLE_IRQ+0x384ea4>
    4b20:	e7000000 	str	r0, [r0, -r0]
    4b24:	0f000045 	svceq	0x00000045
    4b28:	00727265 	rsbseq	r7, r2, r5, ror #4
    4b2c:	00251001 	eoreq	r1, r5, r1
    4b30:	91020000 	tstls	r2, r0
    4b34:	5707006f 	strpl	r0, [r7, -pc, rrx]
    4b38:	84000000 	strhi	r0, [r0]
    4b3c:	10000001 	andne	r0, r0, r1
    4b40:	000000dc 	ldrdeq	r0, [r0], -ip
    4b44:	110007ff 	strdne	r0, [r0, -pc]
    4b48:	0000133c 	andeq	r1, r0, ip, lsr r3
    4b4c:	01730801 	cmneq	r3, r1, lsl #16
    4b50:	03050000 	movweq	r0, #20480	; 0x5000
    4b54:	30009ea8 	andcc	r9, r0, r8, lsr #29
    4b58:	00134111 	andseq	r4, r3, r1, lsl r1
    4b5c:	730a0100 	movwvc	r0, #41216	; 0xa100
    4b60:	05000001 	streq	r0, [r0, #-1]
    4b64:	00bea803 	adcseq	sl, lr, r3, lsl #16
    4b68:	138c1130 	orrne	r1, ip, #12
    4b6c:	0c010000 	stceq	0, cr0, [r1], {0}
    4b70:	000000fb 	strdeq	r0, [r0], -fp
    4b74:	9ea40305 	cdpls	3, 10, cr0, cr4, cr5, {0}
    4b78:	83123000 	tsthi	r2, #0
    4b7c:	01000000 	tsteq	r0, r0
    4b80:	0001c404 	andeq	ip, r1, r4, lsl #8
    4b84:	13010100 	movwne	r0, #4352	; 0x1100
    4b88:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    4b8c:	db000074 	blle	4d64 <DISABLE_IRQ+0x4ce4>
    4b90:	02000001 	andeq	r0, r0, #1
    4b94:	000aca00 	andeq	ip, sl, r0, lsl #20
    4b98:	8f010400 	svchi	0x00010400
    4b9c:	01000000 	tsteq	r0, r0
    4ba0:	00001392 	muleq	r0, r2, r3
    4ba4:	00000026 	andeq	r0, r0, r6, lsr #32
    4ba8:	30006350 	andcc	r6, r0, r0, asr r3
    4bac:	30006450 	andcc	r6, r0, r0, asr r4
    4bb0:	00001a01 	andeq	r1, r0, r1, lsl #20
    4bb4:	000c0d02 	andeq	r0, ip, r2, lsl #26
    4bb8:	30090200 	andcc	r0, r9, r0, lsl #4
    4bbc:	03000000 	movweq	r0, #0
    4bc0:	00620801 	rsbeq	r0, r2, r1, lsl #16
    4bc4:	4b020000 	blmi	84bcc <DISABLE_IRQ+0x84b4c>
    4bc8:	02000002 	andeq	r0, r0, #2
    4bcc:	0000420a 	andeq	r4, r0, sl, lsl #4
    4bd0:	07020300 	streq	r0, [r2, -r0, lsl #6]
    4bd4:	00000070 	andeq	r0, r0, r0, ror r0
    4bd8:	76070403 	strvc	r0, [r7], -r3, lsl #8
    4bdc:	03000000 	movweq	r0, #0
    4be0:	006b0801 	rsbeq	r0, fp, r1, lsl #16
    4be4:	d5020000 	strle	r0, [r2]
    4be8:	0200000d 	andeq	r0, r0, #13
    4bec:	00004911 	andeq	r4, r0, r1, lsl r9
    4bf0:	0cb90400 	cfldrseq	mvf0, [r9]
    4bf4:	03240000 	teqeq	r4, #0
    4bf8:	00ca0139 	sbceq	r0, sl, r9, lsr r1
    4bfc:	9e050000 	cdpls	0, 0, cr0, cr5, cr0, {0}
    4c00:	03000011 	movweq	r0, #17
    4c04:	0025013a 	eoreq	r0, r5, sl, lsr r1
    4c08:	23020000 	movwcs	r0, #8192	; 0x2000
    4c0c:	10860500 	addne	r0, r6, r0, lsl #10
    4c10:	3b030000 	blcc	c4c18 <DISABLE_IRQ+0xc4b98>
    4c14:	0000ca01 	andeq	ip, r0, r1, lsl #20
    4c18:	04230200 	strteq	r0, [r3], #-512	; 0x200
    4c1c:	0006ff05 	andeq	pc, r6, r5, lsl #30
    4c20:	013c0300 	teqeq	ip, r0, lsl #6
    4c24:	00000037 	andeq	r0, r0, r7, lsr r0
    4c28:	05082302 	streq	r2, [r8, #-770]	; 0x302
    4c2c:	00000448 	andeq	r0, r0, r8, asr #8
    4c30:	25013e03 	strcs	r3, [r1, #-3587]	; 0xe03
    4c34:	02000000 	andeq	r0, r0, #0
    4c38:	33050a23 	movwcc	r0, #23075	; 0x5a23
    4c3c:	03000006 	movweq	r0, #6
    4c40:	00cc013f 	sbceq	r0, ip, pc, lsr r1
    4c44:	23020000 	movwcs	r0, #8192	; 0x2000
    4c48:	0ef9050b 	cdpeq	5, 15, cr0, cr9, cr11, {0}
    4c4c:	46030000 	strmi	r0, [r3], -r0
    4c50:	0000df01 	andeq	sp, r0, r1, lsl #30
    4c54:	13230200 	teqne	r3, #0
    4c58:	07040600 	streq	r0, [r4, -r0, lsl #12]
    4c5c:	00000025 	andeq	r0, r0, r5, lsr #32
    4c60:	000000dc 	ldrdeq	r0, [r0], -ip
    4c64:	0000dc08 	andeq	sp, r0, r8, lsl #24
    4c68:	09000700 	stmdbeq	r0, {r8, r9, sl}
    4c6c:	25070704 	strcs	r0, [r7, #-1796]	; 0x704
    4c70:	ef000000 	svc	0x00000000
    4c74:	08000000 	stmdaeq	r0, {}
    4c78:	000000dc 	ldrdeq	r0, [r0], -ip
    4c7c:	460a000f 	strmi	r0, [sl], -pc
    4c80:	03000003 	movweq	r0, #3
    4c84:	00620148 	rsbeq	r0, r2, r8, asr #2
    4c88:	040b0000 	streq	r0, [fp]
    4c8c:	000000ef 	andeq	r0, r0, pc, ror #1
    4c90:	139f010c 	orrsne	r0, pc, #3
    4c94:	2b010000 	blcs	44c9c <DISABLE_IRQ+0x44c1c>
    4c98:	30006350 	andcc	r6, r0, r0, asr r3
    4c9c:	300063e8 	andcc	r6, r0, r8, ror #7
    4ca0:	000045fa 	strdeq	r4, [r0], -sl
    4ca4:	00000128 	andeq	r0, r0, r8, lsr #2
    4ca8:	7272650d 	rsbsvc	r6, r2, #54525952	; 0x3400000
    4cac:	252d0100 	strcs	r0, [sp, #-256]!	; 0x100
    4cb0:	02000000 	andeq	r0, r0, #0
    4cb4:	0e007791 	mcreq	7, 0, r7, cr0, cr1, {4}
    4cb8:	00001362 	andeq	r1, r0, r2, ror #6
    4cbc:	e8011c01 	stmda	r1, {r0, sl, fp, ip}
    4cc0:	14300063 	ldrtne	r0, [r0], #-99	; 0x63
    4cc4:	25300064 	ldrcs	r0, [r0, #-100]!	; 0x64
    4cc8:	50000046 	andpl	r0, r0, r6, asr #32
    4ccc:	0f000001 	svceq	0x00000001
    4cd0:	00000f9e 	muleq	r0, lr, pc
    4cd4:	00ca1c01 	sbceq	r1, sl, r1, lsl #24
    4cd8:	46440000 	strbmi	r0, [r4], -r0
    4cdc:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4ce0:	00001357 	andeq	r1, r0, r7, asr r3
    4ce4:	14010d01 	strne	r0, [r1], #-3329	; 0xd01
    4ce8:	50300064 	eorspl	r0, r0, r4, rrx
    4cec:	57300064 	ldrpl	r0, [r0, -r4, rrx]!
    4cf0:	86000046 	strhi	r0, [r0], -r6, asr #32
    4cf4:	0f000001 	svceq	0x00000001
    4cf8:	00000f9e 	muleq	r0, lr, pc
    4cfc:	00ca0d01 	sbceq	r0, sl, r1, lsl #26
    4d00:	46820000 	strmi	r0, [r2], r0
    4d04:	650d0000 	strvs	r0, [sp]
    4d08:	01007272 	tsteq	r0, r2, ror r2
    4d0c:	0000250f 	andeq	r2, r0, pc, lsl #10
    4d10:	6f910200 	svcvs	0x00910200
    4d14:	00570700 	subseq	r0, r7, r0, lsl #14
    4d18:	01970000 	orrseq	r0, r7, r0
    4d1c:	dc100000 	ldcle	0, cr0, [r0], {0}
    4d20:	ff000000 	undefined instruction 0xff000000
    4d24:	3c110007 	ldccc	0, cr0, [r1], {7}
    4d28:	01000013 	tsteq	r0, r3, lsl r0
    4d2c:	00018608 	andeq	r8, r1, r8, lsl #12
    4d30:	ac030500 	cfstr32ge	mvfx0, [r3], {0}
    4d34:	113000de 	ldrsbne	r0, [r0, -lr]!
    4d38:	00001341 	andeq	r1, r0, r1, asr #6
    4d3c:	01860901 	orreq	r0, r6, r1, lsl #18
    4d40:	03050000 	movweq	r0, #20480	; 0x5000
    4d44:	3000feac 	andcc	pc, r0, ip, lsr #29
    4d48:	0013aa11 	andseq	sl, r3, r1, lsl sl
    4d4c:	fb0b0100 	blx	2c5156 <DISABLE_IRQ+0x2c50d6>
    4d50:	05000000 	streq	r0, [r0]
    4d54:	00dea803 	sbcseq	sl, lr, r3, lsl #16
    4d58:	00831230 	addeq	r1, r3, r0, lsr r2
    4d5c:	04010000 	streq	r0, [r1]
    4d60:	000001d7 	ldrdeq	r0, [r0], -r7
    4d64:	04130101 	ldreq	r0, [r3], #-257	; 0x101
    4d68:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    4d6c:	01f50000 	mvnseq	r0, r0
    4d70:	00020000 	andeq	r0, r2, r0
    4d74:	00000bc8 	andeq	r0, r0, r8, asr #23
    4d78:	008f0104 	addeq	r0, pc, r4, lsl #2
    4d7c:	b2010000 	andlt	r0, r1, #0
    4d80:	26000013 	undefined instruction 0x26000013
    4d84:	50000000 	andpl	r0, r0, r0
    4d88:	68300064 	ldmdavs	r0!, {r2, r5, r6}
    4d8c:	73300065 	teqvc	r0, #101	; 0x65
    4d90:	0200001a 	andeq	r0, r0, #26
    4d94:	00000c0d 	andeq	r0, r0, sp, lsl #24
    4d98:	00300902 	eorseq	r0, r0, r2, lsl #18
    4d9c:	01030000 	tsteq	r3, r0
    4da0:	00006208 	andeq	r6, r0, r8, lsl #4
    4da4:	024b0200 	subeq	r0, fp, #0
    4da8:	0a020000 	beq	84db0 <DISABLE_IRQ+0x84d30>
    4dac:	00000042 	andeq	r0, r0, r2, asr #32
    4db0:	70070203 	andvc	r0, r7, r3, lsl #4
    4db4:	02000000 	andeq	r0, r0, #0
    4db8:	00000b52 	andeq	r0, r0, r2, asr fp
    4dbc:	00540b02 	subseq	r0, r4, r2, lsl #22
    4dc0:	04030000 	streq	r0, [r3]
    4dc4:	00007607 	andeq	r7, r0, r7, lsl #12
    4dc8:	08010300 	stmdaeq	r1, {r8, r9}
    4dcc:	0000006b 	andeq	r0, r0, fp, rrx
    4dd0:	000dd502 	andeq	sp, sp, r2, lsl #10
    4dd4:	54110200 	ldrpl	r0, [r1], #-512	; 0x200
    4dd8:	04000000 	streq	r0, [r0]
    4ddc:	00000cb9 	undefined instruction 0x00000cb9
    4de0:	01390324 	teqeq	r9, r4, lsr #6
    4de4:	000000d5 	ldrdeq	r0, [r0], -r5
    4de8:	00119e05 	andseq	r9, r1, r5, lsl #28
    4dec:	013a0300 	teqeq	sl, r0, lsl #6
    4df0:	00000025 	andeq	r0, r0, r5, lsr #32
    4df4:	05002302 	streq	r2, [r0, #-770]	; 0x302
    4df8:	00001086 	andeq	r1, r0, r6, lsl #1
    4dfc:	d5013b03 	strle	r3, [r1, #-2819]	; 0xb03
    4e00:	02000000 	andeq	r0, r0, #0
    4e04:	ff050423 	undefined instruction 0xff050423
    4e08:	03000006 	movweq	r0, #6
    4e0c:	0037013c 	eorseq	r0, r7, ip, lsr r1
    4e10:	23020000 	movwcs	r0, #8192	; 0x2000
    4e14:	04480508 	strbeq	r0, [r8], #-1288	; 0x508
    4e18:	3e030000 	cdpcc	0, 0, cr0, cr3, cr0, {0}
    4e1c:	00002501 	andeq	r2, r0, r1, lsl #10
    4e20:	0a230200 	beq	8c5628 <MEM_SIZE+0xc5628>
    4e24:	00063305 	andeq	r3, r6, r5, lsl #6
    4e28:	013f0300 	teqeq	pc, r0, lsl #6
    4e2c:	000000d7 	ldrdeq	r0, [r0], -r7
    4e30:	050b2302 	streq	r2, [fp, #-770]	; 0x302
    4e34:	00000ef9 	strdeq	r0, [r0], -r9
    4e38:	ea014603 	b	5664c <DISABLE_IRQ+0x565cc>
    4e3c:	02000000 	andeq	r0, r0, #0
    4e40:	06001323 	streq	r1, [r0], -r3, lsr #6
    4e44:	00250704 	eoreq	r0, r5, r4, lsl #14
    4e48:	00e70000 	rsceq	r0, r7, r0
    4e4c:	e7080000 	str	r0, [r8, -r0]
    4e50:	07000000 	streq	r0, [r0, -r0]
    4e54:	07040900 	streq	r0, [r4, -r0, lsl #18]
    4e58:	00002507 	andeq	r2, r0, r7, lsl #10
    4e5c:	0000fa00 	andeq	pc, r0, r0, lsl #20
    4e60:	00e70800 	rsceq	r0, r7, r0, lsl #16
    4e64:	000f0000 	andeq	r0, pc, r0
    4e68:	0003460a 	andeq	r4, r3, sl, lsl #12
    4e6c:	01480300 	cmpeq	r8, r0, lsl #6
    4e70:	0000006d 	andeq	r0, r0, sp, rrx
    4e74:	00fa040b 	rscseq	r0, sl, fp, lsl #8
    4e78:	010c0000 	tsteq	ip, r0
    4e7c:	000013cc 	andeq	r1, r0, ip, asr #7
    4e80:	64502f01 	ldrbvs	r2, [r0], #-3841	; 0xf01
    4e84:	64dc3000 	ldrbvs	r3, [ip]
    4e88:	46953000 	ldrmi	r3, [r5], r0
    4e8c:	620d0000 	andvs	r0, sp, #0
    4e90:	01000013 	tsteq	r0, r3, lsl r0
    4e94:	64dc011f 	ldrbvs	r0, [ip], #287	; 0x11f
    4e98:	65283000 	strvs	r3, [r8]!
    4e9c:	46b43000 	ldrtmi	r3, [r4], r0
    4ea0:	01480000 	cmpeq	r8, r0
    4ea4:	9e0e0000 	cdpls	0, 0, cr0, cr14, cr0, {0}
    4ea8:	0100000f 	tsteq	r0, pc
    4eac:	0000d51f 	andeq	sp, r0, pc, lsl r5
    4eb0:	0046d300 	subeq	sp, r6, r0, lsl #6
    4eb4:	570d0000 	strpl	r0, [sp, -r0]
    4eb8:	01000013 	tsteq	r0, r3, lsl r0
    4ebc:	6528010f 	strvs	r0, [r8, #-271]!	; 0x10f
    4ec0:	65683000 	strbvs	r3, [r8]!
    4ec4:	46e63000 	strbtmi	r3, [r6], r0
    4ec8:	01890000 	orreq	r0, r9, r0
    4ecc:	9e0e0000 	cdpls	0, 0, cr0, cr14, cr0, {0}
    4ed0:	0100000f 	tsteq	r0, pc
    4ed4:	0000d50f 	andeq	sp, r0, pc, lsl #10
    4ed8:	00471100 	subeq	r1, r7, r0, lsl #2
    4edc:	72650f00 	rsbvc	r0, r5, #0
    4ee0:	11010072 	tstne	r1, r2, ror r0
    4ee4:	00000025 	andeq	r0, r0, r5, lsr #32
    4ee8:	106f9102 	rsbne	r9, pc, r2, lsl #2
    4eec:	000013be 	undefined instruction 0x000013be
    4ef0:	01891201 	orreq	r1, r9, r1, lsl #4
    4ef4:	0b000000 	bleq	4efc <DISABLE_IRQ+0x4e7c>
    4ef8:	00004904 	andeq	r4, r0, r4, lsl #18
    4efc:	00620700 	rsbeq	r0, r2, r0, lsl #14
    4f00:	01a00000 	moveq	r0, r0
    4f04:	e7110000 	ldr	r0, [r1, -r0]
    4f08:	ff000000 	undefined instruction 0xff000000
    4f0c:	3c120007 	ldccc	0, cr0, [r2], {7}
    4f10:	01000013 	tsteq	r0, r3, lsl r0
    4f14:	00018f08 	andeq	r8, r1, r8, lsl #30
    4f18:	b0030500 	andlt	r0, r3, r0, lsl #10
    4f1c:	1230011e 	eorsne	r0, r0, #-2147483641	; 0x80000007
    4f20:	00001341 	andeq	r1, r0, r1, asr #6
    4f24:	018f0901 	orreq	r0, pc, r1, lsl #18
    4f28:	03050000 	movweq	r0, #20480	; 0x5000
    4f2c:	30013eb0 	undefined instruction 0x30013eb0
    4f30:	0013c512 	andseq	ip, r3, r2, lsl r5
    4f34:	060b0100 	streq	r0, [fp], -r0, lsl #2
    4f38:	05000001 	streq	r0, [r0, #-1]
    4f3c:	011eac03 	tsteq	lr, r3, lsl #24
    4f40:	045a1230 	ldrbeq	r1, [sl], #-560	; 0x230
    4f44:	0d010000 	stceq	0, cr0, [r1]
    4f48:	00000049 	andeq	r0, r0, r9, asr #32
    4f4c:	5eb00305 	cdppl	3, 11, cr0, cr0, cr5, {0}
    4f50:	83133001 	tsthi	r3, #1
    4f54:	01000000 	tsteq	r0, r0
    4f58:	0001f104 	andeq	pc, r1, r4, lsl #2
    4f5c:	14010100 	strne	r0, [r1], #-256	; 0x100
    4f60:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    4f64:	48000074 	stmdami	r0, {r2, r4, r5, r6}
    4f68:	02000002 	andeq	r0, r0, #2
    4f6c:	000cd100 	andeq	sp, ip, r0, lsl #2
    4f70:	8f010400 	svchi	0x00010400
    4f74:	01000000 	tsteq	r0, r0
    4f78:	000013e7 	andeq	r1, r0, r7, ror #7
    4f7c:	00000026 	andeq	r0, r0, r6, lsr #32
    4f80:	30006568 	andcc	r6, r0, r8, ror #10
    4f84:	3000667c 	andcc	r6, r0, ip, ror r6
    4f88:	00001ae9 	andeq	r1, r0, r9, ror #21
    4f8c:	000c0d02 	andeq	r0, ip, r2, lsl #26
    4f90:	30090200 	andcc	r0, r9, r0, lsl #4
    4f94:	03000000 	movweq	r0, #0
    4f98:	00620801 	rsbeq	r0, r2, r1, lsl #16
    4f9c:	02030000 	andeq	r0, r3, #0
    4fa0:	00007007 	andeq	r7, r0, r7
    4fa4:	0b520200 	bleq	14857ac <MEM_SIZE+0xc857ac>
    4fa8:	0b020000 	bleq	84fb0 <DISABLE_IRQ+0x84f30>
    4fac:	00000049 	andeq	r0, r0, r9, asr #32
    4fb0:	76070403 	strvc	r0, [r7], -r3, lsl #8
    4fb4:	03000000 	movweq	r0, #0
    4fb8:	006b0801 	rsbeq	r0, fp, r1, lsl #16
    4fbc:	d5020000 	strle	r0, [r2]
    4fc0:	0200000d 	andeq	r0, r0, #13
    4fc4:	00004911 	andeq	r4, r0, r1, lsl r9
    4fc8:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    4fcc:	25060704 	strcs	r0, [r6, #-1796]	; 0x704
    4fd0:	77000000 	strvc	r0, [r0, -r0]
    4fd4:	07000000 	streq	r0, [r0, -r0]
    4fd8:	00000064 	andeq	r0, r0, r4, rrx
    4fdc:	4f08000f 	svcmi	0x0008000f
    4fe0:	03000003 	movweq	r0, #3
    4fe4:	0083024d 	addeq	r0, r3, sp, asr #4
    4fe8:	04090000 	streq	r0, [r9]
    4fec:	00000089 	andeq	r0, r0, r9, lsl #1
    4ff0:	009a010a 	addseq	r0, sl, sl, lsl #2
    4ff4:	620b0000 	andvs	r0, fp, #0
    4ff8:	0b000000 	bleq	5000 <DISABLE_IRQ+0x4f80>
    4ffc:	00000062 	andeq	r0, r0, r2, rrx
    5000:	0d9c0c00 	ldceq	12, cr0, [ip]
    5004:	03340000 	teqeq	r4, #0
    5008:	014d0251 	cmpeq	sp, r1, asr r2
    500c:	6b0d0000 	blvs	345014 <DISABLE_IRQ+0x344f94>
    5010:	03000010 	movweq	r0, #16
    5014:	00250252 	eoreq	r0, r5, r2, asr r2
    5018:	23020000 	movwcs	r0, #8192	; 0x2000
    501c:	08760d00 	ldmdaeq	r6!, {r8, sl, fp}^
    5020:	53030000 	movwpl	r0, #12288	; 0x3000
    5024:	00007702 	andeq	r7, r0, r2, lsl #14
    5028:	04230200 	strteq	r0, [r3], #-512	; 0x200
    502c:	000ecd0d 	andeq	ip, lr, sp, lsl #26
    5030:	02540300 	subseq	r0, r4, #0
    5034:	00000062 	andeq	r0, r0, r2, rrx
    5038:	0d082302 	stceq	3, cr2, [r8, #-8]
    503c:	00000428 	andeq	r0, r0, r8, lsr #8
    5040:	62025503 	andvs	r5, r2, #12582912	; 0xc00000
    5044:	02000000 	andeq	r0, r0, #0
    5048:	1b0d0c23 	blne	3480dc <DISABLE_IRQ+0x34805c>
    504c:	03000012 	movweq	r0, #18
    5050:	00620256 	rsbeq	r0, r2, r6, asr r2
    5054:	23020000 	movwcs	r0, #8192	; 0x2000
    5058:	10e60d10 	rscne	r0, r6, r0, lsl sp
    505c:	57030000 	strpl	r0, [r3, -r0]
    5060:	00003e02 	andeq	r3, r0, r2, lsl #28
    5064:	14230200 	strtne	r0, [r3], #-512	; 0x200
    5068:	0007450d 	andeq	r4, r7, sp, lsl #10
    506c:	02580300 	subseq	r0, r8, #0
    5070:	0000003e 	andeq	r0, r0, lr, lsr r0
    5074:	0d182302 	ldceq	3, cr2, [r8, #-8]
    5078:	00000399 	muleq	r0, r9, r3
    507c:	3e025903 	cdpcc	9, 0, cr5, cr2, cr3, {0}
    5080:	02000000 	andeq	r0, r0, #0
    5084:	1c0d1c23 	stcne	12, cr1, [sp], {35}	; 0x23
    5088:	0300000d 	movweq	r0, #13
    508c:	0067025b 	rsbeq	r0, r7, fp, asr r2
    5090:	23020000 	movwcs	r0, #8192	; 0x2000
    5094:	0e610d20 	cdpeq	13, 6, cr0, cr1, cr0, {1}
    5098:	5d030000 	stcpl	0, cr0, [r3]
    509c:	00002502 	andeq	r2, r0, r2, lsl #10
    50a0:	30230200 	eorcc	r0, r3, r0, lsl #4
    50a4:	00076d0d 	andeq	r6, r7, sp, lsl #26
    50a8:	025e0300 	subseq	r0, lr, #0
    50ac:	00000025 	andeq	r0, r0, r5, lsr #32
    50b0:	00312302 	eorseq	r2, r1, r2, lsl #6
    50b4:	000cb208 	andeq	fp, ip, r8, lsl #4
    50b8:	02620300 	rsbeq	r0, r2, #0
    50bc:	0000009a 	muleq	r0, sl, r0
    50c0:	014d0409 	cmpeq	sp, r9, lsl #8
    50c4:	d60e0000 	strle	r0, [lr], -r0
    50c8:	01000013 	tsteq	r0, r3, lsl r0
    50cc:	6568010c 	strbvs	r0, [r8, #-268]!	; 0x10c
    50d0:	65983000 	ldrvs	r3, [r8]
    50d4:	47243000 	strmi	r3, [r4, -r0]!
    50d8:	01a70000 	undefined instruction 0x01a70000
    50dc:	740f0000 	strvc	r0, [pc], #0	; 50e4 <DISABLE_IRQ+0x5064>
    50e0:	0100726d 	tsteq	r0, sp, ror #4
    50e4:	0000620c 	andeq	r6, r0, ip, lsl #4
    50e8:	00474300 	subeq	r4, r7, r0, lsl #6
    50ec:	72610f00 	rsbvc	r0, r1, #0
    50f0:	0c010067 	stceq	0, cr0, [r1], {103}	; 0x67
    50f4:	00000062 	andeq	r0, r0, r2, rrx
    50f8:	00004756 	andeq	r4, r0, r6, asr r7
    50fc:	00045a10 	andeq	r5, r4, r0, lsl sl
    5100:	3e0e0100 	adfcce	f0, f6, f0
    5104:	05000000 	streq	r0, [r0]
    5108:	015eb403 	cmpeq	lr, r3, lsl #8
    510c:	01110030 	tsteq	r1, r0, lsr r0
    5110:	000013f2 	strdeq	r1, [r0], -r2
    5114:	65982601 	ldrvs	r2, [r8, #1537]	; 0x601
    5118:	663c3000 	ldrtvs	r3, [ip], -r0
    511c:	47693000 	strbmi	r3, [r9, -r0]!
    5120:	01ce0000 	biceq	r0, lr, r0
    5124:	65120000 	ldrvs	r0, [r2]
    5128:	01007272 	tsteq	r0, r2, ror r2
    512c:	00002528 	andeq	r2, r0, r8, lsr #10
    5130:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    5134:	13570e00 	cmpne	r7, #0
    5138:	14010000 	strne	r0, [r1]
    513c:	00663c01 	rsbeq	r3, r6, r1, lsl #24
    5140:	00667c30 	rsbeq	r7, r6, r0, lsr ip
    5144:	00479430 	subeq	r9, r7, r0, lsr r4
    5148:	00020400 	andeq	r0, r2, r0, lsl #8
    514c:	0f9e1300 	svceq	0x009e1300
    5150:	14010000 	strne	r0, [r1]
    5154:	00000062 	andeq	r0, r0, r2, rrx
    5158:	000047bf 	undefined instruction 0x000047bf
    515c:	72726512 	rsbsvc	r6, r2, #75497472	; 0x4800000
    5160:	25160100 	ldrcs	r0, [r6, #-256]	; 0x100
    5164:	02000000 	andeq	r0, r0, #0
    5168:	06007791 	undefined instruction 0x06007791
    516c:	00000057 	andeq	r0, r0, r7, asr r0
    5170:	00000215 	andeq	r0, r0, r5, lsl r2
    5174:	00006414 	andeq	r6, r0, r4, lsl r4
    5178:	0007ff00 	andeq	pc, r7, r0, lsl #30
    517c:	00133c10 	andseq	r3, r3, r0, lsl ip
    5180:	04080100 	streq	r0, [r8], #-256	; 0x100
    5184:	05000002 	streq	r0, [r0, #-2]
    5188:	015ebc03 	cmpeq	lr, r3, lsl #24
    518c:	13e11030 	mvnne	r1, #48	; 0x30
    5190:	0a010000 	beq	45198 <DISABLE_IRQ+0x45118>
    5194:	00000159 	andeq	r0, r0, r9, asr r1
    5198:	5eb80305 	cdppl	3, 11, cr0, cr8, cr5, {0}
    519c:	83153001 	tsthi	r5, #1
    51a0:	01000000 	tsteq	r0, r0
    51a4:	00024404 	andeq	r4, r2, r4, lsl #8
    51a8:	16010100 	strne	r0, [r1], -r0, lsl #2
    51ac:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    51b0:	10000074 	andne	r0, r0, r4, ror r0
    51b4:	02000002 	andeq	r0, r0, #2
    51b8:	000dee00 	andeq	lr, sp, r0, lsl #28
    51bc:	8f010400 	svchi	0x00010400
    51c0:	01000000 	tsteq	r0, r0
    51c4:	00001403 	andeq	r1, r0, r3, lsl #8
    51c8:	00000026 	andeq	r0, r0, r6, lsr #32
    51cc:	3000667c 	andcc	r6, r0, ip, ror r6
    51d0:	300067b0 	undefined instruction 0x300067b0
    51d4:	00001b62 	andeq	r1, r0, r2, ror #22
    51d8:	000c0d02 	andeq	r0, ip, r2, lsl #26
    51dc:	30090200 	andcc	r0, r9, r0, lsl #4
    51e0:	03000000 	movweq	r0, #0
    51e4:	00620801 	rsbeq	r0, r2, r1, lsl #16
    51e8:	4b020000 	blmi	851f0 <DISABLE_IRQ+0x85170>
    51ec:	02000002 	andeq	r0, r0, #2
    51f0:	0000420a 	andeq	r4, r0, sl, lsl #4
    51f4:	07020300 	streq	r0, [r2, -r0, lsl #6]
    51f8:	00000070 	andeq	r0, r0, r0, ror r0
    51fc:	000b5202 	andeq	r5, fp, r2, lsl #4
    5200:	540b0200 	strpl	r0, [fp], #-512	; 0x200
    5204:	03000000 	movweq	r0, #0
    5208:	00760704 	rsbseq	r0, r6, r4, lsl #14
    520c:	01030000 	tsteq	r3, r0
    5210:	00006b08 	andeq	r6, r0, r8, lsl #22
    5214:	0dd50200 	lfmeq	f0, 2, [r5]	; (ldcleq 2, cr0, [r5])
    5218:	11020000 	tstne	r2, r0
    521c:	00000054 	andeq	r0, r0, r4, asr r0
    5220:	000cb904 	andeq	fp, ip, r4, lsl #18
    5224:	39032400 	stmdbcc	r3, {sl, sp}
    5228:	0000d501 	andeq	sp, r0, r1, lsl #10
    522c:	119e0500 	orrsne	r0, lr, r0, lsl #10
    5230:	3a030000 	bcc	c5238 <DISABLE_IRQ+0xc51b8>
    5234:	00002501 	andeq	r2, r0, r1, lsl #10
    5238:	00230200 	eoreq	r0, r3, r0, lsl #4
    523c:	00108605 	andseq	r8, r0, r5, lsl #12
    5240:	013b0300 	teqeq	fp, r0, lsl #6
    5244:	000000d5 	ldrdeq	r0, [r0], -r5
    5248:	05042302 	streq	r2, [r4, #-770]	; 0x302
    524c:	000006ff 	strdeq	r0, [r0], -pc
    5250:	37013c03 	strcc	r3, [r1, -r3, lsl #24]
    5254:	02000000 	andeq	r0, r0, #0
    5258:	48050823 	stmdami	r5, {r0, r1, r5, fp}
    525c:	03000004 	movweq	r0, #4
    5260:	0025013e 	eoreq	r0, r5, lr, lsr r1
    5264:	23020000 	movwcs	r0, #8192	; 0x2000
    5268:	0633050a 	ldrteq	r0, [r3], -sl, lsl #10
    526c:	3f030000 	svccc	0x00030000
    5270:	0000d701 	andeq	sp, r0, r1, lsl #14
    5274:	0b230200 	bleq	8c5a7c <MEM_SIZE+0xc5a7c>
    5278:	000ef905 	andeq	pc, lr, r5, lsl #18
    527c:	01460300 	cmpeq	r6, r0, lsl #6
    5280:	000000ea 	andeq	r0, r0, sl, ror #1
    5284:	00132302 	andseq	r2, r3, r2, lsl #6
    5288:	25070406 	strcs	r0, [r7, #-1030]	; 0x406
    528c:	e7000000 	str	r0, [r0, -r0]
    5290:	08000000 	stmdaeq	r0, {}
    5294:	000000e7 	andeq	r0, r0, r7, ror #1
    5298:	04090007 	streq	r0, [r9], #-7
    529c:	00250707 	eoreq	r0, r5, r7, lsl #14
    52a0:	00fa0000 	rscseq	r0, sl, r0
    52a4:	e7080000 	str	r0, [r8, -r0]
    52a8:	0f000000 	svceq	0x00000000
    52ac:	03460a00 	movteq	r0, #27136	; 0x6a00
    52b0:	48030000 	stmdami	r3, {}
    52b4:	00006d01 	andeq	r6, r0, r1, lsl #26
    52b8:	fa040b00 	blx	107ec0 <DISABLE_IRQ+0x107e40>
    52bc:	0c000000 	stceq	0, cr0, [r0], {0}
    52c0:	00141001 	andseq	r1, r4, r1
    52c4:	7c340100 	ldfvcs	f0, [r4]
    52c8:	0c300066 	ldceq	0, cr0, [r0], #-408	; 0xfffffe68
    52cc:	d2300067 	eorsle	r0, r0, #103	; 0x67
    52d0:	0d000047 	stceq	0, cr0, [r0, #-284]	; 0xfffffee4
    52d4:	00001362 	andeq	r1, r0, r2, ror #6
    52d8:	0c012301 	stceq	3, cr2, [r1], {1}
    52dc:	4c300067 	ldcmi	0, cr0, [r0], #-412	; 0xfffffe64
    52e0:	f1300067 	undefined instruction 0xf1300067
    52e4:	61000047 	tstvs	r0, r7, asr #32
    52e8:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    52ec:	00000f9e 	muleq	r0, lr, pc
    52f0:	00d52301 	sbcseq	r2, r5, r1, lsl #6
    52f4:	481c0000 	ldmdami	ip, {}
    52f8:	650f0000 	strvs	r0, [pc, #0]	; 5300 <DISABLE_IRQ+0x5280>
    52fc:	01007272 	tsteq	r0, r2, ror r2
    5300:	00002525 	andeq	r2, r0, r5, lsr #10
    5304:	6f910200 	svcvs	0x00910200
    5308:	6c617610 	stclvs	6, cr7, [r1], #-64	; 0xffffffc0
    530c:	49260100 	stmdbmi	r6!, {r8}
    5310:	00000000 	andeq	r0, r0, r0
    5314:	0013570d 	andseq	r5, r3, sp, lsl #14
    5318:	01120100 	tsteq	r2, r0, lsl #2
    531c:	3000674c 	andcc	r6, r0, ip, asr #14
    5320:	300067b0 	undefined instruction 0x300067b0
    5324:	0000482f 	andeq	r4, r0, pc, lsr #16
    5328:	00000189 	andeq	r0, r0, r9, lsl #3
    532c:	000f9e0e 	andeq	r9, pc, lr, lsl #28
    5330:	d5120100 	ldrle	r0, [r2, #-256]	; 0x100
    5334:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
    5338:	00000048 	andeq	r0, r0, r8, asr #32
    533c:	00006207 	andeq	r6, r0, r7, lsl #4
    5340:	00019a00 	andeq	r9, r1, r0, lsl #20
    5344:	00e71100 	rsceq	r1, r7, r0, lsl #2
    5348:	07ff0000 	ldrbeq	r0, [pc, r0]!
    534c:	133c1200 	teqne	ip, #0
    5350:	09010000 	stmdbeq	r1, {}
    5354:	00000189 	andeq	r0, r0, r9, lsl #3
    5358:	7ed40305 	cdpvc	3, 13, cr0, cr4, cr5, {0}
    535c:	41123001 	tstmi	r2, r1
    5360:	01000013 	tsteq	r0, r3, lsl r0
    5364:	0001890a 	andeq	r8, r1, sl, lsl #18
    5368:	d4030500 	strle	r0, [r3], #-1280	; 0x500
    536c:	1230019e 	eorsne	r0, r0, #-2147483609	; 0x80000027
    5370:	000013fb 	strdeq	r1, [r0], -fp
    5374:	01060c01 	tsteq	r6, r1, lsl #24
    5378:	03050000 	movweq	r0, #20480	; 0x5000
    537c:	30017ed0 	ldrdcc	r7, [r1], -r0
    5380:	0000d507 	andeq	sp, r0, r7, lsl #10
    5384:	0001dd00 	andeq	sp, r1, r0, lsl #26
    5388:	00e70800 	rsceq	r0, r7, r0, lsl #16
    538c:	00040000 	andeq	r0, r4, r0
    5390:	0013fd12 	andseq	pc, r3, r2, lsl sp
    5394:	cd0e0100 	stfgts	f0, [lr]
    5398:	05000001 	streq	r0, [r0, #-1]
    539c:	017ebc03 	cmneq	lr, r3, lsl #24
    53a0:	045a1230 	ldrbeq	r1, [sl], #-560	; 0x230
    53a4:	10010000 	andne	r0, r1, r0
    53a8:	00000049 	andeq	r0, r0, r9, asr #32
    53ac:	bed40305 	cdplt	3, 13, cr0, cr4, cr5, {0}
    53b0:	83133001 	tsthi	r3, #1
    53b4:	01000000 	tsteq	r0, r0
    53b8:	00020c04 	andeq	r0, r2, r4, lsl #24
    53bc:	14010100 	strne	r0, [r1], #-256	; 0x100
    53c0:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    53c4:	de000074 	mcrle	0, 0, r0, cr0, cr4, {3}
    53c8:	02000001 	andeq	r0, r0, #1
    53cc:	000ef700 	andeq	pc, lr, r0, lsl #14
    53d0:	8f010400 	svchi	0x00010400
    53d4:	01000000 	tsteq	r0, r0
    53d8:	00001424 	andeq	r1, r0, r4, lsr #8
    53dc:	00000026 	andeq	r0, r0, r6, lsr #32
    53e0:	300067b0 	undefined instruction 0x300067b0
    53e4:	30006894 	mulcc	r0, r4, r8
    53e8:	00001be0 	andeq	r1, r0, r0, ror #23
    53ec:	000c0d02 	andeq	r0, ip, r2, lsl #26
    53f0:	30090200 	andcc	r0, r9, r0, lsl #4
    53f4:	03000000 	movweq	r0, #0
    53f8:	00620801 	rsbeq	r0, r2, r1, lsl #16
    53fc:	02030000 	andeq	r0, r3, #0
    5400:	00007007 	andeq	r7, r0, r7
    5404:	0b520200 	bleq	1485c0c <MEM_SIZE+0xc85c0c>
    5408:	0b020000 	bleq	85410 <DISABLE_IRQ+0x85390>
    540c:	00000049 	andeq	r0, r0, r9, asr #32
    5410:	76070403 	strvc	r0, [r7], -r3, lsl #8
    5414:	03000000 	movweq	r0, #0
    5418:	006b0801 	rsbeq	r0, fp, r1, lsl #16
    541c:	d5020000 	strle	r0, [r2]
    5420:	0200000d 	andeq	r0, r0, #13
    5424:	00004911 	andeq	r4, r0, r1, lsl r9
    5428:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    542c:	25060704 	strcs	r0, [r6, #-1796]	; 0x704
    5430:	77000000 	strvc	r0, [r0, -r0]
    5434:	07000000 	streq	r0, [r0, -r0]
    5438:	00000064 	andeq	r0, r0, r4, rrx
    543c:	a908000f 	stmdbge	r8, {r0, r1, r2, r3}
    5440:	24000008 	strcs	r0, [r0], #-8
    5444:	df019503 	svcle	0x00019503
    5448:	09000000 	stmdbeq	r0, {}
    544c:	00000f64 	andeq	r0, r0, r4, ror #30
    5450:	62019603 	andvs	r9, r1, #3145728	; 0x300000
    5454:	02000000 	andeq	r0, r0, #0
    5458:	cb090023 	blgt	2454ec <DISABLE_IRQ+0x24546c>
    545c:	0300000c 	movweq	r0, #12
    5460:	00620197 	mlseq	r2, r7, r1, r0
    5464:	23020000 	movwcs	r0, #8192	; 0x2000
    5468:	11d60904 	bicsne	r0, r6, r4, lsl #18
    546c:	98030000 	stmdals	r3, {}
    5470:	00003e01 	andeq	r3, r0, r1, lsl #28
    5474:	08230200 	stmdaeq	r3!, {r9}
    5478:	00129a09 	andseq	r9, r2, r9, lsl #20
    547c:	01990300 	orrseq	r0, r9, r0, lsl #6
    5480:	0000003e 	andeq	r0, r0, lr, lsr r0
    5484:	090c2302 	stmdbeq	ip, {r1, r8, r9, sp}
    5488:	0000067a 	andeq	r0, r0, sl, ror r6
    548c:	3e019a03 	vmlacc.f32	s18, s2, s6
    5490:	02000000 	andeq	r0, r0, #0
    5494:	26091023 	strcs	r1, [r9], -r3, lsr #32
    5498:	0300000d 	movweq	r0, #13
    549c:	0067019c 	mlseq	r7, ip, r1, r0
    54a0:	23020000 	movwcs	r0, #8192	; 0x2000
    54a4:	070a0014 	smladeq	sl, r4, r0, r0
    54a8:	03000008 	movweq	r0, #8
    54ac:	0077019e 	ldrbteq	r0, [r7], #-30	; 0xffffffe2
    54b0:	010b0000 	tsteq	fp, r0
    54b4:	0000141d 	andeq	r1, r0, sp, lsl r4
    54b8:	67b02c01 	ldrvs	r2, [r0, r1, lsl #24]!
    54bc:	68343000 	ldmdavs	r4!, {ip, sp}
    54c0:	48613000 	stmdami	r1!, {ip, sp}^
    54c4:	011d0000 	tsteq	sp, r0
    54c8:	650c0000 	strvs	r0, [ip]
    54cc:	01007272 	tsteq	r0, r2, ror r2
    54d0:	0000252e 	andeq	r2, r0, lr, lsr #10
    54d4:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    54d8:	00142f0d 	andseq	r2, r4, sp, lsl #30
    54dc:	1d300100 	ldfnes	f0, [r0]
    54e0:	00000001 	andeq	r0, r0, r1
    54e4:	0025040e 	eoreq	r0, r5, lr, lsl #8
    54e8:	570f0000 	strpl	r0, [pc, -r0]
    54ec:	01000013 	tsteq	r0, r3, lsl r0
    54f0:	6834010f 	ldmdavs	r4!, {r0, r1, r2, r3, r8}
    54f4:	68943000 	ldmvs	r4, {ip, sp}
    54f8:	488c3000 	stmmi	ip, {ip, sp}
    54fc:	01730000 	cmneq	r3, r0
    5500:	9e100000 	cdpls	0, 1, cr0, cr0, cr0, {0}
    5504:	0100000f 	tsteq	r0, pc
    5508:	0000620f 	andeq	r6, r0, pc, lsl #4
    550c:	0048b700 	subeq	fp, r8, r0, lsl #14
    5510:	72650c00 	rsbvc	r0, r5, #0
    5514:	11010072 	tstne	r1, r2, ror r0
    5518:	00000025 	andeq	r0, r0, r5, lsr #32
    551c:	0d6f9102 	stfeqp	f1, [pc, #-8]!
    5520:	000013be 	undefined instruction 0x000013be
    5524:	00621201 	rsbeq	r1, r2, r1, lsl #4
    5528:	82110000 	andshi	r0, r1, #0
    552c:	01000001 	tsteq	r0, r1
    5530:	00002513 	andeq	r2, r0, r3, lsl r5
    5534:	0048d500 	subeq	sp, r8, r0, lsl #10
    5538:	57060000 	strpl	r0, [r6, -r0]
    553c:	83000000 	movwhi	r0, #0
    5540:	07000001 	streq	r0, [r0, -r1]
    5544:	00000064 	andeq	r0, r0, r4, rrx
    5548:	3c1200ff 	ldccc	0, cr0, [r2], {255}	; 0xff
    554c:	01000013 	tsteq	r0, r3, lsl r0
    5550:	00017308 	andeq	r7, r1, r8, lsl #6
    5554:	dc030500 	cfstr32le	mvfx0, [r3], {0}
    5558:	123001c2 	eorsne	r0, r0, #-2147483600	; 0x80000030
    555c:	00001417 	andeq	r1, r0, r7, lsl r4
    5560:	01a50a01 	undefined instruction 0x01a50a01
    5564:	03050000 	movweq	r0, #20480	; 0x5000
    5568:	3001c2d8 	ldrdcc	ip, [r1], -r8
    556c:	00df040e 	sbcseq	r0, pc, lr, lsl #8
    5570:	25060000 	strcs	r0, [r6]
    5574:	bc000000 	stclt	0, cr0, [r0], {0}
    5578:	13000001 	movwne	r0, #1
    557c:	00000064 	andeq	r0, r0, r4, rrx
    5580:	120003ff 	andne	r0, r0, #-67108861	; 0xfc000003
    5584:	00001436 	andeq	r1, r0, r6, lsr r4
    5588:	01ab0c01 	undefined instruction 0x01ab0c01
    558c:	03050000 	movweq	r0, #20480	; 0x5000
    5590:	3001bed8 	ldrdcc	fp, [r1], -r8
    5594:	00008314 	andeq	r8, r0, r4, lsl r3
    5598:	da040100 	ble	1059a0 <DISABLE_IRQ+0x105920>
    559c:	01000001 	tsteq	r0, r1
    55a0:	05041501 	streq	r1, [r4, #-1281]	; 0x501
    55a4:	00746e69 	rsbseq	r6, r4, r9, ror #28
    55a8:	0004c400 	andeq	ip, r4, r0, lsl #8
    55ac:	11000200 	tstne	r0, r0, lsl #4
    55b0:	04000010 	streq	r0, [r0], #-16
    55b4:	00008f01 	andeq	r8, r0, r1, lsl #30
    55b8:	14680100 	strbtne	r0, [r8], #-256	; 0x100
    55bc:	00260000 	eoreq	r0, r6, r0
    55c0:	68940000 	ldmvs	r4, {}
    55c4:	698c3000 	stmibvs	ip, {ip, sp}
    55c8:	1c5f3000 	mrane	r3, pc, acc0
    55cc:	0d020000 	stceq	0, cr0, [r2]
    55d0:	0200000c 	andeq	r0, r0, #12
    55d4:	00003009 	andeq	r3, r0, r9
    55d8:	08010300 	stmdaeq	r1, {r8, r9}
    55dc:	00000062 	andeq	r0, r0, r2, rrx
    55e0:	00024b02 	andeq	r4, r2, r2, lsl #22
    55e4:	420a0200 	andmi	r0, sl, #0
    55e8:	03000000 	movweq	r0, #0
    55ec:	00700702 	rsbseq	r0, r0, r2, lsl #14
    55f0:	52020000 	andpl	r0, r2, #0
    55f4:	0200000b 	andeq	r0, r0, #11
    55f8:	0000540b 	andeq	r5, r0, fp, lsl #8
    55fc:	07040300 	streq	r0, [r4, -r0, lsl #6]
    5600:	00000076 	andeq	r0, r0, r6, ror r0
    5604:	6b080103 	blvs	205a18 <DISABLE_IRQ+0x205998>
    5608:	02000000 	andeq	r0, r0, #0
    560c:	00000439 	andeq	r0, r0, r9, lsr r4
    5610:	00301002 	eorseq	r1, r0, r2
    5614:	d5020000 	strle	r0, [r2]
    5618:	0200000d 	andeq	r0, r0, #13
    561c:	00005411 	andeq	r5, r0, r1, lsl r4
    5620:	0cb90400 	cfldrseq	mvf0, [r9]
    5624:	03240000 	teqeq	r4, #0
    5628:	00e00139 	rsceq	r0, r0, r9, lsr r1
    562c:	9e050000 	cdpls	0, 0, cr0, cr5, cr0, {0}
    5630:	03000011 	movweq	r0, #17
    5634:	0025013a 	eoreq	r0, r5, sl, lsr r1
    5638:	23020000 	movwcs	r0, #8192	; 0x2000
    563c:	10860500 	addne	r0, r6, r0, lsl #10
    5640:	3b030000 	blcc	c5648 <DISABLE_IRQ+0xc55c8>
    5644:	0000e001 	andeq	lr, r0, r1
    5648:	04230200 	strteq	r0, [r3], #-512	; 0x200
    564c:	0006ff05 	andeq	pc, r6, r5, lsl #30
    5650:	013c0300 	teqeq	ip, r0, lsl #6
    5654:	00000037 	andeq	r0, r0, r7, lsr r0
    5658:	05082302 	streq	r2, [r8, #-770]	; 0x302
    565c:	00000448 	andeq	r0, r0, r8, asr #8
    5660:	25013e03 	strcs	r3, [r1, #-3587]	; 0xe03
    5664:	02000000 	andeq	r0, r0, #0
    5668:	33050a23 	movwcc	r0, #23075	; 0x5a23
    566c:	03000006 	movweq	r0, #6
    5670:	00e2013f 	rsceq	r0, r2, pc, lsr r1
    5674:	23020000 	movwcs	r0, #8192	; 0x2000
    5678:	0ef9050b 	cdpeq	5, 15, cr0, cr9, cr11, {0}
    567c:	46030000 	strmi	r0, [r3], -r0
    5680:	0000f501 	andeq	pc, r0, r1, lsl #10
    5684:	13230200 	teqne	r3, #0
    5688:	07040600 	streq	r0, [r4, -r0, lsl #12]
    568c:	00000025 	andeq	r0, r0, r5, lsr #32
    5690:	000000f2 	strdeq	r0, [r0], -r2
    5694:	0000f208 	andeq	pc, r0, r8, lsl #4
    5698:	09000700 	stmdbeq	r0, {r8, r9, sl}
    569c:	25070704 	strcs	r0, [r7, #-1796]	; 0x704
    56a0:	05000000 	streq	r0, [r0]
    56a4:	08000001 	stmdaeq	r0, {r0}
    56a8:	000000f2 	strdeq	r0, [r0], -r2
    56ac:	460a000f 	strmi	r0, [sl], -pc
    56b0:	03000003 	movweq	r0, #3
    56b4:	00780148 	rsbseq	r0, r8, r8, asr #2
    56b8:	950a0000 	strls	r0, [sl]
    56bc:	03000011 	movweq	r0, #17
    56c0:	00370159 	eorseq	r0, r7, r9, asr r1
    56c4:	c0040000 	andgt	r0, r4, r0
    56c8:	1400000e 	strne	r0, [r0], #-14
    56cc:	85016c03 	strhi	r6, [r1, #-3075]	; 0xc03
    56d0:	05000001 	streq	r0, [r0, #-1]
    56d4:	000012a5 	andeq	r1, r0, r5, lsr #5
    56d8:	e0016d03 	and	r6, r1, r3, lsl #26
    56dc:	02000000 	andeq	r0, r0, #0
    56e0:	ae050023 	cdpge	0, 0, cr0, cr5, cr3, {1}
    56e4:	03000002 	movweq	r0, #2
    56e8:	00e0016e 	rsceq	r0, r0, lr, ror #2
    56ec:	23020000 	movwcs	r0, #8192	; 0x2000
    56f0:	048a0504 	streq	r0, [sl], #1284	; 0x504
    56f4:	6f030000 	svcvs	0x00030000
    56f8:	0000e001 	andeq	lr, r0, r1
    56fc:	08230200 	stmdaeq	r3!, {r9}
    5700:	0003ec05 	andeq	lr, r3, r5, lsl #24
    5704:	01700300 	cmneq	r0, r0, lsl #6
    5708:	000000e0 	andeq	r0, r0, r0, ror #1
    570c:	050c2302 	streq	r2, [ip, #-770]	; 0x302
    5710:	00000fdb 	ldrdeq	r0, [r0], -fp
    5714:	11017103 	tstne	r1, r3, lsl #2
    5718:	02000001 	andeq	r0, r0, #1
    571c:	66051023 	strvs	r1, [r5], -r3, lsr #32
    5720:	03000003 	movweq	r0, #3
    5724:	00250172 	eoreq	r0, r5, r2, ror r1
    5728:	23020000 	movwcs	r0, #8192	; 0x2000
    572c:	390a0012 	stmdbcc	sl, {r1, r4}
    5730:	0300000f 	movweq	r0, #15
    5734:	011d0177 	tsteq	sp, r7, ror r1
    5738:	ed040000 	stc	0, cr0, [r4]
    573c:	58000001 	stmdapl	r0, {r0}
    5740:	34020803 	strcc	r0, [r2], #-2051	; 0x803
    5744:	05000003 	streq	r0, [r0, #-3]
    5748:	00000332 	andeq	r0, r0, r2, lsr r3
    574c:	34020903 	strcc	r0, [r2], #-2307	; 0x903
    5750:	02000003 	andeq	r0, r0, #3
    5754:	04050023 	streq	r0, [r5], #-35	; 0x23
    5758:	0300000a 	movweq	r0, #10
    575c:	00e0020c 	rsceq	r0, r0, ip, lsl #4
    5760:	23020000 	movwcs	r0, #8192	; 0x2000
    5764:	0d440504 	cfstr64eq	mvdx0, [r4, #-16]
    5768:	0d030000 	stceq	0, cr0, [r3]
    576c:	00033402 	andeq	r3, r3, r2, lsl #8
    5770:	08230200 	stmdaeq	r3!, {r9}
    5774:	000b1c05 	andeq	r1, fp, r5, lsl #24
    5778:	020e0300 	andeq	r0, lr, #0
    577c:	00000049 	andeq	r0, r0, r9, asr #32
    5780:	050c2302 	streq	r2, [ip, #-770]	; 0x302
    5784:	0000117a 	andeq	r1, r0, sl, ror r1
    5788:	37020f03 	strcc	r0, [r2, -r3, lsl #30]
    578c:	02000000 	andeq	r0, r0, #0
    5790:	f4051023 	vst4.8	{d1-d4}, [r5, :128], r3
    5794:	03000005 	movweq	r0, #5
    5798:	00370210 	eorseq	r0, r7, r0, lsl r2
    579c:	23020000 	movwcs	r0, #8192	; 0x2000
    57a0:	08d80512 	ldmeq	r8, {r1, r4, r8, sl}^
    57a4:	13030000 	movwne	r0, #12288	; 0x3000
    57a8:	00033a02 	andeq	r3, r3, r2, lsl #20
    57ac:	14230200 	strtne	r0, [r3], #-512	; 0x200
    57b0:	00099705 	andeq	r9, r9, r5, lsl #14
    57b4:	02140300 	andseq	r0, r4, #0
    57b8:	0000033a 	andeq	r0, r0, sl, lsr r3
    57bc:	05182302 	ldreq	r2, [r8, #-770]	; 0x302
    57c0:	00000e40 	andeq	r0, r0, r0, asr #28
    57c4:	40021703 	andmi	r1, r2, r3, lsl #14
    57c8:	02000003 	andeq	r0, r0, #3
    57cc:	a8051c23 	stmdage	r5, {r0, r1, r5, sl, fp, ip}
    57d0:	03000006 	movweq	r0, #6
    57d4:	00e0021b 	rsceq	r0, r0, fp, lsl r2
    57d8:	23020000 	movwcs	r0, #8192	; 0x2000
    57dc:	02e30520 	rsceq	r0, r3, #134217728	; 0x8000000
    57e0:	20030000 	andcs	r0, r3, r0
    57e4:	00034602 	andeq	r4, r3, r2, lsl #12
    57e8:	24230200 	strtcs	r0, [r3], #-512	; 0x200
    57ec:	000b4405 	andeq	r4, fp, r5, lsl #8
    57f0:	02220300 	eoreq	r0, r2, #0
    57f4:	00000111 	andeq	r0, r0, r1, lsl r1
    57f8:	05282302 	streq	r2, [r8, #-770]!	; 0x302
    57fc:	00000668 	andeq	r0, r0, r8, ror #12
    5800:	37022503 	strcc	r2, [r2, -r3, lsl #10]
    5804:	02000000 	andeq	r0, r0, #0
    5808:	25052a23 	strcs	r2, [r5, #-2595]	; 0xa23
    580c:	0300000e 	movweq	r0, #14
    5810:	00250226 	eoreq	r0, r5, r6, lsr #4
    5814:	23020000 	movwcs	r0, #8192	; 0x2000
    5818:	027d052c 	rsbseq	r0, sp, #184549376	; 0xb000000
    581c:	27030000 	strcs	r0, [r3, -r0]
    5820:	00006202 	andeq	r6, r0, r2, lsl #4
    5824:	2d230200 	sfmcs	f0, 4, [r3]	; (stccs 2, cr0, [r3])
    5828:	000dfc05 	andeq	pc, sp, r5, lsl #24
    582c:	02280300 	eoreq	r0, r8, #0
    5830:	00000025 	andeq	r0, r0, r5, lsr #32
    5834:	052e2302 	streq	r2, [lr, #-770]!	; 0x302
    5838:	00001051 	andeq	r1, r0, r1, asr r0
    583c:	25022a03 	strcs	r2, [r2, #-2563]	; 0xa03
    5840:	02000000 	andeq	r0, r0, #0
    5844:	58052f23 	stmdapl	r5, {r0, r1, r5, r8, r9, sl, fp, sp}
    5848:	03000010 	movweq	r0, #16
    584c:	0025022b 	eoreq	r0, r5, fp, lsr #4
    5850:	23020000 	movwcs	r0, #8192	; 0x2000
    5854:	0f120530 	svceq	0x00120530
    5858:	2d030000 	stccs	0, cr0, [r3]
    585c:	00002502 	andeq	r2, r0, r2, lsl #10
    5860:	31230200 	teqcc	r3, r0, lsl #4
    5864:	000f1c05 	andeq	r1, pc, r5, lsl #24
    5868:	022e0300 	eoreq	r0, lr, #0
    586c:	00000025 	andeq	r0, r0, r5, lsr #32
    5870:	05322302 	ldreq	r2, [r2, #-770]!	; 0x302
    5874:	00000ce3 	andeq	r0, r0, r3, ror #25
    5878:	25023503 	strcs	r3, [r2, #-1283]	; 0x503
    587c:	02000000 	andeq	r0, r0, #0
    5880:	a4053323 	strge	r3, [r5], #-803	; 0x323
    5884:	0300000c 	movweq	r0, #12
    5888:	00490239 	subeq	r0, r9, r9, lsr r2
    588c:	23020000 	movwcs	r0, #8192	; 0x2000
    5890:	03d20534 	bicseq	r0, r2, #218103808	; 0xd000000
    5894:	3a030000 	bcc	c589c <DISABLE_IRQ+0xc581c>
    5898:	00004902 	andeq	r4, r0, r2, lsl #18
    589c:	38230200 	stmdacc	r3!, {r9}
    58a0:	0007e905 	andeq	lr, r7, r5, lsl #18
    58a4:	023b0300 	eorseq	r0, fp, #0
    58a8:	00000049 	andeq	r0, r0, r9, asr #32
    58ac:	053c2302 	ldreq	r2, [ip, #-770]!	; 0x302
    58b0:	000003ab 	andeq	r0, r0, fp, lsr #7
    58b4:	34023c03 	strcc	r3, [r2], #-3075	; 0xc03
    58b8:	02000003 	andeq	r0, r0, #3
    58bc:	f2054023 	vhadd.s8	d4, d5, d19
    58c0:	03000006 	movweq	r0, #6
    58c4:	0049023d 	subeq	r0, r9, sp, lsr r2
    58c8:	23020000 	movwcs	r0, #8192	; 0x2000
    58cc:	0a860544 	beq	fe186de4 <rEINTPEND+0xa8186d3c>
    58d0:	41030000 	tstmi	r3, r0
    58d4:	0000f502 	andeq	pc, r0, r2, lsl #10
    58d8:	48230200 	stmdami	r3!, {r9}
    58dc:	6d040b00 	vstrvs	d0, [r4]
    58e0:	0b000000 	bleq	58e8 <DISABLE_IRQ+0x5868>
    58e4:	00019104 	andeq	r9, r1, r4, lsl #2
    58e8:	05040b00 	streq	r0, [r4, #-2816]	; 0xb00
    58ec:	0b000001 	bleq	58f8 <DISABLE_IRQ+0x5878>
    58f0:	00018504 	andeq	r8, r1, r4, lsl #10
    58f4:	125b0a00 	subsne	r0, fp, #0
    58f8:	43030000 	movwmi	r0, #12288	; 0x3000
    58fc:	00019102 	andeq	r9, r1, r2, lsl #2
    5900:	5a010c00 	bpl	48908 <DISABLE_IRQ+0x48888>
    5904:	01000014 	tsteq	r0, r4, lsl r0
    5908:	03340105 	teqeq	r4, #1073741825	; 0x40000001
    590c:	68940000 	ldmvs	r4, {}
    5910:	69543000 	ldmdbvs	r4, {ip, sp}^
    5914:	48f33000 	ldmmi	r3!, {ip, sp}^
    5918:	03c80000 	biceq	r0, r8, #0
    591c:	af0d0000 	svcge	0x000d0000
    5920:	01000014 	tsteq	r0, r4, lsl r0
    5924:	0003d405 	andeq	sp, r3, r5, lsl #8
    5928:	00491e00 	subeq	r1, r9, r0, lsl #28
    592c:	0f9e0e00 	svceq	0x009e0e00
    5930:	05010000 	streq	r0, [r1]
    5934:	000000e0 	andeq	r0, r0, r0, ror #1
    5938:	080e5101 	stmdaeq	lr, {r0, r8, ip, lr}
    593c:	0100000c 	tsteq	r0, ip
    5940:	00033405 	andeq	r3, r3, r5, lsl #8
    5944:	0f520100 	svceq	0x00520100
    5948:	0074706f 	rsbseq	r7, r4, pc, rrx
    594c:	00370501 	eorseq	r0, r7, r1, lsl #10
    5950:	49310000 	ldmdbmi	r1!, {}
    5954:	73100000 	tstvc	r0, #0
    5958:	01006b74 	tsteq	r0, r4, ror fp
    595c:	0003da07 	andeq	sp, r3, r7, lsl #20
    5960:	00494400 	subeq	r4, r9, r0, lsl #8
    5964:	04c91100 	strbeq	r1, [r9], #256	; 0x100
    5968:	08010000 	stmdaeq	r1, {}
    596c:	00000049 	andeq	r0, r0, r9, asr #32
    5970:	d4011200 	strle	r1, [r1], #-512	; 0x200
    5974:	13000003 	movwne	r0, #3
    5978:	000000e0 	andeq	r0, r0, r0, ror #1
    597c:	c8040b00 	stmdagt	r4, {r8, r9, fp}
    5980:	0b000003 	bleq	5994 <DISABLE_IRQ+0x5914>
    5984:	00004904 	andeq	r4, r0, r4, lsl #18
    5988:	a1011400 	tstge	r1, r0, lsl #8
    598c:	01000014 	tsteq	r0, r4, lsl r0
    5990:	69540124 	ldmdbvs	r4, {r2, r5, r8}^
    5994:	69583000 	ldmdbvs	r8, {ip, sp}^
    5998:	5d013000 	stcpl	0, cr3, [r1]
    599c:	00000405 	andeq	r0, r0, r5, lsl #8
    59a0:	00146f0e 	andseq	r6, r4, lr, lsl #30
    59a4:	05240100 	streq	r0, [r4, #-256]!	; 0x100
    59a8:	01000004 	tsteq	r0, r4
    59ac:	040b0050 	streq	r0, [fp], #-80	; 0x50
    59b0:	0000034c 	andeq	r0, r0, ip, asr #6
    59b4:	143d0115 	ldrtne	r0, [sp], #-277	; 0x115
    59b8:	27010000 	strcs	r0, [r1, -r0]
    59bc:	00695801 	rsbeq	r5, r9, r1, lsl #16
    59c0:	00695c30 	rsbeq	r5, r9, r0, lsr ip
    59c4:	155d0130 	ldrbne	r0, [sp, #-304]	; 0x130
    59c8:	0014c401 	andseq	ip, r4, r1, lsl #8
    59cc:	012a0100 	teqeq	sl, r0, lsl #2
    59d0:	3000695c 	andcc	r6, r0, ip, asr r9
    59d4:	30006960 	andcc	r6, r0, r0, ror #18
    59d8:	01145d01 	tsteq	r4, r1, lsl #26
    59dc:	000014b6 	undefined instruction 0x000014b6
    59e0:	60012d01 	andvs	r2, r1, r1, lsl #26
    59e4:	64300069 	ldrtvs	r0, [r0], #-105	; 0x69
    59e8:	01300069 	teqeq	r0, r9, rrx
    59ec:	0004565d 	andeq	r5, r4, sp, asr r6
    59f0:	146f0e00 	strbtne	r0, [pc], #3584	; 59f8 <DISABLE_IRQ+0x5978>
    59f4:	2d010000 	stccs	0, cr0, [r1]
    59f8:	00000405 	andeq	r0, r0, r5, lsl #8
    59fc:	15005001 	strne	r5, [r0, #-1]
    5a00:	00147501 	andseq	r7, r4, r1, lsl #10
    5a04:	01300100 	teqeq	r0, r0, lsl #2
    5a08:	30006964 	andcc	r6, r0, r4, ror #18
    5a0c:	30006968 	andcc	r6, r0, r8, ror #18
    5a10:	01155d01 	tsteq	r5, r1, lsl #26
    5a14:	0000144c 	andeq	r1, r0, ip, asr #8
    5a18:	68013301 	stmdavs	r1, {r0, r8, r9, ip, sp}
    5a1c:	6c300069 	ldcvs	0, cr0, [r0], #-420	; 0xfffffe5c
    5a20:	01300069 	teqeq	r0, r9, rrx
    5a24:	8501155d 	strhi	r1, [r1, #-1373]	; 0x55d
    5a28:	01000014 	tsteq	r0, r4, lsl r0
    5a2c:	696c0136 	stmdbvs	ip!, {r1, r2, r4, r5, r8}^
    5a30:	69703000 	ldmdbvs	r0!, {ip, sp}^
    5a34:	5d013000 	stcpl	0, cr3, [r1]
    5a38:	14940115 	ldrne	r0, [r4], #277	; 0x115
    5a3c:	39010000 	stmdbcc	r1, {}
    5a40:	00697001 	rsbeq	r7, r9, r1
    5a44:	00697430 	rsbeq	r7, r9, r0, lsr r4
    5a48:	165d0130 	undefined instruction 0x165d0130
    5a4c:	0014d301 	andseq	sp, r4, r1, lsl #6
    5a50:	011f0100 	tsteq	pc, r0, lsl #2
    5a54:	30006974 	andcc	r6, r0, r4, ror r9
    5a58:	3000698c 	andcc	r6, r0, ip, lsl #19
    5a5c:	000049af 	andeq	r4, r0, pc, lsr #19
    5a60:	00146f0d 	andseq	r6, r4, sp, lsl #30
    5a64:	051f0100 	ldreq	r0, [pc, #-256]	; 596c <DISABLE_IRQ+0x58ec>
    5a68:	ce000004 	cdpgt	0, 0, cr0, cr0, cr4, {0}
    5a6c:	00000049 	andeq	r0, r0, r9, asr #32
    5a70:	00010100 	andeq	r0, r1, r0, lsl #2
    5a74:	46000200 	strmi	r0, [r0], -r0, lsl #4
    5a78:	04000011 	streq	r0, [r0], #-17
    5a7c:	001d0501 	andseq	r0, sp, r1, lsl #10
    5a80:	00698c00 	rsbeq	r8, r9, r0, lsl #24
    5a84:	006aa030 	rsbeq	sl, sl, r0, lsr r0
    5a88:	706f2f30 	rsbvc	r2, pc, r0, lsr pc
    5a8c:	72462f74 	subvc	r2, r6, #464	; 0x1d0
    5a90:	646e6569 	strbtvs	r6, [lr], #-1385	; 0x569
    5a94:	5241796c 	subpl	r7, r1, #1769472	; 0x1b0000
    5a98:	696d2f4d 	stmdbvs	sp!, {r0, r2, r3, r6, r8, r9, sl, fp, sp}^
    5a9c:	3432696e 	ldrtcc	r6, [r2], #-2414	; 0x96e
    5aa0:	622f3034 	eorvs	r3, pc, #52	; 0x34
    5aa4:	646c6975 	strbtvs	r6, [ip], #-2421	; 0x975
    5aa8:	6f6f742d 	svcvs	0x006f742d
    5aac:	6863736c 	stmdavs	r3!, {r2, r3, r5, r6, r8, r9, ip, sp, lr}^
    5ab0:	2f6e6961 	svccs	0x006e6961
    5ab4:	6b726f77 	blvs	1ca1898 <MEM_SIZE+0x14a1898>
    5ab8:	2f676e69 	svccs	0x00676e69
    5abc:	2f637273 	svccs	0x00637273
    5ac0:	2d636367 	stclcs	3, cr6, [r3, #-412]!	; 0xfffffe64
    5ac4:	2e342e34 	mrccs	14, 1, r2, cr4, cr4, {1}
    5ac8:	696c2f33 	stmdbvs	ip!, {r0, r1, r4, r5, r8, r9, sl, fp, sp}^
    5acc:	63636762 	cmnvs	r3, #25690112	; 0x1880000
    5ad0:	2f2e2e2f 	svccs	0x002e2e2f
    5ad4:	2f636367 	svccs	0x00636367
    5ad8:	666e6f63 	strbtvs	r6, [lr], -r3, ror #30
    5adc:	612f6769 	teqvs	pc, r9, ror #14
    5ae0:	6c2f6d72 	stcvs	13, cr6, [pc], #-456	; 0xfffffe38
    5ae4:	66316269 	ldrtvs	r6, [r1], -r9, ror #4
    5ae8:	73636e75 	cmnvc	r3, #1872	; 0x750
    5aec:	6d73612e 	ldfvse	f6, [r3, #-184]!	; 0xffffff48
    5af0:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    5af4:	72462f74 	subvc	r2, r6, #464	; 0x1d0
    5af8:	646e6569 	strbtvs	r6, [lr], #-1385	; 0x569
    5afc:	5241796c 	subpl	r7, r1, #1769472	; 0x1b0000
    5b00:	696d2f4d 	stmdbvs	sp!, {r0, r2, r3, r6, r8, r9, sl, fp, sp}^
    5b04:	3432696e 	ldrtcc	r6, [r2], #-2414	; 0x96e
    5b08:	622f3034 	eorvs	r3, pc, #52	; 0x34
    5b0c:	646c6975 	strbtvs	r6, [ip], #-2421	; 0x975
    5b10:	6f6f742d 	svcvs	0x006f742d
    5b14:	6863736c 	stmdavs	r3!, {r2, r3, r5, r6, r8, r9, ip, sp, lr}^
    5b18:	2f6e6961 	svccs	0x006e6961
    5b1c:	6b726f77 	blvs	1ca1900 <MEM_SIZE+0x14a1900>
    5b20:	2f676e69 	svccs	0x00676e69
    5b24:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; (stclcs 2, cr7, [sp, #-388]!)	; 0xfffffe7c
    5b28:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    5b2c:	6e696c2d 	cdpvs	12, 6, cr6, cr9, cr13, {1}
    5b30:	672d7875 	undefined instruction 0x672d7875
    5b34:	6165756e 	cmnvs	r5, lr, ror #10
    5b38:	622f6962 	eorvs	r6, pc, #1605632	; 0x188000
    5b3c:	646c6975 	strbtvs	r6, [ip], #-2421	; 0x975
    5b40:	6975622f 	ldmdbvs	r5!, {r0, r1, r2, r3, r5, r9, sp, lr}^
    5b44:	632d646c 	teqvs	sp, #1811939328	; 0x6c000000
    5b48:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
    5b4c:	6f6e2d6d 	svcvs	0x006e2d6d
    5b50:	6c2d656e 	cfstr32vs	mvfx6, [sp], #-440	; 0xfffffe48
    5b54:	78756e69 	ldmdavc	r5!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
    5b58:	756e672d 	strbvc	r6, [lr, #-1837]!	; 0x72d
    5b5c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    5b60:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    5b64:	00636367 	rsbeq	r6, r3, r7, ror #6
    5b68:	20554e47 	subscs	r4, r5, r7, asr #28
    5b6c:	32205341 	eorcc	r5, r0, #67108865	; 0x4000001
    5b70:	0030322e 	eorseq	r3, r0, lr, lsr #4
    5b74:	01018001 	tsteq	r1, r1
    5b78:	00020000 	andeq	r0, r2, r0
    5b7c:	0000115a 	andeq	r1, r0, sl, asr r1
    5b80:	1dc40104 	stfnee	f0, [r4, #16]
    5b84:	6aa00000 	bvs	fe805b8c <rEINTPEND+0xa8805ae4>
    5b88:	6ab43000 	bvs	fed11b90 <rEINTPEND+0xa8d11ae8>
    5b8c:	6f2f3000 	svcvs	0x002f3000
    5b90:	462f7470 	undefined instruction 0x462f7470
    5b94:	6e656972 	mcrvs	9, 3, r6, cr5, cr2, {3}
    5b98:	41796c64 	cmnmi	r9, r4, ror #24
    5b9c:	6d2f4d52 	stcvs	13, cr4, [pc, #-328]!	; 0xfffffeb8
    5ba0:	32696e69 	rsbcc	r6, r9, #1680	; 0x690
    5ba4:	2f303434 	svccs	0x00303434
    5ba8:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	; 0xfffffe78
    5bac:	6f742d64 	svcvs	0x00742d64
    5bb0:	63736c6f 	cmnvs	r3, #28416	; 0x6f00
    5bb4:	6e696168 	powvsez	f6, f1, #0.0
    5bb8:	726f772f 	rsbvc	r7, pc, #12320768	; 0xbc0000
    5bbc:	676e696b 	strbvs	r6, [lr, -fp, ror #18]!
    5bc0:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    5bc4:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    5bc8:	342e342d 	strtcc	r3, [lr], #-1069	; 0x42d
    5bcc:	6c2f332e 	stcvs	3, cr3, [pc], #-184	; 0xffffff48
    5bd0:	63676269 	cmnvs	r7, #-1879048186	; 0x90000006
    5bd4:	2e2e2f63 	cdpcs	15, 2, cr2, cr14, cr3, {3}
    5bd8:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    5bdc:	6e6f632f 	cdpvs	3, 6, cr6, cr15, cr15, {1}
    5be0:	2f676966 	svccs	0x00676966
    5be4:	2f6d7261 	svccs	0x006d7261
    5be8:	3162696c 	cmncc	r2, ip, ror #18
    5bec:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
    5bf0:	73612e73 	cmnvc	r1, #1840	; 0x730
    5bf4:	6f2f006d 	svcvs	0x002f006d
    5bf8:	462f7470 	undefined instruction 0x462f7470
    5bfc:	6e656972 	mcrvs	9, 3, r6, cr5, cr2, {3}
    5c00:	41796c64 	cmnmi	r9, r4, ror #24
    5c04:	6d2f4d52 	stcvs	13, cr4, [pc, #-328]!	; 0xfffffeb8
    5c08:	32696e69 	rsbcc	r6, r9, #1680	; 0x690
    5c0c:	2f303434 	svccs	0x00303434
    5c10:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	; 0xfffffe78
    5c14:	6f742d64 	svcvs	0x00742d64
    5c18:	63736c6f 	cmnvs	r3, #28416	; 0x6f00
    5c1c:	6e696168 	powvsez	f6, f1, #0.0
    5c20:	726f772f 	rsbvc	r7, pc, #12320768	; 0xbc0000
    5c24:	676e696b 	strbvs	r6, [lr, -fp, ror #18]!
    5c28:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    5c2c:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    5c30:	696c2d65 	stmdbvs	ip!, {r0, r2, r5, r6, r8, sl, fp, sp}^
    5c34:	2d78756e 	cfldr64cs	mvdx7, [r8, #-440]!	; 0xfffffe48
    5c38:	65756e67 	ldrbvs	r6, [r5, #-3687]!	; 0xe67
    5c3c:	2f696261 	svccs	0x00696261
    5c40:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	; 0xfffffe78
    5c44:	75622f64 	strbvc	r2, [r2, #-3940]!	; 0xf64
    5c48:	2d646c69 	stclcs	12, cr6, [r4, #-420]!	; 0xfffffe5c
    5c4c:	612f6363 	teqvs	pc, r3, ror #6
    5c50:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    5c54:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    5c58:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0x96c
    5c5c:	6e672d78 	mcrvs	13, 3, r2, cr7, cr8, {3}
    5c60:	62616575 	rsbvs	r6, r1, #490733568	; 0x1d400000
    5c64:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    5c68:	63636762 	cmnvs	r3, #25690112	; 0x1880000
    5c6c:	554e4700 	strbpl	r4, [lr, #-1792]	; 0x700
    5c70:	20534120 	subscs	r4, r3, r0, lsr #2
    5c74:	30322e32 	eorscc	r2, r2, r2, lsr lr
    5c78:	Address 0x00005c78 is out of bounds.


Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	10001101 	andne	r1, r0, r1, lsl #2
       4:	12011106 	andne	r1, r1, #-2147483647	; 0x80000001
       8:	1b080301 	blne	200c14 <DISABLE_IRQ+0x200b94>
       c:	13082508 	movwne	r2, #34056	; 0x8508
      10:	00000005 	andeq	r0, r0, r5
      14:	10001101 	andne	r1, r0, r1, lsl #2
      18:	12011106 	andne	r1, r1, #-2147483647	; 0x80000001
      1c:	1b080301 	blne	200c28 <DISABLE_IRQ+0x200ba8>
      20:	13082508 	movwne	r2, #34056	; 0x8508
      24:	00000005 	andeq	r0, r0, r5
      28:	25011101 	strcs	r1, [r1, #-257]	; 0x101
      2c:	030b130e 	movweq	r1, #45838	; 0xb30e
      30:	110e1b0e 	tstne	lr, lr, lsl #22
      34:	10011201 	andne	r1, r1, r1, lsl #4
      38:	02000006 	andeq	r0, r0, #6
      3c:	0b0b0024 	bleq	2c00d4 <DISABLE_IRQ+0x2c0054>
      40:	0e030b3e 	vmoveq.16	d3[0], r0
      44:	24030000 	strcs	r0, [r3]
      48:	3e0b0b00 	vmlacc.f64	d0, d11, d0
      4c:	0400000b 	streq	r0, [r0], #-11
      50:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
      54:	0b3b0b3a 	bleq	ec2d44 <MEM_SIZE+0x6c2d44>
      58:	00001349 	andeq	r1, r0, r9, asr #6
      5c:	0b000f05 	bleq	3c78 <DISABLE_IRQ+0x3bf8>
      60:	0013490b 	andseq	r4, r3, fp, lsl #18
      64:	00150600 	andseq	r0, r5, r0, lsl #12
      68:	00000c27 	andeq	r0, r0, r7, lsr #24
      6c:	3f012e07 	svccc	0x00012e07
      70:	3a0e030c 	bcc	380ca8 <DISABLE_IRQ+0x380c28>
      74:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
      78:	010b200c 	tsteq	fp, ip
      7c:	08000013 	stmdaeq	r0, {r0, r1, r4}
      80:	08030034 	stmdaeq	r3, {r2, r4, r5}
      84:	0b3b0b3a 	bleq	ec2d74 <MEM_SIZE+0x6c2d74>
      88:	00001349 	andeq	r1, r0, r9, asr #6
      8c:	49002609 	stmdbmi	r0, {r0, r3, r9, sl, sp}
      90:	0a000013 	beq	e4 <DISABLE_IRQ+0x64>
      94:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
      98:	0b3a0e03 	bleq	e838ac <MEM_SIZE+0x6838ac>
      9c:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
      a0:	01120111 	tsteq	r2, r1, lsl r1
      a4:	13010a40 	movwne	r0, #6720	; 0x1a40
      a8:	2e0b0000 	cdpcs	0, 0, cr0, cr11, cr0, {0}
      ac:	11133101 	tstne	r3, r1, lsl #2
      b0:	40011201 	andmi	r1, r1, r1, lsl #4
      b4:	0013010a 	andseq	r0, r3, sl, lsl #2
      b8:	00340c00 	eorseq	r0, r4, r0, lsl #24
      bc:	00001331 	andeq	r1, r0, r1, lsr r3
      c0:	0300050d 	movweq	r0, #1293	; 0x50d
      c4:	3b0b3a08 	blcc	2ce8ec <DISABLE_IRQ+0x2ce86c>
      c8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
      cc:	0e00000a 	cdpeq	0, 0, cr0, cr0, cr10, {0}
      d0:	0b0b0024 	bleq	2c0168 <DISABLE_IRQ+0x2c00e8>
      d4:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
      d8:	2e0f0000 	cdpcs	0, 0, cr0, cr15, cr0, {0}
      dc:	030c3f00 	movweq	r3, #52992	; 0xcf00
      e0:	3b0b3a0e 	blcc	2ce920 <DISABLE_IRQ+0x2ce8a0>
      e4:	110c270b 	tstne	ip, fp, lsl #14
      e8:	40011201 	andmi	r1, r1, r1, lsl #4
      ec:	10000006 	andne	r0, r0, r6
      f0:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
      f4:	0b3a0e03 	bleq	e83908 <MEM_SIZE+0x683908>
      f8:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
      fc:	01120111 	tsteq	r2, r1, lsl r1
     100:	13010640 	movwne	r0, #5696	; 0x1640
     104:	1d110000 	ldcne	0, cr0, [r1]
     108:	11133101 	tstne	r3, r1, lsl #2
     10c:	58011201 	stmdapl	r1, {r0, r9, ip}
     110:	000b590b 	andeq	r5, fp, fp, lsl #18
     114:	010b1200 	tsteq	fp, r0, lsl #4
     118:	01120111 	tsteq	r2, r1, lsl r1
     11c:	01130000 	tsteq	r3, r0
     120:	01134901 	tsteq	r3, r1, lsl #18
     124:	14000013 	strne	r0, [r0], #-19
     128:	13490021 	movtne	r0, #36897	; 0x9021
     12c:	00000b2f 	andeq	r0, r0, pc, lsr #22
     130:	03003415 	movweq	r3, #1045	; 0x415
     134:	3b0b3a0e 	blcc	2ce974 <DISABLE_IRQ+0x2ce8f4>
     138:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     13c:	1600000a 	strne	r0, [r0], -sl
     140:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     144:	0b3b0b3a 	bleq	ec2e34 <MEM_SIZE+0x6c2e34>
     148:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 0xfffffedc
     14c:	00000a02 	andeq	r0, r0, r2, lsl #20
     150:	00110100 	andseq	r0, r1, r0, lsl #2
     154:	01110610 	tsteq	r1, r0, lsl r6
     158:	08030112 	stmdaeq	r3, {r1, r4, r8}
     15c:	0825081b 	stmdaeq	r5!, {r0, r1, r3, r4, fp}
     160:	00000513 	andeq	r0, r0, r3, lsl r5
     164:	00110100 	andseq	r0, r1, r0, lsl #2
     168:	01110610 	tsteq	r1, r0, lsl r6
     16c:	08030112 	stmdaeq	r3, {r1, r4, r8}
     170:	0825081b 	stmdaeq	r5!, {r0, r1, r3, r4, fp}
     174:	00000513 	andeq	r0, r0, r3, lsl r5
     178:	01110100 	tsteq	r1, r0, lsl #2
     17c:	0b130e25 	bleq	4c3a18 <DISABLE_IRQ+0x4c3998>
     180:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     184:	01120111 	tsteq	r2, r1, lsl r1
     188:	00000610 	andeq	r0, r0, r0, lsl r6
     18c:	3f012e02 	svccc	0x00012e02
     190:	3a0e030c 	bcc	380dc8 <DISABLE_IRQ+0x380d48>
     194:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     198:	2013490c 	andscs	r4, r3, ip, lsl #18
     19c:	0013010b 	andseq	r0, r3, fp, lsl #2
     1a0:	00050300 	andeq	r0, r5, r0, lsl #6
     1a4:	0b3a0e03 	bleq	e839b8 <MEM_SIZE+0x6839b8>
     1a8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     1ac:	24040000 	strcs	r0, [r4]
     1b0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     1b4:	000e030b 	andeq	r0, lr, fp, lsl #6
     1b8:	012e0500 	teqeq	lr, r0, lsl #10
     1bc:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     1c0:	0b3b0b3a 	bleq	ec2eb0 <MEM_SIZE+0x6c2eb0>
     1c4:	01110c27 	tsteq	r1, r7, lsr #24
     1c8:	0a400112 	beq	1000618 <MEM_SIZE+0x800618>
     1cc:	00001301 	andeq	r1, r0, r1, lsl #6
     1d0:	03003406 	movweq	r3, #1030	; 0x406
     1d4:	3b0b3a08 	blcc	2ce9fc <DISABLE_IRQ+0x2ce97c>
     1d8:	0013490b 	andseq	r4, r3, fp, lsl #18
     1dc:	012e0700 	teqeq	lr, r0, lsl #14
     1e0:	01111331 	tsteq	r1, r1, lsr r3
     1e4:	0a400112 	beq	1000634 <MEM_SIZE+0x800634>
     1e8:	00001301 	andeq	r1, r0, r1, lsl #6
     1ec:	31000508 	tstcc	r0, r8, lsl #10
     1f0:	00060213 	andeq	r0, r6, r3, lsl r2
     1f4:	00340900 	eorseq	r0, r4, r0, lsl #18
     1f8:	0b3a0803 	bleq	e8220c <MEM_SIZE+0x68220c>
     1fc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     200:	00000602 	andeq	r0, r0, r2, lsl #12
     204:	0300340a 	movweq	r3, #1034	; 0x40a
     208:	3b0b3a0e 	blcc	2cea48 <DISABLE_IRQ+0x2ce9c8>
     20c:	0013490b 	andseq	r4, r3, fp, lsl #18
     210:	00340b00 	eorseq	r0, r4, r0, lsl #22
     214:	0b3a0803 	bleq	e82228 <MEM_SIZE+0x682228>
     218:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     21c:	00000a02 	andeq	r0, r0, r2, lsl #20
     220:	31011d0c 	tstcc	r1, ip, lsl #26
     224:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     228:	590b5801 	stmdbpl	fp, {r0, fp, ip, lr}
     22c:	0d00000b 	stceq	0, cr0, [r0, #-44]	; 0xffffffd4
     230:	13310005 	teqne	r1, #5
     234:	240e0000 	strcs	r0, [lr]
     238:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     23c:	0008030b 	andeq	r0, r8, fp, lsl #6
     240:	11010000 	tstne	r1, r0
     244:	130e2501 	movwne	r2, #58625	; 0xe501
     248:	1b0e030b 	blne	380e7c <DISABLE_IRQ+0x380dfc>
     24c:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     250:	00061001 	andeq	r1, r6, r1
     254:	00240200 	eoreq	r0, r4, r0, lsl #4
     258:	0b3e0b0b 	bleq	f82e8c <MEM_SIZE+0x782e8c>
     25c:	00000e03 	andeq	r0, r0, r3, lsl #28
     260:	03001603 	movweq	r1, #1539	; 0x603
     264:	3b0b3a0e 	blcc	2ceaa4 <DISABLE_IRQ+0x2cea24>
     268:	0013490b 	andseq	r4, r3, fp, lsl #18
     26c:	000f0400 	andeq	r0, pc, r0, lsl #8
     270:	00000b0b 	andeq	r0, r0, fp, lsl #22
     274:	0b002405 	bleq	9290 <DISABLE_IRQ+0x9210>
     278:	000b3e0b 	andeq	r3, fp, fp, lsl #28
     27c:	000f0600 	andeq	r0, pc, r0, lsl #12
     280:	13490b0b 	movtne	r0, #39691	; 0x9b0b
     284:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
     288:	030c3f01 	movweq	r3, #52993	; 0xcf01
     28c:	3b0b3a0e 	blcc	2ceacc <DISABLE_IRQ+0x2cea4c>
     290:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     294:	010b2013 	tsteq	fp, r3, lsl r0
     298:	08000013 	stmdaeq	r0, {r0, r1, r4}
     29c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     2a0:	0b3b0b3a 	bleq	ec2f90 <MEM_SIZE+0x6c2f90>
     2a4:	00001349 	andeq	r1, r0, r9, asr #6
     2a8:	03000509 	movweq	r0, #1289	; 0x509
     2ac:	3b0b3a08 	blcc	2cead4 <DISABLE_IRQ+0x2cea54>
     2b0:	0013490b 	andseq	r4, r3, fp, lsl #18
     2b4:	00340a00 	eorseq	r0, r4, r0, lsl #20
     2b8:	0b3a0803 	bleq	e822cc <MEM_SIZE+0x6822cc>
     2bc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     2c0:	260b0000 	strcs	r0, [fp], -r0
     2c4:	0c000000 	stceq	0, cr0, [r0], {0}
     2c8:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
     2cc:	01120111 	tsteq	r2, r1, lsl r1
     2d0:	13010a40 	movwne	r0, #6720	; 0x1a40
     2d4:	050d0000 	streq	r0, [sp]
     2d8:	02133100 	andseq	r3, r3, #0
     2dc:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
     2e0:	13310005 	teqne	r1, #5
     2e4:	00000a02 	andeq	r0, r0, r2, lsl #20
     2e8:	3100340f 	tstcc	r0, pc, lsl #8
     2ec:	10000013 	andne	r0, r0, r3, lsl r0
     2f0:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
     2f4:	0b3a0e03 	bleq	e83b08 <MEM_SIZE+0x683b08>
     2f8:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     2fc:	01111349 	tsteq	r1, r9, asr #6
     300:	06400112 	undefined instruction 0x06400112
     304:	00001301 	andeq	r1, r0, r1, lsl #6
     308:	03000511 	movweq	r0, #1297	; 0x511
     30c:	3b0b3a08 	blcc	2ceb34 <DISABLE_IRQ+0x2ceab4>
     310:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     314:	12000006 	andne	r0, r0, #6
     318:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     31c:	0b3b0b3a 	bleq	ec300c <MEM_SIZE+0x6c300c>
     320:	06021349 	streq	r1, [r2], -r9, asr #6
     324:	34130000 	ldrcc	r0, [r3]
     328:	3a080300 	bcc	200f30 <DISABLE_IRQ+0x200eb0>
     32c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     330:	00060213 	andeq	r0, r6, r3, lsl r2
     334:	00341400 	eorseq	r1, r4, r0, lsl #8
     338:	0b3a0e03 	bleq	e83b4c <MEM_SIZE+0x683b4c>
     33c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     340:	00000a02 	andeq	r0, r0, r2, lsl #20
     344:	55010b15 	strpl	r0, [r1, #-2837]	; 0xb15
     348:	16000006 	strne	r0, [r0], -r6
     34c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     350:	0b3b0b3a 	bleq	ec3040 <MEM_SIZE+0x6c3040>
     354:	00001349 	andeq	r1, r0, r9, asr #6
     358:	0b002417 	bleq	93bc <DISABLE_IRQ+0x933c>
     35c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     360:	18000008 	stmdane	r0, {r3}
     364:	13490101 	movtne	r0, #37121	; 0x9101
     368:	00001301 	andeq	r1, r0, r1, lsl #6
     36c:	49002119 	stmdbmi	r0, {r0, r3, r4, r8, sp}
     370:	000b2f13 	andeq	r2, fp, r3, lsl pc
     374:	012e1a00 	teqeq	lr, r0, lsl #20
     378:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     37c:	0b3b0b3a 	bleq	ec306c <MEM_SIZE+0x6c306c>
     380:	13490c27 	movtne	r0, #39975	; 0x9c27
     384:	01120111 	tsteq	r2, r1, lsl r1
     388:	13010a40 	movwne	r0, #6720	; 0x1a40
     38c:	051b0000 	ldreq	r0, [fp]
     390:	3a0e0300 	bcc	380f98 <DISABLE_IRQ+0x380f18>
     394:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     398:	000a0213 	andeq	r0, sl, r3, lsl r2
     39c:	00261c00 	eoreq	r1, r6, r0, lsl #24
     3a0:	00001349 	andeq	r1, r0, r9, asr #6
     3a4:	0300341d 	movweq	r3, #1053	; 0x41d
     3a8:	3b0b3a08 	blcc	2cebd0 <DISABLE_IRQ+0x2ceb50>
     3ac:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     3b0:	1e00000a 	cdpne	0, 0, cr0, cr0, cr10, {0}
     3b4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     3b8:	0b3b0b3a 	bleq	ec30a8 <MEM_SIZE+0x6c30a8>
     3bc:	06021349 	streq	r1, [r2], -r9, asr #6
     3c0:	0b1f0000 	bleq	7c03c8 <DISABLE_IRQ+0x7c0348>
     3c4:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
     3c8:	20000001 	andcs	r0, r0, r1
     3cc:	1331011d 	teqne	r1, #1073741831	; 0x40000007
     3d0:	01120111 	tsteq	r2, r1, lsl r1
     3d4:	0b590b58 	bleq	164313c <MEM_SIZE+0xe4313c>
     3d8:	05210000 	streq	r0, [r1]!
     3dc:	00133100 	andseq	r3, r3, r0, lsl #2
     3e0:	012e2200 	teqeq	lr, r0, lsl #4
     3e4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     3e8:	0b3b0b3a 	bleq	ec30d8 <MEM_SIZE+0x6c30d8>
     3ec:	01110c27 	tsteq	r1, r7, lsr #24
     3f0:	06400112 	undefined instruction 0x06400112
     3f4:	00001301 	andeq	r1, r0, r1, lsl #6
     3f8:	03000523 	movweq	r0, #1315	; 0x523
     3fc:	3b0b3a08 	blcc	2cec24 <DISABLE_IRQ+0x2ceba4>
     400:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     404:	2400000a 	strcs	r0, [r0], #-10
     408:	00000018 	andeq	r0, r0, r8, lsl r0
     40c:	3f012e25 	svccc	0x00012e25
     410:	3a0e030c 	bcc	381048 <DISABLE_IRQ+0x380fc8>
     414:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     418:	1201110c 	andne	r1, r1, #3
     41c:	01064001 	tsteq	r6, r1
     420:	26000013 	undefined instruction 0x26000013
     424:	08030034 	stmdaeq	r3, {r2, r4, r5}
     428:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     42c:	00001349 	andeq	r1, r0, r9, asr #6
     430:	03003427 	movweq	r3, #1063	; 0x427
     434:	3b0b3a0e 	blcc	2cec74 <DISABLE_IRQ+0x2cebf4>
     438:	3f13490b 	svccc	0x0013490b
     43c:	000a020c 	andeq	r0, sl, ip, lsl #4
     440:	11010000 	tstne	r1, r0
     444:	130e2501 	movwne	r2, #58625	; 0xe501
     448:	1b0e030b 	blne	38107c <DISABLE_IRQ+0x380ffc>
     44c:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     450:	00061001 	andeq	r1, r6, r1
     454:	002e0200 	eoreq	r0, lr, r0, lsl #4
     458:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     45c:	0b3b0b3a 	bleq	ec314c <MEM_SIZE+0x6c314c>
     460:	01110c27 	tsteq	r1, r7, lsr #24
     464:	06400112 	undefined instruction 0x06400112
     468:	2e030000 	cdpcs	0, 0, cr0, cr3, cr0, {0}
     46c:	030c3f01 	movweq	r3, #52993	; 0xcf01
     470:	3b0b3a0e 	blcc	2cecb0 <DISABLE_IRQ+0x2cec30>
     474:	110c270b 	tstne	ip, fp, lsl #14
     478:	40011201 	andmi	r1, r1, r1, lsl #4
     47c:	0013010a 	andseq	r0, r3, sl, lsl #2
     480:	00050400 	andeq	r0, r5, r0, lsl #8
     484:	0b3a0e03 	bleq	e83c98 <MEM_SIZE+0x683c98>
     488:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     48c:	00000a02 	andeq	r0, r0, r2, lsl #20
     490:	0b002405 	bleq	94ac <DISABLE_IRQ+0x942c>
     494:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     498:	0600000e 	streq	r0, [r0], -lr
     49c:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
     4a0:	0b3a0e03 	bleq	e83cb4 <MEM_SIZE+0x683cb4>
     4a4:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     4a8:	01120111 	tsteq	r2, r1, lsl r1
     4ac:	00000640 	andeq	r0, r0, r0, asr #12
     4b0:	03003407 	movweq	r3, #1031	; 0x407
     4b4:	3b0b3a08 	blcc	2cecdc <DISABLE_IRQ+0x2cec5c>
     4b8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     4bc:	00000006 	andeq	r0, r0, r6
     4c0:	25011101 	strcs	r1, [r1, #-257]	; 0x101
     4c4:	030b130e 	movweq	r1, #45838	; 0xb30e
     4c8:	110e1b0e 	tstne	lr, lr, lsl #22
     4cc:	10011201 	andne	r1, r1, r1, lsl #4
     4d0:	02000006 	andeq	r0, r0, #6
     4d4:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     4d8:	0b3b0b3a 	bleq	ec31c8 <MEM_SIZE+0x6c31c8>
     4dc:	00001349 	andeq	r1, r0, r9, asr #6
     4e0:	0b002403 	bleq	94f4 <DISABLE_IRQ+0x9474>
     4e4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     4e8:	0400000e 	streq	r0, [r0], #-14
     4ec:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     4f0:	0b3a0b0b 	bleq	e83124 <MEM_SIZE+0x683124>
     4f4:	1301053b 	movwne	r0, #5435	; 0x153b
     4f8:	0d050000 	stceq	0, cr0, [r5]
     4fc:	3a0e0300 	bcc	381104 <DISABLE_IRQ+0x381084>
     500:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     504:	000a3813 	andeq	r3, sl, r3, lsl r8
     508:	000f0600 	andeq	r0, pc, r0, lsl #12
     50c:	00000b0b 	andeq	r0, r0, fp, lsl #22
     510:	49010107 	stmdbmi	r1, {r0, r1, r2, r8}
     514:	00130113 	andseq	r0, r3, r3, lsl r1
     518:	00210800 	eoreq	r0, r1, r0, lsl #16
     51c:	0b2f1349 	bleq	bc5248 <MEM_SIZE+0x3c5248>
     520:	24090000 	strcs	r0, [r9]
     524:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     528:	0a00000b 	beq	55c <DISABLE_IRQ+0x4dc>
     52c:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     530:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     534:	00001349 	andeq	r1, r0, r9, asr #6
     538:	0b000f0b 	bleq	416c <DISABLE_IRQ+0x40ec>
     53c:	0013490b 	andseq	r4, r3, fp, lsl #18
     540:	01150c00 	tsteq	r5, r0, lsl #24
     544:	13010c27 	movwne	r0, #7207	; 0x1c27
     548:	050d0000 	streq	r0, [sp]
     54c:	00134900 	andseq	r4, r3, r0, lsl #18
     550:	012e0e00 	teqeq	lr, r0, lsl #28
     554:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     558:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     55c:	0b200c27 	bleq	803600 <MEM_SIZE+0x3600>
     560:	00001301 	andeq	r1, r0, r1, lsl #6
     564:	0300050f 	movweq	r0, #1295	; 0x50f
     568:	3b0b3a0e 	blcc	2ceda8 <DISABLE_IRQ+0x2ced28>
     56c:	00134905 	andseq	r4, r3, r5, lsl #18
     570:	00341000 	eorseq	r1, r4, r0
     574:	0b3a0e03 	bleq	e83d88 <MEM_SIZE+0x683d88>
     578:	1349053b 	movtne	r0, #38203	; 0x953b
     57c:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
     580:	030c3f01 	movweq	r3, #52993	; 0xcf01
     584:	3b0b3a0e 	blcc	2cedc4 <DISABLE_IRQ+0x2ced44>
     588:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     58c:	010b2013 	tsteq	fp, r3, lsl r0
     590:	12000013 	andne	r0, r0, #19
     594:	08030034 	stmdaeq	r3, {r2, r4, r5}
     598:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     59c:	00001349 	andeq	r1, r0, r9, asr #6
     5a0:	03012e13 	movweq	r2, #7699	; 0x1e13
     5a4:	3b0b3a0e 	blcc	2cede4 <DISABLE_IRQ+0x2ced64>
     5a8:	200c2705 	andcs	r2, ip, r5, lsl #14
     5ac:	0013010b 	andseq	r0, r3, fp, lsl #2
     5b0:	002e1400 	eoreq	r1, lr, r0, lsl #8
     5b4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     5b8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     5bc:	0b200c27 	bleq	803660 <MEM_SIZE+0x3660>
     5c0:	05150000 	ldreq	r0, [r5]
     5c4:	3a080300 	bcc	2011cc <DISABLE_IRQ+0x20114c>
     5c8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     5cc:	16000013 	undefined instruction 0x16000013
     5d0:	0e03012e 	adfeqsp	f0, f3, #0.5
     5d4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     5d8:	13490c27 	movtne	r0, #39975	; 0x9c27
     5dc:	13010b20 	movwne	r0, #6944	; 0x1b20
     5e0:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
     5e4:	3a0e0300 	bcc	3811ec <DISABLE_IRQ+0x38116c>
     5e8:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     5ec:	000b200c 	andeq	r2, fp, ip
     5f0:	012e1800 	teqeq	lr, r0, lsl #16
     5f4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     5f8:	0b3b0b3a 	bleq	ec32e8 <MEM_SIZE+0x6c32e8>
     5fc:	0b200c27 	bleq	8036a0 <MEM_SIZE+0x36a0>
     600:	00001301 	andeq	r1, r0, r1, lsl #6
     604:	03003419 	movweq	r3, #1049	; 0x419
     608:	3b0b3a0e 	blcc	2cee48 <DISABLE_IRQ+0x2cedc8>
     60c:	0013490b 	andseq	r4, r3, fp, lsl #18
     610:	002e1a00 	eoreq	r1, lr, r0, lsl #20
     614:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     618:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     61c:	01110c27 	tsteq	r1, r7, lsr #24
     620:	0a400112 	beq	1000a70 <MEM_SIZE+0x800a70>
     624:	2e1b0000 	cdpcs	0, 1, cr0, cr11, cr0, {0}
     628:	030c3f00 	movweq	r3, #52992	; 0xcf00
     62c:	3b0b3a0e 	blcc	2cee6c <DISABLE_IRQ+0x2cedec>
     630:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     634:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     638:	000a4001 	andeq	r4, sl, r1
     63c:	002e1c00 	eoreq	r1, lr, r0, lsl #24
     640:	01111331 	tsteq	r1, r1, lsr r3
     644:	0a400112 	beq	1000a94 <MEM_SIZE+0x800a94>
     648:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
     64c:	030c3f01 	movweq	r3, #52993	; 0xcf01
     650:	3b0b3a0e 	blcc	2cee90 <DISABLE_IRQ+0x2cee10>
     654:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     658:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     65c:	01064001 	tsteq	r6, r1
     660:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
     664:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     668:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     66c:	06021349 	streq	r1, [r2], -r9, asr #6
     670:	051f0000 	ldreq	r0, [pc, #0]	; 678 <DISABLE_IRQ+0x5f8>
     674:	3a080300 	bcc	20127c <DISABLE_IRQ+0x2011fc>
     678:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     67c:	00060213 	andeq	r0, r6, r3, lsl r2
     680:	00342000 	eorseq	r2, r4, r0
     684:	0b3a0e03 	bleq	e83e98 <MEM_SIZE+0x683e98>
     688:	1349053b 	movtne	r0, #38203	; 0x953b
     68c:	00000602 	andeq	r0, r0, r2, lsl #12
     690:	03003421 	movweq	r3, #1057	; 0x421
     694:	3b0b3a08 	blcc	2ceebc <DISABLE_IRQ+0x2cee3c>
     698:	02134905 	andseq	r4, r3, #81920	; 0x14000
     69c:	22000006 	andcs	r0, r0, #6
     6a0:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
     6a4:	01120111 	tsteq	r2, r1, lsl r1
     6a8:	13010640 	movwne	r0, #5696	; 0x1640
     6ac:	05230000 	streq	r0, [r3]!
     6b0:	02133100 	andseq	r3, r3, #0
     6b4:	2400000a 	strcs	r0, [r0], #-10
     6b8:	13310034 	teqne	r1, #52	; 0x34
     6bc:	2e250000 	cdpcs	0, 2, cr0, cr5, cr0, {0}
     6c0:	11133101 	tstne	r3, r1, lsl #2
     6c4:	40011201 	andmi	r1, r1, r1, lsl #4
     6c8:	0013010a 	andseq	r0, r3, sl, lsl #2
     6cc:	00052600 	andeq	r2, r5, r0, lsl #12
     6d0:	06021331 	undefined instruction 0x06021331
     6d4:	34270000 	strtcc	r0, [r7]
     6d8:	02133100 	andseq	r3, r3, #0
     6dc:	2800000a 	stmdacs	r0, {r1, r3}
     6e0:	13310034 	teqne	r1, #52	; 0x34
     6e4:	00000602 	andeq	r0, r0, r2, lsl #12
     6e8:	03012e29 	movweq	r2, #7721	; 0x1e29
     6ec:	3b0b3a0e 	blcc	2cef2c <DISABLE_IRQ+0x2ceeac>
     6f0:	110c2705 	tstne	ip, r5, lsl #14
     6f4:	40011201 	andmi	r1, r1, r1, lsl #4
     6f8:	00130106 	andseq	r0, r3, r6, lsl #2
     6fc:	012e2a00 	teqeq	lr, r0, lsl #20
     700:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     704:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     708:	01110c27 	tsteq	r1, r7, lsr #24
     70c:	06400112 	undefined instruction 0x06400112
     710:	00001301 	andeq	r1, r0, r1, lsl #6
     714:	31011d2b 	tstcc	r1, fp, lsr #26
     718:	55015213 	strpl	r5, [r1, #-531]	; 0x213
     71c:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
     720:	2c000005 	stccs	0, cr0, [r0], {5}
     724:	13310005 	teqne	r1, #5
     728:	2e2d0000 	cdpcs	0, 2, cr0, cr13, cr0, {0}
     72c:	3a0e0301 	bcc	381338 <DISABLE_IRQ+0x3812b8>
     730:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     734:	1113490c 	tstne	r3, ip, lsl #18
     738:	40011201 	andmi	r1, r1, r1, lsl #4
     73c:	00130106 	andseq	r0, r3, r6, lsl #2
     740:	010b2e00 	tsteq	fp, r0, lsl #28
     744:	00000655 	andeq	r0, r0, r5, asr r6
     748:	3f012e2f 	svccc	0x00012e2f
     74c:	3a0e030c 	bcc	381384 <DISABLE_IRQ+0x381304>
     750:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     754:	1201110c 	andne	r1, r1, #3
     758:	010a4001 	tsteq	sl, r1
     75c:	30000013 	andcc	r0, r0, r3, lsl r0
     760:	1331011d 	teqne	r1, #1073741831	; 0x40000007
     764:	01120111 	tsteq	r2, r1, lsl r1
     768:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
     76c:	05310000 	ldreq	r0, [r1]!
     770:	3a0e0300 	bcc	381378 <DISABLE_IRQ+0x3812f8>
     774:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     778:	000a0213 	andeq	r0, sl, r3, lsl r2
     77c:	012e3200 	teqeq	lr, r0, lsl #4
     780:	0b3a0e03 	bleq	e83f94 <MEM_SIZE+0x683f94>
     784:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236	; 0xffffff14
     788:	01120111 	tsteq	r2, r1, lsl r1
     78c:	13010a40 	movwne	r0, #6720	; 0x1a40
     790:	34330000 	ldrtcc	r0, [r3]
     794:	3a0e0300 	bcc	38139c <DISABLE_IRQ+0x38131c>
     798:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     79c:	000a0213 	andeq	r0, sl, r3, lsl r2
     7a0:	012e3400 	teqeq	lr, r0, lsl #8
     7a4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     7a8:	0b3b0b3a 	bleq	ec3498 <MEM_SIZE+0x6c3498>
     7ac:	01110c27 	tsteq	r1, r7, lsr #24
     7b0:	06400112 	undefined instruction 0x06400112
     7b4:	00001301 	andeq	r1, r0, r1, lsl #6
     7b8:	03000535 	movweq	r0, #1333	; 0x535
     7bc:	3b0b3a0e 	blcc	2ceffc <DISABLE_IRQ+0x2cef7c>
     7c0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     7c4:	36000006 	strcc	r0, [r0], -r6
     7c8:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
     7cc:	0b3a0e03 	bleq	e83fe0 <MEM_SIZE+0x683fe0>
     7d0:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     7d4:	01111349 	tsteq	r1, r9, asr #6
     7d8:	06400112 	undefined instruction 0x06400112
     7dc:	00001301 	andeq	r1, r0, r1, lsl #6
     7e0:	03003437 	movweq	r3, #1079	; 0x437
     7e4:	3b0b3a0e 	blcc	2cf024 <DISABLE_IRQ+0x2cefa4>
     7e8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     7ec:	3800000a 	stmdacc	r0, {r1, r3}
     7f0:	1331011d 	teqne	r1, #1073741831	; 0x40000007
     7f4:	06550152 	undefined instruction 0x06550152
     7f8:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
     7fc:	00001301 	andeq	r1, r0, r1, lsl #6
     800:	11010b39 	tstne	r1, r9, lsr fp
     804:	00011201 	andeq	r1, r1, r1, lsl #4
     808:	00053a00 	andeq	r3, r5, r0, lsl #20
     80c:	0b3a0803 	bleq	e82820 <MEM_SIZE+0x682820>
     810:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     814:	00000602 	andeq	r0, r0, r2, lsl #12
     818:	31011d3b 	tstcc	r1, fp, lsr sp
     81c:	55015213 	strpl	r5, [r1, #-531]	; 0x213
     820:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
     824:	3c00000b 	stccc	0, cr0, [r0], {11}
     828:	08030034 	stmdaeq	r3, {r2, r4, r5}
     82c:	0b3b0b3a 	bleq	ec351c <MEM_SIZE+0x6c351c>
     830:	06021349 	streq	r1, [r2], -r9, asr #6
     834:	343d0000 	ldrtcc	r0, [sp]
     838:	3a080300 	bcc	201440 <DISABLE_IRQ+0x2013c0>
     83c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     840:	000a0213 	andeq	r0, sl, r3, lsl r2
     844:	00343e00 	eorseq	r3, r4, r0, lsl #28
     848:	0b3a0e03 	bleq	e8405c <MEM_SIZE+0x68405c>
     84c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     850:	00000602 	andeq	r0, r0, r2, lsl #12
     854:	0300343f 	movweq	r3, #1087	; 0x43f
     858:	3b0b3a08 	blcc	2cf080 <DISABLE_IRQ+0x2cf000>
     85c:	0013490b 	andseq	r4, r3, fp, lsl #18
     860:	011d4000 	tsteq	sp, r0
     864:	01111331 	tsteq	r1, r1, lsr r3
     868:	0b580112 	bleq	1600cb8 <MEM_SIZE+0xe00cb8>
     86c:	00000b59 	andeq	r0, r0, r9, asr fp
     870:	31011d41 	tstcc	r1, r1, asr #26
     874:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     878:	590b5801 	stmdbpl	fp, {r0, fp, ip, lr}
     87c:	0013010b 	andseq	r0, r3, fp, lsl #2
     880:	00344200 	eorseq	r4, r4, r0, lsl #4
     884:	0b3a0803 	bleq	e82898 <MEM_SIZE+0x682898>
     888:	1349053b 	movtne	r0, #38203	; 0x953b
     88c:	00000a02 	andeq	r0, r0, r2, lsl #20
     890:	31011d43 	tstcc	r1, r3, asr #26
     894:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     898:	590b5801 	stmdbpl	fp, {r0, fp, ip, lr}
     89c:	00130105 	andseq	r0, r3, r5, lsl #2
     8a0:	002e4400 	eoreq	r4, lr, r0, lsl #8
     8a4:	0b3a0e03 	bleq	e840b8 <MEM_SIZE+0x6840b8>
     8a8:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236	; 0xffffff14
     8ac:	01120111 	tsteq	r2, r1, lsl r1
     8b0:	00000a40 	andeq	r0, r0, r0, asr #20
     8b4:	3f012e45 	svccc	0x00012e45
     8b8:	3a0e030c 	bcc	3814f0 <DISABLE_IRQ+0x381470>
     8bc:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     8c0:	1113490c 	tstne	r3, ip, lsl #18
     8c4:	40011201 	andmi	r1, r1, r1, lsl #4
     8c8:	0013010a 	andseq	r0, r3, sl, lsl #2
     8cc:	011d4600 	tsteq	sp, r0, lsl #12
     8d0:	01521331 	cmpeq	r2, r1, lsr r3
     8d4:	0b580655 	bleq	1602230 <MEM_SIZE+0xe02230>
     8d8:	13010b59 	movwne	r0, #7001	; 0x1b59
     8dc:	1d470000 	stclne	0, cr0, [r7]
     8e0:	52133100 	andspl	r3, r3, #0
     8e4:	58065501 	stmdapl	r6, {r0, r8, sl, ip, lr}
     8e8:	000b590b 	andeq	r5, fp, fp, lsl #18
     8ec:	00344800 	eorseq	r4, r4, r0, lsl #16
     8f0:	0b3a0e03 	bleq	e84104 <MEM_SIZE+0x684104>
     8f4:	1349053b 	movtne	r0, #38203	; 0x953b
     8f8:	0a020c3f 	beq	839fc <DISABLE_IRQ+0x8397c>
     8fc:	35490000 	strbcc	r0, [r9]
     900:	00134900 	andseq	r4, r3, r0, lsl #18
     904:	00344a00 	eorseq	r4, r4, r0, lsl #20
     908:	0b3a0e03 	bleq	e8411c <MEM_SIZE+0x68411c>
     90c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     910:	0a020c3f 	beq	83a14 <DISABLE_IRQ+0x83994>
     914:	264b0000 	strbcs	r0, [fp], -r0
     918:	00134900 	andseq	r4, r3, r0, lsl #18
     91c:	11010000 	tstne	r1, r0
     920:	130e2501 	movwne	r2, #58625	; 0xe501
     924:	1b0e030b 	blne	381558 <DISABLE_IRQ+0x3814d8>
     928:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     92c:	00061001 	andeq	r1, r6, r1
     930:	00240200 	eoreq	r0, r4, r0, lsl #4
     934:	0b3e0b0b 	bleq	f83568 <MEM_SIZE+0x783568>
     938:	00000e03 	andeq	r0, r0, r3, lsl #28
     93c:	03001603 	movweq	r1, #1539	; 0x603
     940:	3b0b3a0e 	blcc	2cf180 <DISABLE_IRQ+0x2cf100>
     944:	0013490b 	andseq	r4, r3, fp, lsl #18
     948:	000f0400 	andeq	r0, pc, r0, lsl #8
     94c:	00000b0b 	andeq	r0, r0, fp, lsl #22
     950:	0b002405 	bleq	996c <DISABLE_IRQ+0x98ec>
     954:	000b3e0b 	andeq	r3, fp, fp, lsl #28
     958:	002e0600 	eoreq	r0, lr, r0, lsl #12
     95c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     960:	0b3b0b3a 	bleq	ec3650 <MEM_SIZE+0x6c3650>
     964:	01120111 	tsteq	r2, r1, lsl r1
     968:	00000640 	andeq	r0, r0, r0, asr #12
     96c:	03012e07 	movweq	r2, #7687	; 0x1e07
     970:	3b0b3a0e 	blcc	2cf1b0 <DISABLE_IRQ+0x2cf130>
     974:	110c270b 	tstne	ip, fp, lsl #14
     978:	40011201 	andmi	r1, r1, r1, lsl #4
     97c:	00130106 	andseq	r0, r3, r6, lsl #2
     980:	00050800 	andeq	r0, r5, r0, lsl #16
     984:	0b3a0e03 	bleq	e84198 <MEM_SIZE+0x684198>
     988:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     98c:	00000602 	andeq	r0, r0, r2, lsl #12
     990:	49010109 	stmdbmi	r1, {r0, r3, r8}
     994:	00130113 	andseq	r0, r3, r3, lsl r1
     998:	00210a00 	eoreq	r0, r1, r0, lsl #20
     99c:	052f1349 	streq	r1, [pc, #-841]!	; 65b <DISABLE_IRQ+0x5db>
     9a0:	340b0000 	strcc	r0, [fp]
     9a4:	3a0e0300 	bcc	3815ac <DISABLE_IRQ+0x38152c>
     9a8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     9ac:	000a0213 	andeq	r0, sl, r3, lsl r2
     9b0:	00340c00 	eorseq	r0, r4, r0, lsl #24
     9b4:	0b3a0e03 	bleq	e841c8 <MEM_SIZE+0x6841c8>
     9b8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     9bc:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
     9c0:	240d0000 	strcs	r0, [sp]
     9c4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     9c8:	0008030b 	andeq	r0, r8, fp, lsl #6
     9cc:	11010000 	tstne	r1, r0
     9d0:	130e2501 	movwne	r2, #58625	; 0xe501
     9d4:	1b0e030b 	blne	381608 <DISABLE_IRQ+0x381588>
     9d8:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     9dc:	00061001 	andeq	r1, r6, r1
     9e0:	00160200 	andseq	r0, r6, r0, lsl #4
     9e4:	0b3a0e03 	bleq	e841f8 <MEM_SIZE+0x6841f8>
     9e8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     9ec:	24030000 	strcs	r0, [r3]
     9f0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     9f4:	000e030b 	andeq	r0, lr, fp, lsl #6
     9f8:	01130400 	tsteq	r3, r0, lsl #8
     9fc:	0b0b0e03 	bleq	2c4210 <DISABLE_IRQ+0x2c4190>
     a00:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     a04:	00001301 	andeq	r1, r0, r1, lsl #6
     a08:	03000d05 	movweq	r0, #3333	; 0xd05
     a0c:	3b0b3a0e 	blcc	2cf24c <DISABLE_IRQ+0x2cf1cc>
     a10:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     a14:	0600000a 	streq	r0, [r0], -sl
     a18:	0b0b000f 	bleq	2c0a5c <DISABLE_IRQ+0x2c09dc>
     a1c:	01070000 	tsteq	r7, r0
     a20:	01134901 	tsteq	r3, r1, lsl #18
     a24:	08000013 	stmdaeq	r0, {r0, r1, r4}
     a28:	13490021 	movtne	r0, #36897	; 0x9021
     a2c:	00000b2f 	andeq	r0, r0, pc, lsr #22
     a30:	0b002409 	bleq	9a5c <DISABLE_IRQ+0x99dc>
     a34:	000b3e0b 	andeq	r3, fp, fp, lsl #28
     a38:	00160a00 	andseq	r0, r6, r0, lsl #20
     a3c:	0b3a0e03 	bleq	e84250 <MEM_SIZE+0x684250>
     a40:	1349053b 	movtne	r0, #38203	; 0x953b
     a44:	0f0b0000 	svceq	0x000b0000
     a48:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
     a4c:	0c000013 	stceq	0, cr0, [r0], {19}
     a50:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 0xffffff48
     a54:	0b3a0e03 	bleq	e84268 <MEM_SIZE+0x684268>
     a58:	01110b3b 	tsteq	r1, fp, lsr fp
     a5c:	06400112 	undefined instruction 0x06400112
     a60:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
     a64:	3a0e0301 	bcc	381670 <DISABLE_IRQ+0x3815f0>
     a68:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     a6c:	1201110c 	andne	r1, r1, #3
     a70:	01064001 	tsteq	r6, r1
     a74:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     a78:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     a7c:	0b3b0b3a 	bleq	ec376c <MEM_SIZE+0x6c376c>
     a80:	06021349 	streq	r1, [r2], -r9, asr #6
     a84:	340f0000 	strcc	r0, [pc], #0	; a8c <DISABLE_IRQ+0xa0c>
     a88:	3a080300 	bcc	201690 <DISABLE_IRQ+0x201610>
     a8c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     a90:	000a0213 	andeq	r0, sl, r3, lsl r2
     a94:	00211000 	eoreq	r1, r1, r0
     a98:	052f1349 	streq	r1, [pc, #-841]!	; 757 <DISABLE_IRQ+0x6d7>
     a9c:	34110000 	ldrcc	r0, [r1]
     aa0:	3a0e0300 	bcc	3816a8 <DISABLE_IRQ+0x381628>
     aa4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     aa8:	000a0213 	andeq	r0, sl, r3, lsl r2
     aac:	00341200 	eorseq	r1, r4, r0, lsl #4
     ab0:	0b3a0e03 	bleq	e842c4 <MEM_SIZE+0x6842c4>
     ab4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ab8:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
     abc:	24130000 	ldrcs	r0, [r3]
     ac0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     ac4:	0008030b 	andeq	r0, r8, fp, lsl #6
     ac8:	11010000 	tstne	r1, r0
     acc:	130e2501 	movwne	r2, #58625	; 0xe501
     ad0:	1b0e030b 	blne	381704 <DISABLE_IRQ+0x381684>
     ad4:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     ad8:	00061001 	andeq	r1, r6, r1
     adc:	00160200 	andseq	r0, r6, r0, lsl #4
     ae0:	0b3a0e03 	bleq	e842f4 <MEM_SIZE+0x6842f4>
     ae4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ae8:	24030000 	strcs	r0, [r3]
     aec:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     af0:	000e030b 	andeq	r0, lr, fp, lsl #6
     af4:	01130400 	tsteq	r3, r0, lsl #8
     af8:	0b0b0e03 	bleq	2c430c <DISABLE_IRQ+0x2c428c>
     afc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     b00:	00001301 	andeq	r1, r0, r1, lsl #6
     b04:	03000d05 	movweq	r0, #3333	; 0xd05
     b08:	3b0b3a0e 	blcc	2cf348 <DISABLE_IRQ+0x2cf2c8>
     b0c:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     b10:	0600000a 	streq	r0, [r0], -sl
     b14:	0b0b000f 	bleq	2c0b58 <DISABLE_IRQ+0x2c0ad8>
     b18:	01070000 	tsteq	r7, r0
     b1c:	01134901 	tsteq	r3, r1, lsl #18
     b20:	08000013 	stmdaeq	r0, {r0, r1, r4}
     b24:	13490021 	movtne	r0, #36897	; 0x9021
     b28:	00000b2f 	andeq	r0, r0, pc, lsr #22
     b2c:	0b002409 	bleq	9b58 <DISABLE_IRQ+0x9ad8>
     b30:	000b3e0b 	andeq	r3, fp, fp, lsl #28
     b34:	00160a00 	andseq	r0, r6, r0, lsl #20
     b38:	0b3a0e03 	bleq	e8434c <MEM_SIZE+0x68434c>
     b3c:	1349053b 	movtne	r0, #38203	; 0x953b
     b40:	0f0b0000 	svceq	0x000b0000
     b44:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
     b48:	0c000013 	stceq	0, cr0, [r0], {19}
     b4c:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
     b50:	0b3a0e03 	bleq	e84364 <MEM_SIZE+0x684364>
     b54:	01110b3b 	tsteq	r1, fp, lsr fp
     b58:	06400112 	undefined instruction 0x06400112
     b5c:	00001301 	andeq	r1, r0, r1, lsl #6
     b60:	0300340d 	movweq	r3, #1037	; 0x40d
     b64:	3b0b3a08 	blcc	2cf38c <DISABLE_IRQ+0x2cf30c>
     b68:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     b6c:	0e00000a 	cdpeq	0, 0, cr0, cr0, cr10, {0}
     b70:	0e03012e 	adfeqsp	f0, f3, #0.5
     b74:	0b3b0b3a 	bleq	ec3864 <MEM_SIZE+0x6c3864>
     b78:	01110c27 	tsteq	r1, r7, lsr #24
     b7c:	06400112 	undefined instruction 0x06400112
     b80:	00001301 	andeq	r1, r0, r1, lsl #6
     b84:	0300050f 	movweq	r0, #1295	; 0x50f
     b88:	3b0b3a0e 	blcc	2cf3c8 <DISABLE_IRQ+0x2cf348>
     b8c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     b90:	10000006 	andne	r0, r0, r6
     b94:	13490021 	movtne	r0, #36897	; 0x9021
     b98:	0000052f 	andeq	r0, r0, pc, lsr #10
     b9c:	03003411 	movweq	r3, #1041	; 0x411
     ba0:	3b0b3a0e 	blcc	2cf3e0 <DISABLE_IRQ+0x2cf360>
     ba4:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     ba8:	1200000a 	andne	r0, r0, #10
     bac:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     bb0:	0b3b0b3a 	bleq	ec38a0 <MEM_SIZE+0x6c38a0>
     bb4:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 0xfffffedc
     bb8:	00000c3c 	andeq	r0, r0, ip, lsr ip
     bbc:	0b002413 	bleq	9c10 <DISABLE_IRQ+0x9b90>
     bc0:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     bc4:	00000008 	andeq	r0, r0, r8
     bc8:	25011101 	strcs	r1, [r1, #-257]	; 0x101
     bcc:	030b130e 	movweq	r1, #45838	; 0xb30e
     bd0:	110e1b0e 	tstne	lr, lr, lsl #22
     bd4:	10011201 	andne	r1, r1, r1, lsl #4
     bd8:	02000006 	andeq	r0, r0, #6
     bdc:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     be0:	0b3b0b3a 	bleq	ec38d0 <MEM_SIZE+0x6c38d0>
     be4:	00001349 	andeq	r1, r0, r9, asr #6
     be8:	0b002403 	bleq	9bfc <DISABLE_IRQ+0x9b7c>
     bec:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     bf0:	0400000e 	streq	r0, [r0], #-14
     bf4:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     bf8:	0b3a0b0b 	bleq	e8382c <MEM_SIZE+0x68382c>
     bfc:	1301053b 	movwne	r0, #5435	; 0x153b
     c00:	0d050000 	stceq	0, cr0, [r5]
     c04:	3a0e0300 	bcc	38180c <DISABLE_IRQ+0x38178c>
     c08:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     c0c:	000a3813 	andeq	r3, sl, r3, lsl r8
     c10:	000f0600 	andeq	r0, pc, r0, lsl #12
     c14:	00000b0b 	andeq	r0, r0, fp, lsl #22
     c18:	49010107 	stmdbmi	r1, {r0, r1, r2, r8}
     c1c:	00130113 	andseq	r0, r3, r3, lsl r1
     c20:	00210800 	eoreq	r0, r1, r0, lsl #16
     c24:	0b2f1349 	bleq	bc5950 <MEM_SIZE+0x3c5950>
     c28:	24090000 	strcs	r0, [r9]
     c2c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     c30:	0a00000b 	beq	c64 <DISABLE_IRQ+0xbe4>
     c34:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     c38:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     c3c:	00001349 	andeq	r1, r0, r9, asr #6
     c40:	0b000f0b 	bleq	4874 <DISABLE_IRQ+0x47f4>
     c44:	0013490b 	andseq	r4, r3, fp, lsl #18
     c48:	002e0c00 	eoreq	r0, lr, r0, lsl #24
     c4c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     c50:	0b3b0b3a 	bleq	ec3940 <MEM_SIZE+0x6c3940>
     c54:	01120111 	tsteq	r2, r1, lsl r1
     c58:	00000640 	andeq	r0, r0, r0, asr #12
     c5c:	03012e0d 	movweq	r2, #7693	; 0x1e0d
     c60:	3b0b3a0e 	blcc	2cf4a0 <DISABLE_IRQ+0x2cf420>
     c64:	110c270b 	tstne	ip, fp, lsl #14
     c68:	40011201 	andmi	r1, r1, r1, lsl #4
     c6c:	00130106 	andseq	r0, r3, r6, lsl #2
     c70:	00050e00 	andeq	r0, r5, r0, lsl #28
     c74:	0b3a0e03 	bleq	e84488 <MEM_SIZE+0x684488>
     c78:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     c7c:	00000602 	andeq	r0, r0, r2, lsl #12
     c80:	0300340f 	movweq	r3, #1039	; 0x40f
     c84:	3b0b3a08 	blcc	2cf4ac <DISABLE_IRQ+0x2cf42c>
     c88:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     c8c:	1000000a 	andne	r0, r0, sl
     c90:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     c94:	0b3b0b3a 	bleq	ec3984 <MEM_SIZE+0x6c3984>
     c98:	00001349 	andeq	r1, r0, r9, asr #6
     c9c:	49002111 	stmdbmi	r0, {r0, r4, r8, sp}
     ca0:	00052f13 	andeq	r2, r5, r3, lsl pc
     ca4:	00341200 	eorseq	r1, r4, r0, lsl #4
     ca8:	0b3a0e03 	bleq	e844bc <MEM_SIZE+0x6844bc>
     cac:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     cb0:	00000a02 	andeq	r0, r0, r2, lsl #20
     cb4:	03003413 	movweq	r3, #1043	; 0x413
     cb8:	3b0b3a0e 	blcc	2cf4f8 <DISABLE_IRQ+0x2cf478>
     cbc:	3f13490b 	svccc	0x0013490b
     cc0:	000c3c0c 	andeq	r3, ip, ip, lsl #24
     cc4:	00241400 	eoreq	r1, r4, r0, lsl #8
     cc8:	0b3e0b0b 	bleq	f838fc <MEM_SIZE+0x7838fc>
     ccc:	00000803 	andeq	r0, r0, r3, lsl #16
     cd0:	01110100 	tsteq	r1, r0, lsl #2
     cd4:	0b130e25 	bleq	4c4570 <DISABLE_IRQ+0x4c44f0>
     cd8:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     cdc:	01120111 	tsteq	r2, r1, lsl r1
     ce0:	00000610 	andeq	r0, r0, r0, lsl r6
     ce4:	03001602 	movweq	r1, #1538	; 0x602
     ce8:	3b0b3a0e 	blcc	2cf528 <DISABLE_IRQ+0x2cf4a8>
     cec:	0013490b 	andseq	r4, r3, fp, lsl #18
     cf0:	00240300 	eoreq	r0, r4, r0, lsl #6
     cf4:	0b3e0b0b 	bleq	f83928 <MEM_SIZE+0x783928>
     cf8:	00000e03 	andeq	r0, r0, r3, lsl #28
     cfc:	0b000f04 	bleq	4914 <DISABLE_IRQ+0x4894>
     d00:	0500000b 	streq	r0, [r0, #-11]
     d04:	0b0b0024 	bleq	2c0d9c <DISABLE_IRQ+0x2c0d1c>
     d08:	00000b3e 	andeq	r0, r0, lr, lsr fp
     d0c:	49010106 	stmdbmi	r1, {r1, r2, r8}
     d10:	00130113 	andseq	r0, r3, r3, lsl r1
     d14:	00210700 	eoreq	r0, r1, r0, lsl #14
     d18:	0b2f1349 	bleq	bc5a44 <MEM_SIZE+0x3c5a44>
     d1c:	16080000 	strne	r0, [r8], -r0
     d20:	3a0e0300 	bcc	381928 <DISABLE_IRQ+0x3818a8>
     d24:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     d28:	09000013 	stmdbeq	r0, {r0, r1, r4}
     d2c:	0b0b000f 	bleq	2c0d70 <DISABLE_IRQ+0x2c0cf0>
     d30:	00001349 	andeq	r1, r0, r9, asr #6
     d34:	2701150a 	strcs	r1, [r1, -sl, lsl #10]
     d38:	0013010c 	andseq	r0, r3, ip, lsl #2
     d3c:	00050b00 	andeq	r0, r5, r0, lsl #22
     d40:	00001349 	andeq	r1, r0, r9, asr #6
     d44:	0301130c 	movweq	r1, #4876	; 0x130c
     d48:	3a0b0b0e 	bcc	2c3988 <DISABLE_IRQ+0x2c3908>
     d4c:	01053b0b 	tsteq	r5, fp, lsl #22
     d50:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
     d54:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     d58:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     d5c:	0a381349 	beq	e05a88 <MEM_SIZE+0x605a88>
     d60:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
     d64:	3a0e0301 	bcc	381970 <DISABLE_IRQ+0x3818f0>
     d68:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     d6c:	1201110c 	andne	r1, r1, #3
     d70:	01064001 	tsteq	r6, r1
     d74:	0f000013 	svceq	0x00000013
     d78:	08030005 	stmdaeq	r3, {r0, r2}
     d7c:	0b3b0b3a 	bleq	ec3a6c <MEM_SIZE+0x6c3a6c>
     d80:	06021349 	streq	r1, [r2], -r9, asr #6
     d84:	34100000 	ldrcc	r0, [r0]
     d88:	3a0e0300 	bcc	381990 <DISABLE_IRQ+0x381910>
     d8c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     d90:	000a0213 	andeq	r0, sl, r3, lsl r2
     d94:	012e1100 	teqeq	lr, r0, lsl #2
     d98:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     d9c:	0b3b0b3a 	bleq	ec3a8c <MEM_SIZE+0x6c3a8c>
     da0:	01120111 	tsteq	r2, r1, lsl r1
     da4:	13010640 	movwne	r0, #5696	; 0x1640
     da8:	34120000 	ldrcc	r0, [r2]
     dac:	3a080300 	bcc	2019b4 <DISABLE_IRQ+0x201934>
     db0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     db4:	000a0213 	andeq	r0, sl, r3, lsl r2
     db8:	00051300 	andeq	r1, r5, r0, lsl #6
     dbc:	0b3a0e03 	bleq	e845d0 <MEM_SIZE+0x6845d0>
     dc0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     dc4:	00000602 	andeq	r0, r0, r2, lsl #12
     dc8:	49002114 	stmdbmi	r0, {r2, r4, r8, sp}
     dcc:	00052f13 	andeq	r2, r5, r3, lsl pc
     dd0:	00341500 	eorseq	r1, r4, r0, lsl #10
     dd4:	0b3a0e03 	bleq	e845e8 <MEM_SIZE+0x6845e8>
     dd8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ddc:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252	; 0xffffff04
     de0:	24160000 	ldrcs	r0, [r6]
     de4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     de8:	0008030b 	andeq	r0, r8, fp, lsl #6
     dec:	11010000 	tstne	r1, r0
     df0:	130e2501 	movwne	r2, #58625	; 0xe501
     df4:	1b0e030b 	blne	381a28 <DISABLE_IRQ+0x3819a8>
     df8:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     dfc:	00061001 	andeq	r1, r6, r1
     e00:	00160200 	andseq	r0, r6, r0, lsl #4
     e04:	0b3a0e03 	bleq	e84618 <MEM_SIZE+0x684618>
     e08:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     e0c:	24030000 	strcs	r0, [r3]
     e10:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     e14:	000e030b 	andeq	r0, lr, fp, lsl #6
     e18:	01130400 	tsteq	r3, r0, lsl #8
     e1c:	0b0b0e03 	bleq	2c4630 <DISABLE_IRQ+0x2c45b0>
     e20:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     e24:	00001301 	andeq	r1, r0, r1, lsl #6
     e28:	03000d05 	movweq	r0, #3333	; 0xd05
     e2c:	3b0b3a0e 	blcc	2cf66c <DISABLE_IRQ+0x2cf5ec>
     e30:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     e34:	0600000a 	streq	r0, [r0], -sl
     e38:	0b0b000f 	bleq	2c0e7c <DISABLE_IRQ+0x2c0dfc>
     e3c:	01070000 	tsteq	r7, r0
     e40:	01134901 	tsteq	r3, r1, lsl #18
     e44:	08000013 	stmdaeq	r0, {r0, r1, r4}
     e48:	13490021 	movtne	r0, #36897	; 0x9021
     e4c:	00000b2f 	andeq	r0, r0, pc, lsr #22
     e50:	0b002409 	bleq	9e7c <DISABLE_IRQ+0x9dfc>
     e54:	000b3e0b 	andeq	r3, fp, fp, lsl #28
     e58:	00160a00 	andseq	r0, r6, r0, lsl #20
     e5c:	0b3a0e03 	bleq	e84670 <MEM_SIZE+0x684670>
     e60:	1349053b 	movtne	r0, #38203	; 0x953b
     e64:	0f0b0000 	svceq	0x000b0000
     e68:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
     e6c:	0c000013 	stceq	0, cr0, [r0], {19}
     e70:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 0xffffff48
     e74:	0b3a0e03 	bleq	e84688 <MEM_SIZE+0x684688>
     e78:	01110b3b 	tsteq	r1, fp, lsr fp
     e7c:	06400112 	undefined instruction 0x06400112
     e80:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
     e84:	3a0e0301 	bcc	381a90 <DISABLE_IRQ+0x381a10>
     e88:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     e8c:	1201110c 	andne	r1, r1, #3
     e90:	01064001 	tsteq	r6, r1
     e94:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     e98:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     e9c:	0b3b0b3a 	bleq	ec3b8c <MEM_SIZE+0x6c3b8c>
     ea0:	06021349 	streq	r1, [r2], -r9, asr #6
     ea4:	340f0000 	strcc	r0, [pc], #0	; eac <DISABLE_IRQ+0xe2c>
     ea8:	3a080300 	bcc	201ab0 <DISABLE_IRQ+0x201a30>
     eac:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     eb0:	000a0213 	andeq	r0, sl, r3, lsl r2
     eb4:	00341000 	eorseq	r1, r4, r0
     eb8:	0b3a0803 	bleq	e82ecc <MEM_SIZE+0x682ecc>
     ebc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ec0:	21110000 	tstcs	r1, r0
     ec4:	2f134900 	svccs	0x00134900
     ec8:	12000005 	andne	r0, r0, #5
     ecc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     ed0:	0b3b0b3a 	bleq	ec3bc0 <MEM_SIZE+0x6c3bc0>
     ed4:	0a021349 	beq	85c00 <DISABLE_IRQ+0x85b80>
     ed8:	34130000 	ldrcc	r0, [r3]
     edc:	3a0e0300 	bcc	381ae4 <DISABLE_IRQ+0x381a64>
     ee0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     ee4:	3c0c3f13 	stccc	15, cr3, [ip], {19}
     ee8:	1400000c 	strne	r0, [r0], #-12
     eec:	0b0b0024 	bleq	2c0f84 <DISABLE_IRQ+0x2c0f04>
     ef0:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     ef4:	01000000 	tsteq	r0, r0
     ef8:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     efc:	0e030b13 	vmoveq.32	d3[0], r0
     f00:	01110e1b 	tsteq	r1, fp, lsl lr
     f04:	06100112 	undefined instruction 0x06100112
     f08:	16020000 	strne	r0, [r2], -r0
     f0c:	3a0e0300 	bcc	381b14 <DISABLE_IRQ+0x381a94>
     f10:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     f14:	03000013 	movweq	r0, #19
     f18:	0b0b0024 	bleq	2c0fb0 <DISABLE_IRQ+0x2c0f30>
     f1c:	0e030b3e 	vmoveq.16	d3[0], r0
     f20:	0f040000 	svceq	0x00040000
     f24:	000b0b00 	andeq	r0, fp, r0, lsl #22
     f28:	00240500 	eoreq	r0, r4, r0, lsl #10
     f2c:	0b3e0b0b 	bleq	f83b60 <MEM_SIZE+0x783b60>
     f30:	01060000 	tsteq	r6, r0
     f34:	01134901 	tsteq	r3, r1, lsl #18
     f38:	07000013 	smladeq	r0, r3, r0, r0
     f3c:	13490021 	movtne	r0, #36897	; 0x9021
     f40:	00000b2f 	andeq	r0, r0, pc, lsr #22
     f44:	03011308 	movweq	r1, #4872	; 0x1308
     f48:	3a0b0b0e 	bcc	2c3b88 <DISABLE_IRQ+0x2c3b08>
     f4c:	01053b0b 	tsteq	r5, fp, lsl #22
     f50:	09000013 	stmdbeq	r0, {r0, r1, r4}
     f54:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     f58:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     f5c:	0a381349 	beq	e05c88 <MEM_SIZE+0x605c88>
     f60:	160a0000 	strne	r0, [sl], -r0
     f64:	3a0e0300 	bcc	381b6c <DISABLE_IRQ+0x381aec>
     f68:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     f6c:	0b000013 	bleq	fc0 <DISABLE_IRQ+0xf40>
     f70:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 0xffffff48
     f74:	0b3a0e03 	bleq	e84788 <MEM_SIZE+0x684788>
     f78:	01110b3b 	tsteq	r1, fp, lsr fp
     f7c:	06400112 	undefined instruction 0x06400112
     f80:	00001301 	andeq	r1, r0, r1, lsl #6
     f84:	0300340c 	movweq	r3, #1036	; 0x40c
     f88:	3b0b3a08 	blcc	2cf7b0 <DISABLE_IRQ+0x2cf730>
     f8c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     f90:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
     f94:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     f98:	0b3b0b3a 	bleq	ec3c88 <MEM_SIZE+0x6c3c88>
     f9c:	00001349 	andeq	r1, r0, r9, asr #6
     fa0:	0b000f0e 	bleq	4be0 <DISABLE_IRQ+0x4b60>
     fa4:	0013490b 	andseq	r4, r3, fp, lsl #18
     fa8:	012e0f00 	teqeq	lr, r0, lsl #30
     fac:	0b3a0e03 	bleq	e847c0 <MEM_SIZE+0x6847c0>
     fb0:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     fb4:	01120111 	tsteq	r2, r1, lsl r1
     fb8:	13010640 	movwne	r0, #5696	; 0x1640
     fbc:	05100000 	ldreq	r0, [r0]
     fc0:	3a0e0300 	bcc	381bc8 <DISABLE_IRQ+0x381b48>
     fc4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     fc8:	00060213 	andeq	r0, r6, r3, lsl r2
     fcc:	00341100 	eorseq	r1, r4, r0, lsl #2
     fd0:	0b3a0e03 	bleq	e847e4 <MEM_SIZE+0x6847e4>
     fd4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     fd8:	00000602 	andeq	r0, r0, r2, lsl #12
     fdc:	03003412 	movweq	r3, #1042	; 0x412
     fe0:	3b0b3a0e 	blcc	2cf820 <DISABLE_IRQ+0x2cf7a0>
     fe4:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     fe8:	1300000a 	movwne	r0, #10
     fec:	13490021 	movtne	r0, #36897	; 0x9021
     ff0:	0000052f 	andeq	r0, r0, pc, lsr #10
     ff4:	03003414 	movweq	r3, #1044	; 0x414
     ff8:	3b0b3a0e 	blcc	2cf838 <DISABLE_IRQ+0x2cf7b8>
     ffc:	3f13490b 	svccc	0x0013490b
    1000:	000c3c0c 	andeq	r3, ip, ip, lsl #24
    1004:	00241500 	eoreq	r1, r4, r0, lsl #10
    1008:	0b3e0b0b 	bleq	f83c3c <MEM_SIZE+0x783c3c>
    100c:	00000803 	andeq	r0, r0, r3, lsl #16
    1010:	01110100 	tsteq	r1, r0, lsl #2
    1014:	0b130e25 	bleq	4c48b0 <DISABLE_IRQ+0x4c4830>
    1018:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    101c:	01120111 	tsteq	r2, r1, lsl r1
    1020:	00000610 	andeq	r0, r0, r0, lsl r6
    1024:	03001602 	movweq	r1, #1538	; 0x602
    1028:	3b0b3a0e 	blcc	2cf868 <DISABLE_IRQ+0x2cf7e8>
    102c:	0013490b 	andseq	r4, r3, fp, lsl #18
    1030:	00240300 	eoreq	r0, r4, r0, lsl #6
    1034:	0b3e0b0b 	bleq	f83c68 <MEM_SIZE+0x783c68>
    1038:	00000e03 	andeq	r0, r0, r3, lsl #28
    103c:	03011304 	movweq	r1, #4868	; 0x1304
    1040:	3a0b0b0e 	bcc	2c3c80 <DISABLE_IRQ+0x2c3c00>
    1044:	01053b0b 	tsteq	r5, fp, lsl #22
    1048:	05000013 	streq	r0, [r0, #-19]
    104c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1050:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1054:	0a381349 	beq	e05d80 <MEM_SIZE+0x605d80>
    1058:	0f060000 	svceq	0x00060000
    105c:	000b0b00 	andeq	r0, fp, r0, lsl #22
    1060:	01010700 	tsteq	r1, r0, lsl #14
    1064:	13011349 	movwne	r1, #4937	; 0x1349
    1068:	21080000 	tstcs	r8, r0
    106c:	2f134900 	svccs	0x00134900
    1070:	0900000b 	stmdbeq	r0, {r0, r1, r3}
    1074:	0b0b0024 	bleq	2c110c <DISABLE_IRQ+0x2c108c>
    1078:	00000b3e 	andeq	r0, r0, lr, lsr fp
    107c:	0300160a 	movweq	r1, #1546	; 0x60a
    1080:	3b0b3a0e 	blcc	2cf8c0 <DISABLE_IRQ+0x2cf840>
    1084:	00134905 	andseq	r4, r3, r5, lsl #18
    1088:	000f0b00 	andeq	r0, pc, r0, lsl #22
    108c:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    1090:	2e0c0000 	cdpcs	0, 0, cr0, cr12, cr0, {0}
    1094:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1098:	3b0b3a0e 	blcc	2cf8d8 <DISABLE_IRQ+0x2cf858>
    109c:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    10a0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    10a4:	01064001 	tsteq	r6, r1
    10a8:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    10ac:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    10b0:	0b3b0b3a 	bleq	ec3da0 <MEM_SIZE+0x6c3da0>
    10b4:	06021349 	streq	r1, [r2], -r9, asr #6
    10b8:	050e0000 	streq	r0, [lr]
    10bc:	3a0e0300 	bcc	381cc4 <DISABLE_IRQ+0x381c44>
    10c0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    10c4:	000a0213 	andeq	r0, sl, r3, lsl r2
    10c8:	00050f00 	andeq	r0, r5, r0, lsl #30
    10cc:	0b3a0803 	bleq	e830e0 <MEM_SIZE+0x6830e0>
    10d0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    10d4:	00000602 	andeq	r0, r0, r2, lsl #12
    10d8:	03003410 	movweq	r3, #1040	; 0x410
    10dc:	3b0b3a08 	blcc	2cf904 <DISABLE_IRQ+0x2cf884>
    10e0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    10e4:	11000006 	tstne	r0, r6
    10e8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    10ec:	0b3b0b3a 	bleq	ec3ddc <MEM_SIZE+0x6c3ddc>
    10f0:	00001349 	andeq	r1, r0, r9, asr #6
    10f4:	27011512 	smladcs	r1, r2, r5, r1
    10f8:	0013010c 	andseq	r0, r3, ip, lsl #2
    10fc:	00051300 	andeq	r1, r5, r0, lsl #6
    1100:	00001349 	andeq	r1, r0, r9, asr #6
    1104:	3f012e14 	svccc	0x00012e14
    1108:	3a0e030c 	bcc	381d40 <DISABLE_IRQ+0x381cc0>
    110c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1110:	1201110c 	andne	r1, r1, #3
    1114:	010a4001 	tsteq	sl, r1
    1118:	15000013 	strne	r0, [r0, #-19]
    111c:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 0xffffff48
    1120:	0b3a0e03 	bleq	e84934 <MEM_SIZE+0x684934>
    1124:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    1128:	01120111 	tsteq	r2, r1, lsl r1
    112c:	00000a40 	andeq	r0, r0, r0, asr #20
    1130:	3f012e16 	svccc	0x00012e16
    1134:	3a0e030c 	bcc	381d6c <DISABLE_IRQ+0x381cec>
    1138:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    113c:	1201110c 	andne	r1, r1, #3
    1140:	00064001 	andeq	r4, r6, r1
    1144:	11010000 	tstne	r1, r0
    1148:	11061000 	tstne	r6, r0
    114c:	03011201 	movweq	r1, #4609	; 0x1201
    1150:	25081b08 	strcs	r1, [r8, #-2824]	; 0xb08
    1154:	00051308 	andeq	r1, r5, r8, lsl #6
    1158:	11010000 	tstne	r1, r0
    115c:	11061000 	tstne	r6, r0
    1160:	03011201 	movweq	r1, #4609	; 0x1201
    1164:	25081b08 	strcs	r1, [r8, #-2824]	; 0xb08
    1168:	00051308 	andeq	r1, r5, r8, lsl #6
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	30000040 	andcc	r0, r0, r0, asr #32
  14:	00000070 	andeq	r0, r0, r0, ror r0
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	00550002 	subseq	r0, r5, r2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	30000000 	andcc	r0, r0, r0
  34:	00000040 	andeq	r0, r0, r0, asr #32
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	00ab0002 	adceq	r0, fp, r2
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	300000b0 	strhcc	r0, [r0], -r0
  54:	00000128 	andeq	r0, r0, r8, lsr #2
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	021b0002 	andseq	r0, fp, #2
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	300001d8 	ldrdcc	r0, [r0], -r8
  74:	00000094 	muleq	r0, r4, r0
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	02740002 	rsbseq	r0, r4, #2
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	3000026c 	andcc	r0, r0, ip, ror #4
  94:	000000b8 	strheq	r0, [r0], -r8
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	02c80002 	sbceq	r0, r8, #2
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	30000324 	andcc	r0, r0, r4, lsr #6
  b4:	000000ec 	andeq	r0, r0, ip, ror #1
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	03fb0002 	mvnseq	r0, #2
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	30000410 	andcc	r0, r0, r0, lsl r4
  d4:	00000598 	muleq	r0, r8, r5
	...
  e0:	0000001c 	andeq	r0, r0, ip, lsl r0
  e4:	07f60002 	ldrbeq	r0, [r6, r2]!
  e8:	00040000 	andeq	r0, r4, r0
  ec:	00000000 	andeq	r0, r0, r0
  f0:	300009a8 	andcc	r0, r0, r8, lsr #19
  f4:	00000084 	andeq	r0, r0, r4, lsl #1
	...
 100:	0000001c 	andeq	r0, r0, ip, lsl r0
 104:	08970002 	ldmeq	r7, {r1}
 108:	00040000 	andeq	r0, r4, r0
 10c:	00000000 	andeq	r0, r0, r0
 110:	30000a2c 	andcc	r0, r0, ip, lsr #20
 114:	00005760 	andeq	r5, r0, r0, ror #14
	...
 120:	0000001c 	andeq	r0, r0, ip, lsl r0
 124:	488d0002 	stmmi	sp, {r1}
 128:	00040000 	andeq	r0, r4, r0
 12c:	00000000 	andeq	r0, r0, r0
 130:	3000618c 	andcc	r6, r0, ip, lsl #3
 134:	000000d0 	ldrdeq	r0, [r0], -r0
	...
 140:	0000001c 	andeq	r0, r0, ip, lsl r0
 144:	49c30002 	stmibmi	r3, {r1}^
 148:	00040000 	andeq	r0, r4, r0
 14c:	00000000 	andeq	r0, r0, r0
 150:	3000625c 	andcc	r6, r0, ip, asr r2
 154:	000000f4 	strdeq	r0, [r0], -r4
	...
 160:	0000001c 	andeq	r0, r0, ip, lsl r0
 164:	4b8f0002 	blmi	fe3c0174 <rEINTPEND+0xa83c00cc>
 168:	00040000 	andeq	r0, r4, r0
 16c:	00000000 	andeq	r0, r0, r0
 170:	30006350 	andcc	r6, r0, r0, asr r3
 174:	00000100 	andeq	r0, r0, r0, lsl #2
	...
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	4d6e0002 	stclmi	0, cr0, [lr, #-8]!
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	30006450 	andcc	r6, r0, r0, asr r4
 194:	00000118 	andeq	r0, r0, r8, lsl r1
	...
 1a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1a4:	4f670002 	svcmi	0x00670002
 1a8:	00040000 	andeq	r0, r4, r0
 1ac:	00000000 	andeq	r0, r0, r0
 1b0:	30006568 	andcc	r6, r0, r8, ror #10
 1b4:	00000114 	andeq	r0, r0, r4, lsl r1
	...
 1c0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c4:	51b30002 	undefined instruction 0x51b30002
 1c8:	00040000 	andeq	r0, r4, r0
 1cc:	00000000 	andeq	r0, r0, r0
 1d0:	3000667c 	andcc	r6, r0, ip, ror r6
 1d4:	00000134 	andeq	r0, r0, r4, lsr r1
	...
 1e0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1e4:	53c70002 	bicpl	r0, r7, #2
 1e8:	00040000 	andeq	r0, r4, r0
 1ec:	00000000 	andeq	r0, r0, r0
 1f0:	300067b0 	undefined instruction 0x300067b0
 1f4:	000000e4 	andeq	r0, r0, r4, ror #1
	...
 200:	0000001c 	andeq	r0, r0, ip, lsl r0
 204:	55a90002 	strpl	r0, [r9, #2]!
 208:	00040000 	andeq	r0, r4, r0
 20c:	00000000 	andeq	r0, r0, r0
 210:	30006894 	mulcc	r0, r4, r8
 214:	000000f8 	strdeq	r0, [r0], -r8
	...
 220:	0000001c 	andeq	r0, r0, ip, lsl r0
 224:	5a710002 	bpl	1c40234 <MEM_SIZE+0x1440234>
 228:	00040000 	andeq	r0, r4, r0
 22c:	00000000 	andeq	r0, r0, r0
 230:	3000698c 	andcc	r6, r0, ip, lsl #19
 234:	00000114 	andeq	r0, r0, r4, lsl r1
	...
 240:	0000001c 	andeq	r0, r0, ip, lsl r0
 244:	5b760002 	blpl	1d80254 <MEM_SIZE+0x1580254>
 248:	00040000 	andeq	r0, r4, r0
 24c:	00000000 	andeq	r0, r0, r0
 250:	30006aa0 	andcc	r6, r0, r0, lsr #21
 254:	00000014 	andeq	r0, r0, r4, lsl r0
	...

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
       0:	0000000c 	andeq	r0, r0, ip
       4:	ffffffff 	undefined instruction 0xffffffff
       8:	7c010001 	stcvc	0, cr0, [r1], {1}
       c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      10:	0000000c 	andeq	r0, r0, ip
      14:	00000000 	andeq	r0, r0, r0
      18:	300000b0 	strhcc	r0, [r0], -r0
      1c:	00000024 	andeq	r0, r0, r4, lsr #32
      20:	0000000c 	andeq	r0, r0, ip
      24:	00000000 	andeq	r0, r0, r0
      28:	300000d4 	ldrdcc	r0, [r0], -r4
      2c:	00000024 	andeq	r0, r0, r4, lsr #32
      30:	0000000c 	andeq	r0, r0, ip
      34:	00000000 	andeq	r0, r0, r0
      38:	300000f8 	strdcc	r0, [r0], -r8
      3c:	00000004 	andeq	r0, r0, r4
      40:	00000018 	andeq	r0, r0, r8, lsl r0
      44:	00000000 	andeq	r0, r0, r0
      48:	300000fc 	strdcc	r0, [r0], -ip
      4c:	00000070 	andeq	r0, r0, r0, ror r0
      50:	11080e4c 	tstne	r8, ip, asr #28
      54:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
      58:	00000002 	andeq	r0, r0, r2
      5c:	00000018 	andeq	r0, r0, r8, lsl r0
      60:	00000000 	andeq	r0, r0, r0
      64:	3000016c 	andcc	r0, r0, ip, ror #2
      68:	0000006c 	andeq	r0, r0, ip, rrx
      6c:	11080e44 	tstne	r8, r4, asr #28
      70:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
      74:	00000002 	andeq	r0, r0, r2
      78:	0000000c 	andeq	r0, r0, ip
      7c:	ffffffff 	undefined instruction 0xffffffff
      80:	7c010001 	stcvc	0, cr0, [r1], {1}
      84:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      88:	0000000c 	andeq	r0, r0, ip
      8c:	00000078 	andeq	r0, r0, r8, ror r0
      90:	30000324 	andcc	r0, r0, r4, lsr #6
      94:	0000002c 	andeq	r0, r0, ip, lsr #32
      98:	0000000c 	andeq	r0, r0, ip
      9c:	00000078 	andeq	r0, r0, r8, ror r0
      a0:	30000350 	andcc	r0, r0, r0, asr r3
      a4:	00000010 	andeq	r0, r0, r0, lsl r0
      a8:	0000000c 	andeq	r0, r0, ip
      ac:	00000078 	andeq	r0, r0, r8, ror r0
      b0:	30000360 	andcc	r0, r0, r0, ror #6
      b4:	00000018 	andeq	r0, r0, r8, lsl r0
      b8:	0000000c 	andeq	r0, r0, ip
      bc:	00000078 	andeq	r0, r0, r8, ror r0
      c0:	30000378 	andcc	r0, r0, r8, ror r3
      c4:	00000098 	muleq	r0, r8, r0
      c8:	0000000c 	andeq	r0, r0, ip
      cc:	ffffffff 	undefined instruction 0xffffffff
      d0:	7c010001 	stcvc	0, cr0, [r1], {1}
      d4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      d8:	0000000c 	andeq	r0, r0, ip
      dc:	000000c8 	andeq	r0, r0, r8, asr #1
      e0:	30000410 	andcc	r0, r0, r0, lsl r4
      e4:	00000024 	andeq	r0, r0, r4, lsr #32
      e8:	00000030 	andeq	r0, r0, r0, lsr r0
      ec:	000000c8 	andeq	r0, r0, r8, asr #1
      f0:	30000434 	andcc	r0, r0, r4, lsr r4
      f4:	00000144 	andeq	r0, r0, r4, asr #2
      f8:	11240e44 	teqne	r4, r4, asr #28
      fc:	0b11010e 	bleq	44053c <DISABLE_IRQ+0x4404bc>
     100:	030a1102 	movweq	r1, #41218	; 0xa102
     104:	11040911 	tstne	r4, r1, lsl r9
     108:	07110508 	ldreq	r0, [r1, -r8, lsl #10]
     10c:	07061106 	streq	r1, [r6, -r6, lsl #2]
     110:	11080511 	tstne	r8, r1, lsl r5
     114:	0e500904 	cdpeq	9, 5, cr0, cr0, cr4, {0}
     118:	00000078 	andeq	r0, r0, r8, ror r0
     11c:	0000000c 	andeq	r0, r0, ip
     120:	000000c8 	andeq	r0, r0, r8, asr #1
     124:	30000578 	andcc	r0, r0, r8, ror r5
     128:	000001a8 	andeq	r0, r0, r8, lsr #3
     12c:	00000030 	andeq	r0, r0, r0, lsr r0
     130:	000000c8 	andeq	r0, r0, r8, asr #1
     134:	30000720 	andcc	r0, r0, r0, lsr #14
     138:	000001a4 	andeq	r0, r0, r4, lsr #3
     13c:	44240e44 	strtmi	r0, [r4], #-3652	; 0xe44
     140:	0e11300e 	cdpeq	0, 1, cr3, cr1, cr14, {0}
     144:	020b1101 	andeq	r1, fp, #1073741824	; 0x40000000
     148:	11030a11 	tstne	r3, r1, lsl sl
     14c:	08110409 	ldmdaeq	r1, {r0, r3, sl}
     150:	06071105 	streq	r1, [r7], -r5, lsl #2
     154:	11070611 	tstne	r7, r1, lsl r6
     158:	04110805 	ldreq	r0, [r1], #-2053	; 0x805
     15c:	00000009 	andeq	r0, r0, r9
     160:	0000001c 	andeq	r0, r0, ip, lsl r0
     164:	000000c8 	andeq	r0, r0, r8, asr #1
     168:	300008c4 	andcc	r0, r0, r4, asr #17
     16c:	00000054 	andeq	r0, r0, r4, asr r0
     170:	11100e44 	tstne	r0, r4, asr #28
     174:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     178:	03051102 	movweq	r1, #20738	; 0x5102
     17c:	00040411 	andeq	r0, r4, r1, lsl r4
     180:	00000028 	andeq	r0, r0, r8, lsr #32
     184:	000000c8 	andeq	r0, r0, r8, asr #1
     188:	30000918 	andcc	r0, r0, r8, lsl r9
     18c:	00000040 	andeq	r0, r0, r0, asr #32
     190:	44100e44 	ldrmi	r0, [r0], #-3652	; 0xe44
     194:	0e44180e 	cdpeq	8, 4, cr1, cr4, cr14, {0}
     198:	0e110298 	mrceq	2, 0, r0, cr1, cr8, {4}
     19c:	06041105 	streq	r1, [r4], -r5, lsl #2
     1a0:	11010311 	tstne	r1, r1, lsl r3
     1a4:	01110202 	tsteq	r1, r2, lsl #4
     1a8:	04001103 	streq	r1, [r0], #-259	; 0x103
     1ac:	00000018 	andeq	r0, r0, r8, lsl r0
     1b0:	000000c8 	andeq	r0, r0, r8, asr #1
     1b4:	30000958 	andcc	r0, r0, r8, asr r9
     1b8:	00000050 	andeq	r0, r0, r0, asr r0
     1bc:	48040e44 	stmdami	r4, {r2, r6, r9, sl, fp}
     1c0:	0e11180e 	cdpeq	8, 1, cr1, cr1, cr14, {0}
     1c4:	00000001 	andeq	r0, r0, r1
     1c8:	0000000c 	andeq	r0, r0, ip
     1cc:	ffffffff 	undefined instruction 0xffffffff
     1d0:	7c010001 	stcvc	0, cr0, [r1], {1}
     1d4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     1d8:	00000014 	andeq	r0, r0, r4, lsl r0
     1dc:	000001c8 	andeq	r0, r0, r8, asr #3
     1e0:	300009a8 	andcc	r0, r0, r8, lsr #19
     1e4:	00000018 	andeq	r0, r0, r8, lsl r0
     1e8:	11040e44 	tstne	r4, r4, asr #28
     1ec:	00000104 	andeq	r0, r0, r4, lsl #2
     1f0:	00000014 	andeq	r0, r0, r4, lsl r0
     1f4:	000001c8 	andeq	r0, r0, r8, asr #3
     1f8:	300009c0 	andcc	r0, r0, r0, asr #19
     1fc:	00000018 	andeq	r0, r0, r8, lsl r0
     200:	11040e44 	tstne	r4, r4, asr #28
     204:	00000104 	andeq	r0, r0, r4, lsl #2
     208:	0000000c 	andeq	r0, r0, ip
     20c:	000001c8 	andeq	r0, r0, r8, asr #3
     210:	300009d8 	ldrdcc	r0, [r0], -r8
     214:	00000018 	andeq	r0, r0, r8, lsl r0
     218:	00000018 	andeq	r0, r0, r8, lsl r0
     21c:	000001c8 	andeq	r0, r0, r8, asr #3
     220:	300009f0 	strdcc	r0, [r0], -r0
     224:	0000003c 	andeq	r0, r0, ip, lsr r0
     228:	11080e58 	tstne	r8, r8, asr lr
     22c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     230:	00000002 	andeq	r0, r0, r2
     234:	0000000c 	andeq	r0, r0, ip
     238:	ffffffff 	undefined instruction 0xffffffff
     23c:	7c010001 	stcvc	0, cr0, [r1], {1}
     240:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     244:	0000000c 	andeq	r0, r0, ip
     248:	00000234 	andeq	r0, r0, r4, lsr r2
     24c:	30000a2c 	andcc	r0, r0, ip, lsr #20
     250:	00000030 	andeq	r0, r0, r0, lsr r0
     254:	0000000c 	andeq	r0, r0, ip
     258:	00000234 	andeq	r0, r0, r4, lsr r2
     25c:	30000a5c 	andcc	r0, r0, ip, asr sl
     260:	0000000c 	andeq	r0, r0, ip
     264:	0000000c 	andeq	r0, r0, ip
     268:	00000234 	andeq	r0, r0, r4, lsr r2
     26c:	30000a68 	andcc	r0, r0, r8, ror #20
     270:	00000004 	andeq	r0, r0, r4
     274:	00000024 	andeq	r0, r0, r4, lsr #32
     278:	00000234 	andeq	r0, r0, r4, lsr r2
     27c:	30000a6c 	andcc	r0, r0, ip, ror #20
     280:	000000c0 	andeq	r0, r0, r0, asr #1
     284:	11180e44 	tstne	r8, r4, asr #28
     288:	0811010a 	ldmdaeq	r1, {r1, r3, r8}
     28c:	03071102 	movweq	r1, #28930	; 0x7102
     290:	11040611 	tstne	r4, r1, lsl r6
     294:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     298:	00000006 	andeq	r0, r0, r6
     29c:	00000014 	andeq	r0, r0, r4, lsl r0
     2a0:	00000234 	andeq	r0, r0, r4, lsr r2
     2a4:	30000b2c 	andcc	r0, r0, ip, lsr #22
     2a8:	00000080 	andeq	r0, r0, r0, lsl #1
     2ac:	11040e44 	tstne	r4, r4, asr #28
     2b0:	00000104 	andeq	r0, r0, r4, lsl #2
     2b4:	0000000c 	andeq	r0, r0, ip
     2b8:	00000234 	andeq	r0, r0, r4, lsr r2
     2bc:	30000bac 	andcc	r0, r0, ip, lsr #23
     2c0:	00000050 	andeq	r0, r0, r0, asr r0
     2c4:	0000000c 	andeq	r0, r0, ip
     2c8:	00000234 	andeq	r0, r0, r4, lsr r2
     2cc:	30000bfc 	strdcc	r0, [r0], -ip
     2d0:	00000024 	andeq	r0, r0, r4, lsr #32
     2d4:	0000000c 	andeq	r0, r0, ip
     2d8:	00000234 	andeq	r0, r0, r4, lsr r2
     2dc:	30000c20 	andcc	r0, r0, r0, lsr #24
     2e0:	00000034 	andeq	r0, r0, r4, lsr r0
     2e4:	0000000c 	andeq	r0, r0, ip
     2e8:	00000234 	andeq	r0, r0, r4, lsr r2
     2ec:	30000c54 	andcc	r0, r0, r4, asr ip
     2f0:	00000034 	andeq	r0, r0, r4, lsr r0
     2f4:	0000000c 	andeq	r0, r0, ip
     2f8:	00000234 	andeq	r0, r0, r4, lsr r2
     2fc:	30000c88 	andcc	r0, r0, r8, lsl #25
     300:	0000003c 	andeq	r0, r0, ip, lsr r0
     304:	0000000c 	andeq	r0, r0, ip
     308:	00000234 	andeq	r0, r0, r4, lsr r2
     30c:	30000cc4 	andcc	r0, r0, r4, asr #25
     310:	00000030 	andeq	r0, r0, r0, lsr r0
     314:	00000018 	andeq	r0, r0, r8, lsl r0
     318:	00000234 	andeq	r0, r0, r4, lsr r2
     31c:	30000cf4 	strdcc	r0, [r0], -r4
     320:	0000009c 	muleq	r0, ip, r0
     324:	110c0e44 	tstne	ip, r4, asr #28
     328:	05110106 	ldreq	r0, [r1, #-262]	; 0x106
     32c:	03041102 	movweq	r1, #16642	; 0x4102
     330:	00000014 	andeq	r0, r0, r4, lsl r0
     334:	00000234 	andeq	r0, r0, r4, lsr r2
     338:	30000d90 	mulcc	r0, r0, sp
     33c:	00000080 	andeq	r0, r0, r0, lsl #1
     340:	11040e44 	tstne	r4, r4, asr #28
     344:	00000104 	andeq	r0, r0, r4, lsl #2
     348:	00000014 	andeq	r0, r0, r4, lsl r0
     34c:	00000234 	andeq	r0, r0, r4, lsr r2
     350:	30000e10 	andcc	r0, r0, r0, lsl lr
     354:	000000b4 	strheq	r0, [r0], -r4
     358:	11040e44 	tstne	r4, r4, asr #28
     35c:	00000104 	andeq	r0, r0, r4, lsl #2
     360:	0000000c 	andeq	r0, r0, ip
     364:	00000234 	andeq	r0, r0, r4, lsr r2
     368:	30000ec4 	andcc	r0, r0, r4, asr #29
     36c:	00000044 	andeq	r0, r0, r4, asr #32
     370:	00000014 	andeq	r0, r0, r4, lsl r0
     374:	00000234 	andeq	r0, r0, r4, lsr r2
     378:	30000f08 	andcc	r0, r0, r8, lsl #30
     37c:	00000078 	andeq	r0, r0, r8, ror r0
     380:	11040e44 	tstne	r4, r4, asr #28
     384:	00000104 	andeq	r0, r0, r4, lsl #2
     388:	0000000c 	andeq	r0, r0, ip
     38c:	00000234 	andeq	r0, r0, r4, lsr r2
     390:	30000f80 	andcc	r0, r0, r0, lsl #31
     394:	00000054 	andeq	r0, r0, r4, asr r0
     398:	0000000c 	andeq	r0, r0, ip
     39c:	00000234 	andeq	r0, r0, r4, lsr r2
     3a0:	30000fd4 	ldrdcc	r0, [r0], -r4
     3a4:	00000034 	andeq	r0, r0, r4, lsr r0
     3a8:	00000014 	andeq	r0, r0, r4, lsl r0
     3ac:	00000234 	andeq	r0, r0, r4, lsr r2
     3b0:	30001008 	andcc	r1, r0, r8
     3b4:	0000009c 	muleq	r0, ip, r0
     3b8:	11040e4c 	tstne	r4, ip, asr #28
     3bc:	00000104 	andeq	r0, r0, r4, lsl #2
     3c0:	0000000c 	andeq	r0, r0, ip
     3c4:	00000234 	andeq	r0, r0, r4, lsr r2
     3c8:	300010a4 	andcc	r1, r0, r4, lsr #1
     3cc:	00000070 	andeq	r0, r0, r0, ror r0
     3d0:	0000000c 	andeq	r0, r0, ip
     3d4:	00000234 	andeq	r0, r0, r4, lsr r2
     3d8:	30001114 	andcc	r1, r0, r4, lsl r1
     3dc:	00000004 	andeq	r0, r0, r4
     3e0:	00000018 	andeq	r0, r0, r8, lsl r0
     3e4:	00000234 	andeq	r0, r0, r4, lsr r2
     3e8:	30001118 	andcc	r1, r0, r8, lsl r1
     3ec:	00000024 	andeq	r0, r0, r4, lsr #32
     3f0:	11080e44 	tstne	r8, r4, asr #28
     3f4:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     3f8:	00000002 	andeq	r0, r0, r2
     3fc:	00000018 	andeq	r0, r0, r8, lsl r0
     400:	00000234 	andeq	r0, r0, r4, lsr r2
     404:	3000113c 	andcc	r1, r0, ip, lsr r1
     408:	00000024 	andeq	r0, r0, r4, lsr #32
     40c:	11080e44 	tstne	r8, r4, asr #28
     410:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     414:	00000002 	andeq	r0, r0, r2
     418:	0000001c 	andeq	r0, r0, ip, lsl r0
     41c:	00000234 	andeq	r0, r0, r4, lsr r2
     420:	30001160 	andcc	r1, r0, r0, ror #2
     424:	000000a4 	andeq	r0, r0, r4, lsr #1
     428:	11100e48 	tstne	r0, r8, asr #28
     42c:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     430:	03051102 	movweq	r1, #20738	; 0x5102
     434:	00040411 	andeq	r0, r4, r1, lsl r4
     438:	0000001c 	andeq	r0, r0, ip, lsl r0
     43c:	00000234 	andeq	r0, r0, r4, lsr r2
     440:	30001204 	andcc	r1, r0, r4, lsl #4
     444:	000000e0 	andeq	r0, r0, r0, ror #1
     448:	11100e48 	tstne	r0, r8, asr #28
     44c:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     450:	03051102 	movweq	r1, #20738	; 0x5102
     454:	00040411 	andeq	r0, r4, r1, lsl r4
     458:	00000024 	andeq	r0, r0, r4, lsr #32
     45c:	00000234 	andeq	r0, r0, r4, lsr r2
     460:	300012e4 	andcc	r1, r0, r4, ror #5
     464:	0000007c 	andeq	r0, r0, ip, ror r0
     468:	11140e44 	tstne	r4, r4, asr #28
     46c:	0711010e 	ldreq	r0, [r1, -lr, lsl #2]
     470:	03061102 	movweq	r1, #24834	; 0x6102
     474:	11040511 	tstne	r4, r1, lsl r5
     478:	0e480504 	cdpeq	5, 4, cr0, cr8, cr4, {0}
     47c:	00000020 	andeq	r0, r0, r0, lsr #32
     480:	0000001c 	andeq	r0, r0, ip, lsl r0
     484:	00000234 	andeq	r0, r0, r4, lsr r2
     488:	30001360 	andcc	r1, r0, r0, ror #6
     48c:	000000f8 	strdeq	r0, [r0], -r8
     490:	11100e44 	tstne	r0, r4, asr #28
     494:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     498:	03051102 	movweq	r1, #20738	; 0x5102
     49c:	00040411 	andeq	r0, r4, r1, lsl r4
     4a0:	00000024 	andeq	r0, r0, r4, lsr #32
     4a4:	00000234 	andeq	r0, r0, r4, lsr r2
     4a8:	30001458 	andcc	r1, r0, r8, asr r4
     4ac:	000000f0 	strdeq	r0, [r0], -r0
     4b0:	11180e44 	tstne	r8, r4, asr #28
     4b4:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     4b8:	03071102 	movweq	r1, #28930	; 0x7102
     4bc:	11040611 	tstne	r4, r1, lsl r6
     4c0:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     4c4:	00000006 	andeq	r0, r0, r6
     4c8:	00000018 	andeq	r0, r0, r8, lsl r0
     4cc:	00000234 	andeq	r0, r0, r4, lsr r2
     4d0:	30001548 	andcc	r1, r0, r8, asr #10
     4d4:	0000009c 	muleq	r0, ip, r0
     4d8:	11080e48 	tstne	r8, r8, asr #28
     4dc:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     4e0:	00000002 	andeq	r0, r0, r2
     4e4:	0000001c 	andeq	r0, r0, ip, lsl r0
     4e8:	00000234 	andeq	r0, r0, r4, lsr r2
     4ec:	300015e4 	andcc	r1, r0, r4, ror #11
     4f0:	00000084 	andeq	r0, r0, r4, lsl #1
     4f4:	110c0e44 	tstne	ip, r4, asr #28
     4f8:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     4fc:	03041102 	movweq	r1, #16642	; 0x4102
     500:	00180e48 	andseq	r0, r8, r8, asr #28
     504:	00000018 	andeq	r0, r0, r8, lsl r0
     508:	00000234 	andeq	r0, r0, r4, lsr r2
     50c:	30001668 	andcc	r1, r0, r8, ror #12
     510:	00000084 	andeq	r0, r0, r4, lsl #1
     514:	11080e44 	tstne	r8, r4, asr #28
     518:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     51c:	100e4802 	andne	r4, lr, r2, lsl #16
     520:	0000001c 	andeq	r0, r0, ip, lsl r0
     524:	00000234 	andeq	r0, r0, r4, lsr r2
     528:	300016ec 	andcc	r1, r0, ip, ror #13
     52c:	00000098 	muleq	r0, r8, r0
     530:	11100e44 	tstne	r0, r4, asr #28
     534:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     538:	03051102 	movweq	r1, #20738	; 0x5102
     53c:	00040411 	andeq	r0, r4, r1, lsl r4
     540:	0000001c 	andeq	r0, r0, ip, lsl r0
     544:	00000234 	andeq	r0, r0, r4, lsr r2
     548:	30001784 	andcc	r1, r0, r4, lsl #15
     54c:	00000044 	andeq	r0, r0, r4, asr #32
     550:	11100e44 	tstne	r0, r4, asr #28
     554:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     558:	03051102 	movweq	r1, #20738	; 0x5102
     55c:	00040411 	andeq	r0, r4, r1, lsl r4
     560:	00000018 	andeq	r0, r0, r8, lsl r0
     564:	00000234 	andeq	r0, r0, r4, lsr r2
     568:	300017c8 	andcc	r1, r0, r8, asr #15
     56c:	000000a4 	andeq	r0, r0, r4, lsr #1
     570:	11080e44 	tstne	r8, r4, asr #28
     574:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     578:	100e4802 	andne	r4, lr, r2, lsl #16
     57c:	00000018 	andeq	r0, r0, r8, lsl r0
     580:	00000234 	andeq	r0, r0, r4, lsr r2
     584:	3000186c 	andcc	r1, r0, ip, ror #16
     588:	00000050 	andeq	r0, r0, r0, asr r0
     58c:	11080e44 	tstne	r8, r4, asr #28
     590:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     594:	00000002 	andeq	r0, r0, r2
     598:	00000028 	andeq	r0, r0, r8, lsr #32
     59c:	00000234 	andeq	r0, r0, r4, lsr r2
     5a0:	300018bc 	undefined instruction 0x300018bc
     5a4:	000000f4 	strdeq	r0, [r0], -r4
     5a8:	11200e44 	teqne	r0, r4, asr #28
     5ac:	0a11010e 	beq	4409ec <DISABLE_IRQ+0x44096c>
     5b0:	03091102 	movweq	r1, #37122	; 0x9102
     5b4:	11040811 	tstne	r4, r1, lsl r8
     5b8:	06110507 	ldreq	r0, [r1], -r7, lsl #10
     5bc:	07051106 	streq	r1, [r5, -r6, lsl #2]
     5c0:	00080411 	andeq	r0, r8, r1, lsl r4
     5c4:	0000001c 	andeq	r0, r0, ip, lsl r0
     5c8:	00000234 	andeq	r0, r0, r4, lsr r2
     5cc:	300019b0 	undefined instruction 0x300019b0
     5d0:	0000009c 	muleq	r0, ip, r0
     5d4:	11100e44 	tstne	r0, r4, asr #28
     5d8:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     5dc:	03051102 	movweq	r1, #20738	; 0x5102
     5e0:	00040411 	andeq	r0, r4, r1, lsl r4
     5e4:	0000001c 	andeq	r0, r0, ip, lsl r0
     5e8:	00000234 	andeq	r0, r0, r4, lsr r2
     5ec:	30001a4c 	andcc	r1, r0, ip, asr #20
     5f0:	000000b8 	strheq	r0, [r0], -r8
     5f4:	110c0e44 	tstne	ip, r4, asr #28
     5f8:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     5fc:	03041102 	movweq	r1, #16642	; 0x4102
     600:	00180e50 	andseq	r0, r8, r0, asr lr
     604:	00000024 	andeq	r0, r0, r4, lsr #32
     608:	00000234 	andeq	r0, r0, r4, lsr r2
     60c:	30001b04 	andcc	r1, r0, r4, lsl #22
     610:	00000104 	andeq	r0, r0, r4, lsl #2
     614:	11180e44 	tstne	r8, r4, asr #28
     618:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     61c:	03071102 	movweq	r1, #28930	; 0x7102
     620:	11040611 	tstne	r4, r1, lsl r6
     624:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     628:	00000006 	andeq	r0, r0, r6
     62c:	0000001c 	andeq	r0, r0, ip, lsl r0
     630:	00000234 	andeq	r0, r0, r4, lsr r2
     634:	30001c08 	andcc	r1, r0, r8, lsl #24
     638:	000000e0 	andeq	r0, r0, r0, ror #1
     63c:	11100e44 	tstne	r0, r4, asr #28
     640:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     644:	03051102 	movweq	r1, #20738	; 0x5102
     648:	00040411 	andeq	r0, r4, r1, lsl r4
     64c:	0000001c 	andeq	r0, r0, ip, lsl r0
     650:	00000234 	andeq	r0, r0, r4, lsr r2
     654:	30001ce8 	andcc	r1, r0, r8, ror #25
     658:	0000006c 	andeq	r0, r0, ip, rrx
     65c:	11100e44 	tstne	r0, r4, asr #28
     660:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     664:	03051102 	movweq	r1, #20738	; 0x5102
     668:	00040411 	andeq	r0, r4, r1, lsl r4
     66c:	0000001c 	andeq	r0, r0, ip, lsl r0
     670:	00000234 	andeq	r0, r0, r4, lsr r2
     674:	30001d54 	andcc	r1, r0, r4, asr sp
     678:	00000064 	andeq	r0, r0, r4, rrx
     67c:	11100e44 	tstne	r0, r4, asr #28
     680:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     684:	03051102 	movweq	r1, #20738	; 0x5102
     688:	00040411 	andeq	r0, r4, r1, lsl r4
     68c:	0000001c 	andeq	r0, r0, ip, lsl r0
     690:	00000234 	andeq	r0, r0, r4, lsr r2
     694:	30001db8 	undefined instruction 0x30001db8
     698:	000000d4 	ldrdeq	r0, [r0], -r4
     69c:	11100e44 	tstne	r0, r4, asr #28
     6a0:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     6a4:	03051102 	movweq	r1, #20738	; 0x5102
     6a8:	00040411 	andeq	r0, r4, r1, lsl r4
     6ac:	00000024 	andeq	r0, r0, r4, lsr #32
     6b0:	00000234 	andeq	r0, r0, r4, lsr r2
     6b4:	30001e8c 	andcc	r1, r0, ip, lsl #29
     6b8:	000000b0 	strheq	r0, [r0], -r0
     6bc:	11180e44 	tstne	r8, r4, asr #28
     6c0:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     6c4:	03071102 	movweq	r1, #28930	; 0x7102
     6c8:	11040611 	tstne	r4, r1, lsl r6
     6cc:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     6d0:	00000006 	andeq	r0, r0, r6
     6d4:	00000024 	andeq	r0, r0, r4, lsr #32
     6d8:	00000234 	andeq	r0, r0, r4, lsr r2
     6dc:	30001f3c 	andcc	r1, r0, ip, lsr pc
     6e0:	00000078 	andeq	r0, r0, r8, ror r0
     6e4:	11180e44 	tstne	r8, r4, asr #28
     6e8:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     6ec:	03071102 	movweq	r1, #28930	; 0x7102
     6f0:	11040611 	tstne	r4, r1, lsl r6
     6f4:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     6f8:	00000006 	andeq	r0, r0, r6
     6fc:	00000028 	andeq	r0, r0, r8, lsr #32
     700:	00000234 	andeq	r0, r0, r4, lsr r2
     704:	30001fb4 	undefined instruction 0x30001fb4
     708:	000000f4 	strdeq	r0, [r0], -r4
     70c:	11200e44 	teqne	r0, r4, asr #28
     710:	0a11010e 	beq	440b50 <DISABLE_IRQ+0x440ad0>
     714:	03091102 	movweq	r1, #37122	; 0x9102
     718:	11040811 	tstne	r4, r1, lsl r8
     71c:	06110507 	ldreq	r0, [r1], -r7, lsl #10
     720:	07051106 	streq	r1, [r5, -r6, lsl #2]
     724:	00080411 	andeq	r0, r8, r1, lsl r4
     728:	00000018 	andeq	r0, r0, r8, lsl r0
     72c:	00000234 	andeq	r0, r0, r4, lsr r2
     730:	300020a8 	andcc	r2, r0, r8, lsr #1
     734:	00000084 	andeq	r0, r0, r4, lsl #1
     738:	11080e44 	tstne	r8, r4, asr #28
     73c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     740:	100e4802 	andne	r4, lr, r2, lsl #16
     744:	0000001c 	andeq	r0, r0, ip, lsl r0
     748:	00000234 	andeq	r0, r0, r4, lsr r2
     74c:	3000212c 	andcc	r2, r0, ip, lsr #2
     750:	00000098 	muleq	r0, r8, r0
     754:	11100e44 	tstne	r0, r4, asr #28
     758:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     75c:	03051102 	movweq	r1, #20738	; 0x5102
     760:	00040411 	andeq	r0, r4, r1, lsl r4
     764:	0000001c 	andeq	r0, r0, ip, lsl r0
     768:	00000234 	andeq	r0, r0, r4, lsr r2
     76c:	300021c4 	andcc	r2, r0, r4, asr #3
     770:	00000040 	andeq	r0, r0, r0, asr #32
     774:	11100e44 	tstne	r0, r4, asr #28
     778:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     77c:	03051102 	movweq	r1, #20738	; 0x5102
     780:	00040411 	andeq	r0, r4, r1, lsl r4
     784:	0000001c 	andeq	r0, r0, ip, lsl r0
     788:	00000234 	andeq	r0, r0, r4, lsr r2
     78c:	30002204 	andcc	r2, r0, r4, lsl #4
     790:	00000060 	andeq	r0, r0, r0, rrx
     794:	11100e44 	tstne	r0, r4, asr #28
     798:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     79c:	03051102 	movweq	r1, #20738	; 0x5102
     7a0:	00040411 	andeq	r0, r4, r1, lsl r4
     7a4:	00000018 	andeq	r0, r0, r8, lsl r0
     7a8:	00000234 	andeq	r0, r0, r4, lsr r2
     7ac:	30002264 	andcc	r2, r0, r4, ror #4
     7b0:	00000028 	andeq	r0, r0, r8, lsr #32
     7b4:	11080e44 	tstne	r8, r4, asr #28
     7b8:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     7bc:	00000002 	andeq	r0, r0, r2
     7c0:	0000001c 	andeq	r0, r0, ip, lsl r0
     7c4:	00000234 	andeq	r0, r0, r4, lsr r2
     7c8:	3000228c 	andcc	r2, r0, ip, lsl #5
     7cc:	000000f0 	strdeq	r0, [r0], -r0
     7d0:	11100e44 	tstne	r0, r4, asr #28
     7d4:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     7d8:	03051102 	movweq	r1, #20738	; 0x5102
     7dc:	00040411 	andeq	r0, r4, r1, lsl r4
     7e0:	00000024 	andeq	r0, r0, r4, lsr #32
     7e4:	00000234 	andeq	r0, r0, r4, lsr r2
     7e8:	3000237c 	andcc	r2, r0, ip, ror r3
     7ec:	000000d0 	ldrdeq	r0, [r0], -r0
     7f0:	11180e44 	tstne	r8, r4, asr #28
     7f4:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     7f8:	03071102 	movweq	r1, #28930	; 0x7102
     7fc:	11040611 	tstne	r4, r1, lsl r6
     800:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     804:	00000006 	andeq	r0, r0, r6
     808:	00000024 	andeq	r0, r0, r4, lsr #32
     80c:	00000234 	andeq	r0, r0, r4, lsr r2
     810:	3000244c 	andcc	r2, r0, ip, asr #8
     814:	00000094 	muleq	r0, r4, r0
     818:	11180e44 	tstne	r8, r4, asr #28
     81c:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     820:	03071102 	movweq	r1, #28930	; 0x7102
     824:	11040611 	tstne	r4, r1, lsl r6
     828:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     82c:	00000006 	andeq	r0, r0, r6
     830:	00000024 	andeq	r0, r0, r4, lsr #32
     834:	00000234 	andeq	r0, r0, r4, lsr r2
     838:	300024e0 	andcc	r2, r0, r0, ror #9
     83c:	00000134 	andeq	r0, r0, r4, lsr r1
     840:	11180e44 	tstne	r8, r4, asr #28
     844:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     848:	03071102 	movweq	r1, #28930	; 0x7102
     84c:	11040611 	tstne	r4, r1, lsl r6
     850:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     854:	00000006 	andeq	r0, r0, r6
     858:	00000018 	andeq	r0, r0, r8, lsl r0
     85c:	00000234 	andeq	r0, r0, r4, lsr r2
     860:	30002614 	andcc	r2, r0, r4, lsl r6
     864:	00000058 	andeq	r0, r0, r8, asr r0
     868:	11080e44 	tstne	r8, r4, asr #28
     86c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     870:	00000002 	andeq	r0, r0, r2
     874:	0000001c 	andeq	r0, r0, ip, lsl r0
     878:	00000234 	andeq	r0, r0, r4, lsr r2
     87c:	3000266c 	andcc	r2, r0, ip, ror #12
     880:	000000c4 	andeq	r0, r0, r4, asr #1
     884:	11100e44 	tstne	r0, r4, asr #28
     888:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     88c:	03051102 	movweq	r1, #20738	; 0x5102
     890:	00040411 	andeq	r0, r4, r1, lsl r4
     894:	00000024 	andeq	r0, r0, r4, lsr #32
     898:	00000234 	andeq	r0, r0, r4, lsr r2
     89c:	30002730 	andcc	r2, r0, r0, lsr r7
     8a0:	000000a8 	andeq	r0, r0, r8, lsr #1
     8a4:	11180e44 	tstne	r8, r4, asr #28
     8a8:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     8ac:	03071102 	movweq	r1, #28930	; 0x7102
     8b0:	11040611 	tstne	r4, r1, lsl r6
     8b4:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     8b8:	00000006 	andeq	r0, r0, r6
     8bc:	00000028 	andeq	r0, r0, r8, lsr #32
     8c0:	00000234 	andeq	r0, r0, r4, lsr r2
     8c4:	300027d8 	ldrdcc	r2, [r0], -r8
     8c8:	00000164 	andeq	r0, r0, r4, ror #2
     8cc:	11200e44 	teqne	r0, r4, asr #28
     8d0:	0a11010e 	beq	440d10 <DISABLE_IRQ+0x440c90>
     8d4:	03091102 	movweq	r1, #37122	; 0x9102
     8d8:	11040811 	tstne	r4, r1, lsl r8
     8dc:	06110507 	ldreq	r0, [r1], -r7, lsl #10
     8e0:	07051106 	streq	r1, [r5, -r6, lsl #2]
     8e4:	00080411 	andeq	r0, r8, r1, lsl r4
     8e8:	00000018 	andeq	r0, r0, r8, lsl r0
     8ec:	00000234 	andeq	r0, r0, r4, lsr r2
     8f0:	3000293c 	andcc	r2, r0, ip, lsr r9
     8f4:	00000028 	andeq	r0, r0, r8, lsr #32
     8f8:	11080e44 	tstne	r8, r4, asr #28
     8fc:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     900:	00000002 	andeq	r0, r0, r2
     904:	00000018 	andeq	r0, r0, r8, lsl r0
     908:	00000234 	andeq	r0, r0, r4, lsr r2
     90c:	30002964 	andcc	r2, r0, r4, ror #18
     910:	000000d0 	ldrdeq	r0, [r0], -r0
     914:	11080e44 	tstne	r8, r4, asr #28
     918:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     91c:	00000002 	andeq	r0, r0, r2
     920:	00000018 	andeq	r0, r0, r8, lsl r0
     924:	00000234 	andeq	r0, r0, r4, lsr r2
     928:	30002a34 	andcc	r2, r0, r4, lsr sl
     92c:	000000e4 	andeq	r0, r0, r4, ror #1
     930:	11080e48 	tstne	r8, r8, asr #28
     934:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     938:	00000002 	andeq	r0, r0, r2
     93c:	00000018 	andeq	r0, r0, r8, lsl r0
     940:	00000234 	andeq	r0, r0, r4, lsr r2
     944:	30002b18 	andcc	r2, r0, r8, lsl fp
     948:	0000006c 	andeq	r0, r0, ip, rrx
     94c:	11080e44 	tstne	r8, r4, asr #28
     950:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     954:	00000002 	andeq	r0, r0, r2
     958:	00000018 	andeq	r0, r0, r8, lsl r0
     95c:	00000234 	andeq	r0, r0, r4, lsr r2
     960:	30002b84 	andcc	r2, r0, r4, lsl #23
     964:	000000dc 	ldrdeq	r0, [r0], -ip
     968:	11080e48 	tstne	r8, r8, asr #28
     96c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     970:	00000002 	andeq	r0, r0, r2
     974:	00000030 	andeq	r0, r0, r0, lsr r0
     978:	00000234 	andeq	r0, r0, r4, lsr r2
     97c:	30002c60 	andcc	r2, r0, r0, ror #24
     980:	000000c0 	andeq	r0, r0, r0, asr #1
     984:	11280e44 	teqne	r8, r4, asr #28
     988:	0b11010e 	bleq	440dc8 <DISABLE_IRQ+0x440d48>
     98c:	030a1102 	movweq	r1, #41218	; 0xa102
     990:	11040911 	tstne	r4, r1, lsl r9
     994:	07110508 	ldreq	r0, [r1, -r8, lsl #10]
     998:	07061106 	streq	r1, [r6, -r6, lsl #2]
     99c:	11080511 	tstne	r8, r1, lsl r5
     9a0:	03110904 	tsteq	r1, #65536	; 0x10000
     9a4:	0000000a 	andeq	r0, r0, sl
     9a8:	00000018 	andeq	r0, r0, r8, lsl r0
     9ac:	00000234 	andeq	r0, r0, r4, lsr r2
     9b0:	30002d20 	andcc	r2, r0, r0, lsr #26
     9b4:	0000005c 	andeq	r0, r0, ip, asr r0
     9b8:	11080e44 	tstne	r8, r4, asr #28
     9bc:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     9c0:	00000002 	andeq	r0, r0, r2
     9c4:	00000018 	andeq	r0, r0, r8, lsl r0
     9c8:	00000234 	andeq	r0, r0, r4, lsr r2
     9cc:	30002d7c 	andcc	r2, r0, ip, ror sp
     9d0:	00000100 	andeq	r0, r0, r0, lsl #2
     9d4:	11080e48 	tstne	r8, r8, asr #28
     9d8:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     9dc:	00000002 	andeq	r0, r0, r2
     9e0:	0000001c 	andeq	r0, r0, ip, lsl r0
     9e4:	00000234 	andeq	r0, r0, r4, lsr r2
     9e8:	30002e7c 	andcc	r2, r0, ip, ror lr
     9ec:	000000e4 	andeq	r0, r0, r4, ror #1
     9f0:	11100e48 	tstne	r0, r8, asr #28
     9f4:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     9f8:	03051102 	movweq	r1, #20738	; 0x5102
     9fc:	00040411 	andeq	r0, r4, r1, lsl r4
     a00:	00000024 	andeq	r0, r0, r4, lsr #32
     a04:	00000234 	andeq	r0, r0, r4, lsr r2
     a08:	30002f60 	andcc	r2, r0, r0, ror #30
     a0c:	00000224 	andeq	r0, r0, r4, lsr #4
     a10:	11180e44 	tstne	r8, r4, asr #28
     a14:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     a18:	03071102 	movweq	r1, #28930	; 0x7102
     a1c:	11040611 	tstne	r4, r1, lsl r6
     a20:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     a24:	00000006 	andeq	r0, r0, r6
     a28:	00000030 	andeq	r0, r0, r0, lsr r0
     a2c:	00000234 	andeq	r0, r0, r4, lsr r2
     a30:	30003184 	andcc	r3, r0, r4, lsl #3
     a34:	0000013c 	andeq	r0, r0, ip, lsr r1
     a38:	48240e44 	stmdami	r4!, {r2, r6, r9, sl, fp}
     a3c:	0e11400e 	cdpeq	0, 1, cr4, cr1, cr14, {0}
     a40:	020b1101 	andeq	r1, fp, #1073741824	; 0x40000000
     a44:	11030a11 	tstne	r3, r1, lsl sl
     a48:	08110409 	ldmdaeq	r1, {r0, r3, sl}
     a4c:	06071105 	streq	r1, [r7], -r5, lsl #2
     a50:	11070611 	tstne	r7, r1, lsl r6
     a54:	04110805 	ldreq	r0, [r1], #-2053	; 0x805
     a58:	00000009 	andeq	r0, r0, r9
     a5c:	00000024 	andeq	r0, r0, r4, lsr #32
     a60:	00000234 	andeq	r0, r0, r4, lsr r2
     a64:	300032c0 	andcc	r3, r0, r0, asr #5
     a68:	0000018c 	andeq	r0, r0, ip, lsl #3
     a6c:	4c140e44 	ldcmi	14, cr0, [r4], {68}	; 0x44
     a70:	0e11380e 	cdpeq	8, 1, cr3, cr1, cr14, {0}
     a74:	02071101 	andeq	r1, r7, #1073741824	; 0x40000000
     a78:	11030611 	tstne	r3, r1, lsl r6
     a7c:	04110405 	ldreq	r0, [r1], #-1029	; 0x405
     a80:	00000005 	andeq	r0, r0, r5
     a84:	00000028 	andeq	r0, r0, r8, lsr #32
     a88:	00000234 	andeq	r0, r0, r4, lsr r2
     a8c:	3000344c 	andcc	r3, r0, ip, asr #8
     a90:	000000ec 	andeq	r0, r0, ip, ror #1
     a94:	111c0e44 	tstne	ip, r4, asr #28
     a98:	0a11010e 	beq	440ed8 <DISABLE_IRQ+0x440e58>
     a9c:	03081102 	movweq	r1, #33026	; 0x8102
     aa0:	11040711 	tstne	r4, r1, lsl r7
     aa4:	05110506 	ldreq	r0, [r1, #-1286]	; 0x506
     aa8:	07041106 	streq	r1, [r4, -r6, lsl #2]
     aac:	00300e4c 	eorseq	r0, r0, ip, asr #28
     ab0:	00000028 	andeq	r0, r0, r8, lsr #32
     ab4:	00000234 	andeq	r0, r0, r4, lsr r2
     ab8:	30003538 	andcc	r3, r0, r8, lsr r5
     abc:	000001a8 	andeq	r0, r0, r8, lsr #3
     ac0:	11200e48 	teqne	r0, r8, asr #28
     ac4:	0a11010e 	beq	440f04 <DISABLE_IRQ+0x440e84>
     ac8:	03091102 	movweq	r1, #37122	; 0x9102
     acc:	11040811 	tstne	r4, r1, lsl r8
     ad0:	06110507 	ldreq	r0, [r1], -r7, lsl #10
     ad4:	07051106 	streq	r1, [r5, -r6, lsl #2]
     ad8:	00080411 	andeq	r0, r8, r1, lsl r4
     adc:	0000001c 	andeq	r0, r0, ip, lsl r0
     ae0:	00000234 	andeq	r0, r0, r4, lsr r2
     ae4:	300036e0 	andcc	r3, r0, r0, ror #13
     ae8:	00000094 	muleq	r0, r4, r0
     aec:	11100e44 	tstne	r0, r4, asr #28
     af0:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     af4:	03051102 	movweq	r1, #20738	; 0x5102
     af8:	00040411 	andeq	r0, r4, r1, lsl r4
     afc:	0000000c 	andeq	r0, r0, ip
     b00:	00000234 	andeq	r0, r0, r4, lsr r2
     b04:	30003774 	andcc	r3, r0, r4, ror r7
     b08:	00000010 	andeq	r0, r0, r0, lsl r0
     b0c:	0000000c 	andeq	r0, r0, ip
     b10:	00000234 	andeq	r0, r0, r4, lsr r2
     b14:	30003784 	andcc	r3, r0, r4, lsl #15
     b18:	00000010 	andeq	r0, r0, r0, lsl r0
     b1c:	00000024 	andeq	r0, r0, r4, lsr #32
     b20:	00000234 	andeq	r0, r0, r4, lsr r2
     b24:	30003794 	mulcc	r0, r4, r7
     b28:	000001c0 	andeq	r0, r0, r0, asr #3
     b2c:	11140e44 	tstne	r4, r4, asr #28
     b30:	0711010e 	ldreq	r0, [r1, -lr, lsl #2]
     b34:	03061102 	movweq	r1, #24834	; 0x6102
     b38:	11040511 	tstne	r4, r1, lsl r5
     b3c:	0e480504 	cdpeq	5, 4, cr0, cr8, cr4, {0}
     b40:	00000020 	andeq	r0, r0, r0, lsr #32
     b44:	00000018 	andeq	r0, r0, r8, lsl r0
     b48:	00000234 	andeq	r0, r0, r4, lsr r2
     b4c:	30003954 	andcc	r3, r0, r4, asr r9
     b50:	0000002c 	andeq	r0, r0, ip, lsr #32
     b54:	48040e44 	stmdami	r4, {r2, r6, r9, sl, fp}
     b58:	0e11100e 	cdpeq	0, 1, cr1, cr1, cr14, {0}
     b5c:	00000001 	andeq	r0, r0, r1
     b60:	00000020 	andeq	r0, r0, r0, lsr #32
     b64:	00000234 	andeq	r0, r0, r4, lsr r2
     b68:	30003980 	andcc	r3, r0, r0, lsl #19
     b6c:	00000184 	andeq	r0, r0, r4, lsl #3
     b70:	11100e44 	tstne	r0, r4, asr #28
     b74:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     b78:	03051102 	movweq	r1, #20738	; 0x5102
     b7c:	4c040411 	cfstrsmi	mvf0, [r4], {17}
     b80:	0000180e 	andeq	r1, r0, lr, lsl #16
     b84:	0000001c 	andeq	r0, r0, ip, lsl r0
     b88:	00000234 	andeq	r0, r0, r4, lsr r2
     b8c:	30003b04 	andcc	r3, r0, r4, lsl #22
     b90:	000000dc 	ldrdeq	r0, [r0], -ip
     b94:	11100e44 	tstne	r0, r4, asr #28
     b98:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     b9c:	03051102 	movweq	r1, #20738	; 0x5102
     ba0:	00040411 	andeq	r0, r4, r1, lsl r4
     ba4:	0000001c 	andeq	r0, r0, ip, lsl r0
     ba8:	00000234 	andeq	r0, r0, r4, lsr r2
     bac:	30003be0 	andcc	r3, r0, r0, ror #23
     bb0:	00000098 	muleq	r0, r8, r0
     bb4:	110c0e44 	tstne	ip, r4, asr #28
     bb8:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     bbc:	03041102 	movweq	r1, #16642	; 0x4102
     bc0:	00180e48 	andseq	r0, r8, r8, asr #28
     bc4:	0000001c 	andeq	r0, r0, ip, lsl r0
     bc8:	00000234 	andeq	r0, r0, r4, lsr r2
     bcc:	30003c78 	andcc	r3, r0, r8, ror ip
     bd0:	00000130 	andeq	r0, r0, r0, lsr r1
     bd4:	110c0e44 	tstne	ip, r4, asr #28
     bd8:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     bdc:	03041102 	movweq	r1, #16642	; 0x4102
     be0:	00180e48 	andseq	r0, r8, r8, asr #28
     be4:	00000020 	andeq	r0, r0, r0, lsr #32
     be8:	00000234 	andeq	r0, r0, r4, lsr r2
     bec:	30003da8 	andcc	r3, r0, r8, lsr #27
     bf0:	00000110 	andeq	r0, r0, r0, lsl r1
     bf4:	11100e44 	tstne	r0, r4, asr #28
     bf8:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     bfc:	03051102 	movweq	r1, #20738	; 0x5102
     c00:	48040411 	stmdami	r4, {r0, r4, sl}
     c04:	0000180e 	andeq	r1, r0, lr, lsl #16
     c08:	0000001c 	andeq	r0, r0, ip, lsl r0
     c0c:	00000234 	andeq	r0, r0, r4, lsr r2
     c10:	30003eb8 	undefined instruction 0x30003eb8
     c14:	00000134 	andeq	r0, r0, r4, lsr r1
     c18:	11100e44 	tstne	r0, r4, asr #28
     c1c:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
     c20:	03051102 	movweq	r1, #20738	; 0x5102
     c24:	00040411 	andeq	r0, r4, r1, lsl r4
     c28:	00000030 	andeq	r0, r0, r0, lsr r0
     c2c:	00000234 	andeq	r0, r0, r4, lsr r2
     c30:	30003fec 	andcc	r3, r0, ip, ror #31
     c34:	000001a0 	andeq	r0, r0, r0, lsr #3
     c38:	11280e44 	teqne	r8, r4, asr #28
     c3c:	0b11010e 	bleq	44107c <DISABLE_IRQ+0x440ffc>
     c40:	030a1102 	movweq	r1, #41218	; 0xa102
     c44:	11040911 	tstne	r4, r1, lsl r9
     c48:	07110508 	ldreq	r0, [r1, -r8, lsl #10]
     c4c:	07061106 	streq	r1, [r6, -r6, lsl #2]
     c50:	11080511 	tstne	r8, r1, lsl r5
     c54:	03110904 	tsteq	r1, #65536	; 0x10000
     c58:	0000000a 	andeq	r0, r0, sl
     c5c:	0000002c 	andeq	r0, r0, ip, lsr #32
     c60:	00000234 	andeq	r0, r0, r4, lsr r2
     c64:	3000418c 	andcc	r4, r0, ip, lsl #3
     c68:	000000c8 	andeq	r0, r0, r8, asr #1
     c6c:	11200e44 	teqne	r0, r4, asr #28
     c70:	0a11010e 	beq	4410b0 <DISABLE_IRQ+0x441030>
     c74:	03091102 	movweq	r1, #37122	; 0x9102
     c78:	11040811 	tstne	r4, r1, lsl r8
     c7c:	06110507 	ldreq	r0, [r1], -r7, lsl #10
     c80:	07051106 	streq	r1, [r5, -r6, lsl #2]
     c84:	48080411 	stmdami	r8, {r0, r4, sl}
     c88:	0000280e 	andeq	r2, r0, lr, lsl #16
     c8c:	00000024 	andeq	r0, r0, r4, lsr #32
     c90:	00000234 	andeq	r0, r0, r4, lsr r2
     c94:	30004254 	andcc	r4, r0, r4, asr r2
     c98:	00000160 	andeq	r0, r0, r0, ror #2
     c9c:	11140e44 	tstne	r4, r4, asr #28
     ca0:	0711010e 	ldreq	r0, [r1, -lr, lsl #2]
     ca4:	03061102 	movweq	r1, #24834	; 0x6102
     ca8:	11040511 	tstne	r4, r1, lsl r5
     cac:	0e480504 	cdpeq	5, 4, cr0, cr8, cr4, {0}
     cb0:	00000020 	andeq	r0, r0, r0, lsr #32
     cb4:	00000024 	andeq	r0, r0, r4, lsr #32
     cb8:	00000234 	andeq	r0, r0, r4, lsr r2
     cbc:	300043b4 	undefined instruction 0x300043b4
     cc0:	00000120 	andeq	r0, r0, r0, lsr #2
     cc4:	11180e44 	tstne	r8, r4, asr #28
     cc8:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     ccc:	03071102 	movweq	r1, #28930	; 0x7102
     cd0:	11040611 	tstne	r4, r1, lsl r6
     cd4:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     cd8:	00000006 	andeq	r0, r0, r6
     cdc:	0000001c 	andeq	r0, r0, ip, lsl r0
     ce0:	00000234 	andeq	r0, r0, r4, lsr r2
     ce4:	300044d4 	ldrdcc	r4, [r0], -r4
     ce8:	000000c4 	andeq	r0, r0, r4, asr #1
     cec:	110c0e44 	tstne	ip, r4, asr #28
     cf0:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     cf4:	03041102 	movweq	r1, #16642	; 0x4102
     cf8:	00180e48 	andseq	r0, r8, r8, asr #28
     cfc:	0000001c 	andeq	r0, r0, ip, lsl r0
     d00:	00000234 	andeq	r0, r0, r4, lsr r2
     d04:	30004598 	mulcc	r0, r8, r5
     d08:	000000c0 	andeq	r0, r0, r0, asr #1
     d0c:	110c0e44 	tstne	ip, r4, asr #28
     d10:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     d14:	03041102 	movweq	r1, #16642	; 0x4102
     d18:	00180e48 	andseq	r0, r8, r8, asr #28
     d1c:	00000024 	andeq	r0, r0, r4, lsr #32
     d20:	00000234 	andeq	r0, r0, r4, lsr r2
     d24:	30004658 	andcc	r4, r0, r8, asr r6
     d28:	000001e8 	andeq	r0, r0, r8, ror #3
     d2c:	11180e44 	tstne	r8, r4, asr #28
     d30:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     d34:	03071102 	movweq	r1, #28930	; 0x7102
     d38:	11040611 	tstne	r4, r1, lsl r6
     d3c:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     d40:	00000006 	andeq	r0, r0, r6
     d44:	00000024 	andeq	r0, r0, r4, lsr #32
     d48:	00000234 	andeq	r0, r0, r4, lsr r2
     d4c:	30004840 	andcc	r4, r0, r0, asr #16
     d50:	0000018c 	andeq	r0, r0, ip, lsl #3
     d54:	11140e44 	tstne	r4, r4, asr #28
     d58:	0711010e 	ldreq	r0, [r1, -lr, lsl #2]
     d5c:	03061102 	movweq	r1, #24834	; 0x6102
     d60:	11040511 	tstne	r4, r1, lsl r5
     d64:	0e480504 	cdpeq	5, 4, cr0, cr8, cr4, {0}
     d68:	00000020 	andeq	r0, r0, r0, lsr #32
     d6c:	00000028 	andeq	r0, r0, r8, lsr #32
     d70:	00000234 	andeq	r0, r0, r4, lsr r2
     d74:	300049cc 	andcc	r4, r0, ip, asr #19
     d78:	000001b4 	undefined instruction 0x000001b4
     d7c:	11200e44 	teqne	r0, r4, asr #28
     d80:	0a11010e 	beq	4411c0 <DISABLE_IRQ+0x441140>
     d84:	03091102 	movweq	r1, #37122	; 0x9102
     d88:	11040811 	tstne	r4, r1, lsl r8
     d8c:	06110507 	ldreq	r0, [r1], -r7, lsl #10
     d90:	07051106 	streq	r1, [r5, -r6, lsl #2]
     d94:	00080411 	andeq	r0, r8, r1, lsl r4
     d98:	00000030 	andeq	r0, r0, r0, lsr r0
     d9c:	00000234 	andeq	r0, r0, r4, lsr r2
     da0:	30004b80 	andcc	r4, r0, r0, lsl #23
     da4:	00000378 	andeq	r0, r0, r8, ror r3
     da8:	11240e44 	teqne	r4, r4, asr #28
     dac:	0b11010e 	bleq	4411ec <DISABLE_IRQ+0x44116c>
     db0:	030a1102 	movweq	r1, #41218	; 0xa102
     db4:	11040911 	tstne	r4, r1, lsl r9
     db8:	07110508 	ldreq	r0, [r1, -r8, lsl #10]
     dbc:	07061106 	streq	r1, [r6, -r6, lsl #2]
     dc0:	11080511 	tstne	r8, r1, lsl r5
     dc4:	0e480904 	cdpeq	9, 4, cr0, cr8, cr4, {0}
     dc8:	00000038 	andeq	r0, r0, r8, lsr r0
     dcc:	00000030 	andeq	r0, r0, r0, lsr r0
     dd0:	00000234 	andeq	r0, r0, r4, lsr r2
     dd4:	30004ef8 	strdcc	r4, [r0], -r8
     dd8:	0000023c 	andeq	r0, r0, ip, lsr r2
     ddc:	11240e44 	teqne	r4, r4, asr #28
     de0:	0b11010e 	bleq	441220 <DISABLE_IRQ+0x4411a0>
     de4:	030a1102 	movweq	r1, #41218	; 0xa102
     de8:	11040911 	tstne	r4, r1, lsl r9
     dec:	07110508 	ldreq	r0, [r1, -r8, lsl #10]
     df0:	07061106 	streq	r1, [r6, -r6, lsl #2]
     df4:	11080511 	tstne	r8, r1, lsl r5
     df8:	0e4c0904 	cdpeq	9, 4, cr0, cr12, cr4, {0}
     dfc:	00000030 	andeq	r0, r0, r0, lsr r0
     e00:	00000024 	andeq	r0, r0, r4, lsr #32
     e04:	00000234 	andeq	r0, r0, r4, lsr r2
     e08:	30005134 	andcc	r5, r0, r4, lsr r1
     e0c:	000000d0 	ldrdeq	r0, [r0], -r0
     e10:	11180e44 	tstne	r8, r4, asr #28
     e14:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     e18:	03071102 	movweq	r1, #28930	; 0x7102
     e1c:	11040611 	tstne	r4, r1, lsl r6
     e20:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     e24:	00000006 	andeq	r0, r0, r6
     e28:	0000001c 	andeq	r0, r0, ip, lsl r0
     e2c:	00000234 	andeq	r0, r0, r4, lsr r2
     e30:	30005204 	andcc	r5, r0, r4, lsl #4
     e34:	000000a0 	andeq	r0, r0, r0, lsr #1
     e38:	110c0e44 	tstne	ip, r4, asr #28
     e3c:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
     e40:	03041102 	movweq	r1, #16642	; 0x4102
     e44:	00180e48 	andseq	r0, r8, r8, asr #28
     e48:	00000024 	andeq	r0, r0, r4, lsr #32
     e4c:	00000234 	andeq	r0, r0, r4, lsr r2
     e50:	300052a4 	andcc	r5, r0, r4, lsr #5
     e54:	000001cc 	andeq	r0, r0, ip, asr #3
     e58:	11180e44 	tstne	r8, r4, asr #28
     e5c:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     e60:	03071102 	movweq	r1, #28930	; 0x7102
     e64:	11040611 	tstne	r4, r1, lsl r6
     e68:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     e6c:	00000006 	andeq	r0, r0, r6
     e70:	00000024 	andeq	r0, r0, r4, lsr #32
     e74:	00000234 	andeq	r0, r0, r4, lsr r2
     e78:	30005470 	andcc	r5, r0, r0, ror r4
     e7c:	00000160 	andeq	r0, r0, r0, ror #2
     e80:	11140e44 	tstne	r4, r4, asr #28
     e84:	0711010e 	ldreq	r0, [r1, -lr, lsl #2]
     e88:	03061102 	movweq	r1, #24834	; 0x6102
     e8c:	11040511 	tstne	r4, r1, lsl r5
     e90:	0e480504 	cdpeq	5, 4, cr0, cr8, cr4, {0}
     e94:	00000020 	andeq	r0, r0, r0, lsr #32
     e98:	00000024 	andeq	r0, r0, r4, lsr #32
     e9c:	00000234 	andeq	r0, r0, r4, lsr r2
     ea0:	300055d0 	ldrdcc	r5, [r0], -r0
     ea4:	0000019c 	muleq	r0, ip, r1
     ea8:	11180e44 	tstne	r8, r4, asr #28
     eac:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     eb0:	03071102 	movweq	r1, #28930	; 0x7102
     eb4:	11040611 	tstne	r4, r1, lsl r6
     eb8:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     ebc:	200e4c06 	andcs	r4, lr, r6, lsl #24
     ec0:	0000002c 	andeq	r0, r0, ip, lsr #32
     ec4:	00000234 	andeq	r0, r0, r4, lsr r2
     ec8:	3000576c 	andcc	r5, r0, ip, ror #14
     ecc:	000002ec 	andeq	r0, r0, ip, ror #5
     ed0:	44200e44 	strtmi	r0, [r0], #-3652	; 0xe44
     ed4:	0e11480e 	cdpeq	8, 1, cr4, cr1, cr14, {0}
     ed8:	020a1101 	andeq	r1, sl, #1073741824	; 0x40000000
     edc:	11030911 	tstne	r3, r1, lsl r9
     ee0:	07110408 	ldreq	r0, [r1, -r8, lsl #8]
     ee4:	06061105 	streq	r1, [r6], -r5, lsl #2
     ee8:	11070511 	tstne	r7, r1, lsl r5
     eec:	00000804 	andeq	r0, r0, r4, lsl #16
     ef0:	00000024 	andeq	r0, r0, r4, lsr #32
     ef4:	00000234 	andeq	r0, r0, r4, lsr r2
     ef8:	30005a58 	andcc	r5, r0, r8, asr sl
     efc:	0000015c 	andeq	r0, r0, ip, asr r1
     f00:	11180e44 	tstne	r8, r4, asr #28
     f04:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     f08:	03071102 	movweq	r1, #28930	; 0x7102
     f0c:	11040611 	tstne	r4, r1, lsl r6
     f10:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     f14:	200e4806 	andcs	r4, lr, r6, lsl #16
     f18:	00000018 	andeq	r0, r0, r8, lsl r0
     f1c:	00000234 	andeq	r0, r0, r4, lsr r2
     f20:	30005bb4 	undefined instruction 0x30005bb4
     f24:	00000074 	andeq	r0, r0, r4, ror r0
     f28:	11080e44 	tstne	r8, r4, asr #28
     f2c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     f30:	00000002 	andeq	r0, r0, r2
     f34:	00000024 	andeq	r0, r0, r4, lsr #32
     f38:	00000234 	andeq	r0, r0, r4, lsr r2
     f3c:	30005c28 	andcc	r5, r0, r8, lsr #24
     f40:	00000114 	andeq	r0, r0, r4, lsl r1
     f44:	11180e44 	tstne	r8, r4, asr #28
     f48:	0811010e 	ldmdaeq	r1, {r1, r2, r3, r8}
     f4c:	03071102 	movweq	r1, #28930	; 0x7102
     f50:	11040611 	tstne	r4, r1, lsl r6
     f54:	04110505 	ldreq	r0, [r1], #-1285	; 0x505
     f58:	00000006 	andeq	r0, r0, r6
     f5c:	00000018 	andeq	r0, r0, r8, lsl r0
     f60:	00000234 	andeq	r0, r0, r4, lsr r2
     f64:	30005d3c 	andcc	r5, r0, ip, lsr sp
     f68:	00000090 	muleq	r0, r0, r0
     f6c:	11080e44 	tstne	r8, r4, asr #28
     f70:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     f74:	00000002 	andeq	r0, r0, r2
     f78:	00000018 	andeq	r0, r0, r8, lsl r0
     f7c:	00000234 	andeq	r0, r0, r4, lsr r2
     f80:	30005dcc 	andcc	r5, r0, ip, asr #27
     f84:	00000100 	andeq	r0, r0, r0, lsl #2
     f88:	11080e44 	tstne	r8, r4, asr #28
     f8c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     f90:	00000002 	andeq	r0, r0, r2
     f94:	00000024 	andeq	r0, r0, r4, lsr #32
     f98:	00000234 	andeq	r0, r0, r4, lsr r2
     f9c:	30005ecc 	andcc	r5, r0, ip, asr #29
     fa0:	000002c0 	andeq	r0, r0, r0, asr #5
     fa4:	44180e44 	ldrmi	r0, [r8], #-3652	; 0xe44
     fa8:	0e11380e 	cdpeq	8, 1, cr3, cr1, cr14, {0}
     fac:	02081101 	andeq	r1, r8, #1073741824	; 0x40000000
     fb0:	11030711 	tstne	r3, r1, lsl r7
     fb4:	05110406 	ldreq	r0, [r1, #-1030]	; 0x406
     fb8:	06041105 	streq	r1, [r4], -r5, lsl #2
     fbc:	0000000c 	andeq	r0, r0, ip
     fc0:	ffffffff 	undefined instruction 0xffffffff
     fc4:	7c010001 	stcvc	0, cr0, [r1], {1}
     fc8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     fcc:	00000018 	andeq	r0, r0, r8, lsl r0
     fd0:	00000fbc 	undefined instruction 0x00000fbc
     fd4:	3000618c 	andcc	r6, r0, ip, lsl #3
     fd8:	0000007c 	andeq	r0, r0, ip, ror r0
     fdc:	11080e48 	tstne	r8, r8, asr #28
     fe0:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
     fe4:	00000002 	andeq	r0, r0, r2
     fe8:	00000018 	andeq	r0, r0, r8, lsl r0
     fec:	00000fbc 	undefined instruction 0x00000fbc
     ff0:	30006208 	andcc	r6, r0, r8, lsl #4
     ff4:	0000001c 	andeq	r0, r0, ip, lsl r0
     ff8:	11080e44 	tstne	r8, r4, asr #28
     ffc:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1000:	00000002 	andeq	r0, r0, r2
    1004:	00000018 	andeq	r0, r0, r8, lsl r0
    1008:	00000fbc 	undefined instruction 0x00000fbc
    100c:	30006224 	andcc	r6, r0, r4, lsr #4
    1010:	0000001c 	andeq	r0, r0, ip, lsl r0
    1014:	11080e44 	tstne	r8, r4, asr #28
    1018:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    101c:	00000002 	andeq	r0, r0, r2
    1020:	00000018 	andeq	r0, r0, r8, lsl r0
    1024:	00000fbc 	undefined instruction 0x00000fbc
    1028:	30006240 	andcc	r6, r0, r0, asr #4
    102c:	0000001c 	andeq	r0, r0, ip, lsl r0
    1030:	11080e44 	tstne	r8, r4, asr #28
    1034:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1038:	00000002 	andeq	r0, r0, r2
    103c:	0000000c 	andeq	r0, r0, ip
    1040:	ffffffff 	undefined instruction 0xffffffff
    1044:	7c010001 	stcvc	0, cr0, [r1], {1}
    1048:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    104c:	00000018 	andeq	r0, r0, r8, lsl r0
    1050:	0000103c 	andeq	r1, r0, ip, lsr r0
    1054:	3000625c 	andcc	r6, r0, ip, asr r2
    1058:	0000008c 	andeq	r0, r0, ip, lsl #1
    105c:	11080e48 	tstne	r8, r8, asr #28
    1060:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1064:	00000002 	andeq	r0, r0, r2
    1068:	00000018 	andeq	r0, r0, r8, lsl r0
    106c:	0000103c 	andeq	r1, r0, ip, lsr r0
    1070:	300062e8 	andcc	r6, r0, r8, ror #5
    1074:	0000002c 	andeq	r0, r0, ip, lsr #32
    1078:	11080e44 	tstne	r8, r4, asr #28
    107c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1080:	00000002 	andeq	r0, r0, r2
    1084:	0000001c 	andeq	r0, r0, ip, lsl r0
    1088:	0000103c 	andeq	r1, r0, ip, lsr r0
    108c:	30006314 	andcc	r6, r0, r4, lsl r3
    1090:	0000003c 	andeq	r0, r0, ip, lsr r0
    1094:	110c0e44 	tstne	ip, r4, asr #28
    1098:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
    109c:	03041102 	movweq	r1, #16642	; 0x4102
    10a0:	00180e48 	andseq	r0, r8, r8, asr #28
    10a4:	0000000c 	andeq	r0, r0, ip
    10a8:	ffffffff 	undefined instruction 0xffffffff
    10ac:	7c010001 	stcvc	0, cr0, [r1], {1}
    10b0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    10b4:	00000018 	andeq	r0, r0, r8, lsl r0
    10b8:	000010a4 	andeq	r1, r0, r4, lsr #1
    10bc:	30006350 	andcc	r6, r0, r0, asr r3
    10c0:	00000098 	muleq	r0, r8, r0
    10c4:	48040e44 	stmdami	r4, {r2, r6, r9, sl, fp}
    10c8:	0e11100e 	cdpeq	0, 1, cr1, cr1, cr14, {0}
    10cc:	00000001 	andeq	r0, r0, r1
    10d0:	00000018 	andeq	r0, r0, r8, lsl r0
    10d4:	000010a4 	andeq	r1, r0, r4, lsr #1
    10d8:	300063e8 	andcc	r6, r0, r8, ror #7
    10dc:	0000002c 	andeq	r0, r0, ip, lsr #32
    10e0:	11080e44 	tstne	r8, r4, asr #28
    10e4:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    10e8:	00000002 	andeq	r0, r0, r2
    10ec:	0000001c 	andeq	r0, r0, ip, lsl r0
    10f0:	000010a4 	andeq	r1, r0, r4, lsr #1
    10f4:	30006414 	andcc	r6, r0, r4, lsl r4
    10f8:	0000003c 	andeq	r0, r0, ip, lsr r0
    10fc:	110c0e44 	tstne	ip, r4, asr #28
    1100:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
    1104:	03041102 	movweq	r1, #16642	; 0x4102
    1108:	00180e48 	andseq	r0, r8, r8, asr #28
    110c:	0000000c 	andeq	r0, r0, ip
    1110:	ffffffff 	undefined instruction 0xffffffff
    1114:	7c010001 	stcvc	0, cr0, [r1], {1}
    1118:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    111c:	00000018 	andeq	r0, r0, r8, lsl r0
    1120:	0000110c 	andeq	r1, r0, ip, lsl #2
    1124:	30006450 	andcc	r6, r0, r0, asr r4
    1128:	0000008c 	andeq	r0, r0, ip, lsl #1
    112c:	11080e48 	tstne	r8, r8, asr #28
    1130:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1134:	00000002 	andeq	r0, r0, r2
    1138:	0000001c 	andeq	r0, r0, ip, lsl r0
    113c:	0000110c 	andeq	r1, r0, ip, lsl #2
    1140:	300064dc 	ldrdcc	r6, [r0], -ip
    1144:	0000004c 	andeq	r0, r0, ip, asr #32
    1148:	11100e44 	tstne	r0, r4, asr #28
    114c:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
    1150:	03051102 	movweq	r1, #20738	; 0x5102
    1154:	00040411 	andeq	r0, r4, r1, lsl r4
    1158:	0000001c 	andeq	r0, r0, ip, lsl r0
    115c:	0000110c 	andeq	r1, r0, ip, lsl #2
    1160:	30006528 	andcc	r6, r0, r8, lsr #10
    1164:	00000040 	andeq	r0, r0, r0, asr #32
    1168:	110c0e44 	tstne	ip, r4, asr #28
    116c:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
    1170:	03041102 	movweq	r1, #16642	; 0x4102
    1174:	00180e48 	andseq	r0, r8, r8, asr #28
    1178:	0000000c 	andeq	r0, r0, ip
    117c:	ffffffff 	undefined instruction 0xffffffff
    1180:	7c010001 	stcvc	0, cr0, [r1], {1}
    1184:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1188:	00000018 	andeq	r0, r0, r8, lsl r0
    118c:	00001178 	andeq	r1, r0, r8, ror r1
    1190:	30006568 	andcc	r6, r0, r8, ror #10
    1194:	00000030 	andeq	r0, r0, r0, lsr r0
    1198:	11080e48 	tstne	r8, r8, asr #28
    119c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    11a0:	00000002 	andeq	r0, r0, r2
    11a4:	00000018 	andeq	r0, r0, r8, lsl r0
    11a8:	00001178 	andeq	r1, r0, r8, ror r1
    11ac:	30006598 	mulcc	r0, r8, r5
    11b0:	000000a4 	andeq	r0, r0, r4, lsr #1
    11b4:	48040e44 	stmdami	r4, {r2, r6, r9, sl, fp}
    11b8:	0e11200e 	cdpeq	0, 1, cr2, cr1, cr14, {0}
    11bc:	00000001 	andeq	r0, r0, r1
    11c0:	00000018 	andeq	r0, r0, r8, lsl r0
    11c4:	00001178 	andeq	r1, r0, r8, ror r1
    11c8:	3000663c 	andcc	r6, r0, ip, lsr r6
    11cc:	00000040 	andeq	r0, r0, r0, asr #32
    11d0:	48040e44 	stmdami	r4, {r2, r6, r9, sl, fp}
    11d4:	0e11100e 	cdpeq	0, 1, cr1, cr1, cr14, {0}
    11d8:	00000001 	andeq	r0, r0, r1
    11dc:	0000000c 	andeq	r0, r0, ip
    11e0:	ffffffff 	undefined instruction 0xffffffff
    11e4:	7c010001 	stcvc	0, cr0, [r1], {1}
    11e8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    11ec:	00000018 	andeq	r0, r0, r8, lsl r0
    11f0:	000011dc 	ldrdeq	r1, [r0], -ip
    11f4:	3000667c 	andcc	r6, r0, ip, ror r6
    11f8:	00000090 	muleq	r0, r0, r0
    11fc:	11080e48 	tstne	r8, r8, asr #28
    1200:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1204:	00000002 	andeq	r0, r0, r2
    1208:	0000001c 	andeq	r0, r0, ip, lsl r0
    120c:	000011dc 	ldrdeq	r1, [r0], -ip
    1210:	3000670c 	andcc	r6, r0, ip, lsl #14
    1214:	00000040 	andeq	r0, r0, r0, asr #32
    1218:	110c0e44 	tstne	ip, r4, asr #28
    121c:	0511010e 	ldreq	r0, [r1, #-270]	; 0x10e
    1220:	03041102 	movweq	r1, #16642	; 0x4102
    1224:	00180e48 	andseq	r0, r8, r8, asr #28
    1228:	0000001c 	andeq	r0, r0, ip, lsl r0
    122c:	000011dc 	ldrdeq	r1, [r0], -ip
    1230:	3000674c 	andcc	r6, r0, ip, asr #14
    1234:	00000064 	andeq	r0, r0, r4, rrx
    1238:	11100e44 	tstne	r0, r4, asr #28
    123c:	0611010e 	ldreq	r0, [r1], -lr, lsl #2
    1240:	03051102 	movweq	r1, #20738	; 0x5102
    1244:	00040411 	andeq	r0, r4, r1, lsl r4
    1248:	0000000c 	andeq	r0, r0, ip
    124c:	ffffffff 	undefined instruction 0xffffffff
    1250:	7c010001 	stcvc	0, cr0, [r1], {1}
    1254:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1258:	00000018 	andeq	r0, r0, r8, lsl r0
    125c:	00001248 	andeq	r1, r0, r8, asr #4
    1260:	300067b0 	undefined instruction 0x300067b0
    1264:	00000084 	andeq	r0, r0, r4, lsl #1
    1268:	48080e44 	stmdami	r8, {r2, r6, r9, sl, fp}
    126c:	0e11100e 	cdpeq	0, 1, cr1, cr1, cr14, {0}
    1270:	02041101 	andeq	r1, r4, #1073741824	; 0x40000000
    1274:	00000020 	andeq	r0, r0, r0, lsr #32
    1278:	00001248 	andeq	r1, r0, r8, asr #4
    127c:	30006834 	andcc	r6, r0, r4, lsr r8
    1280:	00000060 	andeq	r0, r0, r0, rrx
    1284:	44100e44 	ldrmi	r0, [r0], #-3652	; 0xe44
    1288:	0e11180e 	cdpeq	8, 1, cr1, cr1, cr14, {0}
    128c:	02061101 	andeq	r1, r6, #1073741824	; 0x40000000
    1290:	11030511 	tstne	r3, r1, lsl r5
    1294:	00000404 	andeq	r0, r0, r4, lsl #8
    1298:	0000000c 	andeq	r0, r0, ip
    129c:	ffffffff 	undefined instruction 0xffffffff
    12a0:	7c010001 	stcvc	0, cr0, [r1], {1}
    12a4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    12a8:	0000002c 	andeq	r0, r0, ip, lsr #32
    12ac:	00001298 	muleq	r0, r8, r2
    12b0:	30006894 	mulcc	r0, r4, r8
    12b4:	000000c0 	andeq	r0, r0, r0, asr #1
    12b8:	11200e4c 	teqne	r0, ip, asr #28
    12bc:	0a11010b 	beq	4416f0 <DISABLE_IRQ+0x441670>
    12c0:	03091102 	movweq	r1, #37122	; 0x9102
    12c4:	11040811 	tstne	r4, r1, lsl r8
    12c8:	06110507 	ldreq	r0, [r1], -r7, lsl #10
    12cc:	07051106 	streq	r1, [r5, -r6, lsl #2]
    12d0:	60080411 	andvs	r0, r8, r1, lsl r4
    12d4:	0000380e 	andeq	r3, r0, lr, lsl #16
    12d8:	0000000c 	andeq	r0, r0, ip
    12dc:	00001298 	muleq	r0, r8, r2
    12e0:	30006954 	andcc	r6, r0, r4, asr r9
    12e4:	00000004 	andeq	r0, r0, r4
    12e8:	0000000c 	andeq	r0, r0, ip
    12ec:	00001298 	muleq	r0, r8, r2
    12f0:	30006958 	andcc	r6, r0, r8, asr r9
    12f4:	00000004 	andeq	r0, r0, r4
    12f8:	0000000c 	andeq	r0, r0, ip
    12fc:	00001298 	muleq	r0, r8, r2
    1300:	3000695c 	andcc	r6, r0, ip, asr r9
    1304:	00000004 	andeq	r0, r0, r4
    1308:	0000000c 	andeq	r0, r0, ip
    130c:	00001298 	muleq	r0, r8, r2
    1310:	30006960 	andcc	r6, r0, r0, ror #18
    1314:	00000004 	andeq	r0, r0, r4
    1318:	0000000c 	andeq	r0, r0, ip
    131c:	00001298 	muleq	r0, r8, r2
    1320:	30006964 	andcc	r6, r0, r4, ror #18
    1324:	00000004 	andeq	r0, r0, r4
    1328:	0000000c 	andeq	r0, r0, ip
    132c:	00001298 	muleq	r0, r8, r2
    1330:	30006968 	andcc	r6, r0, r8, ror #18
    1334:	00000004 	andeq	r0, r0, r4
    1338:	0000000c 	andeq	r0, r0, ip
    133c:	00001298 	muleq	r0, r8, r2
    1340:	3000696c 	andcc	r6, r0, ip, ror #18
    1344:	00000004 	andeq	r0, r0, r4
    1348:	0000000c 	andeq	r0, r0, ip
    134c:	00001298 	muleq	r0, r8, r2
    1350:	30006970 	andcc	r6, r0, r0, ror r9
    1354:	00000004 	andeq	r0, r0, r4
    1358:	00000018 	andeq	r0, r0, r8, lsl r0
    135c:	00001298 	muleq	r0, r8, r2
    1360:	30006974 	andcc	r6, r0, r4, ror r9
    1364:	00000018 	andeq	r0, r0, r8, lsl r0
    1368:	11080e44 	tstne	r8, r4, asr #28
    136c:	0411010e 	ldreq	r0, [r1], #-270	; 0x10e
    1370:	00000002 	andeq	r0, r0, r2
    1374:	0000000c 	andeq	r0, r0, ip
    1378:	ffffffff 	undefined instruction 0xffffffff
    137c:	7c010001 	stcvc	0, cr0, [r1], {1}
    1380:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1384:	00000018 	andeq	r0, r0, r8, lsl r0
    1388:	00001374 	andeq	r1, r0, r4, ror r3
    138c:	3000698c 	andcc	r6, r0, ip, lsl #19
    1390:	000000fc 	strdeq	r0, [r0], -ip
    1394:	028eec02 	addeq	lr, lr, #512	; 0x200
    1398:	ce4c080e 	cdpgt	8, 4, cr0, cr12, cr14, {0}
    139c:	0000000e 	andeq	r0, r0, lr

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	0000004c 	andeq	r0, r0, ip, asr #32
       4:	00000058 	andeq	r0, r0, r8, asr r0
       8:	585d0001 	ldmdapl	sp, {r0}^
       c:	bc000000 	stclt	0, cr0, [r0], {0}
      10:	02000000 	andeq	r0, r0, #0
      14:	00087d00 	andeq	r7, r8, r0, lsl #26
      18:	00000000 	andeq	r0, r0, r0
      1c:	bc000000 	stclt	0, cr0, [r0], {0}
      20:	c0000000 	andgt	r0, r0, r0
      24:	01000000 	tsteq	r0, r0
      28:	00c05d00 	sbceq	r5, r0, r0, lsl #26
      2c:	01280000 	teqeq	r8, r0
      30:	00020000 	andeq	r0, r2, r0
      34:	0000087d 	andeq	r0, r0, sp, ror r8
      38:	00000000 	andeq	r0, r0, r0
      3c:	002c0000 	eoreq	r0, ip, r0
      40:	00300000 	eorseq	r0, r0, r0
      44:	00010000 	andeq	r0, r1, r0
      48:	00000050 	andeq	r0, r0, r0, asr r0
      4c:	00000000 	andeq	r0, r0, r0
      50:	00003c00 	andeq	r3, r0, r0, lsl #24
      54:	00004000 	andeq	r4, r0, r0
      58:	50000100 	andpl	r0, r0, r0, lsl #2
	...
      64:	0000003c 	andeq	r0, r0, ip, lsr r0
      68:	00000044 	andeq	r0, r0, r4, asr #32
      6c:	00510001 	subseq	r0, r1, r1
      70:	00000000 	andeq	r0, r0, r0
      74:	68000000 	stmdavs	r0, {}
      78:	8c000000 	stchi	0, cr0, [r0], {0}
      7c:	01000000 	tsteq	r0, r0
      80:	00a05100 	adceq	r5, r0, r0, lsl #2
      84:	00bc0000 	adcseq	r0, ip, r0
      88:	00010000 	andeq	r0, r1, r0
      8c:	0000cc51 	andeq	ip, r0, r1, asr ip
      90:	0000ec00 	andeq	lr, r0, r0, lsl #24
      94:	51000100 	tstpl	r0, r0, lsl #2
	...
      a4:	00000020 	andeq	r0, r0, r0, lsr #32
      a8:	00500001 	subseq	r0, r0, r1
      ac:	00000000 	andeq	r0, r0, r0
      b0:	24000000 	strcs	r0, [r0]
      b4:	28000000 	stmdacs	r0, {}
      b8:	01000000 	tsteq	r0, r0
      bc:	00285d00 	eoreq	r5, r8, r0, lsl #26
      c0:	00380000 	eorseq	r0, r8, r0
      c4:	00020000 	andeq	r0, r2, r0
      c8:	0038247d 	eorseq	r2, r8, sp, ror r4
      cc:	01680000 	cmneq	r8, r0
      d0:	00030000 	andeq	r0, r3, r0
      d4:	0000f87d 	andeq	pc, r0, sp, ror r8
      d8:	00000000 	andeq	r0, r0, r0
      dc:	24000000 	strcs	r0, [r0]
      e0:	64000000 	strvs	r0, [r0]
      e4:	01000000 	tsteq	r0, r0
      e8:	00645000 	rsbeq	r5, r4, r0
      ec:	01680000 	cmneq	r8, r0
      f0:	00010000 	andeq	r0, r1, r0
      f4:	00000055 	andeq	r0, r0, r5, asr r0
      f8:	00000000 	andeq	r0, r0, r0
      fc:	00002400 	andeq	r2, r0, r0, lsl #8
     100:	00004c00 	andeq	r4, r0, r0, lsl #24
     104:	51000100 	tstpl	r0, r0, lsl #2
     108:	0000004c 	andeq	r0, r0, ip, asr #32
     10c:	00000068 	andeq	r0, r0, r8, rrx
     110:	74540001 	ldrbvc	r0, [r4], #-1
     114:	68000000 	stmdavs	r0, {}
     118:	01000001 	tsteq	r0, r1
     11c:	00005400 	andeq	r5, r0, r0, lsl #8
     120:	00000000 	andeq	r0, r0, r0
     124:	00240000 	eoreq	r0, r4, r0
     128:	00640000 	rsbeq	r0, r4, r0
     12c:	00010000 	andeq	r0, r1, r0
     130:	00006452 	andeq	r6, r0, r2, asr r4
     134:	00016800 	andeq	r6, r1, r0, lsl #16
     138:	5a000100 	bpl	540 <DISABLE_IRQ+0x4c0>
	...
     144:	00000024 	andeq	r0, r0, r4, lsr #32
     148:	00000030 	andeq	r0, r0, r0, lsr r0
     14c:	30530001 	subscc	r0, r3, r1
     150:	9c000000 	stcls	0, cr0, [r0], {0}
     154:	01000000 	tsteq	r0, r0
     158:	00005600 	andeq	r5, r0, r0, lsl #12
     15c:	00000000 	andeq	r0, r0, r0
     160:	00600000 	rsbeq	r0, r0, r0
     164:	01180000 	tsteq	r8, r0
     168:	00010000 	andeq	r0, r1, r0
     16c:	00011857 	andeq	r1, r1, r7, asr r8
     170:	00013800 	andeq	r3, r1, r0, lsl #16
     174:	53000100 	movwpl	r0, #256	; 0x100
     178:	00000138 	andeq	r0, r0, r8, lsr r1
     17c:	00000144 	andeq	r0, r0, r4, asr #2
     180:	44570001 	ldrbmi	r0, [r7], #-1
     184:	60000001 	andvs	r0, r0, r1
     188:	01000001 	tsteq	r0, r1
     18c:	01605300 	cmneq	r0, r0, lsl #6
     190:	01680000 	cmneq	r8, r0
     194:	00010000 	andeq	r0, r1, r0
     198:	00000057 	andeq	r0, r0, r7, asr r0
     19c:	00000000 	andeq	r0, r0, r0
     1a0:	00016800 	andeq	r6, r1, r0, lsl #16
     1a4:	00018c00 	andeq	r8, r1, r0, lsl #24
     1a8:	50000100 	andpl	r0, r0, r0, lsl #2
     1ac:	0000018c 	andeq	r0, r0, ip, lsl #3
     1b0:	000001ac 	andeq	r0, r0, ip, lsr #3
     1b4:	ac5c0001 	mrrcge	0, 0, r0, ip, cr1
     1b8:	b0000001 	andlt	r0, r0, r1
     1bc:	01000001 	tsteq	r0, r1
     1c0:	01b05000 	movseq	r5, r0
     1c4:	01b40000 	undefined instruction 0x01b40000
     1c8:	00010000 	andeq	r0, r1, r0
     1cc:	0001b45c 	andeq	fp, r1, ip, asr r4
     1d0:	00028800 	andeq	r8, r2, r0, lsl #16
     1d4:	50000100 	andpl	r0, r0, r0, lsl #2
     1d8:	00000288 	andeq	r0, r0, r8, lsl #5
     1dc:	0000028c 	andeq	r0, r0, ip, lsl #5
     1e0:	8c5c0001 	mrrchi	0, 0, r0, ip, cr1
     1e4:	a4000002 	strge	r0, [r0], #-2
     1e8:	01000002 	tsteq	r0, r2
     1ec:	02a45000 	adceq	r5, r4, #0
     1f0:	02a80000 	adceq	r0, r8, #0
     1f4:	00010000 	andeq	r0, r1, r0
     1f8:	0002a85c 	andeq	sl, r2, ip, asr r8
     1fc:	0002b800 	andeq	fp, r2, r0, lsl #16
     200:	50000100 	andpl	r0, r0, r0, lsl #2
     204:	000002b8 	undefined instruction 0x000002b8
     208:	000002bc 	undefined instruction 0x000002bc
     20c:	bc5c0001 	mrrclt	0, 0, r0, ip, cr1
     210:	d4000002 	strle	r0, [r0], #-2
     214:	01000002 	tsteq	r0, r2
     218:	02d45000 	sbcseq	r5, r4, #0
     21c:	02d80000 	sbcseq	r0, r8, #0
     220:	00010000 	andeq	r0, r1, r0
     224:	0002d85c 	andeq	sp, r2, ip, asr r8
     228:	0002f000 	andeq	pc, r2, r0
     22c:	50000100 	andpl	r0, r0, r0, lsl #2
     230:	000002f0 	strdeq	r0, [r0], -r0
     234:	000002f4 	strdeq	r0, [r0], -r4
     238:	f45c0001 	undefined instruction 0xf45c0001
     23c:	0c000002 	stceq	0, cr0, [r0], {2}
     240:	01000003 	tsteq	r0, r3
     244:	030c5000 	movweq	r5, #49152	; 0xc000
     248:	03100000 	tsteq	r0, #0
     24c:	00010000 	andeq	r0, r1, r0
     250:	0000005c 	andeq	r0, r0, ip, asr r0
     254:	00000000 	andeq	r0, r0, r0
     258:	00031000 	andeq	r1, r3, r0
     25c:	00031400 	andeq	r1, r3, r0, lsl #8
     260:	5d000100 	stfpls	f0, [r0]
     264:	00000314 	andeq	r0, r0, r4, lsl r3
     268:	00000318 	andeq	r0, r0, r8, lsl r3
     26c:	247d0002 	ldrbtcs	r0, [sp], #-2
     270:	00000318 	andeq	r0, r0, r8, lsl r3
     274:	000004b4 	undefined instruction 0x000004b4
     278:	307d0002 	rsbscc	r0, sp, r2
	...
     284:	00000310 	andeq	r0, r0, r0, lsl r3
     288:	00000350 	andeq	r0, r0, r0, asr r3
     28c:	50500001 	subspl	r0, r0, r1
     290:	b4000003 	strlt	r0, [r0], #-3
     294:	01000004 	tsteq	r0, r4
     298:	00005a00 	andeq	r5, r0, r0, lsl #20
     29c:	00000000 	andeq	r0, r0, r0
     2a0:	03100000 	tsteq	r0, #0
     2a4:	03400000 	movteq	r0, #0
     2a8:	00010000 	andeq	r0, r1, r0
     2ac:	00034051 	andeq	r4, r3, r1, asr r0
     2b0:	0004b400 	andeq	fp, r4, r0, lsl #8
     2b4:	5b000100 	blpl	6bc <DISABLE_IRQ+0x63c>
	...
     2c0:	00000310 	andeq	r0, r0, r0, lsl r3
     2c4:	00000350 	andeq	r0, r0, r0, asr r3
     2c8:	50520001 	subspl	r0, r2, r1
     2cc:	b4000003 	strlt	r0, [r0], #-3
     2d0:	01000004 	tsteq	r0, r4
     2d4:	00005400 	andeq	r5, r0, r0, lsl #8
     2d8:	00000000 	andeq	r0, r0, r0
     2dc:	03100000 	tsteq	r0, #0
     2e0:	03240000 	teqeq	r4, #0
     2e4:	00010000 	andeq	r0, r1, r0
     2e8:	00032453 	andeq	r2, r3, r3, asr r4
     2ec:	0004b400 	andeq	fp, r4, r0, lsl #8
     2f0:	58000100 	stmdapl	r0, {r8}
	...
     2fc:	00000428 	andeq	r0, r0, r8, lsr #8
     300:	00000434 	andeq	r0, r0, r4, lsr r4
     304:	a0510001 	subsge	r0, r1, r1
     308:	a4000004 	strge	r0, [r0], #-4
     30c:	01000004 	tsteq	r0, r4
     310:	04b05100 	ldrteq	r5, [r0], #256	; 0x100
     314:	04b40000 	ldrteq	r0, [r4]
     318:	00010000 	andeq	r0, r1, r0
     31c:	00000051 	andeq	r0, r0, r1, asr r0
     320:	00000000 	andeq	r0, r0, r0
     324:	00035000 	andeq	r5, r3, r0
     328:	00035c00 	andeq	r5, r3, r0, lsl #24
     32c:	52000100 	andpl	r0, r0, #0
     330:	000003a8 	andeq	r0, r0, r8, lsr #7
     334:	000003dc 	ldrdeq	r0, [r0], -ip
     338:	60520001 	subsvs	r0, r2, r1
     33c:	78000004 	stmdavc	r0, {r2}
     340:	01000004 	tsteq	r0, r4
     344:	04805200 	streq	r5, [r0], #512	; 0x200
     348:	04940000 	ldreq	r0, [r4]
     34c:	00010000 	andeq	r0, r1, r0
     350:	00000052 	andeq	r0, r0, r2, asr r0
     354:	00000000 	andeq	r0, r0, r0
     358:	00032c00 	andeq	r2, r3, r0, lsl #24
     35c:	00036c00 	andeq	r6, r3, r0, lsl #24
     360:	77000200 	strvc	r0, [r0, -r0, lsl #4]
     364:	00036c7c 	andeq	r6, r3, ip, ror ip
     368:	0003b800 	andeq	fp, r3, r0, lsl #16
     36c:	91000200 	tstls	r0, r0, lsl #4
     370:	0003b84c 	andeq	fp, r3, ip, asr #16
     374:	0003dc00 	andeq	sp, r3, r0, lsl #24
     378:	77000200 	strvc	r0, [r0, -r0, lsl #4]
     37c:	0003dc7c 	andeq	sp, r3, ip, ror ip
     380:	0004b400 	andeq	fp, r4, r0, lsl #8
     384:	91000200 	tstls	r0, r0, lsl #4
     388:	0000004c 	andeq	r0, r0, ip, asr #32
     38c:	00000000 	andeq	r0, r0, r0
     390:	00035000 	andeq	r5, r3, r0
     394:	00035800 	andeq	r5, r3, r0, lsl #16
     398:	51000100 	tstpl	r0, r0, lsl #2
     39c:	00000384 	andeq	r0, r0, r4, lsl #7
     3a0:	000003dc 	ldrdeq	r0, [r0], -ip
     3a4:	00510001 	subseq	r0, r1, r1
     3a8:	00000000 	andeq	r0, r0, r0
     3ac:	b4000000 	strlt	r0, [r0]
     3b0:	b8000004 	stmdalt	r0, {r2}
     3b4:	01000004 	tsteq	r0, r4
     3b8:	04b85d00 	ldrteq	r5, [r8], #3328	; 0xd00
     3bc:	05080000 	streq	r0, [r8]
     3c0:	00020000 	andeq	r0, r2, r0
     3c4:	0000107d 	andeq	r1, r0, sp, ror r0
     3c8:	00000000 	andeq	r0, r0, r0
     3cc:	04b40000 	ldrteq	r0, [r4]
     3d0:	04c40000 	strbeq	r0, [r4]
     3d4:	00010000 	andeq	r0, r1, r0
     3d8:	0004c450 	andeq	ip, r4, r0, asr r4
     3dc:	0004e000 	andeq	lr, r4, r0
     3e0:	54000100 	strpl	r0, [r0], #-256	; 0x100
     3e4:	000004e8 	andeq	r0, r0, r8, ror #9
     3e8:	000004f0 	strdeq	r0, [r0], -r0
     3ec:	fc540001 	mrrc2	0, 0, r0, r4, cr1
     3f0:	08000004 	stmdaeq	r0, {r2}
     3f4:	01000005 	tsteq	r0, r5
     3f8:	00005400 	andeq	r5, r0, r0, lsl #8
     3fc:	00000000 	andeq	r0, r0, r0
     400:	04b40000 	ldrteq	r0, [r4]
     404:	04c40000 	strbeq	r0, [r4]
     408:	00010000 	andeq	r0, r1, r0
     40c:	0004c451 	andeq	ip, r4, r1, asr r4
     410:	0004e400 	andeq	lr, r4, r0, lsl #8
     414:	55000100 	strpl	r0, [r0, #-256]	; 0x100
     418:	000004e8 	andeq	r0, r0, r8, ror #9
     41c:	00000508 	andeq	r0, r0, r8, lsl #10
     420:	00550001 	subseq	r0, r5, r1
     424:	00000000 	andeq	r0, r0, r0
     428:	08000000 	stmdaeq	r0, {}
     42c:	0c000005 	stceq	0, cr0, [r0], {5}
     430:	01000005 	tsteq	r0, r5
     434:	050c5d00 	streq	r5, [ip, #-3328]	; 0xd00
     438:	05100000 	ldreq	r0, [r0]
     43c:	00020000 	andeq	r0, r2, r0
     440:	0510107d 	ldreq	r1, [r0, #-125]	; 0x7d
     444:	05140000 	ldreq	r0, [r4]
     448:	00020000 	andeq	r0, r2, r0
     44c:	0514187d 	ldreq	r1, [r4, #-2173]	; 0x87d
     450:	05480000 	strbeq	r0, [r8]
     454:	00030000 	andeq	r0, r3, r0
     458:	0002987d 	andeq	r9, r2, sp, ror r8
     45c:	00000000 	andeq	r0, r0, r0
     460:	48000000 	stmdami	r0, {}
     464:	4c000005 	stcmi	0, cr0, [r0], {5}
     468:	01000005 	tsteq	r0, r5
     46c:	054c5d00 	strbeq	r5, [ip, #-3328]	; 0xd00
     470:	05540000 	ldrbeq	r0, [r4]
     474:	00020000 	andeq	r0, r2, r0
     478:	0554047d 	ldrbeq	r0, [r4, #-1149]	; 0x47d
     47c:	05980000 	ldreq	r0, [r8]
     480:	00020000 	andeq	r0, r2, r0
     484:	0000187d 	andeq	r1, r0, sp, ror r8
	...
     490:	00040000 	andeq	r0, r4, r0
     494:	00010000 	andeq	r0, r1, r0
     498:	0000045d 	andeq	r0, r0, sp, asr r4
     49c:	00001800 	andeq	r1, r0, r0, lsl #16
     4a0:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     4a4:	00000004 	andeq	r0, r0, r4
     4a8:	00000000 	andeq	r0, r0, r0
     4ac:	00001800 	andeq	r1, r0, r0, lsl #16
     4b0:	00001c00 	andeq	r1, r0, r0, lsl #24
     4b4:	5d000100 	stfpls	f0, [r0]
     4b8:	0000001c 	andeq	r0, r0, ip, lsl r0
     4bc:	00000030 	andeq	r0, r0, r0, lsr r0
     4c0:	047d0002 	ldrbteq	r0, [sp], #-2
	...
     4cc:	00000048 	andeq	r0, r0, r8, asr #32
     4d0:	00000060 	andeq	r0, r0, r0, rrx
     4d4:	605d0001 	subsvs	r0, sp, r1
     4d8:	84000000 	strhi	r0, [r0]
     4dc:	02000000 	andeq	r0, r0, #0
     4e0:	00087d00 	andeq	r7, r8, r0, lsl #26
     4e4:	00000000 	andeq	r0, r0, r0
     4e8:	58000000 	stmdapl	r0, {}
     4ec:	70000000 	andvc	r0, r0, r0
     4f0:	01000000 	tsteq	r0, r0
     4f4:	00005200 	andeq	r5, r0, r0, lsl #4
     4f8:	00000000 	andeq	r0, r0, r0
     4fc:	00400000 	subeq	r0, r0, r0
     500:	00440000 	subeq	r0, r4, r0
     504:	00010000 	andeq	r0, r1, r0
     508:	0000445d 	andeq	r4, r0, sp, asr r4
     50c:	00010000 	andeq	r0, r1, r0
     510:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     514:	00000018 	andeq	r0, r0, r8, lsl r0
     518:	00000000 	andeq	r0, r0, r0
     51c:	00004000 	andeq	r4, r0, r0
     520:	00005800 	andeq	r5, r0, r0, lsl #16
     524:	50000100 	andpl	r0, r0, r0, lsl #2
     528:	00000058 	andeq	r0, r0, r8, asr r0
     52c:	00000090 	muleq	r0, r0, r0
     530:	005c0001 	subseq	r0, ip, r1
     534:	00000000 	andeq	r0, r0, r0
     538:	40000000 	andmi	r0, r0, r0
     53c:	d0000000 	andle	r0, r0, r0
     540:	01000000 	tsteq	r0, r0
     544:	00e85100 	rsceq	r5, r8, r0, lsl #2
     548:	01000000 	tsteq	r0, r0
     54c:	00010000 	andeq	r0, r1, r0
     550:	00000051 	andeq	r0, r0, r1, asr r0
     554:	00000000 	andeq	r0, r0, r0
     558:	00004000 	andeq	r4, r0, r0
     55c:	0000ac00 	andeq	sl, r0, r0, lsl #24
     560:	52000100 	andpl	r0, r0, #0
	...
     56c:	0000009c 	muleq	r0, ip, r0
     570:	000000d8 	ldrdeq	r0, [r0], -r8
     574:	e85c0001 	ldmda	ip, {r0}^
     578:	00000000 	andeq	r0, r0, r0
     57c:	01000001 	tsteq	r0, r1
     580:	00005c00 	andeq	r5, r0, r0, lsl #24
     584:	00000000 	andeq	r0, r0, r0
     588:	006c0000 	rsbeq	r0, ip, r0
     58c:	008c0000 	addeq	r0, ip, r0
     590:	00010000 	andeq	r0, r1, r0
     594:	00000054 	andeq	r0, r0, r4, asr r0
     598:	00000000 	andeq	r0, r0, r0
     59c:	00009800 	andeq	r9, r0, r0, lsl #16
     5a0:	0000e800 	andeq	lr, r0, r0, lsl #16
     5a4:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     5b0:	00000078 	andeq	r0, r0, r8, ror r0
     5b4:	000000e0 	andeq	r0, r0, r0, ror #1
     5b8:	e85a0001 	ldmda	sl, {r0}^
     5bc:	00000000 	andeq	r0, r0, r0
     5c0:	01000001 	tsteq	r0, r1
     5c4:	00005a00 	andeq	r5, r0, r0, lsl #20
     5c8:	00000000 	andeq	r0, r0, r0
     5cc:	00700000 	rsbseq	r0, r0, r0
     5d0:	00dc0000 	sbcseq	r0, ip, r0
     5d4:	00010000 	andeq	r0, r1, r0
     5d8:	0000e858 	andeq	lr, r0, r8, asr r8
     5dc:	00010000 	andeq	r0, r1, r0
     5e0:	58000100 	stmdapl	r0, {r8}
	...
     5ec:	00000100 	andeq	r0, r0, r0, lsl #2
     5f0:	00000104 	andeq	r0, r0, r4, lsl #2
     5f4:	045d0001 	ldrbeq	r0, [sp], #-1
     5f8:	80000001 	andhi	r0, r0, r1
     5fc:	02000001 	andeq	r0, r0, #1
     600:	00047d00 	andeq	r7, r4, r0, lsl #26
     604:	00000000 	andeq	r0, r0, r0
     608:	d0000000 	andle	r0, r0, r0
     60c:	e0000001 	and	r0, r0, r1
     610:	01000001 	tsteq	r0, r1
     614:	00005000 	andeq	r5, r0, r0
     618:	00000000 	andeq	r0, r0, r0
     61c:	01f40000 	mvnseq	r0, r0
     620:	02000000 	andeq	r0, r0, #0
     624:	00010000 	andeq	r0, r1, r0
     628:	00000051 	andeq	r0, r0, r1, asr r0
     62c:	00000000 	andeq	r0, r0, r0
     630:	00022800 	andeq	r2, r2, r0, lsl #16
     634:	00024800 	andeq	r4, r2, r0, lsl #16
     638:	52000100 	andpl	r0, r0, #0
	...
     644:	0000025c 	andeq	r0, r0, ip, asr r2
     648:	0000026c 	andeq	r0, r0, ip, ror #4
     64c:	6c500001 	mrrcvs	0, 0, r0, r0, cr1
     650:	98000002 	stmdals	r0, {r1}
     654:	01000002 	tsteq	r0, r2
     658:	00005200 	andeq	r5, r0, r0, lsl #4
     65c:	00000000 	andeq	r0, r0, r0
     660:	025c0000 	subseq	r0, ip, #0
     664:	027c0000 	rsbseq	r0, ip, #0
     668:	00010000 	andeq	r0, r1, r0
     66c:	00028c51 	andeq	r8, r2, r1, asr ip
     670:	00029800 	andeq	r9, r2, r0, lsl #16
     674:	51000100 	tstpl	r0, r0, lsl #2
	...
     680:	0000026c 	andeq	r0, r0, ip, ror #4
     684:	00000280 	andeq	r0, r0, r0, lsl #5
     688:	88500001 	ldmdahi	r0, {r0}^
     68c:	94000002 	strls	r0, [r0], #-2
     690:	01000002 	tsteq	r0, r2
     694:	00005000 	andeq	r5, r0, r0
     698:	00000000 	andeq	r0, r0, r0
     69c:	02980000 	addseq	r0, r8, #0
     6a0:	02a40000 	adceq	r0, r4, #0
     6a4:	00010000 	andeq	r0, r1, r0
     6a8:	0002ac50 	andeq	sl, r2, r0, asr ip
     6ac:	0002b000 	andeq	fp, r2, r0
     6b0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     6bc:	000002a4 	andeq	r0, r0, r4, lsr #5
     6c0:	000002b8 	undefined instruction 0x000002b8
     6c4:	c0500001 	subsgt	r0, r0, r1
     6c8:	c4000002 	strgt	r0, [r0], #-2
     6cc:	01000002 	tsteq	r0, r2
     6d0:	00005000 	andeq	r5, r0, r0
     6d4:	00000000 	andeq	r0, r0, r0
     6d8:	02c80000 	sbceq	r0, r8, #0
     6dc:	02cc0000 	sbceq	r0, ip, #0
     6e0:	00010000 	andeq	r0, r1, r0
     6e4:	0002cc5d 	andeq	ip, r2, sp, asr ip
     6e8:	00036400 	andeq	r6, r3, r0, lsl #8
     6ec:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     6f0:	0000000c 	andeq	r0, r0, ip
     6f4:	00000000 	andeq	r0, r0, r0
     6f8:	0002c800 	andeq	ip, r2, r0, lsl #16
     6fc:	00032c00 	andeq	r2, r3, r0, lsl #24
     700:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     70c:	000002c8 	andeq	r0, r0, r8, asr #5
     710:	00000330 	andeq	r0, r0, r0, lsr r3
     714:	00510001 	subseq	r0, r1, r1
     718:	00000000 	andeq	r0, r0, r0
     71c:	c8000000 	stmdagt	r0, {}
     720:	28000002 	stmdacs	r0, {r1}
     724:	01000003 	tsteq	r0, r3
     728:	00005200 	andeq	r5, r0, r0, lsl #4
     72c:	00000000 	andeq	r0, r0, r0
     730:	02c80000 	sbceq	r0, r8, #0
     734:	03040000 	movweq	r0, #16384	; 0x4000
     738:	00010000 	andeq	r0, r1, r0
     73c:	00000053 	andeq	r0, r0, r3, asr r0
     740:	00000000 	andeq	r0, r0, r0
     744:	0002c800 	andeq	ip, r2, r0, lsl #16
     748:	0002d400 	andeq	sp, r2, r0, lsl #8
     74c:	91000200 	tstls	r0, r0, lsl #4
     750:	0002d400 	andeq	sp, r2, r0, lsl #8
     754:	00036400 	andeq	r6, r3, r0, lsl #8
     758:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
     764:	00000310 	andeq	r0, r0, r0, lsl r3
     768:	00000324 	andeq	r0, r0, r4, lsr #6
     76c:	00530001 	subseq	r0, r3, r1
     770:	00000000 	andeq	r0, r0, r0
     774:	64000000 	strvs	r0, [r0]
     778:	68000003 	stmdavs	r0, {r0, r1}
     77c:	01000003 	tsteq	r0, r3
     780:	03685d00 	cmneq	r8, #0
     784:	03e40000 	mvneq	r0, #0
     788:	00020000 	andeq	r0, r2, r0
     78c:	0000047d 	andeq	r0, r0, sp, ror r4
     790:	00000000 	andeq	r0, r0, r0
     794:	03900000 	orrseq	r0, r0, #0
     798:	03b80000 	undefined instruction 0x03b80000
     79c:	00010000 	andeq	r0, r1, r0
     7a0:	00000053 	andeq	r0, r0, r3, asr r0
     7a4:	00000000 	andeq	r0, r0, r0
     7a8:	0003e400 	andeq	lr, r3, r0, lsl #8
     7ac:	0003e800 	andeq	lr, r3, r0, lsl #16
     7b0:	5d000100 	stfpls	f0, [r0]
     7b4:	000003e8 	andeq	r0, r0, r8, ror #7
     7b8:	00000498 	muleq	r0, r8, r4
     7bc:	047d0002 	ldrbteq	r0, [sp], #-2
	...
     7c8:	000003e4 	andeq	r0, r0, r4, ror #7
     7cc:	000003f8 	strdeq	r0, [r0], -r8
     7d0:	f8500001 	undefined instruction 0xf8500001
     7d4:	70000003 	andvc	r0, r0, r3
     7d8:	01000004 	tsteq	r0, r4
     7dc:	047c5200 	ldrbteq	r5, [ip], #-512	; 0x200
     7e0:	04980000 	ldreq	r0, [r8]
     7e4:	00010000 	andeq	r0, r1, r0
     7e8:	00000052 	andeq	r0, r0, r2, asr r0
     7ec:	00000000 	andeq	r0, r0, r0
     7f0:	0003e400 	andeq	lr, r3, r0, lsl #8
     7f4:	00041c00 	andeq	r1, r4, r0, lsl #24
     7f8:	51000100 	tstpl	r0, r0, lsl #2
     7fc:	00000448 	andeq	r0, r0, r8, asr #8
     800:	0000044c 	andeq	r0, r0, ip, asr #8
     804:	00510001 	subseq	r0, r1, r1
     808:	00000000 	andeq	r0, r0, r0
     80c:	ec000000 	stc	0, cr0, [r0], {0}
     810:	38000003 	stmdacc	r0, {r0, r1}
     814:	01000004 	tsteq	r0, r4
     818:	04485300 	strbeq	r5, [r8], #-768	; 0x300
     81c:	04500000 	ldrbeq	r0, [r0]
     820:	00010000 	andeq	r0, r1, r0
     824:	00000053 	andeq	r0, r0, r3, asr r0
     828:	00000000 	andeq	r0, r0, r0
     82c:	00041400 	andeq	r1, r4, r0, lsl #8
     830:	00042000 	andeq	r2, r4, r0
     834:	50000100 	andpl	r0, r0, r0, lsl #2
     838:	00000440 	andeq	r0, r0, r0, asr #8
     83c:	00000474 	andeq	r0, r0, r4, ror r4
     840:	7c500001 	mrrcvc	0, 0, r0, r0, cr1
     844:	98000004 	stmdals	r0, {r2}
     848:	01000004 	tsteq	r0, r4
     84c:	00005000 	andeq	r5, r0, r0
     850:	00000000 	andeq	r0, r0, r0
     854:	04500000 	ldrbeq	r0, [r0]
     858:	046c0000 	strbteq	r0, [ip]
     85c:	00010000 	andeq	r0, r1, r0
     860:	00047c53 	andeq	r7, r4, r3, asr ip
     864:	00049800 	andeq	r9, r4, r0, lsl #16
     868:	53000100 	movwpl	r0, #256	; 0x100
	...
     874:	0000049c 	muleq	r0, ip, r4
     878:	000004c0 	andeq	r0, r0, r0, asr #9
     87c:	c8520001 	ldmdagt	r2, {r0}^
     880:	dc000004 	stcle	0, cr0, [r0], {4}
     884:	01000004 	tsteq	r0, r4
     888:	00005200 	andeq	r5, r0, r0, lsl #4
     88c:	00000000 	andeq	r0, r0, r0
     890:	04a00000 	strteq	r0, [r0]
     894:	04bc0000 	ldrteq	r0, [ip]
     898:	00010000 	andeq	r0, r1, r0
     89c:	0004c853 	andeq	ip, r4, r3, asr r8
     8a0:	0004dc00 	andeq	sp, r4, r0, lsl #24
     8a4:	53000100 	movwpl	r0, #256	; 0x100
	...
     8b0:	000004dc 	ldrdeq	r0, [r0], -ip
     8b4:	000004e0 	andeq	r0, r0, r0, ror #9
     8b8:	e05d0001 	subs	r0, sp, r1
     8bc:	54000004 	strpl	r0, [r0], #-4
     8c0:	02000005 	andeq	r0, r0, #5
     8c4:	00047d00 	andeq	r7, r4, r0, lsl #26
     8c8:	00000000 	andeq	r0, r0, r0
     8cc:	a8000000 	stmdage	r0, {}
     8d0:	c8000005 	stmdagt	r0, {r0, r2}
     8d4:	01000005 	tsteq	r0, r5
     8d8:	00005200 	andeq	r5, r0, r0, lsl #4
     8dc:	00000000 	andeq	r0, r0, r0
     8e0:	05dc0000 	ldrbeq	r0, [ip]
     8e4:	05e80000 	strbeq	r0, [r8]!
     8e8:	00010000 	andeq	r0, r1, r0
     8ec:	0005e85d 	andeq	lr, r5, sp, asr r8
     8f0:	00067800 	andeq	r7, r6, r0, lsl #16
     8f4:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     8f8:	00000004 	andeq	r0, r0, r4
     8fc:	00000000 	andeq	r0, r0, r0
     900:	0005dc00 	andeq	sp, r5, r0, lsl #24
     904:	00061c00 	andeq	r1, r6, r0, lsl #24
     908:	51000100 	tstpl	r0, r0, lsl #2
     90c:	0000065c 	andeq	r0, r0, ip, asr r6
     910:	00000678 	andeq	r0, r0, r8, ror r6
     914:	00510001 	subseq	r0, r1, r1
     918:	00000000 	andeq	r0, r0, r0
     91c:	20000000 	andcs	r0, r0, r0
     920:	5c000006 	stcpl	0, cr0, [r0], {6}
     924:	01000006 	tsteq	r0, r6
     928:	00005c00 	andeq	r5, r0, r0, lsl #24
     92c:	00000000 	andeq	r0, r0, r0
     930:	069c0000 	ldreq	r0, [ip], r0
     934:	06b40000 	ldrteq	r0, [r4], r0
     938:	00010000 	andeq	r0, r1, r0
     93c:	0006b452 	andeq	fp, r6, r2, asr r4
     940:	0006cc00 	andeq	ip, r6, r0, lsl #24
     944:	5c000100 	stfpls	f0, [r0], {0}
     948:	000006d0 	ldrdeq	r0, [r0], -r0
     94c:	000006e8 	andeq	r0, r0, r8, ror #13
     950:	005c0001 	subseq	r0, ip, r1
     954:	00000000 	andeq	r0, r0, r0
     958:	98000000 	stmdals	r0, {}
     95c:	ac000006 	stcge	0, cr0, [r0], {6}
     960:	01000006 	tsteq	r0, r6
     964:	00005300 	andeq	r5, r0, r0, lsl #6
     968:	00000000 	andeq	r0, r0, r0
     96c:	06ec0000 	strbteq	r0, [ip], r0
     970:	06f00000 	ldrbteq	r0, [r0], r0
     974:	00010000 	andeq	r0, r1, r0
     978:	0006f05d 	andeq	pc, r6, sp, asr r0
     97c:	00071000 	andeq	r1, r7, r0
     980:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     984:	00000008 	andeq	r0, r0, r8
     988:	00000000 	andeq	r0, r0, r0
     98c:	0006ec00 	andeq	lr, r6, r0, lsl #24
     990:	0006f800 	andeq	pc, r6, r0, lsl #16
     994:	50000100 	andpl	r0, r0, r0, lsl #2
     998:	000006f8 	strdeq	r0, [r0], -r8
     99c:	00000710 	andeq	r0, r0, r0, lsl r7
     9a0:	00540001 	subseq	r0, r4, r1
     9a4:	00000000 	andeq	r0, r0, r0
     9a8:	10000000 	andne	r0, r0, r0
     9ac:	14000007 	strne	r0, [r0], #-7
     9b0:	01000007 	tsteq	r0, r7
     9b4:	07145d00 	ldreq	r5, [r4, -r0, lsl #26]
     9b8:	07340000 	ldreq	r0, [r4, -r0]!
     9bc:	00020000 	andeq	r0, r2, r0
     9c0:	0000087d 	andeq	r0, r0, sp, ror r8
     9c4:	00000000 	andeq	r0, r0, r0
     9c8:	07340000 	ldreq	r0, [r4, -r0]!
     9cc:	073c0000 	ldreq	r0, [ip, -r0]!
     9d0:	00010000 	andeq	r0, r1, r0
     9d4:	00073c5d 	andeq	r3, r7, sp, asr ip
     9d8:	0007d800 	andeq	sp, r7, r0, lsl #16
     9dc:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     9e0:	00000010 	andeq	r0, r0, r0, lsl r0
     9e4:	00000000 	andeq	r0, r0, r0
     9e8:	00073400 	andeq	r3, r7, r0, lsl #8
     9ec:	00074800 	andeq	r4, r7, r0, lsl #16
     9f0:	50000100 	andpl	r0, r0, r0, lsl #2
     9f4:	00000748 	andeq	r0, r0, r8, asr #14
     9f8:	000007d8 	ldrdeq	r0, [r0], -r8
     9fc:	00540001 	subseq	r0, r4, r1
     a00:	00000000 	andeq	r0, r0, r0
     a04:	34000000 	strcc	r0, [r0]
     a08:	48000007 	stmdami	r0, {r0, r1, r2}
     a0c:	01000007 	tsteq	r0, r7
     a10:	07485100 	strbeq	r5, [r8, -r0, lsl #2]
     a14:	07d80000 	ldrbeq	r0, [r8, r0]
     a18:	00010000 	andeq	r0, r1, r0
     a1c:	00000055 	andeq	r0, r0, r5, asr r0
     a20:	00000000 	andeq	r0, r0, r0
     a24:	00078400 	andeq	r8, r7, r0, lsl #8
     a28:	0007b000 	andeq	fp, r7, r0
     a2c:	51000100 	tstpl	r0, r0, lsl #2
     a30:	000007b8 	undefined instruction 0x000007b8
     a34:	000007bc 	undefined instruction 0x000007bc
     a38:	c4510001 	ldrbgt	r0, [r1], #-1
     a3c:	c8000007 	stmdagt	r0, {r0, r1, r2}
     a40:	01000007 	tsteq	r0, r7
     a44:	00005100 	andeq	r5, r0, r0, lsl #2
     a48:	00000000 	andeq	r0, r0, r0
     a4c:	07d80000 	ldrbeq	r0, [r8, r0]
     a50:	07e00000 	strbeq	r0, [r0, r0]!
     a54:	00010000 	andeq	r0, r1, r0
     a58:	0007e05d 	andeq	lr, r7, sp, asr r0
     a5c:	0008b800 	andeq	fp, r8, r0, lsl #16
     a60:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     a64:	00000010 	andeq	r0, r0, r0, lsl r0
     a68:	00000000 	andeq	r0, r0, r0
     a6c:	0007d800 	andeq	sp, r7, r0, lsl #16
     a70:	0007ec00 	andeq	lr, r7, r0, lsl #24
     a74:	50000100 	andpl	r0, r0, r0, lsl #2
     a78:	000007ec 	andeq	r0, r0, ip, ror #15
     a7c:	0000086c 	andeq	r0, r0, ip, ror #16
     a80:	00540001 	subseq	r0, r4, r1
     a84:	00000000 	andeq	r0, r0, r0
     a88:	d8000000 	stmdale	r0, {}
     a8c:	ec000007 	stc	0, cr0, [r0], {7}
     a90:	01000007 	tsteq	r0, r7
     a94:	07ec5100 	strbeq	r5, [ip, r0, lsl #2]!
     a98:	08b80000 	ldmeq	r8!, {}
     a9c:	00010000 	andeq	r0, r1, r0
     aa0:	00000055 	andeq	r0, r0, r5, asr r0
     aa4:	00000000 	andeq	r0, r0, r0
     aa8:	00083400 	andeq	r3, r8, r0, lsl #8
     aac:	00085400 	andeq	r5, r8, r0, lsl #8
     ab0:	53000100 	movwpl	r0, #256	; 0x100
     ab4:	0000085c 	andeq	r0, r0, ip, asr r8
     ab8:	00000860 	andeq	r0, r0, r0, ror #16
     abc:	68530001 	ldmdavs	r3, {r0}^
     ac0:	74000008 	strvc	r0, [r0], #-8
     ac4:	01000008 	tsteq	r0, r8
     ac8:	00005300 	andeq	r5, r0, r0, lsl #6
     acc:	00000000 	andeq	r0, r0, r0
     ad0:	07f80000 	ldrbeq	r0, [r8, r0]!
     ad4:	08000000 	stmdaeq	r0, {}
     ad8:	00010000 	andeq	r0, r1, r0
     adc:	00086c54 	andeq	r6, r8, r4, asr ip
     ae0:	0008b800 	andeq	fp, r8, r0, lsl #16
     ae4:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
     af0:	00000884 	andeq	r0, r0, r4, lsl #17
     af4:	000008a0 	andeq	r0, r0, r0, lsr #17
     af8:	00530001 	subseq	r0, r3, r1
     afc:	00000000 	andeq	r0, r0, r0
     b00:	f8000000 	undefined instruction 0xf8000000
     b04:	00000007 	andeq	r0, r0, r7
     b08:	01000008 	tsteq	r0, r8
     b0c:	08705600 	ldmdaeq	r0!, {r9, sl, ip, lr}^
     b10:	08b80000 	ldmeq	r8!, {}
     b14:	00010000 	andeq	r0, r1, r0
     b18:	00000056 	andeq	r0, r0, r6, asr r0
     b1c:	00000000 	andeq	r0, r0, r0
     b20:	0008b800 	andeq	fp, r8, r0, lsl #16
     b24:	0008bc00 	andeq	fp, r8, r0, lsl #24
     b28:	5d000100 	stfpls	f0, [r0]
     b2c:	000008bc 	undefined instruction 0x000008bc
     b30:	000008c4 	andeq	r0, r0, r4, asr #17
     b34:	147d0002 	ldrbtne	r0, [sp], #-2
     b38:	000008c4 	andeq	r0, r0, r4, asr #17
     b3c:	00000934 	andeq	r0, r0, r4, lsr r9
     b40:	207d0002 	rsbscs	r0, sp, r2
	...
     b4c:	000008d0 	ldrdeq	r0, [r0], -r0
     b50:	000008dc 	ldrdeq	r0, [r0], -ip
     b54:	f0530001 	undefined instruction 0xf0530001
     b58:	34000008 	strcc	r0, [r0], #-8
     b5c:	01000009 	tsteq	r0, r9
     b60:	00005300 	andeq	r5, r0, r0, lsl #6
     b64:	00000000 	andeq	r0, r0, r0
     b68:	08cc0000 	stmiaeq	ip, {}^
     b6c:	08e00000 	stmiaeq	r0!, {}^
     b70:	00010000 	andeq	r0, r1, r0
     b74:	0008e854 	andeq	lr, r8, r4, asr r8
     b78:	00093400 	andeq	r3, r9, r0, lsl #8
     b7c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
     b88:	00000934 	andeq	r0, r0, r4, lsr r9
     b8c:	00000938 	andeq	r0, r0, r8, lsr r9
     b90:	385d0001 	ldmdacc	sp, {r0}^
     b94:	2c000009 	stccs	0, cr0, [r0], {9}
     b98:	0200000a 	andeq	r0, r0, #10
     b9c:	00107d00 	andseq	r7, r0, r0, lsl #26
     ba0:	00000000 	andeq	r0, r0, r0
     ba4:	34000000 	strcc	r0, [r0]
     ba8:	48000009 	stmdami	r0, {r0, r3}
     bac:	01000009 	tsteq	r0, r9
     bb0:	09485000 	stmdbeq	r8, {ip, lr}^
     bb4:	09500000 	ldmdbeq	r0, {}^
     bb8:	00010000 	andeq	r0, r1, r0
     bbc:	00095054 	andeq	r5, r9, r4, asr r0
     bc0:	00096000 	andeq	r6, r9, r0
     bc4:	50000100 	andpl	r0, r0, r0, lsl #2
     bc8:	00000960 	andeq	r0, r0, r0, ror #18
     bcc:	00000968 	andeq	r0, r0, r8, ror #18
     bd0:	68540001 	ldmdavs	r4, {r0}^
     bd4:	7c000009 	stcvc	0, cr0, [r0], {9}
     bd8:	01000009 	tsteq	r0, r9
     bdc:	097c5000 	ldmdbeq	ip!, {ip, lr}^
     be0:	09ec0000 	stmibeq	ip!, {}^
     be4:	00010000 	andeq	r0, r1, r0
     be8:	0009fc54 	andeq	pc, r9, r4, asr ip
     bec:	000a2c00 	andeq	r2, sl, r0, lsl #24
     bf0:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
     bfc:	00000934 	andeq	r0, r0, r4, lsr r9
     c00:	00000948 	andeq	r0, r0, r8, asr #18
     c04:	48510001 	ldmdami	r1, {r0}^
     c08:	b0000009 	andlt	r0, r0, r9
     c0c:	01000009 	tsteq	r0, r9
     c10:	0a0c5600 	beq	316418 <DISABLE_IRQ+0x316398>
     c14:	0a1c0000 	beq	700c1c <DISABLE_IRQ+0x700b9c>
     c18:	00010000 	andeq	r0, r1, r0
     c1c:	00000056 	andeq	r0, r0, r6, asr r0
     c20:	00000000 	andeq	r0, r0, r0
     c24:	00093400 	andeq	r3, r9, r0, lsl #8
     c28:	00094800 	andeq	r4, r9, r0, lsl #16
     c2c:	52000100 	andpl	r0, r0, #0
     c30:	00000948 	andeq	r0, r0, r8, asr #18
     c34:	00000a2c 	andeq	r0, r0, ip, lsr #20
     c38:	00550001 	subseq	r0, r5, r1
     c3c:	00000000 	andeq	r0, r0, r0
     c40:	b4000000 	strlt	r0, [r0]
     c44:	c0000009 	andgt	r0, r0, r9
     c48:	01000009 	tsteq	r0, r9
     c4c:	09c85200 	stmibeq	r8, {r9, ip, lr}^
     c50:	09d40000 	ldmibeq	r4, {}^
     c54:	00010000 	andeq	r0, r1, r0
     c58:	000a1c52 	andeq	r1, sl, r2, asr ip
     c5c:	000a2000 	andeq	r2, sl, r0
     c60:	52000100 	andpl	r0, r0, #0
	...
     c6c:	00000994 	muleq	r0, r4, r9
     c70:	000009f4 	strdeq	r0, [r0], -r4
     c74:	fc5e0001 	mrrc2	0, 0, r0, lr, cr1
     c78:	00000009 	andeq	r0, r0, r9
     c7c:	0100000a 	tsteq	r0, sl
     c80:	0a0c5e00 	beq	318488 <DISABLE_IRQ+0x318408>
     c84:	0a100000 	beq	400c8c <DISABLE_IRQ+0x400c0c>
     c88:	00010000 	andeq	r0, r1, r0
     c8c:	000a1c5e 	andeq	r1, sl, lr, asr ip
     c90:	000a2c00 	andeq	r2, sl, r0, lsl #24
     c94:	5e000100 	adfpls	f0, f0, f0
	...
     ca0:	000009d4 	ldrdeq	r0, [r0], -r4
     ca4:	000009f4 	strdeq	r0, [r0], -r4
     ca8:	fc520001 	mrrc2	0, 0, r0, r2, cr1
     cac:	00000009 	andeq	r0, r0, r9
     cb0:	0100000a 	tsteq	r0, sl
     cb4:	0a205200 	beq	8154bc <MEM_SIZE+0x154bc>
     cb8:	0a2c0000 	beq	b00cc0 <MEM_SIZE+0x300cc0>
     cbc:	00010000 	andeq	r0, r1, r0
     cc0:	00000052 	andeq	r0, r0, r2, asr r0
     cc4:	00000000 	andeq	r0, r0, r0
     cc8:	000a2c00 	andeq	r2, sl, r0, lsl #24
     ccc:	000a3000 	andeq	r3, sl, r0
     cd0:	5d000100 	stfpls	f0, [r0]
     cd4:	00000a30 	andeq	r0, r0, r0, lsr sl
     cd8:	00000b1c 	andeq	r0, r0, ip, lsl fp
     cdc:	187d0002 	ldmdane	sp!, {r1}^
	...
     ce8:	00000a2c 	andeq	r0, r0, ip, lsr #20
     cec:	00000a4c 	andeq	r0, r0, ip, asr #20
     cf0:	4c500001 	mrrcmi	0, 0, r0, r0, cr1
     cf4:	5c00000a 	stcpl	0, cr0, [r0], {10}
     cf8:	0100000a 	tsteq	r0, sl
     cfc:	0a5c5400 	beq	1715d04 <MEM_SIZE+0xf15d04>
     d00:	0a640000 	beq	1900d08 <MEM_SIZE+0x1100d08>
     d04:	00010000 	andeq	r0, r1, r0
     d08:	000a6c50 	andeq	r6, sl, r0, asr ip
     d0c:	000a8400 	andeq	r8, sl, r0, lsl #8
     d10:	50000100 	andpl	r0, r0, r0, lsl #2
     d14:	00000a88 	andeq	r0, r0, r8, lsl #21
     d18:	00000a9c 	muleq	r0, ip, sl
     d1c:	00540001 	subseq	r0, r4, r1
     d20:	00000000 	andeq	r0, r0, r0
     d24:	2c000000 	stccs	0, cr0, [r0], {0}
     d28:	4400000a 	strmi	r0, [r0], #-10
     d2c:	0100000a 	tsteq	r0, sl
     d30:	0a445100 	beq	1115138 <MEM_SIZE+0x915138>
     d34:	0b1c0000 	bleq	700d3c <DISABLE_IRQ+0x700cbc>
     d38:	00010000 	andeq	r0, r1, r0
     d3c:	00000056 	andeq	r0, r0, r6, asr r0
     d40:	00000000 	andeq	r0, r0, r0
     d44:	000a2c00 	andeq	r2, sl, r0, lsl #24
     d48:	000a4400 	andeq	r4, sl, r0, lsl #8
     d4c:	52000100 	andpl	r0, r0, #0
     d50:	00000a44 	andeq	r0, r0, r4, asr #20
     d54:	00000b1c 	andeq	r0, r0, ip, lsl fp
     d58:	00550001 	subseq	r0, r5, r1
     d5c:	00000000 	andeq	r0, r0, r0
     d60:	60000000 	andvs	r0, r0, r0
     d64:	6c00000a 	stcvs	0, cr0, [r0], {10}
     d68:	0100000a 	tsteq	r0, sl
     d6c:	0a9c5400 	beq	fe715d74 <rEINTPEND+0xa8715ccc>
     d70:	0ab80000 	beq	fee00d78 <rEINTPEND+0xa8e00cd0>
     d74:	00010000 	andeq	r0, r1, r0
     d78:	000ac054 	andeq	ip, sl, r4, asr r0
     d7c:	000ac400 	andeq	ip, sl, r0, lsl #8
     d80:	54000100 	strpl	r0, [r0], #-256	; 0x100
     d84:	00000af0 	strdeq	r0, [r0], -r0
     d88:	00000b10 	andeq	r0, r0, r0, lsl fp
     d8c:	00540001 	subseq	r0, r4, r1
     d90:	00000000 	andeq	r0, r0, r0
     d94:	40000000 	andmi	r0, r0, r0
     d98:	9400000a 	strls	r0, [r0], #-10
     d9c:	0100000a 	tsteq	r0, sl
     da0:	0ab85400 	beq	fee15da8 <rEINTPEND+0xa8e15d00>
     da4:	0ad00000 	beq	ff400dac <rEINTPEND+0xa9400d04>
     da8:	00010000 	andeq	r0, r1, r0
     dac:	000ad854 	andeq	sp, sl, r4, asr r8
     db0:	000af000 	andeq	pc, sl, r0
     db4:	54000100 	strpl	r0, [r0], #-256	; 0x100
     db8:	00000b10 	andeq	r0, r0, r0, lsl fp
     dbc:	00000b1c 	andeq	r0, r0, ip, lsl fp
     dc0:	00540001 	subseq	r0, r4, r1
     dc4:	00000000 	andeq	r0, r0, r0
     dc8:	1c000000 	stcne	0, cr0, [r0], {0}
     dcc:	2400000b 	strcs	r0, [r0], #-11
     dd0:	0100000b 	tsteq	r0, fp
     dd4:	0b245d00 	bleq	9181dc <MEM_SIZE+0x1181dc>
     dd8:	0bb80000 	bleq	fee00de0 <rEINTPEND+0xa8e00d38>
     ddc:	00020000 	andeq	r0, r2, r0
     de0:	0000087d 	andeq	r0, r0, sp, ror r8
     de4:	00000000 	andeq	r0, r0, r0
     de8:	0b1c0000 	bleq	700df0 <DISABLE_IRQ+0x700d70>
     dec:	0b380000 	bleq	e00df4 <MEM_SIZE+0x600df4>
     df0:	00010000 	andeq	r0, r1, r0
     df4:	000b3850 	andeq	r3, fp, r0, asr r8
     df8:	000b4000 	andeq	r4, fp, r0
     dfc:	54000100 	strpl	r0, [r0], #-256	; 0x100
     e00:	00000b40 	andeq	r0, r0, r0, asr #22
     e04:	00000b48 	andeq	r0, r0, r8, asr #22
     e08:	50500001 	subspl	r0, r0, r1
     e0c:	7c00000b 	stcvc	0, cr0, [r0], {11}
     e10:	0100000b 	tsteq	r0, fp
     e14:	0b805400 	bleq	fe015e1c <rEINTPEND+0xa8015d74>
     e18:	0b840000 	bleq	fe100e20 <rEINTPEND+0xa8100d78>
     e1c:	00010000 	andeq	r0, r1, r0
     e20:	000b9850 	andeq	r9, fp, r0, asr r8
     e24:	000ba000 	andeq	sl, fp, r0
     e28:	54000100 	strpl	r0, [r0], #-256	; 0x100
     e2c:	00000ba4 	andeq	r0, r0, r4, lsr #23
     e30:	00000bac 	andeq	r0, r0, ip, lsr #23
     e34:	00540001 	subseq	r0, r4, r1
     e38:	00000000 	andeq	r0, r0, r0
     e3c:	5c000000 	stcpl	0, cr0, [r0], {0}
     e40:	7800000b 	stmdavc	r0, {r0, r1, r3}
     e44:	0100000b 	tsteq	r0, fp
     e48:	0b985300 	bleq	fe615a50 <rEINTPEND+0xa86159a8>
     e4c:	0b9c0000 	bleq	fe700e54 <rEINTPEND+0xa8700dac>
     e50:	00010000 	andeq	r0, r1, r0
     e54:	000ba453 	andeq	sl, fp, r3, asr r4
     e58:	000ba800 	andeq	sl, fp, r0, lsl #16
     e5c:	53000100 	movwpl	r0, #256	; 0x100
	...
     e68:	00000bb8 	undefined instruction 0x00000bb8
     e6c:	00000bbc 	undefined instruction 0x00000bbc
     e70:	bc5d0001 	mrrclt	0, 0, r0, sp, cr1
     e74:	c400000b 	strgt	r0, [r0], #-11
     e78:	0200000b 	andeq	r0, r0, #11
     e7c:	c40c7d00 	strgt	r7, [ip], #-3328	; 0xd00
     e80:	3c00000b 	stccc	0, cr0, [r0], {11}
     e84:	0200000c 	andeq	r0, r0, #12
     e88:	00187d00 	andseq	r7, r8, r0, lsl #26
     e8c:	00000000 	andeq	r0, r0, r0
     e90:	b8000000 	stmdalt	r0, {}
     e94:	cc00000b 	stcgt	0, cr0, [r0], {11}
     e98:	0100000b 	tsteq	r0, fp
     e9c:	0bcc5000 	bleq	ff314ea4 <rEINTPEND+0xa9314dfc>
     ea0:	0bdc0000 	bleq	ff700ea8 <rEINTPEND+0xa9700e00>
     ea4:	00010000 	andeq	r0, r1, r0
     ea8:	000bdc54 	andeq	sp, fp, r4, asr ip
     eac:	000bf000 	andeq	pc, fp, r0
     eb0:	50000100 	andpl	r0, r0, r0, lsl #2
     eb4:	00000bf0 	strdeq	r0, [r0], -r0
     eb8:	00000bfc 	strdeq	r0, [r0], -ip
     ebc:	fc540001 	mrrc2	0, 0, r0, r4, cr1
     ec0:	0400000b 	streq	r0, [r0], #-11
     ec4:	0100000c 	tsteq	r0, ip
     ec8:	0c045000 	stceq	0, cr5, [r4], {0}
     ecc:	0c3c0000 	ldceq	0, cr0, [ip]
     ed0:	00010000 	andeq	r0, r1, r0
     ed4:	00000054 	andeq	r0, r0, r4, asr r0
     ed8:	00000000 	andeq	r0, r0, r0
     edc:	000bb800 	andeq	fp, fp, r0, lsl #16
     ee0:	000c0000 	andeq	r0, ip, r0
     ee4:	51000100 	tstpl	r0, r0, lsl #2
     ee8:	00000c34 	andeq	r0, r0, r4, lsr ip
     eec:	00000c38 	andeq	r0, r0, r8, lsr ip
     ef0:	00510001 	subseq	r0, r1, r1
     ef4:	00000000 	andeq	r0, r0, r0
     ef8:	b8000000 	stmdalt	r0, {}
     efc:	cc00000b 	stcgt	0, cr0, [r0], {11}
     f00:	0100000b 	tsteq	r0, fp
     f04:	0bcc5200 	bleq	ff31570c <rEINTPEND+0xa9315664>
     f08:	0c3c0000 	ldceq	0, cr0, [ip]
     f0c:	00010000 	andeq	r0, r1, r0
     f10:	00000055 	andeq	r0, r0, r5, asr r0
     f14:	00000000 	andeq	r0, r0, r0
     f18:	000c3c00 	andeq	r3, ip, r0, lsl #24
     f1c:	000c4000 	andeq	r4, ip, r0
     f20:	5d000100 	stfpls	f0, [r0]
     f24:	00000c40 	andeq	r0, r0, r0, asr #24
     f28:	00000c48 	andeq	r0, r0, r8, asr #24
     f2c:	087d0002 	ldmdaeq	sp!, {r1}^
     f30:	00000c48 	andeq	r0, r0, r8, asr #24
     f34:	00000cc0 	andeq	r0, r0, r0, asr #25
     f38:	107d0002 	rsbsne	r0, sp, r2
	...
     f44:	00000c3c 	andeq	r0, r0, ip, lsr ip
     f48:	00000c4c 	andeq	r0, r0, ip, asr #24
     f4c:	4c500001 	mrrcmi	0, 0, r0, r0, cr1
     f50:	b000000c 	andlt	r0, r0, ip
     f54:	0100000c 	tsteq	r0, ip
     f58:	00005400 	andeq	r5, r0, r0, lsl #8
     f5c:	00000000 	andeq	r0, r0, r0
     f60:	0c3c0000 	ldceq	0, cr0, [ip]
     f64:	0c7c0000 	ldcleq	0, cr0, [ip]
     f68:	00010000 	andeq	r0, r1, r0
     f6c:	000c9051 	andeq	r9, ip, r1, asr r0
     f70:	000cb800 	andeq	fp, ip, r0, lsl #16
     f74:	51000100 	tstpl	r0, r0, lsl #2
	...
     f80:	00000c8c 	andeq	r0, r0, ip, lsl #25
     f84:	00000cb8 	undefined instruction 0x00000cb8
     f88:	005e0001 	subseq	r0, lr, r1
     f8c:	00000000 	andeq	r0, r0, r0
     f90:	94000000 	strls	r0, [r0]
     f94:	b800000c 	stmdalt	r0, {r2, r3}
     f98:	0100000c 	tsteq	r0, ip
     f9c:	00005c00 	andeq	r5, r0, r0, lsl #24
     fa0:	00000000 	andeq	r0, r0, r0
     fa4:	0cc00000 	stcleq	0, cr0, [r0], {0}
     fa8:	0cc40000 	stcleq	0, cr0, [r4], {0}
     fac:	00010000 	andeq	r0, r1, r0
     fb0:	000cc45d 	andeq	ip, ip, sp, asr r4
     fb4:	000d5800 	andeq	r5, sp, r0, lsl #16
     fb8:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
     fbc:	00000010 	andeq	r0, r0, r0, lsl r0
     fc0:	00000000 	andeq	r0, r0, r0
     fc4:	000cc000 	andeq	ip, ip, r0
     fc8:	000cdc00 	andeq	sp, ip, r0, lsl #24
     fcc:	50000100 	andpl	r0, r0, r0, lsl #2
     fd0:	00000cdc 	ldrdeq	r0, [r0], -ip
     fd4:	00000d58 	andeq	r0, r0, r8, asr sp
     fd8:	00560001 	subseq	r0, r6, r1
     fdc:	00000000 	andeq	r0, r0, r0
     fe0:	dc000000 	stcle	0, cr0, [r0], {0}
     fe4:	e800000c 	stmda	r0, {r2, r3}
     fe8:	0100000c 	tsteq	r0, ip
     fec:	0d305100 	ldfeqs	f5, [r0]
     ff0:	0d480000 	stcleq	0, cr0, [r8]
     ff4:	00010000 	andeq	r0, r1, r0
     ff8:	00000051 	andeq	r0, r0, r1, asr r0
     ffc:	00000000 	andeq	r0, r0, r0
    1000:	000d5800 	andeq	r5, sp, r0, lsl #16
    1004:	000d5c00 	andeq	r5, sp, r0, lsl #24
    1008:	5d000100 	stfpls	f0, [r0]
    100c:	00000d5c 	andeq	r0, r0, ip, asr sp
    1010:	00000d9c 	muleq	r0, ip, sp
    1014:	107d0002 	rsbsne	r0, sp, r2
	...
    1020:	00000d58 	andeq	r0, r0, r8, asr sp
    1024:	00000d64 	andeq	r0, r0, r4, ror #26
    1028:	64500001 	ldrbvs	r0, [r0], #-1
    102c:	9c00000d 	stcls	0, cr0, [r0], {13}
    1030:	0100000d 	tsteq	r0, sp
    1034:	00005500 	andeq	r5, r0, r0, lsl #10
    1038:	00000000 	andeq	r0, r0, r0
    103c:	0d740000 	ldcleq	0, cr0, [r4]
    1040:	0d800000 	stceq	0, cr0, [r0]
    1044:	00010000 	andeq	r0, r1, r0
    1048:	000d8854 	andeq	r8, sp, r4, asr r8
    104c:	000d9c00 	andeq	r9, sp, r0, lsl #24
    1050:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    105c:	00000d9c 	muleq	r0, ip, sp
    1060:	00000da0 	andeq	r0, r0, r0, lsr #27
    1064:	a05d0001 	subsge	r0, sp, r1
    1068:	a800000d 	stmdage	r0, {r0, r2, r3}
    106c:	0200000d 	andeq	r0, r0, #13
    1070:	a8087d00 	stmdage	r8, {r8, sl, fp, ip, sp, lr}
    1074:	4000000d 	andmi	r0, r0, sp
    1078:	0200000e 	andeq	r0, r0, #14
    107c:	00107d00 	andseq	r7, r0, r0, lsl #26
    1080:	00000000 	andeq	r0, r0, r0
    1084:	9c000000 	stcls	0, cr0, [r0], {0}
    1088:	ac00000d 	stcge	0, cr0, [r0], {13}
    108c:	0100000d 	tsteq	r0, sp
    1090:	0dac5000 	stceq	0, cr5, [ip]
    1094:	0e400000 	cdpeq	0, 4, cr0, cr0, cr0, {0}
    1098:	00010000 	andeq	r0, r1, r0
    109c:	00000054 	andeq	r0, r0, r4, asr r0
    10a0:	00000000 	andeq	r0, r0, r0
    10a4:	000d9c00 	andeq	r9, sp, r0, lsl #24
    10a8:	000ddc00 	andeq	sp, sp, r0, lsl #24
    10ac:	51000100 	tstpl	r0, r0, lsl #2
    10b0:	00000df0 	strdeq	r0, [r0], -r0
    10b4:	00000e38 	andeq	r0, r0, r8, lsr lr
    10b8:	00510001 	subseq	r0, r1, r1
    10bc:	00000000 	andeq	r0, r0, r0
    10c0:	10000000 	andne	r0, r0, r0
    10c4:	2800000e 	stmdacs	r0, {r1, r2, r3}
    10c8:	0100000e 	tsteq	r0, lr
    10cc:	00005300 	andeq	r5, r0, r0, lsl #6
    10d0:	00000000 	andeq	r0, r0, r0
    10d4:	0dec0000 	stcleq	0, cr0, [ip]
    10d8:	0e380000 	cdpeq	0, 3, cr0, cr8, cr0, {0}
    10dc:	00010000 	andeq	r0, r1, r0
    10e0:	0000005e 	andeq	r0, r0, lr, asr r0
    10e4:	00000000 	andeq	r0, r0, r0
    10e8:	000df400 	andeq	pc, sp, r0, lsl #8
    10ec:	000e1c00 	andeq	r1, lr, r0, lsl #24
    10f0:	5c000100 	stfpls	f0, [r0], {0}
	...
    10fc:	00000e40 	andeq	r0, r0, r0, asr #28
    1100:	00000e44 	andeq	r0, r0, r4, asr #28
    1104:	445d0001 	ldrbmi	r0, [sp], #-1
    1108:	9000000e 	andls	r0, r0, lr
    110c:	0200000e 	andeq	r0, r0, #14
    1110:	00087d00 	andeq	r7, r8, r0, lsl #26
    1114:	00000000 	andeq	r0, r0, r0
    1118:	40000000 	andmi	r0, r0, r0
    111c:	4c00000e 	stcmi	0, cr0, [r0], {14}
    1120:	0100000e 	tsteq	r0, lr
    1124:	0e4c5000 	cdpeq	0, 4, cr5, cr12, cr0, {0}
    1128:	0e900000 	cdpeq	0, 9, cr0, cr0, cr0, {0}
    112c:	00010000 	andeq	r0, r1, r0
    1130:	00000054 	andeq	r0, r0, r4, asr r0
    1134:	00000000 	andeq	r0, r0, r0
    1138:	000e7000 	andeq	r7, lr, r0
    113c:	000e8800 	andeq	r8, lr, r0, lsl #16
    1140:	53000100 	movwpl	r0, #256	; 0x100
	...
    114c:	00000e90 	muleq	r0, r0, lr
    1150:	00000e94 	muleq	r0, r4, lr
    1154:	945d0001 	ldrbls	r0, [sp], #-1
    1158:	8400000e 	strhi	r0, [r0], #-14
    115c:	0200000f 	andeq	r0, r0, #15
    1160:	00207d00 	eoreq	r7, r0, r0, lsl #26
    1164:	00000000 	andeq	r0, r0, r0
    1168:	90000000 	andls	r0, r0, r0
    116c:	b000000e 	andlt	r0, r0, lr
    1170:	0100000e 	tsteq	r0, lr
    1174:	0eb05000 	cdpeq	0, 11, cr5, cr0, cr0, {0}
    1178:	0f840000 	svceq	0x00840000
    117c:	00010000 	andeq	r0, r1, r0
    1180:	00000055 	andeq	r0, r0, r5, asr r0
    1184:	00000000 	andeq	r0, r0, r0
    1188:	000e9000 	andeq	r9, lr, r0
    118c:	000eb000 	andeq	fp, lr, r0
    1190:	51000100 	tstpl	r0, r0, lsl #2
    1194:	00000eb0 	undefined instruction 0x00000eb0
    1198:	00000f84 	andeq	r0, r0, r4, lsl #31
    119c:	00580001 	subseq	r0, r8, r1
    11a0:	00000000 	andeq	r0, r0, r0
    11a4:	b0000000 	andlt	r0, r0, r0
    11a8:	bc00000e 	stclt	0, cr0, [r0], {14}
    11ac:	0100000e 	tsteq	r0, lr
    11b0:	0ee85700 	cdpeq	7, 14, cr5, cr8, cr0, {0}
    11b4:	0f580000 	svceq	0x00580000
    11b8:	00010000 	andeq	r0, r1, r0
    11bc:	000f6057 	andeq	r6, pc, r7, asr r0
    11c0:	000f8400 	andeq	r8, pc, r0, lsl #8
    11c4:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    11d0:	00000eb0 	undefined instruction 0x00000eb0
    11d4:	00000ebc 	undefined instruction 0x00000ebc
    11d8:	40510001 	subsmi	r0, r1, r1
    11dc:	5800000f 	stmdapl	r0, {r0, r1, r2, r3}
    11e0:	0100000f 	tsteq	r0, pc
    11e4:	00005100 	andeq	r5, r0, r0, lsl #2
    11e8:	00000000 	andeq	r0, r0, r0
    11ec:	0f840000 	svceq	0x00840000
    11f0:	0f880000 	svceq	0x00880000
    11f4:	00010000 	andeq	r0, r1, r0
    11f8:	000f885d 	andeq	r8, pc, sp, asr r8
    11fc:	00102000 	andseq	r2, r0, r0
    1200:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    1204:	00000010 	andeq	r0, r0, r0, lsl r0
    1208:	00000000 	andeq	r0, r0, r0
    120c:	000f8400 	andeq	r8, pc, r0, lsl #8
    1210:	000fa800 	andeq	sl, pc, r0, lsl #16
    1214:	50000100 	andpl	r0, r0, r0, lsl #2
    1218:	00000fa8 	andeq	r0, r0, r8, lsr #31
    121c:	00000fbc 	undefined instruction 0x00000fbc
    1220:	bc540001 	mrrclt	0, 0, r0, r4, cr1
    1224:	c400000f 	strgt	r0, [r0], #-15
    1228:	0100000f 	tsteq	r0, pc
    122c:	0fc85000 	svceq	0x00c85000
    1230:	0fdc0000 	svceq	0x00dc0000
    1234:	00010000 	andeq	r0, r1, r0
    1238:	000fe454 	andeq	lr, pc, r4, asr r4
    123c:	000fe800 	andeq	lr, pc, r0, lsl #16
    1240:	50000100 	andpl	r0, r0, r0, lsl #2
    1244:	00000fe8 	andeq	r0, r0, r8, ror #31
    1248:	00000ff0 	strdeq	r0, [r0], -r0
    124c:	00540001 	subseq	r0, r4, r1
    1250:	00000000 	andeq	r0, r0, r0
    1254:	84000000 	strhi	r0, [r0]
    1258:	9800000f 	stmdals	r0, {r0, r1, r2, r3}
    125c:	0100000f 	tsteq	r0, pc
    1260:	0f985100 	svceq	0x00985100
    1264:	10200000 	eorne	r0, r0, r0
    1268:	00010000 	andeq	r0, r1, r0
    126c:	00000055 	andeq	r0, r0, r5, asr r0
    1270:	00000000 	andeq	r0, r0, r0
    1274:	000fc800 	andeq	ip, pc, r0, lsl #16
    1278:	000fd400 	andeq	sp, pc, r0, lsl #8
    127c:	53000100 	movwpl	r0, #256	; 0x100
    1280:	00000ff4 	strdeq	r0, [r0], -r4
    1284:	00001018 	andeq	r1, r0, r8, lsl r0
    1288:	00530001 	subseq	r0, r3, r1
    128c:	00000000 	andeq	r0, r0, r0
    1290:	20000000 	andcs	r0, r0, r0
    1294:	24000010 	strcs	r0, [r0], #-16
    1298:	01000010 	tsteq	r0, r0, lsl r0
    129c:	10245d00 	eorne	r5, r4, r0, lsl #26
    12a0:	10340000 	eorsne	r0, r4, r0
    12a4:	00020000 	andeq	r0, r2, r0
    12a8:	10340c7d 	eorsne	r0, r4, sp, ror ip
    12ac:	10d80000 	sbcsne	r0, r8, r0
    12b0:	00020000 	andeq	r0, r2, r0
    12b4:	0000187d 	andeq	r1, r0, sp, ror r8
    12b8:	00000000 	andeq	r0, r0, r0
    12bc:	10200000 	eorne	r0, r0, r0
    12c0:	103c0000 	eorsne	r0, ip, r0
    12c4:	00010000 	andeq	r0, r1, r0
    12c8:	00103c50 	andseq	r3, r0, r0, asr ip
    12cc:	0010ac00 	andseq	sl, r0, r0, lsl #24
    12d0:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    12dc:	00001020 	andeq	r1, r0, r0, lsr #32
    12e0:	00001078 	andeq	r1, r0, r8, ror r0
    12e4:	8c510001 	mrrchi	0, 0, r0, r1, cr1
    12e8:	cc000010 	stcgt	0, cr0, [r0], {16}
    12ec:	01000010 	tsteq	r0, r0, lsl r0
    12f0:	00005100 	andeq	r5, r0, r0, lsl #2
    12f4:	00000000 	andeq	r0, r0, r0
    12f8:	10680000 	rsbne	r0, r8, r0
    12fc:	10740000 	rsbsne	r0, r4, r0
    1300:	00010000 	andeq	r0, r1, r0
    1304:	0010ac54 	andseq	sl, r0, r4, asr ip
    1308:	0010d800 	andseq	sp, r0, r0, lsl #16
    130c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    1318:	000010d8 	ldrdeq	r1, [r0], -r8
    131c:	000010dc 	ldrdeq	r1, [r0], -ip
    1320:	dc5d0001 	mrrcle	0, 0, r0, sp, cr1
    1324:	dc000010 	stcle	0, cr0, [r0], {16}
    1328:	02000011 	andeq	r0, r0, #17
    132c:	00187d00 	andseq	r7, r8, r0, lsl #26
    1330:	00000000 	andeq	r0, r0, r0
    1334:	d8000000 	stmdale	r0, {}
    1338:	ec000010 	stc	0, cr0, [r0], {16}
    133c:	01000010 	tsteq	r0, r0, lsl r0
    1340:	10ec5000 	rscne	r5, ip, r0
    1344:	11000000 	tstne	r0, r0
    1348:	00010000 	andeq	r0, r1, r0
    134c:	00110055 	andseq	r0, r1, r5, asr r0
    1350:	00112000 	andseq	r2, r1, r0
    1354:	50000100 	andpl	r0, r0, r0, lsl #2
    1358:	00001120 	andeq	r1, r0, r0, lsr #2
    135c:	00001150 	andeq	r1, r0, r0, asr r1
    1360:	a0550001 	subsge	r0, r5, r1
    1364:	dc000011 	stcle	0, cr0, [r0], {17}
    1368:	01000011 	tsteq	r0, r1, lsl r0
    136c:	00005500 	andeq	r5, r0, r0, lsl #10
    1370:	00000000 	andeq	r0, r0, r0
    1374:	10d80000 	sbcsne	r0, r8, r0
    1378:	10ec0000 	rscne	r0, ip, r0
    137c:	00010000 	andeq	r0, r1, r0
    1380:	0010ec51 	andseq	lr, r0, r1, asr ip
    1384:	0011dc00 	andseq	sp, r1, r0, lsl #24
    1388:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    1394:	000010e8 	andeq	r1, r0, r8, ror #1
    1398:	00001108 	andeq	r1, r0, r8, lsl #2
    139c:	18540001 	ldmdane	r4, {r0}^
    13a0:	dc000011 	stcle	0, cr0, [r0], {17}
    13a4:	01000011 	tsteq	r0, r1, lsl r0
    13a8:	00005400 	andeq	r5, r0, r0, lsl #8
    13ac:	00000000 	andeq	r0, r0, r0
    13b0:	11840000 	orrne	r0, r4, r0
    13b4:	11ac0000 	undefined instruction 0x11ac0000
    13b8:	00010000 	andeq	r0, r1, r0
    13bc:	00000051 	andeq	r0, r0, r1, asr r0
    13c0:	00000000 	andeq	r0, r0, r0
    13c4:	0011dc00 	andseq	sp, r1, r0, lsl #24
    13c8:	0011e000 	andseq	lr, r1, r0
    13cc:	5d000100 	stfpls	f0, [r0]
    13d0:	000011e0 	andeq	r1, r0, r0, ror #3
    13d4:	000012bc 	undefined instruction 0x000012bc
    13d8:	107d0002 	rsbsne	r0, sp, r2
	...
    13e4:	000011dc 	ldrdeq	r1, [r0], -ip
    13e8:	000011ec 	andeq	r1, r0, ip, ror #3
    13ec:	ec500001 	mrrc	0, 0, r0, r0, cr1
    13f0:	bc000011 	stclt	0, cr0, [r0], {17}
    13f4:	01000012 	tsteq	r0, r2, lsl r0
    13f8:	00005400 	andeq	r5, r0, r0, lsl #8
    13fc:	00000000 	andeq	r0, r0, r0
    1400:	11dc0000 	bicsne	r0, ip, r0
    1404:	11f00000 	mvnsne	r0, r0
    1408:	00010000 	andeq	r0, r1, r0
    140c:	0011f051 	andseq	pc, r1, r1, asr r0
    1410:	0012bc00 	andseq	fp, r2, r0, lsl #24
    1414:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    1420:	000012bc 	undefined instruction 0x000012bc
    1424:	000012c0 	andeq	r1, r0, r0, asr #5
    1428:	c05d0001 	subsgt	r0, sp, r1
    142c:	28000012 	stmdacs	r0, {r1, r4}
    1430:	02000013 	andeq	r0, r0, #19
    1434:	00107d00 	andseq	r7, r0, r0, lsl #26
    1438:	00000000 	andeq	r0, r0, r0
    143c:	bc000000 	stclt	0, cr0, [r0], {0}
    1440:	cc000012 	stcgt	0, cr0, [r0], {18}
    1444:	01000012 	tsteq	r0, r2, lsl r0
    1448:	12cc5000 	sbcne	r5, ip, #0
    144c:	13280000 	teqne	r8, #0
    1450:	00010000 	andeq	r0, r1, r0
    1454:	00000054 	andeq	r0, r0, r4, asr r0
    1458:	00000000 	andeq	r0, r0, r0
    145c:	0012bc00 	andseq	fp, r2, r0, lsl #24
    1460:	0012d000 	andseq	sp, r2, r0
    1464:	51000100 	tstpl	r0, r0, lsl #2
    1468:	000012d0 	ldrdeq	r1, [r0], -r0
    146c:	000012dc 	ldrdeq	r1, [r0], -ip
    1470:	dc550001 	mrrcle	0, 0, r0, r5, cr1
    1474:	e0000012 	and	r0, r0, r2, lsl r0
    1478:	01000012 	tsteq	r0, r2, lsl r0
    147c:	12e05100 	rscne	r5, r0, #0
    1480:	13280000 	teqne	r8, #0
    1484:	00010000 	andeq	r0, r1, r0
    1488:	00000055 	andeq	r0, r0, r5, asr r0
    148c:	00000000 	andeq	r0, r0, r0
    1490:	00132800 	andseq	r2, r3, r0, lsl #16
    1494:	00132c00 	andseq	r2, r3, r0, lsl #24
    1498:	5d000100 	stfpls	f0, [r0]
    149c:	0000132c 	andeq	r1, r0, ip, lsr #6
    14a0:	0000138c 	andeq	r1, r0, ip, lsl #7
    14a4:	107d0002 	rsbsne	r0, sp, r2
	...
    14b0:	00001328 	andeq	r1, r0, r8, lsr #6
    14b4:	00001338 	andeq	r1, r0, r8, lsr r3
    14b8:	38500001 	ldmdacc	r0, {r0}^
    14bc:	8c000013 	stchi	0, cr0, [r0], {19}
    14c0:	01000013 	tsteq	r0, r3, lsl r0
    14c4:	00005400 	andeq	r5, r0, r0, lsl #8
    14c8:	00000000 	andeq	r0, r0, r0
    14cc:	13280000 	teqne	r8, #0
    14d0:	133c0000 	teqne	ip, #0
    14d4:	00010000 	andeq	r0, r1, r0
    14d8:	00133c51 	andseq	r3, r3, r1, asr ip
    14dc:	00134800 	andseq	r4, r3, r0, lsl #16
    14e0:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    14e4:	00001348 	andeq	r1, r0, r8, asr #6
    14e8:	0000134c 	andeq	r1, r0, ip, asr #6
    14ec:	4c510001 	mrrcmi	0, 0, r0, r1, cr1
    14f0:	8c000013 	stchi	0, cr0, [r0], {19}
    14f4:	01000013 	tsteq	r0, r3, lsl r0
    14f8:	00005500 	andeq	r5, r0, r0, lsl #10
    14fc:	00000000 	andeq	r0, r0, r0
    1500:	138c0000 	orrne	r0, ip, #0
    1504:	13900000 	orrsne	r0, r0, #0
    1508:	00010000 	andeq	r0, r1, r0
    150c:	0013905d 	andseq	r9, r3, sp, asr r0
    1510:	00146000 	andseq	r6, r4, r0
    1514:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    1518:	00000010 	andeq	r0, r0, r0, lsl r0
    151c:	00000000 	andeq	r0, r0, r0
    1520:	00138c00 	andseq	r8, r3, r0, lsl #24
    1524:	0013a000 	andseq	sl, r3, r0
    1528:	50000100 	andpl	r0, r0, r0, lsl #2
    152c:	000013a0 	andeq	r1, r0, r0, lsr #7
    1530:	000013ec 	andeq	r1, r0, ip, ror #7
    1534:	14550001 	ldrbne	r0, [r5], #-1
    1538:	1c000014 	stcne	0, cr0, [r0], {20}
    153c:	01000014 	tsteq	r0, r4, lsl r0
    1540:	14305500 	ldrtne	r5, [r0], #-1280	; 0x500
    1544:	14340000 	ldrtne	r0, [r4]
    1548:	00010000 	andeq	r0, r1, r0
    154c:	00143855 	andseq	r3, r4, r5, asr r8
    1550:	00146000 	andseq	r6, r4, r0
    1554:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    1560:	0000138c 	andeq	r1, r0, ip, lsl #7
    1564:	000013a0 	andeq	r1, r0, r0, lsr #7
    1568:	a0510001 	subsge	r0, r1, r1
    156c:	c8000013 	stmdagt	r0, {r0, r1, r4}
    1570:	01000013 	tsteq	r0, r3, lsl r0
    1574:	14145600 	ldrne	r5, [r4], #-1536	; 0x600
    1578:	141c0000 	ldrne	r0, [ip]
    157c:	00010000 	andeq	r0, r1, r0
    1580:	00143856 	andseq	r3, r4, r6, asr r8
    1584:	00146000 	andseq	r6, r4, r0
    1588:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    1594:	0000138c 	andeq	r1, r0, ip, lsl #7
    1598:	000013a0 	andeq	r1, r0, r0, lsr #7
    159c:	a0520001 	subsge	r0, r2, r1
    15a0:	60000013 	andvs	r0, r0, r3, lsl r0
    15a4:	01000014 	tsteq	r0, r4, lsl r0
    15a8:	00005400 	andeq	r5, r0, r0, lsl #8
    15ac:	00000000 	andeq	r0, r0, r0
    15b0:	13cc0000 	bicne	r0, ip, #0
    15b4:	13d80000 	bicsne	r0, r8, #0
    15b8:	00010000 	andeq	r0, r1, r0
    15bc:	0013e051 	andseq	lr, r3, r1, asr r0
    15c0:	00141000 	andseq	r1, r4, r0
    15c4:	51000100 	tstpl	r0, r0, lsl #2
    15c8:	0000141c 	andeq	r1, r0, ip, lsl r4
    15cc:	00001424 	andeq	r1, r0, r4, lsr #8
    15d0:	30510001 	subscc	r0, r1, r1
    15d4:	38000014 	stmdacc	r0, {r2, r4}
    15d8:	01000014 	tsteq	r0, r4, lsl r0
    15dc:	00005100 	andeq	r5, r0, r0, lsl #2
    15e0:	00000000 	andeq	r0, r0, r0
    15e4:	13a80000 	undefined instruction 0x13a80000
    15e8:	14100000 	ldrne	r0, [r0]
    15ec:	00010000 	andeq	r0, r1, r0
    15f0:	00141c53 	andseq	r1, r4, r3, asr ip
    15f4:	00142400 	andseq	r2, r4, r0, lsl #8
    15f8:	53000100 	movwpl	r0, #256	; 0x100
    15fc:	00001430 	andeq	r1, r0, r0, lsr r4
    1600:	0000143c 	andeq	r1, r0, ip, lsr r4
    1604:	40530001 	subsmi	r0, r3, r1
    1608:	44000014 	strmi	r0, [r0], #-20
    160c:	01000014 	tsteq	r0, r4, lsl r0
    1610:	14505300 	ldrbne	r5, [r0], #-768	; 0x300
    1614:	14540000 	ldrbne	r0, [r4]
    1618:	00010000 	andeq	r0, r1, r0
    161c:	00000053 	andeq	r0, r0, r3, asr r0
    1620:	00000000 	andeq	r0, r0, r0
    1624:	0013ec00 	andseq	lr, r3, r0, lsl #24
    1628:	00143000 	andseq	r3, r4, r0
    162c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    1630:	00001434 	andeq	r1, r0, r4, lsr r4
    1634:	00001438 	andeq	r1, r0, r8, lsr r4
    1638:	00550001 	subseq	r0, r5, r1
    163c:	00000000 	andeq	r0, r0, r0
    1640:	60000000 	andvs	r0, r0, r0
    1644:	64000014 	strvs	r0, [r0], #-20
    1648:	01000014 	tsteq	r0, r4, lsl r0
    164c:	14645d00 	strbtne	r5, [r4], #-3328	; 0xd00
    1650:	15100000 	ldrne	r0, [r0]
    1654:	00020000 	andeq	r0, r2, r0
    1658:	0000187d 	andeq	r1, r0, sp, ror r8
    165c:	00000000 	andeq	r0, r0, r0
    1660:	14600000 	strbtne	r0, [r0]
    1664:	14740000 	ldrbtne	r0, [r4]
    1668:	00010000 	andeq	r0, r1, r0
    166c:	00147450 	andseq	r7, r4, r0, asr r4
    1670:	00149c00 	andseq	r9, r4, r0, lsl #24
    1674:	54000100 	strpl	r0, [r0], #-256	; 0x100
    1678:	000014a4 	andeq	r1, r0, r4, lsr #9
    167c:	000014a8 	andeq	r1, r0, r8, lsr #9
    1680:	d4540001 	ldrble	r0, [r4], #-1
    1684:	e4000014 	str	r0, [r0], #-20
    1688:	01000014 	tsteq	r0, r4, lsl r0
    168c:	14ec5400 	strbtne	r5, [ip], #1024	; 0x400
    1690:	150c0000 	strne	r0, [ip]
    1694:	00010000 	andeq	r0, r1, r0
    1698:	00000054 	andeq	r0, r0, r4, asr r0
    169c:	00000000 	andeq	r0, r0, r0
    16a0:	00146000 	andseq	r6, r4, r0
    16a4:	00147400 	andseq	r7, r4, r0, lsl #8
    16a8:	51000100 	tstpl	r0, r0, lsl #2
    16ac:	00001474 	andeq	r1, r0, r4, ror r4
    16b0:	00001510 	andeq	r1, r0, r0, lsl r5
    16b4:	00560001 	subseq	r0, r6, r1
    16b8:	00000000 	andeq	r0, r0, r0
    16bc:	60000000 	andvs	r0, r0, r0
    16c0:	74000014 	strvc	r0, [r0], #-20
    16c4:	01000014 	tsteq	r0, r4, lsl r0
    16c8:	14745200 	ldrbtne	r5, [r4], #-512	; 0x200
    16cc:	15100000 	ldrne	r0, [r0]
    16d0:	00010000 	andeq	r0, r1, r0
    16d4:	00000055 	andeq	r0, r0, r5, asr r0
    16d8:	00000000 	andeq	r0, r0, r0
    16dc:	00149c00 	andseq	r9, r4, r0, lsl #24
    16e0:	0014b400 	andseq	fp, r4, r0, lsl #8
    16e4:	54000100 	strpl	r0, [r0], #-256	; 0x100
    16e8:	000014bc 	undefined instruction 0x000014bc
    16ec:	000014e0 	andeq	r1, r0, r0, ror #9
    16f0:	e4540001 	ldrb	r0, [r4], #-1
    16f4:	ec000014 	stc	0, cr0, [r0], {20}
    16f8:	01000014 	tsteq	r0, r4, lsl r0
    16fc:	150c5400 	strne	r5, [ip, #-1024]	; 0x400
    1700:	15100000 	ldrne	r0, [r0]
    1704:	00010000 	andeq	r0, r1, r0
    1708:	00000054 	andeq	r0, r0, r4, asr r0
    170c:	00000000 	andeq	r0, r0, r0
    1710:	00147c00 	andseq	r7, r4, r0, lsl #24
    1714:	0014d000 	andseq	sp, r4, r0
    1718:	53000100 	movwpl	r0, #256	; 0x100
    171c:	000014e0 	andeq	r1, r0, r0, ror #9
    1720:	000014e8 	andeq	r1, r0, r8, ror #9
    1724:	ec530001 	mrrc	0, 0, r0, r3, cr1
    1728:	f0000014 	undefined instruction 0xf0000014
    172c:	01000014 	tsteq	r0, r4, lsl r0
    1730:	14fc5300 	ldrbtne	r5, [ip], #768	; 0x300
    1734:	15000000 	strne	r0, [r0]
    1738:	00010000 	andeq	r0, r1, r0
    173c:	00000053 	andeq	r0, r0, r3, asr r0
    1740:	00000000 	andeq	r0, r0, r0
    1744:	00151000 	andseq	r1, r5, r0
    1748:	00151400 	andseq	r1, r5, r0, lsl #8
    174c:	5d000100 	stfpls	f0, [r0]
    1750:	00001514 	andeq	r1, r0, r4, lsl r5
    1754:	00001588 	andeq	r1, r0, r8, lsl #11
    1758:	187d0002 	ldmdane	sp!, {r1}^
	...
    1764:	00001510 	andeq	r1, r0, r0, lsl r5
    1768:	00001524 	andeq	r1, r0, r4, lsr #10
    176c:	24500001 	ldrbcs	r0, [r0], #-1
    1770:	38000015 	stmdacc	r0, {r0, r2, r4}
    1774:	01000015 	tsteq	r0, r5, lsl r0
    1778:	15385400 	ldrne	r5, [r8, #-1024]!	; 0x400
    177c:	153c0000 	ldrne	r0, [ip]!
    1780:	00010000 	andeq	r0, r1, r0
    1784:	00153c50 	andseq	r3, r5, r0, asr ip
    1788:	00158800 	andseq	r8, r5, r0, lsl #16
    178c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    1798:	00001510 	andeq	r1, r0, r0, lsl r5
    179c:	00001524 	andeq	r1, r0, r4, lsr #10
    17a0:	24510001 	ldrbcs	r0, [r1], #-1
    17a4:	88000015 	stmdahi	r0, {r0, r2, r4}
    17a8:	01000015 	tsteq	r0, r5, lsl r0
    17ac:	00005700 	andeq	r5, r0, r0, lsl #14
    17b0:	00000000 	andeq	r0, r0, r0
    17b4:	15880000 	strne	r0, [r8]
    17b8:	158c0000 	strne	r0, [ip]
    17bc:	00010000 	andeq	r0, r1, r0
    17c0:	00158c5d 	andseq	r8, r5, sp, asr ip
    17c4:	00167c00 	andseq	r7, r6, r0, lsl #24
    17c8:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    17cc:	00000020 	andeq	r0, r0, r0, lsr #32
    17d0:	00000000 	andeq	r0, r0, r0
    17d4:	00158800 	andseq	r8, r5, r0, lsl #16
    17d8:	0015a400 	andseq	sl, r5, r0, lsl #8
    17dc:	50000100 	andpl	r0, r0, r0, lsl #2
    17e0:	000015a4 	andeq	r1, r0, r4, lsr #11
    17e4:	000015b8 	undefined instruction 0x000015b8
    17e8:	b8540001 	ldmdalt	r4, {r0}^
    17ec:	f0000015 	undefined instruction 0xf0000015
    17f0:	01000015 	tsteq	r0, r5, lsl r0
    17f4:	15f05000 	ldrbne	r5, [r0]!
    17f8:	165c0000 	ldrbne	r0, [ip], -r0
    17fc:	00010000 	andeq	r0, r1, r0
    1800:	00165c54 	andseq	r5, r6, r4, asr ip
    1804:	00166800 	andseq	r6, r6, r0, lsl #16
    1808:	50000100 	andpl	r0, r0, r0, lsl #2
    180c:	00001668 	andeq	r1, r0, r8, ror #12
    1810:	0000167c 	andeq	r1, r0, ip, ror r6
    1814:	00540001 	subseq	r0, r4, r1
    1818:	00000000 	andeq	r0, r0, r0
    181c:	88000000 	stmdahi	r0, {}
    1820:	a4000015 	strge	r0, [r0], #-21
    1824:	01000015 	tsteq	r0, r5, lsl r0
    1828:	15a45100 	strne	r5, [r4, #256]!	; 0x100
    182c:	15dc0000 	ldrbne	r0, [ip]
    1830:	00010000 	andeq	r0, r1, r0
    1834:	0015dc56 	andseq	sp, r5, r6, asr ip
    1838:	0015f000 	andseq	pc, r5, r0
    183c:	51000100 	tstpl	r0, r0, lsl #2
    1840:	000015f0 	strdeq	r1, [r0], -r0
    1844:	0000165c 	andeq	r1, r0, ip, asr r6
    1848:	5c560001 	mrrcpl	0, 0, r0, r6, cr1
    184c:	68000016 	stmdavs	r0, {r1, r2, r4}
    1850:	01000016 	tsteq	r0, r6, lsl r0
    1854:	16685100 	strbtne	r5, [r8], -r0, lsl #2
    1858:	167c0000 	ldrbtne	r0, [ip], -r0
    185c:	00010000 	andeq	r0, r1, r0
    1860:	00000056 	andeq	r0, r0, r6, asr r0
    1864:	00000000 	andeq	r0, r0, r0
    1868:	00158800 	andseq	r8, r5, r0, lsl #16
    186c:	0015a400 	andseq	sl, r5, r0, lsl #8
    1870:	52000100 	andpl	r0, r0, #0
    1874:	000015a4 	andeq	r1, r0, r4, lsr #11
    1878:	000015e4 	andeq	r1, r0, r4, ror #11
    187c:	e4570001 	ldrb	r0, [r7], #-1
    1880:	f0000015 	undefined instruction 0xf0000015
    1884:	01000015 	tsteq	r0, r5, lsl r0
    1888:	15f05200 	ldrbne	r5, [r0, #512]!	; 0x200
    188c:	165c0000 	ldrbne	r0, [ip], -r0
    1890:	00010000 	andeq	r0, r1, r0
    1894:	00165c57 	andseq	r5, r6, r7, asr ip
    1898:	00166800 	andseq	r6, r6, r0, lsl #16
    189c:	52000100 	andpl	r0, r0, #0
    18a0:	00001668 	andeq	r1, r0, r8, ror #12
    18a4:	0000167c 	andeq	r1, r0, ip, ror r6
    18a8:	00570001 	subseq	r0, r7, r1
    18ac:	00000000 	andeq	r0, r0, r0
    18b0:	88000000 	stmdahi	r0, {}
    18b4:	a4000015 	strge	r0, [r0], #-21
    18b8:	01000015 	tsteq	r0, r5, lsl r0
    18bc:	15a45300 	strne	r5, [r4, #768]!	; 0x300
    18c0:	167c0000 	ldrbtne	r0, [ip], -r0
    18c4:	00010000 	andeq	r0, r1, r0
    18c8:	00000055 	andeq	r0, r0, r5, asr r0
    18cc:	00000000 	andeq	r0, r0, r0
    18d0:	0015a000 	andseq	sl, r5, r0
    18d4:	0015bc00 	andseq	fp, r5, r0, lsl #24
    18d8:	58000100 	stmdapl	r0, {r8}
    18dc:	000015c8 	andeq	r1, r0, r8, asr #11
    18e0:	0000167c 	andeq	r1, r0, ip, ror r6
    18e4:	00580001 	subseq	r0, r8, r1
    18e8:	00000000 	andeq	r0, r0, r0
    18ec:	18000000 	stmdane	r0, {}
    18f0:	38000016 	stmdacc	r0, {r1, r2, r4}
    18f4:	01000016 	tsteq	r0, r6, lsl r0
    18f8:	00005300 	andeq	r5, r0, r0, lsl #6
    18fc:	00000000 	andeq	r0, r0, r0
    1900:	16140000 	ldrne	r0, [r4], -r0
    1904:	165c0000 	ldrbne	r0, [ip], -r0
    1908:	00010000 	andeq	r0, r1, r0
    190c:	00000052 	andeq	r0, r0, r2, asr r0
    1910:	00000000 	andeq	r0, r0, r0
    1914:	00162000 	andseq	r2, r6, r0
    1918:	00165c00 	andseq	r5, r6, r0, lsl #24
    191c:	5a000100 	bpl	1d24 <DISABLE_IRQ+0x1ca4>
	...
    1928:	0000167c 	andeq	r1, r0, ip, ror r6
    192c:	00001680 	andeq	r1, r0, r0, lsl #13
    1930:	805d0001 	subshi	r0, sp, r1
    1934:	88000016 	stmdahi	r0, {r1, r2, r4}
    1938:	02000016 	andeq	r0, r0, #22
    193c:	88087d00 	stmdahi	r8, {r8, sl, fp, ip, sp, lr}
    1940:	00000016 	andeq	r0, r0, r6, lsl r0
    1944:	02000017 	andeq	r0, r0, #23
    1948:	00107d00 	andseq	r7, r0, r0, lsl #26
    194c:	00000000 	andeq	r0, r0, r0
    1950:	7c000000 	stcvc	0, cr0, [r0], {0}
    1954:	8c000016 	stchi	0, cr0, [r0], {22}
    1958:	01000016 	tsteq	r0, r6, lsl r0
    195c:	168c5000 	strne	r5, [ip], r0
    1960:	17000000 	strne	r0, [r0, -r0]
    1964:	00010000 	andeq	r0, r1, r0
    1968:	00000054 	andeq	r0, r0, r4, asr r0
    196c:	00000000 	andeq	r0, r0, r0
    1970:	00167c00 	andseq	r7, r6, r0, lsl #24
    1974:	0016bc00 	andseq	fp, r6, r0, lsl #24
    1978:	51000100 	tstpl	r0, r0, lsl #2
    197c:	000016d0 	ldrdeq	r1, [r0], -r0
    1980:	000016f8 	strdeq	r1, [r0], -r8
    1984:	00510001 	subseq	r0, r1, r1
    1988:	00000000 	andeq	r0, r0, r0
    198c:	cc000000 	stcgt	0, cr0, [r0], {0}
    1990:	f8000016 	undefined instruction 0xf8000016
    1994:	01000016 	tsteq	r0, r6, lsl r0
    1998:	00005e00 	andeq	r5, r0, r0, lsl #28
    199c:	00000000 	andeq	r0, r0, r0
    19a0:	16d40000 	ldrbne	r0, [r4], r0
    19a4:	16f80000 	ldrbtne	r0, [r8], r0
    19a8:	00010000 	andeq	r0, r1, r0
    19ac:	0000005c 	andeq	r0, r0, ip, asr r0
    19b0:	00000000 	andeq	r0, r0, r0
    19b4:	00170000 	andseq	r0, r7, r0
    19b8:	00170400 	andseq	r0, r7, r0, lsl #8
    19bc:	5d000100 	stfpls	f0, [r0]
    19c0:	00001704 	andeq	r1, r0, r4, lsl #14
    19c4:	00001798 	muleq	r0, r8, r7
    19c8:	107d0002 	rsbsne	r0, sp, r2
	...
    19d4:	00001700 	andeq	r1, r0, r0, lsl #14
    19d8:	0000171c 	andeq	r1, r0, ip, lsl r7
    19dc:	1c500001 	mrrcne	0, 0, r0, r0, cr1
    19e0:	98000017 	stmdals	r0, {r0, r1, r2, r4}
    19e4:	01000017 	tsteq	r0, r7, lsl r0
    19e8:	00005600 	andeq	r5, r0, r0, lsl #12
    19ec:	00000000 	andeq	r0, r0, r0
    19f0:	171c0000 	ldrne	r0, [ip, -r0]
    19f4:	17280000 	strne	r0, [r8, -r0]!
    19f8:	00010000 	andeq	r0, r1, r0
    19fc:	00177051 	andseq	r7, r7, r1, asr r0
    1a00:	00178800 	andseq	r8, r7, r0, lsl #16
    1a04:	51000100 	tstpl	r0, r0, lsl #2
	...
    1a10:	00001798 	muleq	r0, r8, r7
    1a14:	0000179c 	muleq	r0, ip, r7
    1a18:	9c5d0001 	mrrcls	0, 0, r0, sp, cr1
    1a1c:	d8000017 	stmdale	r0, {r0, r1, r2, r4}
    1a20:	02000017 	andeq	r0, r0, #23
    1a24:	00107d00 	andseq	r7, r0, r0, lsl #26
    1a28:	00000000 	andeq	r0, r0, r0
    1a2c:	98000000 	stmdals	r0, {}
    1a30:	a4000017 	strge	r0, [r0], #-23
    1a34:	01000017 	tsteq	r0, r7, lsl r0
    1a38:	17a45000 	strne	r5, [r4, r0]!
    1a3c:	17d80000 	ldrbne	r0, [r8, r0]
    1a40:	00010000 	andeq	r0, r1, r0
    1a44:	00000055 	andeq	r0, r0, r5, asr r0
    1a48:	00000000 	andeq	r0, r0, r0
    1a4c:	0017a800 	andseq	sl, r7, r0, lsl #16
    1a50:	0017b400 	andseq	fp, r7, r0, lsl #8
    1a54:	54000100 	strpl	r0, [r0], #-256	; 0x100
    1a58:	000017cc 	andeq	r1, r0, ip, asr #15
    1a5c:	000017d8 	ldrdeq	r1, [r0], -r8
    1a60:	00540001 	subseq	r0, r4, r1
    1a64:	00000000 	andeq	r0, r0, r0
    1a68:	d8000000 	stmdale	r0, {}
    1a6c:	dc000017 	stcle	0, cr0, [r0], {23}
    1a70:	01000017 	tsteq	r0, r7, lsl r0
    1a74:	17dc5d00 	ldrbne	r5, [ip, r0, lsl #26]
    1a78:	18380000 	ldmdane	r8!, {}
    1a7c:	00020000 	andeq	r0, r2, r0
    1a80:	0000107d 	andeq	r1, r0, sp, ror r0
    1a84:	00000000 	andeq	r0, r0, r0
    1a88:	17d80000 	ldrbne	r0, [r8, r0]
    1a8c:	17fc0000 	ldrbne	r0, [ip, r0]!
    1a90:	00010000 	andeq	r0, r1, r0
    1a94:	0017fc50 	andseq	pc, r7, r0, asr ip
    1a98:	00181000 	andseq	r1, r8, r0
    1a9c:	54000100 	strpl	r0, [r0], #-256	; 0x100
    1aa0:	00001810 	andeq	r1, r0, r0, lsl r8
    1aa4:	00001818 	andeq	r1, r0, r8, lsl r8
    1aa8:	18500001 	ldmdane	r0, {r0}^
    1aac:	20000018 	andcs	r0, r0, r8, lsl r0
    1ab0:	01000018 	tsteq	r0, r8, lsl r0
    1ab4:	18205400 	stmdane	r0!, {sl, ip, lr}
    1ab8:	18240000 	stmdane	r4!, {}
    1abc:	00010000 	andeq	r0, r1, r0
    1ac0:	00182850 	andseq	r2, r8, r0, asr r8
    1ac4:	00183800 	andseq	r3, r8, r0, lsl #16
    1ac8:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    1ad4:	000017d8 	ldrdeq	r1, [r0], -r8
    1ad8:	000017ec 	andeq	r1, r0, ip, ror #15
    1adc:	ec510001 	mrrc	0, 0, r0, r1, cr1
    1ae0:	38000017 	stmdacc	r0, {r0, r1, r2, r4}
    1ae4:	01000018 	tsteq	r0, r8, lsl r0
    1ae8:	00005500 	andeq	r5, r0, r0, lsl #10
    1aec:	00000000 	andeq	r0, r0, r0
    1af0:	18380000 	ldmdane	r8!, {}
    1af4:	183c0000 	ldmdane	ip!, {}
    1af8:	00010000 	andeq	r0, r1, r0
    1afc:	00183c5d 	andseq	r3, r8, sp, asr ip
    1b00:	00186000 	andseq	r6, r8, r0
    1b04:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    1b08:	00000008 	andeq	r0, r0, r8
    1b0c:	00000000 	andeq	r0, r0, r0
    1b10:	00186000 	andseq	r6, r8, r0
    1b14:	00186400 	andseq	r6, r8, r0, lsl #8
    1b18:	5d000100 	stfpls	f0, [r0]
    1b1c:	00001864 	andeq	r1, r0, r4, ror #16
    1b20:	00001950 	andeq	r1, r0, r0, asr r9
    1b24:	107d0002 	rsbsne	r0, sp, r2
	...
    1b30:	00001860 	andeq	r1, r0, r0, ror #16
    1b34:	00001874 	andeq	r1, r0, r4, ror r8
    1b38:	74500001 	ldrbvc	r0, [r0], #-1
    1b3c:	cc000018 	stcgt	0, cr0, [r0], {24}
    1b40:	01000018 	tsteq	r0, r8, lsl r0
    1b44:	18f45400 	ldmne	r4!, {sl, ip, lr}^
    1b48:	190c0000 	stmdbne	ip, {}
    1b4c:	00010000 	andeq	r0, r1, r0
    1b50:	00192054 	andseq	r2, r9, r4, asr r0
    1b54:	00192400 	andseq	r2, r9, r0, lsl #8
    1b58:	54000100 	strpl	r0, [r0], #-256	; 0x100
    1b5c:	00001928 	andeq	r1, r0, r8, lsr #18
    1b60:	00001950 	andeq	r1, r0, r0, asr r9
    1b64:	00540001 	subseq	r0, r4, r1
    1b68:	00000000 	andeq	r0, r0, r0
    1b6c:	60000000 	andvs	r0, r0, r0
    1b70:	74000018 	strvc	r0, [r0], #-24
    1b74:	01000018 	tsteq	r0, r8, lsl r0
    1b78:	18745100 	ldmdane	r4!, {r8, ip, lr}^
    1b7c:	18a80000 	stmiane	r8!, {}
    1b80:	00010000 	andeq	r0, r1, r0
    1b84:	0018f456 	andseq	pc, r8, r6, asr r4
    1b88:	00190c00 	andseq	r0, r9, r0, lsl #24
    1b8c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    1b90:	00001928 	andeq	r1, r0, r8, lsr #18
    1b94:	00001950 	andeq	r1, r0, r0, asr r9
    1b98:	00560001 	subseq	r0, r6, r1
    1b9c:	00000000 	andeq	r0, r0, r0
    1ba0:	60000000 	andvs	r0, r0, r0
    1ba4:	74000018 	strvc	r0, [r0], #-24
    1ba8:	01000018 	tsteq	r0, r8, lsl r0
    1bac:	18745200 	ldmdane	r4!, {r9, ip, lr}^
    1bb0:	19500000 	ldmdbne	r0, {}^
    1bb4:	00010000 	andeq	r0, r1, r0
    1bb8:	00000055 	andeq	r0, r0, r5, asr r0
    1bbc:	00000000 	andeq	r0, r0, r0
    1bc0:	0018ac00 	andseq	sl, r8, r0, lsl #24
    1bc4:	0018b800 	andseq	fp, r8, r0, lsl #16
    1bc8:	51000100 	tstpl	r0, r0, lsl #2
    1bcc:	000018c0 	andeq	r1, r0, r0, asr #17
    1bd0:	000018f0 	strdeq	r1, [r0], -r0
    1bd4:	0c510001 	mrrceq	0, 0, r0, r1, cr1
    1bd8:	14000019 	strne	r0, [r0], #-25
    1bdc:	01000019 	tsteq	r0, r9, lsl r0
    1be0:	19205100 	stmdbne	r0!, {r8, ip, lr}
    1be4:	19280000 	stmdbne	r8!, {}
    1be8:	00010000 	andeq	r0, r1, r0
    1bec:	00000051 	andeq	r0, r0, r1, asr r0
    1bf0:	00000000 	andeq	r0, r0, r0
    1bf4:	00187c00 	andseq	r7, r8, r0, lsl #24
    1bf8:	0018f000 	andseq	pc, r8, r0
    1bfc:	52000100 	andpl	r0, r0, #0
    1c00:	000018fc 	strdeq	r1, [r0], -ip
    1c04:	00001900 	andeq	r1, r0, r0, lsl #18
    1c08:	0c520001 	mrrceq	0, 0, r0, r2, cr1
    1c0c:	14000019 	strne	r0, [r0], #-25
    1c10:	01000019 	tsteq	r0, r9, lsl r0
    1c14:	19205200 	stmdbne	r0!, {r9, ip, lr}
    1c18:	192c0000 	stmdbne	ip!, {}
    1c1c:	00010000 	andeq	r0, r1, r0
    1c20:	00193052 	andseq	r3, r9, r2, asr r0
    1c24:	00193400 	andseq	r3, r9, r0, lsl #8
    1c28:	52000100 	andpl	r0, r0, #0
    1c2c:	00001940 	andeq	r1, r0, r0, asr #18
    1c30:	00001944 	andeq	r1, r0, r4, asr #18
    1c34:	00520001 	subseq	r0, r2, r1
    1c38:	00000000 	andeq	r0, r0, r0
    1c3c:	cc000000 	stcgt	0, cr0, [r0], {0}
    1c40:	fc000018 	stc2	0, cr0, [r0], {24}
    1c44:	01000018 	tsteq	r0, r8, lsl r0
    1c48:	190c5400 	stmdbne	ip, {sl, ip, lr}
    1c4c:	19200000 	stmdbne	r0!, {}
    1c50:	00010000 	andeq	r0, r1, r0
    1c54:	00192454 	andseq	r2, r9, r4, asr r4
    1c58:	00192800 	andseq	r2, r9, r0, lsl #16
    1c5c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    1c68:	00001950 	andeq	r1, r0, r0, asr r9
    1c6c:	00001954 	andeq	r1, r0, r4, asr r9
    1c70:	545d0001 	ldrbpl	r0, [sp], #-1
    1c74:	20000019 	andcs	r0, r0, r9, lsl r0
    1c78:	0200001a 	andeq	r0, r0, #26
    1c7c:	00187d00 	andseq	r7, r8, r0, lsl #26
    1c80:	00000000 	andeq	r0, r0, r0
    1c84:	50000000 	andpl	r0, r0, r0
    1c88:	64000019 	strvs	r0, [r0], #-25
    1c8c:	01000019 	tsteq	r0, r9, lsl r0
    1c90:	19645000 	stmdbne	r4!, {ip, lr}^
    1c94:	19980000 	ldmibne	r8, {}
    1c98:	00010000 	andeq	r0, r1, r0
    1c9c:	0019a054 	andseq	sl, r9, r4, asr r0
    1ca0:	0019a400 	andseq	sl, r9, r0, lsl #8
    1ca4:	54000100 	strpl	r0, [r0], #-256	; 0x100
    1ca8:	000019d0 	ldrdeq	r1, [r0], -r0
    1cac:	000019ec 	andeq	r1, r0, ip, ror #19
    1cb0:	f0540001 	undefined instruction 0xf0540001
    1cb4:	f4000019 	vst4.8	{d0-d3}, [r0, :64], r9
    1cb8:	01000019 	tsteq	r0, r9, lsl r0
    1cbc:	19fc5400 	ldmibne	ip!, {sl, ip, lr}^
    1cc0:	1a1c0000 	bne	701cc8 <DISABLE_IRQ+0x701c48>
    1cc4:	00010000 	andeq	r0, r1, r0
    1cc8:	00000054 	andeq	r0, r0, r4, asr r0
    1ccc:	00000000 	andeq	r0, r0, r0
    1cd0:	00195000 	andseq	r5, r9, r0
    1cd4:	00196400 	andseq	r6, r9, r0, lsl #8
    1cd8:	51000100 	tstpl	r0, r0, lsl #2
    1cdc:	00001964 	andeq	r1, r0, r4, ror #18
    1ce0:	00001a20 	andeq	r1, r0, r0, lsr #20
    1ce4:	00560001 	subseq	r0, r6, r1
    1ce8:	00000000 	andeq	r0, r0, r0
    1cec:	50000000 	andpl	r0, r0, r0
    1cf0:	64000019 	strvs	r0, [r0], #-25
    1cf4:	01000019 	tsteq	r0, r9, lsl r0
    1cf8:	19645200 	stmdbne	r4!, {r9, ip, lr}^
    1cfc:	1a200000 	bne	801d04 <MEM_SIZE+0x1d04>
    1d00:	00010000 	andeq	r0, r1, r0
    1d04:	00000055 	andeq	r0, r0, r5, asr r0
    1d08:	00000000 	andeq	r0, r0, r0
    1d0c:	00199800 	andseq	r9, r9, r0, lsl #16
    1d10:	0019b000 	andseq	fp, r9, r0
    1d14:	54000100 	strpl	r0, [r0], #-256	; 0x100
    1d18:	000019b8 	undefined instruction 0x000019b8
    1d1c:	000019dc 	ldrdeq	r1, [r0], -ip
    1d20:	ec540001 	mrrc	0, 0, r0, r4, cr1
    1d24:	f0000019 	undefined instruction 0xf0000019
    1d28:	01000019 	tsteq	r0, r9, lsl r0
    1d2c:	19f45400 	ldmibne	r4!, {sl, ip, lr}^
    1d30:	19fc0000 	ldmibne	ip!, {}^
    1d34:	00010000 	andeq	r0, r1, r0
    1d38:	001a1c54 	andseq	r1, sl, r4, asr ip
    1d3c:	001a2000 	andseq	r2, sl, r0
    1d40:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    1d4c:	0000196c 	andeq	r1, r0, ip, ror #18
    1d50:	000019cc 	andeq	r1, r0, ip, asr #19
    1d54:	dc520001 	mrrcle	0, 0, r0, r2, cr1
    1d58:	e0000019 	and	r0, r0, r9, lsl r0
    1d5c:	01000019 	tsteq	r0, r9, lsl r0
    1d60:	19f05200 	ldmibne	r0!, {r9, ip, lr}^
    1d64:	19f80000 	ldmibne	r8!, {}^
    1d68:	00010000 	andeq	r0, r1, r0
    1d6c:	0019fc52 	andseq	pc, r9, r2, asr ip
    1d70:	001a0000 	andseq	r0, sl, r0
    1d74:	52000100 	andpl	r0, r0, #0
    1d78:	00001a0c 	andeq	r1, r0, ip, lsl #20
    1d7c:	00001a10 	andeq	r1, r0, r0, lsl sl
    1d80:	00520001 	subseq	r0, r2, r1
    1d84:	00000000 	andeq	r0, r0, r0
    1d88:	20000000 	andcs	r0, r0, r0
    1d8c:	2400001a 	strcs	r0, [r0], #-26
    1d90:	0100001a 	tsteq	r0, sl, lsl r0
    1d94:	1a245d00 	bne	91919c <MEM_SIZE+0x11919c>
    1d98:	1ab40000 	bne	fed01da0 <rEINTPEND+0xa8d01cf8>
    1d9c:	00020000 	andeq	r0, r2, r0
    1da0:	0000187d 	andeq	r1, r0, sp, ror r8
    1da4:	00000000 	andeq	r0, r0, r0
    1da8:	1a200000 	bne	801db0 <MEM_SIZE+0x1db0>
    1dac:	1a340000 	bne	d01db4 <MEM_SIZE+0x501db4>
    1db0:	00010000 	andeq	r0, r1, r0
    1db4:	001a3450 	andseq	r3, sl, r0, asr r4
    1db8:	001ab400 	andseq	fp, sl, r0, lsl #8
    1dbc:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    1dc8:	00001a20 	andeq	r1, r0, r0, lsr #20
    1dcc:	00001a34 	andeq	r1, r0, r4, lsr sl
    1dd0:	34510001 	ldrbcc	r0, [r1], #-1
    1dd4:	b400001a 	strlt	r0, [r0], #-26
    1dd8:	0100001a 	tsteq	r0, sl, lsl r0
    1ddc:	00005600 	andeq	r5, r0, r0, lsl #12
    1de0:	00000000 	andeq	r0, r0, r0
    1de4:	1ab40000 	bne	fed01dec <rEINTPEND+0xa8d01d44>
    1de8:	1ab80000 	bne	fee01df0 <rEINTPEND+0xa8e01d48>
    1dec:	00010000 	andeq	r0, r1, r0
    1df0:	001ab85d 	andseq	fp, sl, sp, asr r8
    1df4:	001be800 	andseq	lr, fp, r0, lsl #16
    1df8:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    1dfc:	00000018 	andeq	r0, r0, r8, lsl r0
    1e00:	00000000 	andeq	r0, r0, r0
    1e04:	001ab400 	andseq	fp, sl, r0, lsl #8
    1e08:	001ad000 	andseq	sp, sl, r0
    1e0c:	50000100 	andpl	r0, r0, r0, lsl #2
    1e10:	00001ad0 	ldrdeq	r1, [r0], -r0
    1e14:	00001ae4 	andeq	r1, r0, r4, ror #21
    1e18:	e4540001 	ldrb	r0, [r4], #-1
    1e1c:	fc00001a 	stc2	0, cr0, [r0], {26}
    1e20:	0100001a 	tsteq	r0, sl, lsl r0
    1e24:	1afc5000 	bne	fff15e2c <rEINTPEND+0xa9f15d84>
    1e28:	1b080000 	blne	201e30 <DISABLE_IRQ+0x201db0>
    1e2c:	00010000 	andeq	r0, r1, r0
    1e30:	001b0854 	andseq	r0, fp, r4, asr r8
    1e34:	001b2000 	andseq	r2, fp, r0
    1e38:	50000100 	andpl	r0, r0, r0, lsl #2
    1e3c:	00001b20 	andeq	r1, r0, r0, lsr #22
    1e40:	00001be8 	andeq	r1, r0, r8, ror #23
    1e44:	00540001 	subseq	r0, r4, r1
    1e48:	00000000 	andeq	r0, r0, r0
    1e4c:	b4000000 	strlt	r0, [r0]
    1e50:	d000001a 	andle	r0, r0, sl, lsl r0
    1e54:	0100001a 	tsteq	r0, sl, lsl r0
    1e58:	1ad05100 	bne	ff416260 <rEINTPEND+0xa94161b8>
    1e5c:	1be80000 	blne	ffa01e64 <rEINTPEND+0xa9a01dbc>
    1e60:	00010000 	andeq	r0, r1, r0
    1e64:	00000056 	andeq	r0, r0, r6, asr r0
    1e68:	00000000 	andeq	r0, r0, r0
    1e6c:	001ab400 	andseq	fp, sl, r0, lsl #8
    1e70:	001b1400 	andseq	r1, fp, r0, lsl #8
    1e74:	52000100 	andpl	r0, r0, #0
    1e78:	00001b14 	andeq	r1, r0, r4, lsl fp
    1e7c:	00001b44 	andeq	r1, r0, r4, asr #22
    1e80:	5c570001 	mrrcpl	0, 0, r0, r7, cr1
    1e84:	6400001b 	strvs	r0, [r0], #-27
    1e88:	0100001b 	tsteq	r0, fp, lsl r0
    1e8c:	1b7c5700 	blne	1f17a94 <MEM_SIZE+0x1717a94>
    1e90:	1b840000 	blne	fe101e98 <rEINTPEND+0xa8101df0>
    1e94:	00010000 	andeq	r0, r1, r0
    1e98:	001ba057 	andseq	sl, fp, r7, asr r0
    1e9c:	001bb000 	andseq	fp, fp, r0
    1ea0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    1ea4:	00001bb4 	undefined instruction 0x00001bb4
    1ea8:	00001bbc 	undefined instruction 0x00001bbc
    1eac:	00570001 	subseq	r0, r7, r1
    1eb0:	00000000 	andeq	r0, r0, r0
    1eb4:	b4000000 	strlt	r0, [r0]
    1eb8:	d000001a 	andle	r0, r0, sl, lsl r0
    1ebc:	0100001a 	tsteq	r0, sl, lsl r0
    1ec0:	1ad05300 	bne	ff416ac8 <rEINTPEND+0xa9416a20>
    1ec4:	1be80000 	blne	ffa01ecc <rEINTPEND+0xa9a01e24>
    1ec8:	00010000 	andeq	r0, r1, r0
    1ecc:	00000055 	andeq	r0, r0, r5, asr r0
    1ed0:	00000000 	andeq	r0, r0, r0
    1ed4:	001acc00 	andseq	ip, sl, r0, lsl #24
    1ed8:	001b1400 	andseq	r1, fp, r0, lsl #8
    1edc:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    1ee0:	00001b44 	andeq	r1, r0, r4, asr #22
    1ee4:	00001b5c 	andeq	r1, r0, ip, asr fp
    1ee8:	64570001 	ldrbvs	r0, [r7], #-1
    1eec:	7c00001b 	stcvc	0, cr0, [r0], {27}
    1ef0:	0100001b 	tsteq	r0, fp, lsl r0
    1ef4:	1b845700 	blne	fe117afc <rEINTPEND+0xa8117a54>
    1ef8:	1ba00000 	blne	fe801f00 <rEINTPEND+0xa8801e58>
    1efc:	00010000 	andeq	r0, r1, r0
    1f00:	001bb057 	andseq	fp, fp, r7, asr r0
    1f04:	001bb400 	andseq	fp, fp, r0, lsl #8
    1f08:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    1f0c:	00001bbc 	undefined instruction 0x00001bbc
    1f10:	00001be8 	andeq	r1, r0, r8, ror #23
    1f14:	00570001 	subseq	r0, r7, r1
    1f18:	00000000 	andeq	r0, r0, r0
    1f1c:	fc000000 	stc2	0, cr0, [r0], {0}
    1f20:	0800001a 	stmdaeq	r0, {r1, r3, r4}
    1f24:	0100001b 	tsteq	r0, fp, lsl r0
    1f28:	1b1c5800 	blne	717f30 <DISABLE_IRQ+0x717eb0>
    1f2c:	1be80000 	blne	ffa01f34 <rEINTPEND+0xa9a01e8c>
    1f30:	00010000 	andeq	r0, r1, r0
    1f34:	00000058 	andeq	r0, r0, r8, asr r0
    1f38:	00000000 	andeq	r0, r0, r0
    1f3c:	001be800 	andseq	lr, fp, r0, lsl #16
    1f40:	001bec00 	andseq	lr, fp, r0, lsl #24
    1f44:	5d000100 	stfpls	f0, [r0]
    1f48:	00001bec 	andeq	r1, r0, ip, ror #23
    1f4c:	00001c40 	andeq	r1, r0, r0, asr #24
    1f50:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    1f5c:	00001c40 	andeq	r1, r0, r0, asr #24
    1f60:	00001c44 	andeq	r1, r0, r4, asr #24
    1f64:	445d0001 	ldrbmi	r0, [sp], #-1
    1f68:	0400001c 	streq	r0, [r0], #-28
    1f6c:	0200001d 	andeq	r0, r0, #29
    1f70:	00107d00 	andseq	r7, r0, r0, lsl #26
    1f74:	00000000 	andeq	r0, r0, r0
    1f78:	40000000 	andmi	r0, r0, r0
    1f7c:	5400001c 	strpl	r0, [r0], #-28
    1f80:	0100001c 	tsteq	r0, ip, lsl r0
    1f84:	1c545000 	mrane	r5, r4, acc0
    1f88:	1c640000 	stclne	0, cr0, [r4]
    1f8c:	00010000 	andeq	r0, r1, r0
    1f90:	001c6454 	andseq	r6, ip, r4, asr r4
    1f94:	001c9000 	andseq	r9, ip, r0
    1f98:	50000100 	andpl	r0, r0, r0, lsl #2
    1f9c:	00001c90 	muleq	r0, r0, ip
    1fa0:	00001cc0 	andeq	r1, r0, r0, asr #25
    1fa4:	e4540001 	ldrb	r0, [r4], #-1
    1fa8:	ec00001c 	stc	0, cr0, [r0], {28}
    1fac:	0100001c 	tsteq	r0, ip, lsl r0
    1fb0:	1cfc5400 	cfldrdne	mvd5, [ip]
    1fb4:	1d000000 	stcne	0, cr0, [r0]
    1fb8:	00010000 	andeq	r0, r1, r0
    1fbc:	00000054 	andeq	r0, r0, r4, asr r0
    1fc0:	00000000 	andeq	r0, r0, r0
    1fc4:	001c4000 	andseq	r4, ip, r0
    1fc8:	001c5400 	andseq	r5, ip, r0, lsl #8
    1fcc:	51000100 	tstpl	r0, r0, lsl #2
    1fd0:	00001c54 	andeq	r1, r0, r4, asr ip
    1fd4:	00001c74 	andeq	r1, r0, r4, ror ip
    1fd8:	74560001 	ldrbvc	r0, [r6], #-1
    1fdc:	9000001c 	andls	r0, r0, ip, lsl r0
    1fe0:	0100001c 	tsteq	r0, ip, lsl r0
    1fe4:	1c905100 	ldfnes	f5, [r0], {0}
    1fe8:	1ca00000 	stcne	0, cr0, [r0]
    1fec:	00010000 	andeq	r0, r1, r0
    1ff0:	001cd456 	andseq	sp, ip, r6, asr r4
    1ff4:	001cd800 	andseq	sp, ip, r0, lsl #16
    1ff8:	56000100 	strpl	r0, [r0], -r0, lsl #2
    1ffc:	00001ce4 	andeq	r1, r0, r4, ror #25
    2000:	00001cec 	andeq	r1, r0, ip, ror #25
    2004:	fc560001 	mrrc2	0, 0, r0, r6, cr1
    2008:	0400001c 	streq	r0, [r0], #-28
    200c:	0100001d 	tsteq	r0, sp, lsl r0
    2010:	00005600 	andeq	r5, r0, r0, lsl #12
    2014:	00000000 	andeq	r0, r0, r0
    2018:	1c400000 	marne	acc0, r0, r0
    201c:	1c540000 	mrane	r0, r4, acc0
    2020:	00010000 	andeq	r0, r1, r0
    2024:	001c5452 	andseq	r5, ip, r2, asr r4
    2028:	001d0400 	andseq	r0, sp, r0, lsl #8
    202c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    2038:	00001ca4 	andeq	r1, r0, r4, lsr #25
    203c:	00001cac 	andeq	r1, r0, ip, lsr #25
    2040:	b4520001 	ldrblt	r0, [r2], #-1
    2044:	e000001c 	and	r0, r0, ip, lsl r0
    2048:	0100001c 	tsteq	r0, ip, lsl r0
    204c:	1cec5200 	sfmne	f5, 2, [ip]	; (stclne 2, cr5, [ip])
    2050:	1cf00000 	ldclne	0, cr0, [r0]
    2054:	00010000 	andeq	r0, r1, r0
    2058:	00000052 	andeq	r0, r0, r2, asr r0
    205c:	00000000 	andeq	r0, r0, r0
    2060:	001cc000 	andseq	ip, ip, r0
    2064:	001cfc00 	andseq	pc, ip, r0, lsl #24
    2068:	54000100 	strpl	r0, [r0], #-256	; 0x100
    206c:	00001d00 	andeq	r1, r0, r0, lsl #26
    2070:	00001d04 	andeq	r1, r0, r4, lsl #26
    2074:	00540001 	subseq	r0, r4, r1
    2078:	00000000 	andeq	r0, r0, r0
    207c:	04000000 	streq	r0, [r0]
    2080:	0800001d 	stmdaeq	r0, {r0, r2, r3, r4}
    2084:	0100001d 	tsteq	r0, sp, lsl r0
    2088:	1d085d00 	stcne	13, cr5, [r8]
    208c:	1dac0000 	stcne	0, cr0, [ip]
    2090:	00020000 	andeq	r0, r2, r0
    2094:	0000187d 	andeq	r1, r0, sp, ror r8
    2098:	00000000 	andeq	r0, r0, r0
    209c:	1d040000 	stcne	0, cr0, [r4]
    20a0:	1d2c0000 	stcne	0, cr0, [ip]
    20a4:	00010000 	andeq	r0, r1, r0
    20a8:	001d2c50 	andseq	r2, sp, r0, asr ip
    20ac:	001d3c00 	andseq	r3, sp, r0, lsl #24
    20b0:	54000100 	strpl	r0, [r0], #-256	; 0x100
    20b4:	00001d3c 	andeq	r1, r0, ip, lsr sp
    20b8:	00001d60 	andeq	r1, r0, r0, ror #26
    20bc:	64500001 	ldrbvs	r0, [r0], #-1
    20c0:	6c00001d 	stcvs	0, cr0, [r0], {29}
    20c4:	0100001d 	tsteq	r0, sp, lsl r0
    20c8:	1d745400 	cfldrdne	mvd5, [r4]
    20cc:	1d780000 	ldclne	0, cr0, [r8]
    20d0:	00010000 	andeq	r0, r1, r0
    20d4:	001da054 	andseq	sl, sp, r4, asr r0
    20d8:	001da400 	andseq	sl, sp, r0, lsl #8
    20dc:	50000100 	andpl	r0, r0, r0, lsl #2
    20e0:	00001da4 	andeq	r1, r0, r4, lsr #27
    20e4:	00001dac 	andeq	r1, r0, ip, lsr #27
    20e8:	00540001 	subseq	r0, r4, r1
    20ec:	00000000 	andeq	r0, r0, r0
    20f0:	04000000 	streq	r0, [r0]
    20f4:	1c00001d 	stcne	0, cr0, [r0], {29}
    20f8:	0100001d 	tsteq	r0, sp, lsl r0
    20fc:	1d1c5100 	ldfnes	f5, [ip]
    2100:	1d400000 	stclne	0, cr0, [r0]
    2104:	00010000 	andeq	r0, r1, r0
    2108:	001d4056 	andseq	r4, sp, r6, asr r0
    210c:	001d6000 	andseq	r6, sp, r0
    2110:	51000100 	tstpl	r0, r0, lsl #2
    2114:	00001d60 	andeq	r1, r0, r0, ror #26
    2118:	00001dac 	andeq	r1, r0, ip, lsr #27
    211c:	00560001 	subseq	r0, r6, r1
    2120:	00000000 	andeq	r0, r0, r0
    2124:	04000000 	streq	r0, [r0]
    2128:	1c00001d 	stcne	0, cr0, [r0], {29}
    212c:	0100001d 	tsteq	r0, sp, lsl r0
    2130:	1d1c5200 	lfmne	f5, 4, [ip]	; (ldcne 2, cr5, [ip])
    2134:	1dac0000 	stcne	0, cr0, [ip]
    2138:	00010000 	andeq	r0, r1, r0
    213c:	00000055 	andeq	r0, r0, r5, asr r0
    2140:	00000000 	andeq	r0, r0, r0
    2144:	001d1800 	andseq	r1, sp, r0, lsl #16
    2148:	001d8400 	andseq	r8, sp, r0, lsl #8
    214c:	54000100 	strpl	r0, [r0], #-256	; 0x100
    2150:	00001d8c 	andeq	r1, r0, ip, lsl #27
    2154:	00001dac 	andeq	r1, r0, ip, lsr #27
    2158:	00540001 	subseq	r0, r4, r1
    215c:	00000000 	andeq	r0, r0, r0
    2160:	ac000000 	stcge	0, cr0, [r0], {0}
    2164:	b000001d 	andlt	r0, r0, sp, lsl r0
    2168:	0100001d 	tsteq	r0, sp, lsl r0
    216c:	1db05d00 	ldcne	13, cr5, [r0]
    2170:	1f100000 	svcne	0x00100000
    2174:	00020000 	andeq	r0, r2, r0
    2178:	0000207d 	andeq	r2, r0, sp, ror r0
    217c:	00000000 	andeq	r0, r0, r0
    2180:	1dac0000 	stcne	0, cr0, [ip]
    2184:	1dc80000 	stclne	0, cr0, [r8]
    2188:	00010000 	andeq	r0, r1, r0
    218c:	001dc850 	andseq	ip, sp, r0, asr r8
    2190:	001ec800 	andseq	ip, lr, r0, lsl #16
    2194:	54000100 	strpl	r0, [r0], #-256	; 0x100
    2198:	00001ee4 	andeq	r1, r0, r4, ror #29
    219c:	00001f10 	andeq	r1, r0, r0, lsl pc
    21a0:	00540001 	subseq	r0, r4, r1
    21a4:	00000000 	andeq	r0, r0, r0
    21a8:	ac000000 	stcge	0, cr0, [r0], {0}
    21ac:	c800001d 	stmdagt	r0, {r0, r2, r3, r4}
    21b0:	0100001d 	tsteq	r0, sp, lsl r0
    21b4:	1dc85100 	stfnee	f5, [r8]
    21b8:	1f100000 	svcne	0x00100000
    21bc:	00010000 	andeq	r0, r1, r0
    21c0:	00000055 	andeq	r0, r0, r5, asr r0
    21c4:	00000000 	andeq	r0, r0, r0
    21c8:	001dac00 	andseq	sl, sp, r0, lsl #24
    21cc:	001dc800 	andseq	ip, sp, r0, lsl #16
    21d0:	52000100 	andpl	r0, r0, #0
    21d4:	00001dc8 	andeq	r1, r0, r8, asr #27
    21d8:	00001f10 	andeq	r1, r0, r0, lsl pc
    21dc:	00560001 	subseq	r0, r6, r1
    21e0:	00000000 	andeq	r0, r0, r0
    21e4:	ac000000 	stcge	0, cr0, [r0], {0}
    21e8:	c800001d 	stmdagt	r0, {r0, r2, r3, r4}
    21ec:	0100001d 	tsteq	r0, sp, lsl r0
    21f0:	1dc85300 	stclne	3, cr5, [r8]
    21f4:	1f100000 	svcne	0x00100000
    21f8:	00010000 	andeq	r0, r1, r0
    21fc:	0000005a 	andeq	r0, r0, sl, asr r0
    2200:	00000000 	andeq	r0, r0, r0
    2204:	001dac00 	andseq	sl, sp, r0, lsl #24
    2208:	001dc400 	andseq	ip, sp, r0, lsl #8
    220c:	91000200 	tstls	r0, r0, lsl #4
    2210:	001dc408 	andseq	ip, sp, r8, lsl #8
    2214:	001f1000 	andseq	r1, pc, r0
    2218:	59000100 	stmdbpl	r0, {r8}
	...
    2224:	00001f10 	andeq	r1, r0, r0, lsl pc
    2228:	00001f14 	andeq	r1, r0, r4, lsl pc
    222c:	145d0001 	ldrbne	r0, [sp], #-1
    2230:	3800001f 	stmdacc	r0, {r0, r1, r2, r3, r4}
    2234:	0200001f 	andeq	r0, r0, #31
    2238:	00087d00 	andeq	r7, r8, r0, lsl #26
    223c:	00000000 	andeq	r0, r0, r0
    2240:	10000000 	andne	r0, r0, r0
    2244:	1c00001f 	stcne	0, cr0, [r0], {31}
    2248:	0100001f 	tsteq	r0, pc, lsl r0
    224c:	00005000 	andeq	r5, r0, r0
    2250:	00000000 	andeq	r0, r0, r0
    2254:	1f380000 	svcne	0x00380000
    2258:	1f3c0000 	svcne	0x003c0000
    225c:	00010000 	andeq	r0, r1, r0
    2260:	001f3c5d 	andseq	r3, pc, sp, asr ip
    2264:	00200800 	eoreq	r0, r0, r0, lsl #16
    2268:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    226c:	00000008 	andeq	r0, r0, r8
    2270:	00000000 	andeq	r0, r0, r0
    2274:	001f7800 	andseq	r7, pc, r0, lsl #16
    2278:	001f8c00 	andseq	r8, pc, r0, lsl #24
    227c:	53000100 	movwpl	r0, #256	; 0x100
	...
    2288:	00002008 	andeq	r2, r0, r8
    228c:	00002010 	andeq	r2, r0, r0, lsl r0
    2290:	105d0001 	subsne	r0, sp, r1
    2294:	ec000020 	stc	0, cr0, [r0], {32}
    2298:	02000020 	andeq	r0, r0, #32
    229c:	00087d00 	andeq	r7, r8, r0, lsl #26
    22a0:	00000000 	andeq	r0, r0, r0
    22a4:	08000000 	stmdaeq	r0, {}
    22a8:	18000020 	stmdane	r0, {r5}
    22ac:	01000020 	tsteq	r0, r0, lsr #32
    22b0:	20185000 	andscs	r5, r8, r0
    22b4:	20540000 	subscs	r0, r4, r0
    22b8:	00010000 	andeq	r0, r1, r0
    22bc:	00208854 	eoreq	r8, r0, r4, asr r8
    22c0:	0020a000 	eoreq	sl, r0, r0
    22c4:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    22d0:	00002034 	andeq	r2, r0, r4, lsr r0
    22d4:	00002080 	andeq	r2, r0, r0, lsl #1
    22d8:	88530001 	ldmdahi	r3, {r0}^
    22dc:	8c000020 	stchi	0, cr0, [r0], {32}
    22e0:	01000020 	tsteq	r0, r0, lsr #32
    22e4:	20945300 	addscs	r5, r4, r0, lsl #6
    22e8:	20980000 	addscs	r0, r8, r0
    22ec:	00010000 	andeq	r0, r1, r0
    22f0:	0020a053 	eoreq	sl, r0, r3, asr r0
    22f4:	0020c000 	eoreq	ip, r0, r0
    22f8:	53000100 	movwpl	r0, #256	; 0x100
	...
    2304:	00002030 	andeq	r2, r0, r0, lsr r0
    2308:	00002080 	andeq	r2, r0, r0, lsl #1
    230c:	88510001 	ldmdahi	r1, {r0}^
    2310:	8c000020 	stchi	0, cr0, [r0], {32}
    2314:	01000020 	tsteq	r0, r0, lsr #32
    2318:	20945100 	addscs	r5, r4, r0, lsl #2
    231c:	20980000 	addscs	r0, r8, r0
    2320:	00010000 	andeq	r0, r1, r0
    2324:	0020a051 	eoreq	sl, r0, r1, asr r0
    2328:	0020d400 	eoreq	sp, r0, r0, lsl #8
    232c:	51000100 	tstpl	r0, r0, lsl #2
	...
    2338:	000020ec 	andeq	r2, r0, ip, ror #1
    233c:	000020f0 	strdeq	r2, [r0], -r0
    2340:	f05d0001 	undefined instruction 0xf05d0001
    2344:	58000020 	stmdapl	r0, {r5}
    2348:	02000021 	andeq	r0, r0, #33	; 0x21
    234c:	00087d00 	andeq	r7, r8, r0, lsl #26
    2350:	00000000 	andeq	r0, r0, r0
    2354:	ec000000 	stc	0, cr0, [r0], {0}
    2358:	f8000020 	undefined instruction 0xf8000020
    235c:	01000020 	tsteq	r0, r0, lsr #32
    2360:	20f85000 	rscscs	r5, r8, r0
    2364:	21580000 	cmpcs	r8, r0
    2368:	00010000 	andeq	r0, r1, r0
    236c:	00000054 	andeq	r0, r0, r4, asr r0
    2370:	00000000 	andeq	r0, r0, r0
    2374:	00215800 	eoreq	r5, r1, r0, lsl #16
    2378:	00216000 	eoreq	r6, r1, r0
    237c:	5d000100 	stfpls	f0, [r0]
    2380:	00002160 	andeq	r2, r0, r0, ror #2
    2384:	00002234 	andeq	r2, r0, r4, lsr r2
    2388:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    2394:	00002158 	andeq	r2, r0, r8, asr r1
    2398:	0000216c 	andeq	r2, r0, ip, ror #2
    239c:	70500001 	subsvc	r0, r0, r1
    23a0:	78000021 	stmdavc	r0, {r0, r5}
    23a4:	01000021 	tsteq	r0, r1, lsr #32
    23a8:	21905000 	orrscs	r5, r0, r0
    23ac:	21a80000 	undefined instruction 0x21a80000
    23b0:	00010000 	andeq	r0, r1, r0
    23b4:	0021c450 	eoreq	ip, r1, r0, asr r4
    23b8:	0021d400 	eoreq	sp, r1, r0, lsl #8
    23bc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    23c8:	00002158 	andeq	r2, r0, r8, asr r1
    23cc:	000021bc 	undefined instruction 0x000021bc
    23d0:	00510001 	subseq	r0, r1, r1
    23d4:	00000000 	andeq	r0, r0, r0
    23d8:	58000000 	stmdapl	r0, {}
    23dc:	c8000021 	stmdagt	r0, {r0, r5}
    23e0:	01000021 	tsteq	r0, r1, lsr #32
    23e4:	00005200 	andeq	r5, r0, r0, lsl #4
    23e8:	00000000 	andeq	r0, r0, r0
    23ec:	21580000 	cmpcs	r8, r0
    23f0:	21b80000 	undefined instruction 0x21b80000
    23f4:	00010000 	andeq	r0, r1, r0
    23f8:	00000053 	andeq	r0, r0, r3, asr r0
    23fc:	00000000 	andeq	r0, r0, r0
    2400:	0021f000 	eoreq	pc, r1, r0
    2404:	0021fc00 	eoreq	pc, r1, r0, lsl #24
    2408:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    2414:	00002188 	andeq	r2, r0, r8, lsl #3
    2418:	00002190 	muleq	r0, r0, r1
    241c:	fc540001 	mrrc2	0, 0, r0, r4, cr1
    2420:	10000021 	andne	r0, r0, r1, lsr #32
    2424:	01000022 	tsteq	r0, r2, lsr #32
    2428:	22245400 	eorcs	r5, r4, #0
    242c:	22340000 	eorscs	r0, r4, #0
    2430:	00010000 	andeq	r0, r1, r0
    2434:	00000054 	andeq	r0, r0, r4, asr r0
    2438:	00000000 	andeq	r0, r0, r0
    243c:	00223400 	eoreq	r3, r2, r0, lsl #8
    2440:	00223800 	eoreq	r3, r2, r0, lsl #16
    2444:	5d000100 	stfpls	f0, [r0]
    2448:	00002238 	andeq	r2, r0, r8, lsr r2
    244c:	000022f4 	strdeq	r2, [r0], -r4
    2450:	287d0002 	ldmdacs	sp!, {r1}^
	...
    245c:	00002234 	andeq	r2, r0, r4, lsr r2
    2460:	0000224c 	andeq	r2, r0, ip, asr #4
    2464:	5c500001 	mrrcpl	0, 0, r0, r0, cr1
    2468:	68000022 	stmdavs	r0, {r1, r5}
    246c:	01000022 	tsteq	r0, r2, lsr #32
    2470:	00005000 	andeq	r5, r0, r0
    2474:	00000000 	andeq	r0, r0, r0
    2478:	22800000 	addcs	r0, r0, #0
    247c:	22d40000 	sbcscs	r0, r4, #0
    2480:	00010000 	andeq	r0, r1, r0
    2484:	0022d854 	eoreq	sp, r2, r4, asr r8
    2488:	0022f400 	eoreq	pc, r2, r0, lsl #8
    248c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    2498:	000022f4 	strdeq	r2, [r0], -r4
    249c:	000022f8 	strdeq	r2, [r0], -r8
    24a0:	f85d0001 	undefined instruction 0xf85d0001
    24a4:	50000022 	andpl	r0, r0, r2, lsr #32
    24a8:	02000023 	andeq	r0, r0, #35	; 0x23
    24ac:	00087d00 	andeq	r7, r8, r0, lsl #26
    24b0:	00000000 	andeq	r0, r0, r0
    24b4:	50000000 	andpl	r0, r0, r0
    24b8:	58000023 	stmdapl	r0, {r0, r1, r5}
    24bc:	01000023 	tsteq	r0, r3, lsr #32
    24c0:	23585d00 	cmpcs	r8, #0
    24c4:	24500000 	ldrbcs	r0, [r0]
    24c8:	00020000 	andeq	r0, r2, r0
    24cc:	0000087d 	andeq	r0, r0, sp, ror r8
    24d0:	00000000 	andeq	r0, r0, r0
    24d4:	23500000 	cmpcs	r0, #0
    24d8:	23600000 	cmncs	r0, #0
    24dc:	00010000 	andeq	r0, r1, r0
    24e0:	00236050 	eoreq	r6, r3, r0, asr r0
    24e4:	00238c00 	eoreq	r8, r3, r0, lsl #24
    24e8:	54000100 	strpl	r0, [r0], #-256	; 0x100
    24ec:	00002394 	muleq	r0, r4, r3
    24f0:	0000239c 	muleq	r0, ip, r3
    24f4:	04530001 	ldrbeq	r0, [r3], #-1
    24f8:	14000024 	strne	r0, [r0], #-36	; 0x24
    24fc:	01000024 	tsteq	r0, r4, lsr #32
    2500:	24145400 	ldrcs	r5, [r4], #-1024	; 0x400
    2504:	24280000 	strtcs	r0, [r8]
    2508:	00010000 	andeq	r0, r1, r0
    250c:	00000053 	andeq	r0, r0, r3, asr r0
    2510:	00000000 	andeq	r0, r0, r0
    2514:	00237800 	eoreq	r7, r3, r0, lsl #16
    2518:	00238000 	eoreq	r8, r3, r0
    251c:	54000100 	strpl	r0, [r0], #-256	; 0x100
    2520:	0000238c 	andeq	r2, r0, ip, lsl #7
    2524:	00002404 	andeq	r2, r0, r4, lsl #8
    2528:	20540001 	subscs	r0, r4, r1
    252c:	50000024 	andpl	r0, r0, r4, lsr #32
    2530:	01000024 	tsteq	r0, r4, lsr #32
    2534:	00005400 	andeq	r5, r0, r0, lsl #8
    2538:	00000000 	andeq	r0, r0, r0
    253c:	239c0000 	orrscs	r0, ip, #0
    2540:	23ec0000 	mvncs	r0, #0
    2544:	00010000 	andeq	r0, r1, r0
    2548:	00242853 	eoreq	r2, r4, r3, asr r8
    254c:	00242c00 	eoreq	r2, r4, r0, lsl #24
    2550:	53000100 	movwpl	r0, #256	; 0x100
    2554:	00002434 	andeq	r2, r0, r4, lsr r4
    2558:	00002438 	andeq	r2, r0, r8, lsr r4
    255c:	00530001 	subseq	r0, r3, r1
    2560:	00000000 	andeq	r0, r0, r0
    2564:	50000000 	andpl	r0, r0, r0
    2568:	58000024 	stmdapl	r0, {r2, r5}
    256c:	01000024 	tsteq	r0, r4, lsr #32
    2570:	24585d00 	ldrbcs	r5, [r8], #-3328	; 0xd00
    2574:	25340000 	ldrcs	r0, [r4]!
    2578:	00020000 	andeq	r0, r2, r0
    257c:	0000107d 	andeq	r1, r0, sp, ror r0
    2580:	00000000 	andeq	r0, r0, r0
    2584:	24500000 	ldrbcs	r0, [r0]
    2588:	24600000 	strbtcs	r0, [r0]
    258c:	00010000 	andeq	r0, r1, r0
    2590:	00246050 	eoreq	r6, r4, r0, asr r0
    2594:	00248c00 	eoreq	r8, r4, r0, lsl #24
    2598:	54000100 	strpl	r0, [r0], #-256	; 0x100
    259c:	00002504 	andeq	r2, r0, r4, lsl #10
    25a0:	0000251c 	andeq	r2, r0, ip, lsl r5
    25a4:	00540001 	subseq	r0, r4, r1
    25a8:	00000000 	andeq	r0, r0, r0
    25ac:	78000000 	stmdavc	r0, {}
    25b0:	d0000024 	andle	r0, r0, r4, lsr #32
    25b4:	01000024 	tsteq	r0, r4, lsr #32
    25b8:	24ec5300 	strbtcs	r5, [ip], #768	; 0x300
    25bc:	24f00000 	ldrbtcs	r0, [r0]
    25c0:	00010000 	andeq	r0, r1, r0
    25c4:	0024f853 	eoreq	pc, r4, r3, asr r8
    25c8:	0024fc00 	eoreq	pc, r4, r0, lsl #24
    25cc:	53000100 	movwpl	r0, #256	; 0x100
    25d0:	00002504 	andeq	r2, r0, r4, lsl #10
    25d4:	00002508 	andeq	r2, r0, r8, lsl #10
    25d8:	10530001 	subsne	r0, r3, r1
    25dc:	14000025 	strne	r0, [r0], #-37	; 0x25
    25e0:	01000025 	tsteq	r0, r5, lsr #32
    25e4:	251c5300 	ldrcs	r5, [ip, #-768]	; 0x300
    25e8:	25200000 	strcs	r0, [r0]!
    25ec:	00010000 	andeq	r0, r1, r0
    25f0:	00000053 	andeq	r0, r0, r3, asr r0
    25f4:	00000000 	andeq	r0, r0, r0
    25f8:	00253400 	eoreq	r3, r5, r0, lsl #8
    25fc:	00253800 	eoreq	r3, r5, r0, lsl #16
    2600:	5d000100 	stfpls	f0, [r0]
    2604:	00002538 	andeq	r2, r0, r8, lsr r5
    2608:	00002758 	andeq	r2, r0, r8, asr r7
    260c:	187d0002 	ldmdane	sp!, {r1}^
	...
    2618:	00002534 	andeq	r2, r0, r4, lsr r5
    261c:	0000254c 	andeq	r2, r0, ip, asr #10
    2620:	4c500001 	mrrcmi	0, 0, r0, r0, cr1
    2624:	ac000025 	stcge	0, cr0, [r0], {37}	; 0x25
    2628:	01000026 	tsteq	r0, r6, lsr #32
    262c:	27005500 	strcs	r5, [r0, -r0, lsl #10]
    2630:	27580000 	ldrbcs	r0, [r8, -r0]
    2634:	00010000 	andeq	r0, r1, r0
    2638:	00000055 	andeq	r0, r0, r5, asr r0
    263c:	00000000 	andeq	r0, r0, r0
    2640:	0025d400 	eoreq	sp, r5, r0, lsl #8
    2644:	00261c00 	eoreq	r1, r6, r0, lsl #24
    2648:	52000100 	andpl	r0, r0, #0
    264c:	00002640 	andeq	r2, r0, r0, asr #12
    2650:	00002654 	andeq	r2, r0, r4, asr r6
    2654:	00520001 	subseq	r0, r2, r1
    2658:	00000000 	andeq	r0, r0, r0
    265c:	0c000000 	stceq	0, cr0, [r0], {0}
    2660:	38000026 	stmdacc	r0, {r1, r2, r5}
    2664:	01000026 	tsteq	r0, r6, lsr #32
    2668:	26405300 	strbcs	r5, [r0], -r0, lsl #6
    266c:	26440000 	strbcs	r0, [r4], -r0
    2670:	00010000 	andeq	r0, r1, r0
    2674:	00272053 	eoreq	r2, r7, r3, asr r0
    2678:	00275800 	eoreq	r5, r7, r0, lsl #16
    267c:	53000100 	movwpl	r0, #256	; 0x100
	...
    2688:	00002570 	andeq	r2, r0, r0, ror r5
    268c:	00002578 	andeq	r2, r0, r8, ror r5
    2690:	90540001 	subsls	r0, r4, r1
    2694:	00000025 	andeq	r0, r0, r5, lsr #32
    2698:	01000027 	tsteq	r0, r7, lsr #32
    269c:	27085400 	strcs	r5, [r8, -r0, lsl #8]
    26a0:	27580000 	ldrbcs	r0, [r8, -r0]
    26a4:	00010000 	andeq	r0, r1, r0
    26a8:	00000054 	andeq	r0, r0, r4, asr r0
    26ac:	00000000 	andeq	r0, r0, r0
    26b0:	00261800 	eoreq	r1, r6, r0, lsl #16
    26b4:	00266800 	eoreq	r6, r6, r0, lsl #16
    26b8:	51000100 	tstpl	r0, r0, lsl #2
    26bc:	00002720 	andeq	r2, r0, r0, lsr #14
    26c0:	00002758 	andeq	r2, r0, r8, asr r7
    26c4:	00510001 	subseq	r0, r1, r1
    26c8:	00000000 	andeq	r0, r0, r0
    26cc:	1c000000 	stcne	0, cr0, [r0], {0}
    26d0:	3c000026 	stccc	0, cr0, [r0], {38}	; 0x26
    26d4:	01000026 	tsteq	r0, r6, lsr #32
    26d8:	27205200 	strcs	r5, [r0, -r0, lsl #4]!
    26dc:	27580000 	ldrbcs	r0, [r8, -r0]
    26e0:	00010000 	andeq	r0, r1, r0
    26e4:	00000052 	andeq	r0, r0, r2, asr r0
    26e8:	00000000 	andeq	r0, r0, r0
    26ec:	00275800 	eoreq	r5, r7, r0, lsl #16
    26f0:	00275c00 	eoreq	r5, r7, r0, lsl #24
    26f4:	5d000100 	stfpls	f0, [r0]
    26f8:	0000275c 	andeq	r2, r0, ip, asr r7
    26fc:	00002764 	andeq	r2, r0, r4, ror #14
    2700:	247d0002 	ldrbtcs	r0, [sp], #-2
    2704:	00002764 	andeq	r2, r0, r4, ror #14
    2708:	00002894 	muleq	r0, r4, r8
    270c:	c07d0003 	rsbsgt	r0, sp, r3
	...
    2718:	00275800 	eoreq	r5, r7, r0, lsl #16
    271c:	00278800 	eoreq	r8, r7, r0, lsl #16
    2720:	50000100 	andpl	r0, r0, r0, lsl #2
    2724:	00002788 	andeq	r2, r0, r8, lsl #15
    2728:	00002894 	muleq	r0, r4, r8
    272c:	005a0001 	subseq	r0, sl, r1
    2730:	00000000 	andeq	r0, r0, r0
    2734:	58000000 	stmdapl	r0, {}
    2738:	88000027 	stmdahi	r0, {r0, r1, r2, r5}
    273c:	01000027 	tsteq	r0, r7, lsr #32
    2740:	27885100 	strcs	r5, [r8, r0, lsl #2]
    2744:	28940000 	ldmcs	r4, {}
    2748:	00010000 	andeq	r0, r1, r0
    274c:	0000005b 	andeq	r0, r0, fp, asr r0
    2750:	00000000 	andeq	r0, r0, r0
    2754:	00275800 	eoreq	r5, r7, r0, lsl #16
    2758:	00278800 	eoreq	r8, r7, r0, lsl #16
    275c:	52000100 	andpl	r0, r0, #0
    2760:	00002788 	andeq	r2, r0, r8, lsl #15
    2764:	00002894 	muleq	r0, r4, r8
    2768:	00590001 	subseq	r0, r9, r1
    276c:	00000000 	andeq	r0, r0, r0
    2770:	58000000 	stmdapl	r0, {}
    2774:	88000027 	stmdahi	r0, {r0, r1, r2, r5}
    2778:	01000027 	tsteq	r0, r7, lsr #32
    277c:	27885300 	strcs	r5, [r8, r0, lsl #6]
    2780:	28940000 	ldmcs	r4, {}
    2784:	00010000 	andeq	r0, r1, r0
    2788:	00000054 	andeq	r0, r0, r4, asr r0
    278c:	00000000 	andeq	r0, r0, r0
    2790:	00275800 	eoreq	r5, r7, r0, lsl #16
    2794:	00278000 	eoreq	r8, r7, r0
    2798:	91000200 	tstls	r0, r0, lsl #4
    279c:	00278000 	eoreq	r8, r7, r0
    27a0:	00289400 	eoreq	r9, r8, r0, lsl #8
    27a4:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    27b0:	00002758 	andeq	r2, r0, r8, asr r7
    27b4:	00002788 	andeq	r2, r0, r8, lsl #15
    27b8:	04910002 	ldreq	r0, [r1], #2
    27bc:	00002788 	andeq	r2, r0, r8, lsl #15
    27c0:	00002894 	muleq	r0, r4, r8
    27c4:	00580001 	subseq	r0, r8, r1
    27c8:	00000000 	andeq	r0, r0, r0
    27cc:	58000000 	stmdapl	r0, {}
    27d0:	04000027 	streq	r0, [r0], #-39	; 0x27
    27d4:	02000028 	andeq	r0, r0, #40	; 0x28
    27d8:	04089100 	streq	r9, [r8], #-256	; 0x100
    27dc:	0c000028 	stceq	0, cr0, [r0], {40}	; 0x28
    27e0:	02000028 	andeq	r0, r0, #40	; 0x28
    27e4:	0c009100 	stfeqd	f1, [r0], {0}
    27e8:	18000028 	stmdane	r0, {r3, r5}
    27ec:	01000028 	tsteq	r0, r8, lsr #32
    27f0:	28185200 	ldmdacs	r8, {r9, ip, lr}
    27f4:	285c0000 	ldmdacs	ip, {}^
    27f8:	00020000 	andeq	r0, r2, r0
    27fc:	285c0891 	ldmdacs	ip, {r0, r4, r7, fp}^
    2800:	28940000 	ldmcs	r4, {}
    2804:	00020000 	andeq	r0, r2, r0
    2808:	00000091 	muleq	r0, r1, r0
    280c:	00000000 	andeq	r0, r0, r0
    2810:	27580000 	ldrbcs	r0, [r8, -r0]
    2814:	285c0000 	ldmdacs	ip, {}^
    2818:	00020000 	andeq	r0, r2, r0
    281c:	285c0c91 	ldmdacs	ip, {r0, r4, r7, sl, fp}^
    2820:	28940000 	ldmcs	r4, {}
    2824:	00020000 	andeq	r0, r2, r0
    2828:	00000491 	muleq	r0, r1, r4
    282c:	00000000 	andeq	r0, r0, r0
    2830:	27580000 	ldrbcs	r0, [r8, -r0]
    2834:	27680000 	strbcs	r0, [r8, -r0]!
    2838:	00020000 	andeq	r0, r2, r0
    283c:	27681091 	undefined instruction 0x27681091
    2840:	27840000 	strcs	r0, [r4, r0]
    2844:	00010000 	andeq	r0, r1, r0
    2848:	0027e855 	eoreq	lr, r7, r5, asr r8
    284c:	00285800 	eoreq	r5, r8, r0, lsl #16
    2850:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    285c:	00002834 	andeq	r2, r0, r4, lsr r8
    2860:	00002854 	andeq	r2, r0, r4, asr r8
    2864:	00510001 	subseq	r0, r1, r1
    2868:	00000000 	andeq	r0, r0, r0
    286c:	94000000 	strls	r0, [r0]
    2870:	98000028 	stmdals	r0, {r3, r5}
    2874:	01000028 	tsteq	r0, r8, lsr #32
    2878:	28985d00 	ldmcs	r8, {r8, sl, fp, ip, lr}
    287c:	28a40000 	stmiacs	r4!, {}
    2880:	00020000 	andeq	r0, r2, r0
    2884:	28a4147d 	stmiacs	r4!, {r0, r2, r3, r4, r5, r6, sl, ip}
    2888:	2a200000 	bcs	802890 <MEM_SIZE+0x2890>
    288c:	00020000 	andeq	r0, r2, r0
    2890:	0000387d 	andeq	r3, r0, sp, ror r8
    2894:	00000000 	andeq	r0, r0, r0
    2898:	28e00000 	stmiacs	r0!, {}^
    289c:	29100000 	ldmdbcs	r0, {}
    28a0:	00010000 	andeq	r0, r1, r0
    28a4:	00000052 	andeq	r0, r0, r2, asr r0
    28a8:	00000000 	andeq	r0, r0, r0
    28ac:	002a2000 	eoreq	r2, sl, r0
    28b0:	002a2400 	eoreq	r2, sl, r0, lsl #8
    28b4:	5d000100 	stfpls	f0, [r0]
    28b8:	00002a24 	andeq	r2, r0, r4, lsr #20
    28bc:	00002a30 	andeq	r2, r0, r0, lsr sl
    28c0:	1c7d0002 	ldclne	0, cr0, [sp], #-8
    28c4:	00002a30 	andeq	r2, r0, r0, lsr sl
    28c8:	00002b0c 	andeq	r2, r0, ip, lsl #22
    28cc:	307d0002 	rsbscc	r0, sp, r2
	...
    28d8:	00002a20 	andeq	r2, r0, r0, lsr #20
    28dc:	00002a48 	andeq	r2, r0, r8, asr #20
    28e0:	54500001 	ldrbpl	r0, [r0], #-1
    28e4:	5800002a 	stmdapl	r0, {r1, r3, r5}
    28e8:	0100002a 	tsteq	r0, sl, lsr #32
    28ec:	2aa05000 	bcs	fe8168f4 <rEINTPEND+0xa881684c>
    28f0:	2ad40000 	bcs	ff5028f8 <rEINTPEND+0xa9502850>
    28f4:	00010000 	andeq	r0, r1, r0
    28f8:	00000057 	andeq	r0, r0, r7, asr r0
    28fc:	00000000 	andeq	r0, r0, r0
    2900:	002a2000 	eoreq	r2, sl, r0
    2904:	002a4400 	eoreq	r4, sl, r0, lsl #8
    2908:	51000100 	tstpl	r0, r0, lsl #2
    290c:	00002a44 	andeq	r2, r0, r4, asr #20
    2910:	00002b0c 	andeq	r2, r0, ip, lsl #22
    2914:	005a0001 	subseq	r0, sl, r1
    2918:	00000000 	andeq	r0, r0, r0
    291c:	20000000 	andcs	r0, r0, r0
    2920:	4400002a 	strmi	r0, [r0], #-42	; 0x2a
    2924:	0100002a 	tsteq	r0, sl, lsr #32
    2928:	2a445200 	bcs	1117130 <MEM_SIZE+0x917130>
    292c:	2b0c0000 	blcs	302934 <DISABLE_IRQ+0x3028b4>
    2930:	00010000 	andeq	r0, r1, r0
    2934:	00000058 	andeq	r0, r0, r8, asr r0
    2938:	00000000 	andeq	r0, r0, r0
    293c:	002a2000 	eoreq	r2, sl, r0
    2940:	002a4400 	eoreq	r4, sl, r0, lsl #8
    2944:	53000100 	movwpl	r0, #256	; 0x100
    2948:	00002a44 	andeq	r2, r0, r4, asr #20
    294c:	00002b0c 	andeq	r2, r0, ip, lsl #22
    2950:	00540001 	subseq	r0, r4, r1
    2954:	00000000 	andeq	r0, r0, r0
    2958:	b8000000 	stmdalt	r0, {}
    295c:	d000002a 	andle	r0, r0, sl, lsr #32
    2960:	0100002a 	tsteq	r0, sl, lsr #32
    2964:	00005100 	andeq	r5, r0, r0, lsl #2
    2968:	00000000 	andeq	r0, r0, r0
    296c:	2b0c0000 	blcs	302974 <DISABLE_IRQ+0x3028f4>
    2970:	2b140000 	blcs	502978 <DISABLE_IRQ+0x5028f8>
    2974:	00010000 	andeq	r0, r1, r0
    2978:	002b145d 	eoreq	r1, fp, sp, asr r4
    297c:	002cb400 	eoreq	fp, ip, r0, lsl #8
    2980:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2984:	00000020 	andeq	r0, r0, r0, lsr #32
    2988:	00000000 	andeq	r0, r0, r0
    298c:	002b0c00 	eoreq	r0, fp, r0, lsl #24
    2990:	002b2000 	eoreq	r2, fp, r0
    2994:	50000100 	andpl	r0, r0, r0, lsl #2
    2998:	00002b20 	andeq	r2, r0, r0, lsr #22
    299c:	00002b28 	andeq	r2, r0, r8, lsr #22
    29a0:	28540001 	ldmdacs	r4, {r0}^
    29a4:	2c00002b 	stccs	0, cr0, [r0], {43}	; 0x2b
    29a8:	0100002b 	tsteq	r0, fp, lsr #32
    29ac:	2b2c5000 	blcs	b169b4 <MEM_SIZE+0x3169b4>
    29b0:	2bc40000 	blcs	ff1029b8 <rEINTPEND+0xa9102910>
    29b4:	00010000 	andeq	r0, r1, r0
    29b8:	002c8454 	eoreq	r8, ip, r4, asr r4
    29bc:	002cb400 	eoreq	fp, ip, r0, lsl #8
    29c0:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    29cc:	00002b0c 	andeq	r2, r0, ip, lsl #22
    29d0:	00002b20 	andeq	r2, r0, r0, lsr #22
    29d4:	20510001 	subscs	r0, r1, r1
    29d8:	b400002b 	strlt	r0, [r0], #-43	; 0x2b
    29dc:	0100002c 	tsteq	r0, ip, lsr #32
    29e0:	00005500 	andeq	r5, r0, r0, lsl #10
    29e4:	00000000 	andeq	r0, r0, r0
    29e8:	2c040000 	stccs	0, cr0, [r4], {0}
    29ec:	2c1c0000 	ldccs	0, cr0, [ip], {0}
    29f0:	00010000 	andeq	r0, r1, r0
    29f4:	002c3050 	eoreq	r3, ip, r0, asr r0
    29f8:	002c8400 	eoreq	r8, ip, r0, lsl #8
    29fc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    2a08:	00002b78 	andeq	r2, r0, r8, ror fp
    2a0c:	00002c20 	andeq	r2, r0, r0, lsr #24
    2a10:	2c530001 	mrrccs	0, 0, r0, r3, cr1
    2a14:	8c00002c 	stchi	0, cr0, [r0], {44}	; 0x2c
    2a18:	0100002c 	tsteq	r0, ip, lsr #32
    2a1c:	2c945300 	ldccs	3, cr5, [r4], {0}
    2a20:	2c9c0000 	ldccs	0, cr0, [ip], {0}
    2a24:	00010000 	andeq	r0, r1, r0
    2a28:	00000053 	andeq	r0, r0, r3, asr r0
    2a2c:	00000000 	andeq	r0, r0, r0
    2a30:	002b9400 	eoreq	r9, fp, r0, lsl #8
    2a34:	002c2000 	eoreq	r2, ip, r0
    2a38:	5c000100 	stfpls	f0, [r0], {0}
    2a3c:	00002c2c 	andeq	r2, r0, ip, lsr #24
    2a40:	00002c84 	andeq	r2, r0, r4, lsl #25
    2a44:	005c0001 	subseq	r0, ip, r1
    2a48:	00000000 	andeq	r0, r0, r0
    2a4c:	90000000 	andls	r0, r0, r0
    2a50:	2000002b 	andcs	r0, r0, fp, lsr #32
    2a54:	0100002c 	tsteq	r0, ip, lsr #32
    2a58:	2c2c5200 	sfmcs	f5, 4, [ip]	; (stccs 2, cr5, [ip])
    2a5c:	2c840000 	stccs	0, cr0, [r4], {0}
    2a60:	00010000 	andeq	r0, r1, r0
    2a64:	00000052 	andeq	r0, r0, r2, asr r0
    2a68:	00000000 	andeq	r0, r0, r0
    2a6c:	002b2c00 	eoreq	r2, fp, r0, lsl #24
    2a70:	002b3400 	eoreq	r3, fp, r0, lsl #8
    2a74:	54000100 	strpl	r0, [r0], #-256	; 0x100
    2a78:	00002bc4 	andeq	r2, r0, r4, asr #23
    2a7c:	00002c84 	andeq	r2, r0, r4, lsl #25
    2a80:	00540001 	subseq	r0, r4, r1
    2a84:	00000000 	andeq	r0, r0, r0
    2a88:	bc000000 	stclt	0, cr0, [r0], {0}
    2a8c:	2000002b 	andcs	r0, r0, fp, lsr #32
    2a90:	0100002c 	tsteq	r0, ip, lsr #32
    2a94:	2c2c5e00 	stccs	14, cr5, [ip]
    2a98:	2c840000 	stccs	0, cr0, [r4], {0}
    2a9c:	00010000 	andeq	r0, r1, r0
    2aa0:	0000005e 	andeq	r0, r0, lr, asr r0
    2aa4:	00000000 	andeq	r0, r0, r0
    2aa8:	002b4800 	eoreq	r4, fp, r0, lsl #16
    2aac:	002b5800 	eoreq	r5, fp, r0, lsl #16
    2ab0:	51000100 	tstpl	r0, r0, lsl #2
    2ab4:	00002b60 	andeq	r2, r0, r0, ror #22
    2ab8:	00002c20 	andeq	r2, r0, r0, lsr #24
    2abc:	2c510001 	mrrccs	0, 0, r0, r1, cr1
    2ac0:	8c00002c 	stchi	0, cr0, [r0], {44}	; 0x2c
    2ac4:	0100002c 	tsteq	r0, ip, lsr #32
    2ac8:	2c945100 	ldfcss	f5, [r4], {0}
    2acc:	2c9c0000 	ldccs	0, cr0, [ip], {0}
    2ad0:	00010000 	andeq	r0, r1, r0
    2ad4:	00000051 	andeq	r0, r0, r1, asr r0
    2ad8:	00000000 	andeq	r0, r0, r0
    2adc:	002cb400 	eoreq	fp, ip, r0, lsl #8
    2ae0:	002cb800 	eoreq	fp, ip, r0, lsl #16
    2ae4:	5d000100 	stfpls	f0, [r0]
    2ae8:	00002cb8 	undefined instruction 0x00002cb8
    2aec:	00002d48 	andeq	r2, r0, r8, asr #26
    2af0:	107d0002 	rsbsne	r0, sp, r2
	...
    2afc:	00002cb4 	undefined instruction 0x00002cb4
    2b00:	00002cc0 	andeq	r2, r0, r0, asr #25
    2b04:	c0500001 	subsgt	r0, r0, r1
    2b08:	4800002c 	stmdami	r0, {r2, r3, r5}
    2b0c:	0100002d 	tsteq	r0, sp, lsr #32
    2b10:	00005500 	andeq	r5, r0, r0, lsl #10
    2b14:	00000000 	andeq	r0, r0, r0
    2b18:	2d680000 	stclcs	0, cr0, [r8]
    2b1c:	2d6c0000 	stclcs	0, cr0, [ip]
    2b20:	00010000 	andeq	r0, r1, r0
    2b24:	002d6c5d 	eoreq	r6, sp, sp, asr ip
    2b28:	002d7400 	eoreq	r7, sp, r0, lsl #8
    2b2c:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2b30:	002d7414 	eoreq	r7, sp, r4, lsl r4
    2b34:	002f2800 	eoreq	r2, pc, r0, lsl #16
    2b38:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2b3c:	00000020 	andeq	r0, r0, r0, lsr #32
    2b40:	00000000 	andeq	r0, r0, r0
    2b44:	002d6800 	eoreq	r6, sp, r0, lsl #16
    2b48:	002d7c00 	eoreq	r7, sp, r0, lsl #24
    2b4c:	50000100 	andpl	r0, r0, r0, lsl #2
    2b50:	00002d7c 	andeq	r2, r0, ip, ror sp
    2b54:	00002d8c 	andeq	r2, r0, ip, lsl #27
    2b58:	8c540001 	mrrchi	0, 0, r0, r4, cr1
    2b5c:	a000002d 	andge	r0, r0, sp, lsr #32
    2b60:	0100002d 	tsteq	r0, sp, lsr #32
    2b64:	2da05000 	stccs	0, cr5, [r0]
    2b68:	2dac0000 	stccs	0, cr0, [ip]
    2b6c:	00010000 	andeq	r0, r1, r0
    2b70:	002dac54 	eoreq	sl, sp, r4, asr ip
    2b74:	002de400 	eoreq	lr, sp, r0, lsl #8
    2b78:	50000100 	andpl	r0, r0, r0, lsl #2
    2b7c:	00002de4 	andeq	r2, r0, r4, ror #27
    2b80:	00002e9c 	muleq	r0, ip, lr
    2b84:	ac540001 	mrrcge	0, 0, r0, r4, cr1
    2b88:	2800002e 	stmdacs	r0, {r1, r2, r3, r5}
    2b8c:	0100002f 	tsteq	r0, pc, lsr #32
    2b90:	00005400 	andeq	r5, r0, r0, lsl #8
    2b94:	00000000 	andeq	r0, r0, r0
    2b98:	2d680000 	stclcs	0, cr0, [r8]
    2b9c:	2de00000 	stclcs	0, cr0, [r0]
    2ba0:	00010000 	andeq	r0, r1, r0
    2ba4:	002e1451 	eoreq	r1, lr, r1, asr r4
    2ba8:	002e2400 	eoreq	r2, lr, r0, lsl #8
    2bac:	51000100 	tstpl	r0, r0, lsl #2
	...
    2bb8:	00002d68 	andeq	r2, r0, r8, ror #26
    2bbc:	00002d7c 	andeq	r2, r0, ip, ror sp
    2bc0:	7c520001 	mrrcvc	0, 0, r0, r2, cr1
    2bc4:	2800002d 	stmdacs	r0, {r0, r2, r3, r5}
    2bc8:	0100002f 	tsteq	r0, pc, lsr #32
    2bcc:	00005500 	andeq	r5, r0, r0, lsl #10
    2bd0:	00000000 	andeq	r0, r0, r0
    2bd4:	2dec0000 	stclcs	0, cr0, [ip]
    2bd8:	2e7c0000 	cdpcs	0, 7, cr0, cr12, cr0, {0}
    2bdc:	00010000 	andeq	r0, r1, r0
    2be0:	002e8c52 	eoreq	r8, lr, r2, asr ip
    2be4:	002ea400 	eoreq	sl, lr, r0, lsl #8
    2be8:	51000100 	tstpl	r0, r0, lsl #2
    2bec:	00002eac 	andeq	r2, r0, ip, lsr #29
    2bf0:	00002ef4 	strdeq	r2, [r0], -r4
    2bf4:	00510001 	subseq	r0, r1, r1
    2bf8:	0c00002f 	stceq	0, cr0, [r0], {47}	; 0x2f
    2bfc:	0100002f 	tsteq	r0, pc, lsr #32
    2c00:	00005200 	andeq	r5, r0, r0, lsl #4
    2c04:	00000000 	andeq	r0, r0, r0
    2c08:	2f280000 	svccs	0x00280000
    2c0c:	2f2c0000 	svccs	0x002c0000
    2c10:	00010000 	andeq	r0, r1, r0
    2c14:	002f2c5d 	eoreq	r2, pc, sp, asr ip
    2c18:	002f3400 	eoreq	r3, pc, r0, lsl #8
    2c1c:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2c20:	002f3404 	eoreq	r3, pc, r4, lsl #8
    2c24:	002f5400 	eoreq	r5, pc, r0, lsl #8
    2c28:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2c2c:	00000010 	andeq	r0, r0, r0, lsl r0
    2c30:	00000000 	andeq	r0, r0, r0
    2c34:	002f5400 	eoreq	r5, pc, r0, lsl #8
    2c38:	002f5800 	eoreq	r5, pc, r0, lsl #16
    2c3c:	5d000100 	stfpls	f0, [r0]
    2c40:	00002f58 	andeq	r2, r0, r8, asr pc
    2c44:	00002f64 	andeq	r2, r0, r4, ror #30
    2c48:	107d0002 	rsbsne	r0, sp, r2
    2c4c:	00002f64 	andeq	r2, r0, r4, ror #30
    2c50:	000030d8 	ldrdeq	r3, [r0], -r8
    2c54:	187d0002 	ldmdane	sp!, {r1}^
	...
    2c60:	00002f54 	andeq	r2, r0, r4, asr pc
    2c64:	00002f68 	andeq	r2, r0, r8, ror #30
    2c68:	68500001 	ldmdavs	r0, {r0}^
    2c6c:	9000002f 	andls	r0, r0, pc, lsr #32
    2c70:	01000030 	tsteq	r0, r0, lsr r0
    2c74:	30985400 	addscc	r5, r8, r0, lsl #8
    2c78:	30d80000 	sbcscc	r0, r8, r0
    2c7c:	00010000 	andeq	r0, r1, r0
    2c80:	00000054 	andeq	r0, r0, r4, asr r0
    2c84:	00000000 	andeq	r0, r0, r0
    2c88:	002f5400 	eoreq	r5, pc, r0, lsl #8
    2c8c:	002fc400 	eoreq	ip, pc, r0, lsl #8
    2c90:	51000100 	tstpl	r0, r0, lsl #2
    2c94:	00003014 	andeq	r3, r0, r4, lsl r0
    2c98:	00003030 	andeq	r3, r0, r0, lsr r0
    2c9c:	7c510001 	mrrcvc	0, 0, r0, r1, cr1
    2ca0:	90000030 	andls	r0, r0, r0, lsr r0
    2ca4:	01000030 	tsteq	r0, r0, lsr r0
    2ca8:	30985100 	addscc	r5, r8, r0, lsl #2
    2cac:	309c0000 	addscc	r0, ip, r0
    2cb0:	00010000 	andeq	r0, r1, r0
    2cb4:	0030a451 	eorseq	sl, r0, r1, asr r4
    2cb8:	0030b800 	eorseq	fp, r0, r0, lsl #16
    2cbc:	51000100 	tstpl	r0, r0, lsl #2
    2cc0:	000030c4 	andeq	r3, r0, r4, asr #1
    2cc4:	000030d8 	ldrdeq	r3, [r0], -r8
    2cc8:	00510001 	subseq	r0, r1, r1
    2ccc:	00000000 	andeq	r0, r0, r0
    2cd0:	54000000 	strpl	r0, [r0]
    2cd4:	c800002f 	stmdagt	r0, {r0, r1, r2, r3, r5}
    2cd8:	0100002f 	tsteq	r0, pc, lsr #32
    2cdc:	30b85200 	adcscc	r5, r8, r0, lsl #4
    2ce0:	30c00000 	sbccc	r0, r0, r0
    2ce4:	00010000 	andeq	r0, r1, r0
    2ce8:	00000052 	andeq	r0, r0, r2, asr r0
    2cec:	00000000 	andeq	r0, r0, r0
    2cf0:	002f5400 	eoreq	r5, pc, r0, lsl #8
    2cf4:	002f6c00 	eoreq	r6, pc, r0, lsl #24
    2cf8:	53000100 	movwpl	r0, #256	; 0x100
    2cfc:	00002f6c 	andeq	r2, r0, ip, ror #30
    2d00:	000030d8 	ldrdeq	r3, [r0], -r8
    2d04:	00550001 	subseq	r0, r5, r1
    2d08:	00000000 	andeq	r0, r0, r0
    2d0c:	98000000 	stmdals	r0, {}
    2d10:	a400002f 	strge	r0, [r0], #-47	; 0x2f
    2d14:	0100002f 	tsteq	r0, pc, lsr #32
    2d18:	30805300 	addcc	r5, r0, r0, lsl #6
    2d1c:	30980000 	addscc	r0, r8, r0
    2d20:	00010000 	andeq	r0, r1, r0
    2d24:	0030a853 	eorseq	sl, r0, r3, asr r8
    2d28:	0030c000 	eorseq	ip, r0, r0
    2d2c:	53000100 	movwpl	r0, #256	; 0x100
    2d30:	000030c4 	andeq	r3, r0, r4, asr #1
    2d34:	000030d8 	ldrdeq	r3, [r0], -r8
    2d38:	00530001 	subseq	r0, r3, r1
    2d3c:	00000000 	andeq	r0, r0, r0
    2d40:	d8000000 	stmdale	r0, {}
    2d44:	dc000030 	stcle	0, cr0, [r0], {48}	; 0x30
    2d48:	01000030 	tsteq	r0, r0, lsr r0
    2d4c:	30dc5d00 	sbcscc	r5, ip, r0, lsl #26
    2d50:	31b40000 	undefined instruction 0x31b40000
    2d54:	00020000 	andeq	r0, r2, r0
    2d58:	0000107d 	andeq	r1, r0, sp, ror r0
    2d5c:	00000000 	andeq	r0, r0, r0
    2d60:	30d80000 	sbcscc	r0, r8, r0
    2d64:	30e80000 	rsccc	r0, r8, r0
    2d68:	00010000 	andeq	r0, r1, r0
    2d6c:	0030e850 	eorseq	lr, r0, r0, asr r8
    2d70:	0031b400 	eorseq	fp, r1, r0, lsl #8
    2d74:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    2d80:	000030d8 	ldrdeq	r3, [r0], -r8
    2d84:	000030ec 	andeq	r3, r0, ip, ror #1
    2d88:	ec510001 	mrrc	0, 0, r0, r1, cr1
    2d8c:	b4000030 	strlt	r0, [r0], #-48	; 0x30
    2d90:	01000031 	tsteq	r0, r1, lsr r0
    2d94:	00005400 	andeq	r5, r0, r0, lsl #8
    2d98:	00000000 	andeq	r0, r0, r0
    2d9c:	31b40000 	undefined instruction 0x31b40000
    2da0:	31b80000 	undefined instruction 0x31b80000
    2da4:	00010000 	andeq	r0, r1, r0
    2da8:	0031b85d 	eorseq	fp, r1, sp, asr r8
    2dac:	0031c000 	eorseq	ip, r1, r0
    2db0:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2db4:	0031c00c 	eorseq	ip, r1, ip
    2db8:	00324c00 	eorseq	r4, r2, r0, lsl #24
    2dbc:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2dc0:	00000018 	andeq	r0, r0, r8, lsl r0
    2dc4:	00000000 	andeq	r0, r0, r0
    2dc8:	0031b400 	eorseq	fp, r1, r0, lsl #8
    2dcc:	0031c400 	eorseq	ip, r1, r0, lsl #8
    2dd0:	50000100 	andpl	r0, r0, r0, lsl #2
    2dd4:	000031cc 	andeq	r3, r0, ip, asr #3
    2dd8:	000031ec 	andeq	r3, r0, ip, ror #3
    2ddc:	f0500001 	undefined instruction 0xf0500001
    2de0:	f0000031 	undefined instruction 0xf0000031
    2de4:	01000031 	tsteq	r0, r1, lsr r0
    2de8:	32285000 	eorcc	r5, r8, #0
    2dec:	324c0000 	subcc	r0, ip, #0
    2df0:	00010000 	andeq	r0, r1, r0
    2df4:	00000050 	andeq	r0, r0, r0, asr r0
    2df8:	00000000 	andeq	r0, r0, r0
    2dfc:	0031b400 	eorseq	fp, r1, r0, lsl #8
    2e00:	0031c800 	eorseq	ip, r1, r0, lsl #16
    2e04:	51000100 	tstpl	r0, r0, lsl #2
    2e08:	000031c8 	andeq	r3, r0, r8, asr #3
    2e0c:	0000324c 	andeq	r3, r0, ip, asr #4
    2e10:	00540001 	subseq	r0, r4, r1
    2e14:	00000000 	andeq	r0, r0, r0
    2e18:	c4000000 	strgt	r0, [r0]
    2e1c:	f0000031 	undefined instruction 0xf0000031
    2e20:	01000031 	tsteq	r0, r1, lsr r0
    2e24:	31fc5000 	mvnscc	r5, r0
    2e28:	321c0000 	andscc	r0, ip, #0
    2e2c:	00010000 	andeq	r0, r1, r0
    2e30:	00322850 	eorseq	r2, r2, r0, asr r8
    2e34:	00323c00 	eorseq	r3, r2, r0, lsl #24
    2e38:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    2e44:	0000324c 	andeq	r3, r0, ip, asr #4
    2e48:	00003250 	andeq	r3, r0, r0, asr r2
    2e4c:	505d0001 	subspl	r0, sp, r1
    2e50:	58000032 	stmdapl	r0, {r1, r4, r5}
    2e54:	02000032 	andeq	r0, r0, #50	; 0x32
    2e58:	580c7d00 	stmdapl	ip, {r8, sl, fp, ip, sp, lr}
    2e5c:	7c000032 	stcvc	0, cr0, [r0], {50}	; 0x32
    2e60:	02000033 	andeq	r0, r0, #51	; 0x33
    2e64:	00187d00 	andseq	r7, r8, r0, lsl #26
    2e68:	00000000 	andeq	r0, r0, r0
    2e6c:	4c000000 	stcmi	0, cr0, [r0], {0}
    2e70:	90000032 	andls	r0, r0, r2, lsr r0
    2e74:	01000032 	tsteq	r0, r2, lsr r0
    2e78:	329c5000 	addscc	r5, ip, #0
    2e7c:	32bc0000 	adcscc	r0, ip, #0
    2e80:	00010000 	andeq	r0, r1, r0
    2e84:	0032c850 	eorseq	ip, r2, r0, asr r8
    2e88:	0032f800 	eorseq	pc, r2, r0, lsl #16
    2e8c:	50000100 	andpl	r0, r0, r0, lsl #2
    2e90:	00003304 	andeq	r3, r0, r4, lsl #6
    2e94:	0000330c 	andeq	r3, r0, ip, lsl #6
    2e98:	14500001 	ldrbne	r0, [r0], #-1
    2e9c:	38000033 	stmdacc	r0, {r0, r1, r4, r5}
    2ea0:	01000033 	tsteq	r0, r3, lsr r0
    2ea4:	33445000 	movtcc	r5, #16384	; 0x4000
    2ea8:	33480000 	movtcc	r0, #32768	; 0x8000
    2eac:	00010000 	andeq	r0, r1, r0
    2eb0:	00335850 	eorseq	r5, r3, r0, asr r8
    2eb4:	00335c00 	eorseq	r5, r3, r0, lsl #24
    2eb8:	50000100 	andpl	r0, r0, r0, lsl #2
    2ebc:	0000336c 	andeq	r3, r0, ip, ror #6
    2ec0:	0000337c 	andeq	r3, r0, ip, ror r3
    2ec4:	00500001 	subseq	r0, r0, r1
    2ec8:	00000000 	andeq	r0, r0, r0
    2ecc:	4c000000 	stcmi	0, cr0, [r0], {0}
    2ed0:	60000032 	andvs	r0, r0, r2, lsr r0
    2ed4:	01000032 	tsteq	r0, r2, lsr r0
    2ed8:	32605100 	rsbcc	r5, r0, #0
    2edc:	337c0000 	cmncc	ip, #0
    2ee0:	00010000 	andeq	r0, r1, r0
    2ee4:	00000055 	andeq	r0, r0, r5, asr r0
    2ee8:	00000000 	andeq	r0, r0, r0
    2eec:	00325c00 	eorseq	r5, r2, r0, lsl #24
    2ef0:	0032ec00 	eorseq	lr, r2, r0, lsl #24
    2ef4:	54000100 	strpl	r0, [r0], #-256	; 0x100
    2ef8:	000032f4 	strdeq	r3, [r0], -r4
    2efc:	00003308 	andeq	r3, r0, r8, lsl #6
    2f00:	14540001 	ldrbne	r0, [r4], #-1
    2f04:	7c000033 	stcvc	0, cr0, [r0], {51}	; 0x33
    2f08:	01000033 	tsteq	r0, r3, lsr r0
    2f0c:	00005400 	andeq	r5, r0, r0, lsl #8
    2f10:	00000000 	andeq	r0, r0, r0
    2f14:	337c0000 	cmncc	ip, #0
    2f18:	33800000 	orrcc	r0, r0, #0
    2f1c:	00010000 	andeq	r0, r1, r0
    2f20:	0033805d 	eorseq	r8, r3, sp, asr r0
    2f24:	00338800 	eorseq	r8, r3, r0, lsl #16
    2f28:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2f2c:	00338810 	eorseq	r8, r3, r0, lsl r8
    2f30:	00348c00 	eorseq	r8, r4, r0, lsl #24
    2f34:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    2f38:	00000018 	andeq	r0, r0, r8, lsl r0
    2f3c:	00000000 	andeq	r0, r0, r0
    2f40:	00337c00 	eorseq	r7, r3, r0, lsl #24
    2f44:	00338c00 	eorseq	r8, r3, r0, lsl #24
    2f48:	50000100 	andpl	r0, r0, r0, lsl #2
    2f4c:	000033a8 	andeq	r3, r0, r8, lsr #7
    2f50:	000033c8 	andeq	r3, r0, r8, asr #7
    2f54:	cc500001 	mrrcgt	0, 0, r0, r0, cr1
    2f58:	cc000033 	stcgt	0, cr0, [r0], {51}	; 0x33
    2f5c:	01000033 	tsteq	r0, r3, lsr r0
    2f60:	34045000 	strcc	r5, [r4]
    2f64:	34100000 	ldrcc	r0, [r0]
    2f68:	00010000 	andeq	r0, r1, r0
    2f6c:	00342050 	eorseq	r2, r4, r0, asr r0
    2f70:	00343400 	eorseq	r3, r4, r0, lsl #8
    2f74:	50000100 	andpl	r0, r0, r0, lsl #2
    2f78:	0000343c 	andeq	r3, r0, ip, lsr r4
    2f7c:	00003440 	andeq	r3, r0, r0, asr #8
    2f80:	74500001 	ldrbvc	r0, [r0], #-1
    2f84:	78000034 	stmdavc	r0, {r2, r4, r5}
    2f88:	01000034 	tsteq	r0, r4, lsr r0
    2f8c:	00005000 	andeq	r5, r0, r0
    2f90:	00000000 	andeq	r0, r0, r0
    2f94:	337c0000 	cmncc	ip, #0
    2f98:	33f80000 	mvnscc	r0, #0
    2f9c:	00010000 	andeq	r0, r1, r0
    2fa0:	00344451 	eorseq	r4, r4, r1, asr r4
    2fa4:	00346800 	eorseq	r6, r4, r0, lsl #16
    2fa8:	51000100 	tstpl	r0, r0, lsl #2
	...
    2fb4:	0000337c 	andeq	r3, r0, ip, ror r3
    2fb8:	00003390 	muleq	r0, r0, r3
    2fbc:	90520001 	subsls	r0, r2, r1
    2fc0:	8c000033 	stchi	0, cr0, [r0], {51}	; 0x33
    2fc4:	01000034 	tsteq	r0, r4, lsr r0
    2fc8:	00005400 	andeq	r5, r0, r0, lsl #8
    2fcc:	00000000 	andeq	r0, r0, r0
    2fd0:	338c0000 	orrcc	r0, ip, #0
    2fd4:	33cc0000 	biccc	r0, ip, #0
    2fd8:	00010000 	andeq	r0, r1, r0
    2fdc:	0033d850 	eorseq	sp, r3, r0, asr r8
    2fe0:	0033f400 	eorseq	pc, r3, r0, lsl #8
    2fe4:	50000100 	andpl	r0, r0, r0, lsl #2
    2fe8:	0000341c 	andeq	r3, r0, ip, lsl r4
    2fec:	00003420 	andeq	r3, r0, r0, lsr #8
    2ff0:	34500001 	ldrbcc	r0, [r0], #-1
    2ff4:	4c000034 	stcmi	0, cr0, [r0], {52}	; 0x34
    2ff8:	01000034 	tsteq	r0, r4, lsr r0
    2ffc:	34545000 	ldrbcc	r5, [r4]
    3000:	34640000 	strbtcc	r0, [r4]
    3004:	00010000 	andeq	r0, r1, r0
    3008:	00348450 	eorseq	r8, r4, r0, asr r4
    300c:	00348c00 	eorseq	r8, r4, r0, lsl #24
    3010:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    301c:	0000348c 	andeq	r3, r0, ip, lsl #9
    3020:	00003490 	muleq	r0, r0, r4
    3024:	905d0001 	subsls	r0, sp, r1
    3028:	c0000034 	andgt	r0, r0, r4, lsr r0
    302c:	02000035 	andeq	r0, r0, #53	; 0x35
    3030:	00107d00 	andseq	r7, r0, r0, lsl #26
    3034:	00000000 	andeq	r0, r0, r0
    3038:	8c000000 	stchi	0, cr0, [r0], {0}
    303c:	9c000034 	stcls	0, cr0, [r0], {52}	; 0x34
    3040:	01000034 	tsteq	r0, r4, lsr r0
    3044:	349c5000 	ldrcc	r5, [ip]
    3048:	35c00000 	strbcc	r0, [r0]
    304c:	00010000 	andeq	r0, r1, r0
    3050:	00000054 	andeq	r0, r0, r4, asr r0
    3054:	00000000 	andeq	r0, r0, r0
    3058:	00348c00 	eorseq	r8, r4, r0, lsl #24
    305c:	0034a000 	eorseq	sl, r4, r0
    3060:	51000100 	tstpl	r0, r0, lsl #2
    3064:	000034a0 	andeq	r3, r0, r0, lsr #9
    3068:	000035c0 	andeq	r3, r0, r0, asr #11
    306c:	00550001 	subseq	r0, r5, r1
    3070:	00000000 	andeq	r0, r0, r0
    3074:	c0000000 	andgt	r0, r0, r0
    3078:	c4000035 	strgt	r0, [r0], #-53	; 0x35
    307c:	01000035 	tsteq	r0, r5, lsr r0
    3080:	35c45d00 	strbcc	r5, [r4, #3328]	; 0xd00
    3084:	37600000 	strbcc	r0, [r0, -r0]!
    3088:	00020000 	andeq	r0, r2, r0
    308c:	0000287d 	andeq	r2, r0, sp, ror r8
    3090:	00000000 	andeq	r0, r0, r0
    3094:	35c00000 	strbcc	r0, [r0]
    3098:	35e80000 	strbcc	r0, [r8]!
    309c:	00010000 	andeq	r0, r1, r0
    30a0:	0035e850 	eorseq	lr, r5, r0, asr r8
    30a4:	00362400 	eorseq	r2, r6, r0, lsl #8
    30a8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    30ac:	00003624 	andeq	r3, r0, r4, lsr #12
    30b0:	00003644 	andeq	r3, r0, r4, asr #12
    30b4:	44500001 	ldrbmi	r0, [r0], #-1
    30b8:	18000036 	stmdane	r0, {r1, r2, r4, r5}
    30bc:	01000037 	tsteq	r0, r7, lsr r0
    30c0:	37185500 	ldrcc	r5, [r8, -r0, lsl #10]
    30c4:	371c0000 	ldrcc	r0, [ip, -r0]
    30c8:	00010000 	andeq	r0, r1, r0
    30cc:	00371c50 	eorseq	r1, r7, r0, asr ip
    30d0:	00376000 	eorseq	r6, r7, r0
    30d4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    30e0:	000035c0 	andeq	r3, r0, r0, asr #11
    30e4:	000035e8 	andeq	r3, r0, r8, ror #11
    30e8:	e8510001 	ldmda	r1, {r0}^
    30ec:	60000035 	andvs	r0, r0, r5, lsr r0
    30f0:	01000037 	tsteq	r0, r7, lsr r0
    30f4:	00005600 	andeq	r5, r0, r0, lsl #12
    30f8:	00000000 	andeq	r0, r0, r0
    30fc:	35c00000 	strbcc	r0, [r0]
    3100:	35e80000 	strbcc	r0, [r8]!
    3104:	00010000 	andeq	r0, r1, r0
    3108:	0035e852 	eorseq	lr, r5, r2, asr r8
    310c:	0035f000 	eorseq	pc, r5, r0
    3110:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    3114:	000035f0 	strdeq	r3, [r0], -r0
    3118:	00003604 	andeq	r3, r0, r4, lsl #12
    311c:	04520001 	ldrbeq	r0, [r2], #-1
    3120:	10000036 	andne	r0, r0, r6, lsr r0
    3124:	01000036 	tsteq	r0, r6, lsr r0
    3128:	36105700 	ldrcc	r5, [r0], -r0, lsl #14
    312c:	36440000 	strbcc	r0, [r4], -r0
    3130:	00010000 	andeq	r0, r1, r0
    3134:	00364452 	eorseq	r4, r6, r2, asr r4
    3138:	00370400 	eorseq	r0, r7, r0, lsl #8
    313c:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    3140:	00003704 	andeq	r3, r0, r4, lsl #14
    3144:	0000371c 	andeq	r3, r0, ip, lsl r7
    3148:	1c520001 	mrrcne	0, 0, r0, r2, cr1
    314c:	60000037 	andvs	r0, r0, r7, lsr r0
    3150:	01000037 	tsteq	r0, r7, lsr r0
    3154:	00005700 	andeq	r5, r0, r0, lsl #14
    3158:	00000000 	andeq	r0, r0, r0
    315c:	35c00000 	strbcc	r0, [r0]
    3160:	35c40000 	strbcc	r0, [r4]
    3164:	00010000 	andeq	r0, r1, r0
    3168:	0035dc53 	eorseq	sp, r5, r3, asr ip
    316c:	0035e800 	eorseq	lr, r5, r0, lsl #16
    3170:	53000100 	movwpl	r0, #256	; 0x100
    3174:	000035e8 	andeq	r3, r0, r8, ror #11
    3178:	00003760 	andeq	r3, r0, r0, ror #14
    317c:	005b0001 	subseq	r0, fp, r1
    3180:	00000000 	andeq	r0, r0, r0
    3184:	c0000000 	andgt	r0, r0, r0
    3188:	ac000035 	stcge	0, cr0, [r0], {53}	; 0x35
    318c:	02000036 	andeq	r0, r0, #54	; 0x36
    3190:	ac009100 	stfged	f1, [r0], {0}
    3194:	b0000036 	andlt	r0, r0, r6, lsr r0
    3198:	01000036 	tsteq	r0, r6, lsr r0
    319c:	36b05300 	ldrtcc	r5, [r0], r0, lsl #6
    31a0:	37040000 	strcc	r0, [r4, -r0]
    31a4:	00020000 	andeq	r0, r2, r0
    31a8:	37047891 	undefined instruction 0x37047891
    31ac:	371c0000 	ldrcc	r0, [ip, -r0]
    31b0:	00020000 	andeq	r0, r2, r0
    31b4:	371c0091 	undefined instruction 0x371c0091
    31b8:	37380000 	ldrcc	r0, [r8, -r0]!
    31bc:	00020000 	andeq	r0, r2, r0
    31c0:	37387891 	undefined instruction 0x37387891
    31c4:	37480000 	strbcc	r0, [r8, -r0]
    31c8:	00020000 	andeq	r0, r2, r0
    31cc:	37480091 	undefined instruction 0x37480091
    31d0:	37600000 	strbcc	r0, [r0, -r0]!
    31d4:	00020000 	andeq	r0, r2, r0
    31d8:	00007891 	muleq	r0, r1, r8
    31dc:	00000000 	andeq	r0, r0, r0
    31e0:	35c00000 	strbcc	r0, [r0]
    31e4:	35e80000 	strbcc	r0, [r8]!
    31e8:	00020000 	andeq	r0, r2, r0
    31ec:	35e80491 	strbcc	r0, [r8, #1169]!	; 0x491
    31f0:	36040000 	strcc	r0, [r4], -r0
    31f4:	00010000 	andeq	r0, r1, r0
    31f8:	00360459 	eorseq	r0, r6, r9, asr r4
    31fc:	00361000 	eorseq	r1, r6, r0
    3200:	91000200 	tstls	r0, r0, lsl #4
    3204:	0036107c 	eorseq	r1, r6, ip, ror r0
    3208:	0036bc00 	eorseq	fp, r6, r0, lsl #24
    320c:	59000100 	stmdbpl	r0, {r8}
    3210:	000036bc 	undefined instruction 0x000036bc
    3214:	00003704 	andeq	r3, r0, r4, lsl #14
    3218:	7c910002 	ldcvc	0, cr0, [r1], {2}
    321c:	00003704 	andeq	r3, r0, r4, lsl #14
    3220:	0000371c 	andeq	r3, r0, ip, lsl r7
    3224:	1c590001 	mrrcne	0, 0, r0, r9, cr1
    3228:	38000037 	stmdacc	r0, {r0, r1, r2, r4, r5}
    322c:	02000037 	andeq	r0, r0, #55	; 0x37
    3230:	387c9100 	ldmdacc	ip!, {r8, ip, pc}^
    3234:	60000037 	andvs	r0, r0, r7, lsr r0
    3238:	01000037 	tsteq	r0, r7, lsr r0
    323c:	00005900 	andeq	r5, r0, r0, lsl #18
    3240:	00000000 	andeq	r0, r0, r0
    3244:	35c00000 	strbcc	r0, [r0]
    3248:	35e80000 	strbcc	r0, [r8]!
    324c:	00020000 	andeq	r0, r2, r0
    3250:	35e80891 	strbcc	r0, [r8, #2193]!	; 0x891
    3254:	37600000 	strbcc	r0, [r0, -r0]!
    3258:	00010000 	andeq	r0, r1, r0
    325c:	00000054 	andeq	r0, r0, r4, asr r0
    3260:	00000000 	andeq	r0, r0, r0
    3264:	00360400 	eorseq	r0, r6, r0, lsl #8
    3268:	00361000 	eorseq	r1, r6, r0
    326c:	5a000100 	bpl	3674 <DISABLE_IRQ+0x35f4>
    3270:	000036c4 	andeq	r3, r0, r4, asr #13
    3274:	00003704 	andeq	r3, r0, r4, lsl #14
    3278:	1c5a0001 	mrrcne	0, 0, r0, sl, cr1
    327c:	38000037 	stmdacc	r0, {r0, r1, r2, r4, r5}
    3280:	01000037 	tsteq	r0, r7, lsr r0
    3284:	00005a00 	andeq	r5, r0, r0, lsl #20
    3288:	00000000 	andeq	r0, r0, r0
    328c:	36dc0000 	ldrbcc	r0, [ip], r0
    3290:	36f80000 	ldrbtcc	r0, [r8], r0
    3294:	00010000 	andeq	r0, r1, r0
    3298:	00374c52 	eorseq	r4, r7, r2, asr ip
    329c:	00376000 	eorseq	r6, r7, r0
    32a0:	52000100 	andpl	r0, r0, #0
	...
    32ac:	00003760 	andeq	r3, r0, r0, ror #14
    32b0:	00003764 	andeq	r3, r0, r4, ror #14
    32b4:	645d0001 	ldrbvs	r0, [sp], #-1
    32b8:	6c000037 	stcvs	0, cr0, [r0], {55}	; 0x37
    32bc:	02000037 	andeq	r0, r0, #55	; 0x37
    32c0:	6c207d00 	stcvs	13, cr7, [r0]
    32c4:	28000037 	stmdacs	r0, {r0, r1, r2, r4, r5}
    32c8:	02000038 	andeq	r0, r0, #56	; 0x38
    32cc:	00287d00 	eoreq	r7, r8, r0, lsl #26
    32d0:	00000000 	andeq	r0, r0, r0
    32d4:	60000000 	andvs	r0, r0, r0
    32d8:	84000037 	strhi	r0, [r0], #-55	; 0x37
    32dc:	01000037 	tsteq	r0, r7, lsr r0
    32e0:	00005000 	andeq	r5, r0, r0
    32e4:	00000000 	andeq	r0, r0, r0
    32e8:	37d40000 	ldrbcc	r0, [r4, r0]
    32ec:	37e80000 	strbcc	r0, [r8, r0]!
    32f0:	00010000 	andeq	r0, r1, r0
    32f4:	0037e853 	eorseq	lr, r7, r3, asr r8
    32f8:	0037f000 	eorseq	pc, r7, r0
    32fc:	53000100 	movwpl	r0, #256	; 0x100
	...
    3308:	00003828 	andeq	r3, r0, r8, lsr #16
    330c:	0000382c 	andeq	r3, r0, ip, lsr #16
    3310:	2c5d0001 	mrrccs	0, 0, r0, sp, cr1
    3314:	34000038 	strcc	r0, [r0], #-56	; 0x38
    3318:	02000038 	andeq	r0, r0, #56	; 0x38
    331c:	34147d00 	ldrcc	r7, [r4], #-3328	; 0xd00
    3320:	88000038 	stmdahi	r0, {r3, r4, r5}
    3324:	02000039 	andeq	r0, r0, #57	; 0x39
    3328:	00207d00 	eoreq	r7, r0, r0, lsl #26
    332c:	00000000 	andeq	r0, r0, r0
    3330:	28000000 	stmdacs	r0, {}
    3334:	3c000038 	stccc	0, cr0, [r0], {56}	; 0x38
    3338:	01000038 	tsteq	r0, r8, lsr r0
    333c:	383c5000 	ldmdacc	ip!, {ip, lr}
    3340:	384c0000 	stmdacc	ip, {}^
    3344:	00010000 	andeq	r0, r1, r0
    3348:	00384c54 	eorseq	r4, r8, r4, asr ip
    334c:	00386000 	eorseq	r6, r8, r0
    3350:	50000100 	andpl	r0, r0, r0, lsl #2
    3354:	00003860 	andeq	r3, r0, r0, ror #16
    3358:	00003870 	andeq	r3, r0, r0, ror r8
    335c:	70540001 	subsvc	r0, r4, r1
    3360:	90000038 	andls	r0, r0, r8, lsr r0
    3364:	01000038 	tsteq	r0, r8, lsr r0
    3368:	38905000 	ldmcc	r0, {ip, lr}
    336c:	39700000 	ldmdbcc	r0!, {}^
    3370:	00010000 	andeq	r0, r1, r0
    3374:	00397854 	eorseq	r7, r9, r4, asr r8
    3378:	00398800 	eorseq	r8, r9, r0, lsl #16
    337c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    3388:	00003828 	andeq	r3, r0, r8, lsr #16
    338c:	0000388c 	andeq	r3, r0, ip, lsl #17
    3390:	a4510001 	ldrbge	r0, [r1], #-1
    3394:	dc000038 	stcle	0, cr0, [r0], {56}	; 0x38
    3398:	01000038 	tsteq	r0, r8, lsr r0
    339c:	38e85100 	stmiacc	r8!, {r8, ip, lr}^
    33a0:	38f40000 	ldmcc	r4!, {}^
    33a4:	00010000 	andeq	r0, r1, r0
    33a8:	00390051 	eorseq	r0, r9, r1, asr r0
    33ac:	00390400 	eorseq	r0, r9, r0, lsl #8
    33b0:	51000100 	tstpl	r0, r0, lsl #2
    33b4:	00003910 	andeq	r3, r0, r0, lsl r9
    33b8:	00003920 	andeq	r3, r0, r0, lsr #18
    33bc:	34510001 	ldrbcc	r0, [r1], #-1
    33c0:	40000039 	andmi	r0, r0, r9, lsr r0
    33c4:	01000039 	tsteq	r0, r9, lsr r0
    33c8:	00005100 	andeq	r5, r0, r0, lsl #2
    33cc:	00000000 	andeq	r0, r0, r0
    33d0:	38280000 	stmdacc	r8!, {}
    33d4:	383c0000 	ldmdacc	ip!, {}
    33d8:	00010000 	andeq	r0, r1, r0
    33dc:	00383c52 	eorseq	r3, r8, r2, asr ip
    33e0:	00398800 	eorseq	r8, r9, r0, lsl #16
    33e4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    33f0:	00003860 	andeq	r3, r0, r0, ror #16
    33f4:	00003870 	andeq	r3, r0, r0, ror r8
    33f8:	a8570001 	ldmdage	r7, {r0}^
    33fc:	88000038 	stmdahi	r0, {r3, r4, r5}
    3400:	01000039 	tsteq	r0, r9, lsr r0
    3404:	00005700 	andeq	r5, r0, r0, lsl #14
    3408:	00000000 	andeq	r0, r0, r0
    340c:	39880000 	stmibcc	r8, {}
    3410:	398c0000 	stmibcc	ip, {}
    3414:	00010000 	andeq	r0, r1, r0
    3418:	00398c5d 	eorseq	r8, r9, sp, asr ip
    341c:	003aa800 	eorseq	sl, sl, r0, lsl #16
    3420:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3424:	00000018 	andeq	r0, r0, r8, lsl r0
    3428:	00000000 	andeq	r0, r0, r0
    342c:	00398800 	eorseq	r8, r9, r0, lsl #16
    3430:	00399c00 	eorseq	r9, r9, r0, lsl #24
    3434:	50000100 	andpl	r0, r0, r0, lsl #2
    3438:	0000399c 	muleq	r0, ip, r9
    343c:	00003aa8 	andeq	r3, r0, r8, lsr #21
    3440:	00540001 	subseq	r0, r4, r1
    3444:	00000000 	andeq	r0, r0, r0
    3448:	88000000 	stmdahi	r0, {}
    344c:	a0000039 	andge	r0, r0, r9, lsr r0
    3450:	01000039 	tsteq	r0, r9, lsr r0
    3454:	39a05100 	stmibcc	r0!, {r8, ip, lr}
    3458:	3aa80000 	bcc	fea03460 <rEINTPEND+0xa8a033b8>
    345c:	00010000 	andeq	r0, r1, r0
    3460:	00000055 	andeq	r0, r0, r5, asr r0
    3464:	00000000 	andeq	r0, r0, r0
    3468:	00398800 	eorseq	r8, r9, r0, lsl #16
    346c:	0039a000 	eorseq	sl, r9, r0
    3470:	52000100 	andpl	r0, r0, #0
    3474:	000039a0 	andeq	r3, r0, r0, lsr #19
    3478:	000039fc 	strdeq	r3, [r0], -ip
    347c:	08560001 	ldmdaeq	r6, {r0}^
    3480:	6800003a 	stmdavs	r0, {r1, r3, r4, r5}
    3484:	0100003a 	tsteq	r0, sl, lsr r0
    3488:	3a745600 	bcc	1d18c90 <MEM_SIZE+0x1518c90>
    348c:	3aa80000 	bcc	fea03494 <rEINTPEND+0xa8a033ec>
    3490:	00010000 	andeq	r0, r1, r0
    3494:	00000056 	andeq	r0, r0, r6, asr r0
    3498:	00000000 	andeq	r0, r0, r0
    349c:	003a0c00 	eorseq	r0, sl, r0, lsl #24
    34a0:	003a5400 	eorseq	r5, sl, r0, lsl #8
    34a4:	53000100 	movwpl	r0, #256	; 0x100
    34a8:	00003a5c 	andeq	r3, r0, ip, asr sl
    34ac:	00003a60 	andeq	r3, r0, r0, ror #20
    34b0:	88530001 	ldmdahi	r3, {r0}^
    34b4:	a800003a 	stmdage	r0, {r1, r3, r4, r5}
    34b8:	0100003a 	tsteq	r0, sl, lsr r0
    34bc:	00005300 	andeq	r5, r0, r0, lsl #6
    34c0:	00000000 	andeq	r0, r0, r0
    34c4:	39b00000 	ldmibcc	r0!, {}
    34c8:	39b80000 	ldmibcc	r8!, {}
    34cc:	00010000 	andeq	r0, r1, r0
    34d0:	0039c457 	eorseq	ip, r9, r7, asr r4
    34d4:	003aa800 	eorseq	sl, sl, r0, lsl #16
    34d8:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    34e4:	00003aa8 	andeq	r3, r0, r8, lsr #21
    34e8:	00003aac 	andeq	r3, r0, ip, lsr #21
    34ec:	ac5d0001 	mrrcge	0, 0, r0, sp, cr1
    34f0:	b400003a 	strlt	r0, [r0], #-58	; 0x3a
    34f4:	0200003a 	andeq	r0, r0, #58	; 0x3a
    34f8:	b40c7d00 	strlt	r7, [ip], #-3328	; 0xd00
    34fc:	6c00003a 	stcvs	0, cr0, [r0], {58}	; 0x3a
    3500:	0200003b 	andeq	r0, r0, #59	; 0x3b
    3504:	00187d00 	andseq	r7, r8, r0, lsl #26
    3508:	00000000 	andeq	r0, r0, r0
    350c:	a8000000 	stmdage	r0, {}
    3510:	b800003a 	stmdalt	r0, {r1, r3, r4, r5}
    3514:	0100003a 	tsteq	r0, sl, lsr r0
    3518:	3ab85000 	bcc	fee17520 <rEINTPEND+0xa8e17478>
    351c:	3b6c0000 	blcc	1b03524 <MEM_SIZE+0x1303524>
    3520:	00010000 	andeq	r0, r1, r0
    3524:	00000055 	andeq	r0, r0, r5, asr r0
    3528:	00000000 	andeq	r0, r0, r0
    352c:	003aa800 	eorseq	sl, sl, r0, lsl #16
    3530:	003adc00 	eorseq	sp, sl, r0, lsl #24
    3534:	51000100 	tstpl	r0, r0, lsl #2
    3538:	00003b2c 	andeq	r3, r0, ip, lsr #22
    353c:	00003b38 	andeq	r3, r0, r8, lsr fp
    3540:	00510001 	subseq	r0, r1, r1
    3544:	00000000 	andeq	r0, r0, r0
    3548:	f8000000 	undefined instruction 0xf8000000
    354c:	3800003a 	stmdacc	r0, {r1, r3, r4, r5}
    3550:	0100003b 	tsteq	r0, fp, lsr r0
    3554:	3b405300 	blcc	101815c <MEM_SIZE+0x81815c>
    3558:	3b440000 	blcc	1103560 <MEM_SIZE+0x903560>
    355c:	00010000 	andeq	r0, r1, r0
    3560:	00000053 	andeq	r0, r0, r3, asr r0
    3564:	00000000 	andeq	r0, r0, r0
    3568:	003acc00 	eorseq	ip, sl, r0, lsl #24
    356c:	003ad800 	eorseq	sp, sl, r0, lsl #16
    3570:	54000100 	strpl	r0, [r0], #-256	; 0x100
    3574:	00003ae8 	andeq	r3, r0, r8, ror #21
    3578:	00003b6c 	andeq	r3, r0, ip, ror #22
    357c:	00540001 	subseq	r0, r4, r1
    3580:	00000000 	andeq	r0, r0, r0
    3584:	6c000000 	stcvs	0, cr0, [r0], {0}
    3588:	7000003b 	andvc	r0, r0, fp, lsr r0
    358c:	0100003b 	tsteq	r0, fp, lsr r0
    3590:	3b705d00 	blcc	1c1a998 <MEM_SIZE+0x141a998>
    3594:	3b780000 	blcc	1e0359c <MEM_SIZE+0x160359c>
    3598:	00020000 	andeq	r0, r2, r0
    359c:	3b780c7d 	blcc	1e06798 <MEM_SIZE+0x1606798>
    35a0:	3c2c0000 	stccc	0, cr0, [ip]
    35a4:	00020000 	andeq	r0, r2, r0
    35a8:	0000187d 	andeq	r1, r0, sp, ror r8
    35ac:	00000000 	andeq	r0, r0, r0
    35b0:	3b6c0000 	blcc	1b035b8 <MEM_SIZE+0x13035b8>
    35b4:	3b7c0000 	blcc	1f035bc <MEM_SIZE+0x17035bc>
    35b8:	00010000 	andeq	r0, r1, r0
    35bc:	003b7c50 	eorseq	r7, fp, r0, asr ip
    35c0:	003c2c00 	eorseq	r2, ip, r0, lsl #24
    35c4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    35d0:	00003b6c 	andeq	r3, r0, ip, ror #22
    35d4:	00003ba0 	andeq	r3, r0, r0, lsr #23
    35d8:	d8510001 	ldmdale	r1, {r0}^
    35dc:	f800003b 	undefined instruction 0xf800003b
    35e0:	0100003b 	tsteq	r0, fp, lsr r0
    35e4:	00005100 	andeq	r5, r0, r0, lsl #2
    35e8:	00000000 	andeq	r0, r0, r0
    35ec:	3bbc0000 	blcc	fef035f4 <rEINTPEND+0xa8f0354c>
    35f0:	3bf80000 	blcc	ffe035f8 <rEINTPEND+0xa9e03550>
    35f4:	00010000 	andeq	r0, r1, r0
    35f8:	003c0053 	eorseq	r0, ip, r3, asr r0
    35fc:	003c0400 	eorseq	r0, ip, r0, lsl #8
    3600:	53000100 	movwpl	r0, #256	; 0x100
	...
    360c:	00003b90 	muleq	r0, r0, fp
    3610:	00003b9c 	muleq	r0, ip, fp
    3614:	ac540001 	mrrcge	0, 0, r0, r4, cr1
    3618:	2c00003b 	stccs	0, cr0, [r0], {59}	; 0x3b
    361c:	0100003c 	tsteq	r0, ip, lsr r0
    3620:	00005400 	andeq	r5, r0, r0, lsl #8
    3624:	00000000 	andeq	r0, r0, r0
    3628:	3c2c0000 	stccc	0, cr0, [ip]
    362c:	3c300000 	ldccc	0, cr0, [r0]
    3630:	00010000 	andeq	r0, r1, r0
    3634:	003c305d 	eorseq	r3, ip, sp, asr r0
    3638:	003e1400 	eorseq	r1, lr, r0, lsl #8
    363c:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3640:	00000018 	andeq	r0, r0, r8, lsl r0
    3644:	00000000 	andeq	r0, r0, r0
    3648:	003c2c00 	eorseq	r2, ip, r0, lsl #24
    364c:	003c5400 	eorseq	r5, ip, r0, lsl #8
    3650:	50000100 	andpl	r0, r0, r0, lsl #2
    3654:	00003c54 	andeq	r3, r0, r4, asr ip
    3658:	00003c68 	andeq	r3, r0, r8, ror #24
    365c:	68540001 	ldmdavs	r4, {r0}^
    3660:	a400003c 	strge	r0, [r0], #-60	; 0x3c
    3664:	0100003c 	tsteq	r0, ip, lsr r0
    3668:	3ca85000 	stccc	0, cr5, [r8]
    366c:	3cc00000 	stclcc	0, cr0, [r0], {0}
    3670:	00010000 	andeq	r0, r1, r0
    3674:	003ce454 	eorseq	lr, ip, r4, asr r4
    3678:	003ce800 	eorseq	lr, ip, r0, lsl #16
    367c:	50000100 	andpl	r0, r0, r0, lsl #2
    3680:	00003ce8 	andeq	r3, r0, r8, ror #25
    3684:	00003d94 	muleq	r0, r4, sp
    3688:	ac540001 	mrrcge	0, 0, r0, r4, cr1
    368c:	e000003d 	and	r0, r0, sp, lsr r0
    3690:	0100003d 	tsteq	r0, sp, lsr r0
    3694:	00005400 	andeq	r5, r0, r0, lsl #8
    3698:	00000000 	andeq	r0, r0, r0
    369c:	3c2c0000 	stccc	0, cr0, [ip]
    36a0:	3c440000 	marcc	acc0, r0, r4
    36a4:	00010000 	andeq	r0, r1, r0
    36a8:	003c4451 	eorseq	r4, ip, r1, asr r4
    36ac:	003d9000 	eorseq	r9, sp, r0
    36b0:	56000100 	strpl	r0, [r0], -r0, lsl #2
    36b4:	00003dac 	andeq	r3, r0, ip, lsr #27
    36b8:	00003e14 	andeq	r3, r0, r4, lsl lr
    36bc:	00560001 	subseq	r0, r6, r1
    36c0:	00000000 	andeq	r0, r0, r0
    36c4:	2c000000 	stccs	0, cr0, [r0], {0}
    36c8:	4400003c 	strmi	r0, [r0], #-60	; 0x3c
    36cc:	0100003c 	tsteq	r0, ip, lsr r0
    36d0:	3c445200 	sfmcc	f5, 2, [r4], {0}	; (stclcc 2, cr5, [r4], {0})
    36d4:	3e140000 	cdpcc	0, 1, cr0, cr4, cr0, {0}
    36d8:	00010000 	andeq	r0, r1, r0
    36dc:	00000055 	andeq	r0, r0, r5, asr r0
    36e0:	00000000 	andeq	r0, r0, r0
    36e4:	003c4000 	eorseq	r4, ip, r0
    36e8:	003de000 	eorseq	lr, sp, r0
    36ec:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    36f8:	00003ca8 	andeq	r3, r0, r8, lsr #25
    36fc:	00003cdc 	ldrdeq	r3, [r0], -ip
    3700:	f0530001 	undefined instruction 0xf0530001
    3704:	0400003c 	streq	r0, [r0], #-60	; 0x3c
    3708:	0100003d 	tsteq	r0, sp, lsr r0
    370c:	00005300 	andeq	r5, r0, r0, lsl #6
    3710:	00000000 	andeq	r0, r0, r0
    3714:	3d800000 	stccc	0, cr0, [r0]
    3718:	3da40000 	stccc	0, cr0, [r4]
    371c:	00010000 	andeq	r0, r1, r0
    3720:	003dac51 	eorseq	sl, sp, r1, asr ip
    3724:	003df400 	eorseq	pc, sp, r0, lsl #8
    3728:	51000100 	tstpl	r0, r0, lsl #2
	...
    3734:	00003e14 	andeq	r3, r0, r4, lsl lr
    3738:	00003e18 	andeq	r3, r0, r8, lsl lr
    373c:	185d0001 	ldmdane	sp, {r0}^
    3740:	2000003e 	andcs	r0, r0, lr, lsr r0
    3744:	0200003e 	andeq	r0, r0, #62	; 0x3e
    3748:	20147d00 	andscs	r7, r4, r0, lsl #26
    374c:	a000003e 	andge	r0, r0, lr, lsr r0
    3750:	0200003f 	andeq	r0, r0, #63	; 0x3f
    3754:	00207d00 	eoreq	r7, r0, r0, lsl #26
    3758:	00000000 	andeq	r0, r0, r0
    375c:	14000000 	strne	r0, [r0]
    3760:	2800003e 	stmdacs	r0, {r1, r2, r3, r4, r5}
    3764:	0100003e 	tsteq	r0, lr, lsr r0
    3768:	3e285000 	cdpcc	0, 2, cr5, cr8, cr0, {0}
    376c:	3e380000 	cdpcc	0, 3, cr0, cr8, cr0, {0}
    3770:	00010000 	andeq	r0, r1, r0
    3774:	003e3854 	eorseq	r3, lr, r4, asr r8
    3778:	003e4c00 	eorseq	r4, lr, r0, lsl #24
    377c:	50000100 	andpl	r0, r0, r0, lsl #2
    3780:	00003e4c 	andeq	r3, r0, ip, asr #28
    3784:	00003e5c 	andeq	r3, r0, ip, asr lr
    3788:	5c540001 	mrrcpl	0, 0, r0, r4, cr1
    378c:	7c00003e 	stcvc	0, cr0, [r0], {62}	; 0x3e
    3790:	0100003e 	tsteq	r0, lr, lsr r0
    3794:	3e7c5000 	cdpcc	0, 7, cr5, cr12, cr0, {0}
    3798:	3f840000 	svccc	0x00840000
    379c:	00010000 	andeq	r0, r1, r0
    37a0:	003f8c54 	eorseq	r8, pc, r4, asr ip
    37a4:	003fa000 	eorseq	sl, pc, r0
    37a8:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    37b4:	00003e14 	andeq	r3, r0, r4, lsl lr
    37b8:	00003e78 	andeq	r3, r0, r8, ror lr
    37bc:	90510001 	subsls	r0, r1, r1
    37c0:	b400003e 	strlt	r0, [r0], #-62	; 0x3e
    37c4:	0100003e 	tsteq	r0, lr, lsr r0
    37c8:	3ee85100 	cdpcc	1, 14, cr5, cr8, cr0, {0}
    37cc:	3ef40000 	cdpcc	0, 15, cr0, cr4, cr0, {0}
    37d0:	00010000 	andeq	r0, r1, r0
    37d4:	003f0051 	eorseq	r0, pc, r1, asr r0
    37d8:	003f0400 	eorseq	r0, pc, r0, lsl #8
    37dc:	51000100 	tstpl	r0, r0, lsl #2
    37e0:	00003f10 	andeq	r3, r0, r0, lsl pc
    37e4:	00003f20 	andeq	r3, r0, r0, lsr #30
    37e8:	34510001 	ldrbcc	r0, [r1], #-1
    37ec:	3c00003f 	stccc	0, cr0, [r0], {63}	; 0x3f
    37f0:	0100003f 	tsteq	r0, pc, lsr r0
    37f4:	00005100 	andeq	r5, r0, r0, lsl #2
    37f8:	00000000 	andeq	r0, r0, r0
    37fc:	3e140000 	cdpcc	0, 1, cr0, cr4, cr0, {0}
    3800:	3e280000 	cdpcc	0, 2, cr0, cr8, cr0, {0}
    3804:	00010000 	andeq	r0, r1, r0
    3808:	003e2852 	eorseq	r2, lr, r2, asr r8
    380c:	003fa000 	eorseq	sl, pc, r0
    3810:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    381c:	00003eb4 	undefined instruction 0x00003eb4
    3820:	00003edc 	ldrdeq	r3, [r0], -ip
    3824:	4c510001 	mrrcmi	0, 0, r0, r1, cr1
    3828:	7000003f 	andvc	r0, r0, pc, lsr r0
    382c:	0100003f 	tsteq	r0, pc, lsr r0
    3830:	00005000 	andeq	r5, r0, r0
    3834:	00000000 	andeq	r0, r0, r0
    3838:	3e4c0000 	cdpcc	0, 4, cr0, cr12, cr0, {0}
    383c:	3e5c0000 	cdpcc	0, 5, cr0, cr12, cr0, {0}
    3840:	00010000 	andeq	r0, r1, r0
    3844:	003e9457 	eorseq	r9, lr, r7, asr r4
    3848:	003fa000 	eorseq	sl, pc, r0
    384c:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    3858:	00003fa0 	andeq	r3, r0, r0, lsr #31
    385c:	00003fa4 	andeq	r3, r0, r4, lsr #31
    3860:	a45d0001 	ldrbge	r0, [sp], #-1
    3864:	5400003f 	strpl	r0, [r0], #-63	; 0x3f
    3868:	02000041 	andeq	r0, r0, #65	; 0x41
    386c:	00207d00 	eoreq	r7, r0, r0, lsl #26
    3870:	00000000 	andeq	r0, r0, r0
    3874:	a0000000 	andge	r0, r0, r0
    3878:	b800003f 	stmdalt	r0, {r0, r1, r2, r3, r4, r5}
    387c:	0100003f 	tsteq	r0, pc, lsr r0
    3880:	3fb85000 	svccc	0x00b85000
    3884:	41540000 	cmpmi	r4, r0
    3888:	00010000 	andeq	r0, r1, r0
    388c:	00000054 	andeq	r0, r0, r4, asr r0
    3890:	00000000 	andeq	r0, r0, r0
    3894:	003fd800 	eorseq	sp, pc, r0, lsl #16
    3898:	003fe000 	eorseq	lr, pc, r0
    389c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    38a0:	00004014 	andeq	r4, r0, r4, lsl r0
    38a4:	00004154 	andeq	r4, r0, r4, asr r1
    38a8:	00560001 	subseq	r0, r6, r1
    38ac:	00000000 	andeq	r0, r0, r0
    38b0:	20000000 	andcs	r0, r0, r0
    38b4:	44000040 	strmi	r0, [r0], #-64	; 0x40
    38b8:	01000040 	tsteq	r0, r0, asr #32
    38bc:	407c5e00 	rsbsmi	r5, ip, r0, lsl #28
    38c0:	40940000 	addsmi	r0, r4, r0
    38c4:	00010000 	andeq	r0, r1, r0
    38c8:	0040cc5e 	subeq	ip, r0, lr, asr ip
    38cc:	00412c00 	subeq	r2, r1, r0, lsl #24
    38d0:	5e000100 	adfpls	f0, f0, f0
	...
    38dc:	00003fd8 	ldrdeq	r3, [r0], -r8
    38e0:	00003fe0 	andeq	r3, r0, r0, ror #31
    38e4:	f4550001 	undefined instruction 0xf4550001
    38e8:	5400003f 	strpl	r0, [r0], #-63	; 0x3f
    38ec:	01000041 	tsteq	r0, r1, asr #32
    38f0:	00005500 	andeq	r5, r0, r0, lsl #10
    38f4:	00000000 	andeq	r0, r0, r0
    38f8:	41540000 	cmpmi	r4, r0
    38fc:	41580000 	cmpmi	r8, r0
    3900:	00010000 	andeq	r0, r1, r0
    3904:	0041585d 	subeq	r5, r1, sp, asr r8
    3908:	00416000 	subeq	r6, r1, r0
    390c:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3910:	00416024 	subeq	r6, r1, r4, lsr #32
    3914:	0044cc00 	subeq	ip, r4, r0, lsl #24
    3918:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    391c:	00000038 	andeq	r0, r0, r8, lsr r0
    3920:	00000000 	andeq	r0, r0, r0
    3924:	00415400 	subeq	r5, r1, r0, lsl #8
    3928:	00416800 	subeq	r6, r1, r0, lsl #16
    392c:	50000100 	andpl	r0, r0, r0, lsl #2
    3930:	00004168 	andeq	r4, r0, r8, ror #2
    3934:	00004178 	andeq	r4, r0, r8, ror r1
    3938:	78540001 	ldmdavc	r4, {r0}^
    393c:	8c000041 	stchi	0, cr0, [r0], {65}	; 0x41
    3940:	01000041 	tsteq	r0, r1, asr #32
    3944:	418c5000 	orrmi	r5, ip, r0
    3948:	41980000 	orrsmi	r0, r8, r0
    394c:	00010000 	andeq	r0, r1, r0
    3950:	00419854 	subeq	r9, r1, r4, asr r8
    3954:	0041d000 	subeq	sp, r1, r0
    3958:	50000100 	andpl	r0, r0, r0, lsl #2
    395c:	000041d0 	ldrdeq	r4, [r0], -r0
    3960:	000043b8 	undefined instruction 0x000043b8
    3964:	c8540001 	ldmdagt	r4, {r0}^
    3968:	cc000043 	stcgt	0, cr0, [r0], {67}	; 0x43
    396c:	01000044 	tsteq	r0, r4, asr #32
    3970:	00005400 	andeq	r5, r0, r0, lsl #8
    3974:	00000000 	andeq	r0, r0, r0
    3978:	41540000 	cmpmi	r4, r0
    397c:	41cc0000 	bicmi	r0, ip, r0
    3980:	00010000 	andeq	r0, r1, r0
    3984:	0042e451 	subeq	lr, r2, r1, asr r4
    3988:	0042f000 	subeq	pc, r2, r0
    398c:	51000100 	tstpl	r0, r0, lsl #2
	...
    3998:	00004154 	andeq	r4, r0, r4, asr r1
    399c:	00004168 	andeq	r4, r0, r8, ror #2
    39a0:	68520001 	ldmdavs	r2, {r0}^
    39a4:	cc000041 	stcgt	0, cr0, [r0], {65}	; 0x41
    39a8:	01000044 	tsteq	r0, r4, asr #32
    39ac:	00005500 	andeq	r5, r0, r0, lsl #10
    39b0:	00000000 	andeq	r0, r0, r0
    39b4:	41e40000 	mvnmi	r0, r0
    39b8:	42c80000 	sbcmi	r0, r8, #0
    39bc:	00010000 	andeq	r0, r1, r0
    39c0:	0043c853 	subeq	ip, r3, r3, asr r8
    39c4:	0043f800 	subeq	pc, r3, r0, lsl #16
    39c8:	53000100 	movwpl	r0, #256	; 0x100
    39cc:	00004404 	andeq	r4, r0, r4, lsl #8
    39d0:	00004408 	andeq	r4, r0, r8, lsl #8
    39d4:	10530001 	subsne	r0, r3, r1
    39d8:	cc000044 	stcgt	0, cr0, [r0], {68}	; 0x44
    39dc:	01000044 	tsteq	r0, r4, asr #32
    39e0:	00005300 	andeq	r5, r0, r0, lsl #6
    39e4:	00000000 	andeq	r0, r0, r0
    39e8:	41f00000 	mvnsmi	r0, r0
    39ec:	42d40000 	sbcsmi	r0, r4, #0
    39f0:	00010000 	andeq	r0, r1, r0
    39f4:	00441050 	subeq	r1, r4, r0, asr r0
    39f8:	0044cc00 	subeq	ip, r4, r0, lsl #24
    39fc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    3a08:	000042ac 	andeq	r4, r0, ip, lsr #5
    3a0c:	000042b0 	undefined instruction 0x000042b0
    3a10:	14570001 	ldrbne	r0, [r7], #-1
    3a14:	94000044 	strls	r0, [r0], #-68	; 0x44
    3a18:	01000044 	tsteq	r0, r4, asr #32
    3a1c:	00005700 	andeq	r5, r0, r0, lsl #14
    3a20:	00000000 	andeq	r0, r0, r0
    3a24:	41d80000 	bicsmi	r0, r8, r0
    3a28:	43440000 	movtmi	r0, #16384	; 0x4000
    3a2c:	00010000 	andeq	r0, r1, r0
    3a30:	00435452 	subeq	r5, r3, r2, asr r4
    3a34:	0043a800 	subeq	sl, r3, r0, lsl #16
    3a38:	51000100 	tstpl	r0, r0, lsl #2
    3a3c:	000043b4 	undefined instruction 0x000043b4
    3a40:	000043c0 	andeq	r4, r0, r0, asr #7
    3a44:	c8510001 	ldmdagt	r1, {r0}^
    3a48:	cc000043 	stcgt	0, cr0, [r0], {67}	; 0x43
    3a4c:	01000043 	tsteq	r0, r3, asr #32
    3a50:	44105200 	ldrmi	r5, [r0], #-512	; 0x200
    3a54:	44cc0000 	strbmi	r0, [ip]
    3a58:	00010000 	andeq	r0, r1, r0
    3a5c:	00000052 	andeq	r0, r0, r2, asr r0
    3a60:	00000000 	andeq	r0, r0, r0
    3a64:	0044cc00 	subeq	ip, r4, r0, lsl #24
    3a68:	0044d000 	subeq	sp, r4, r0
    3a6c:	5d000100 	stfpls	f0, [r0]
    3a70:	000044d0 	ldrdeq	r4, [r0], -r0
    3a74:	000044dc 	ldrdeq	r4, [r0], -ip
    3a78:	247d0002 	ldrbtcs	r0, [sp], #-2
    3a7c:	000044dc 	ldrdeq	r4, [r0], -ip
    3a80:	00004708 	andeq	r4, r0, r8, lsl #14
    3a84:	307d0002 	rsbscc	r0, sp, r2
	...
    3a90:	000044cc 	andeq	r4, r0, ip, asr #9
    3a94:	000044e0 	andeq	r4, r0, r0, ror #9
    3a98:	e0500001 	subs	r0, r0, r1
    3a9c:	50000044 	andpl	r0, r0, r4, asr #32
    3aa0:	01000046 	tsteq	r0, r6, asr #32
    3aa4:	46585400 	ldrbmi	r5, [r8], -r0, lsl #8
    3aa8:	47080000 	strmi	r0, [r8, -r0]
    3aac:	00010000 	andeq	r0, r1, r0
    3ab0:	00000054 	andeq	r0, r0, r4, asr r0
    3ab4:	00000000 	andeq	r0, r0, r0
    3ab8:	0044cc00 	subeq	ip, r4, r0, lsl #24
    3abc:	00453400 	subeq	r3, r5, r0, lsl #8
    3ac0:	51000100 	tstpl	r0, r0, lsl #2
    3ac4:	0000454c 	andeq	r4, r0, ip, asr #10
    3ac8:	00004560 	andeq	r4, r0, r0, ror #10
    3acc:	a0510001 	subsge	r0, r1, r1
    3ad0:	ac000045 	stcge	0, cr0, [r0], {69}	; 0x45
    3ad4:	01000045 	tsteq	r0, r5, asr #32
    3ad8:	45b85100 	ldrmi	r5, [r8, #256]!	; 0x100
    3adc:	45bc0000 	ldrmi	r0, [ip]!
    3ae0:	00010000 	andeq	r0, r1, r0
    3ae4:	0045c851 	subeq	ip, r5, r1, asr r8
    3ae8:	0045d000 	subeq	sp, r5, r0
    3aec:	51000100 	tstpl	r0, r0, lsl #2
	...
    3af8:	000044cc 	andeq	r4, r0, ip, asr #9
    3afc:	000044e4 	andeq	r4, r0, r4, ror #9
    3b00:	e4520001 	ldrb	r0, [r2], #-1
    3b04:	08000044 	stmdaeq	r0, {r2, r6}
    3b08:	01000047 	tsteq	r0, r7, asr #32
    3b0c:	00005500 	andeq	r5, r0, r0, lsl #10
    3b10:	00000000 	andeq	r0, r0, r0
    3b14:	45ec0000 	strbmi	r0, [ip]!
    3b18:	45fc0000 	ldrbmi	r0, [ip]!
    3b1c:	00010000 	andeq	r0, r1, r0
    3b20:	0046005c 	subeq	r0, r6, ip, asr r0
    3b24:	00464400 	subeq	r4, r6, r0, lsl #8
    3b28:	5c000100 	stfpls	f0, [r0], {0}
    3b2c:	00004688 	andeq	r4, r0, r8, lsl #13
    3b30:	000046ec 	andeq	r4, r0, ip, ror #13
    3b34:	005c0001 	subseq	r0, ip, r1
    3b38:	00000000 	andeq	r0, r0, r0
    3b3c:	cc000000 	stcgt	0, cr0, [r0], {0}
    3b40:	f8000045 	undefined instruction 0xf8000045
    3b44:	01000045 	tsteq	r0, r5, asr #32
    3b48:	46005200 	strmi	r5, [r0], -r0, lsl #4
    3b4c:	46100000 	ldrmi	r0, [r0], -r0
    3b50:	00010000 	andeq	r0, r1, r0
    3b54:	00465852 	subeq	r5, r6, r2, asr r8
    3b58:	0046ec00 	subeq	lr, r6, r0, lsl #24
    3b5c:	52000100 	andpl	r0, r0, #0
	...
    3b68:	00004508 	andeq	r4, r0, r8, lsl #10
    3b6c:	00004518 	andeq	r4, r0, r8, lsl r5
    3b70:	50570001 	subspl	r0, r7, r1
    3b74:	08000045 	stmdaeq	r0, {r0, r2, r6}
    3b78:	01000047 	tsteq	r0, r7, asr #32
    3b7c:	00005700 	andeq	r5, r0, r0, lsl #14
    3b80:	00000000 	andeq	r0, r0, r0
    3b84:	47080000 	strmi	r0, [r8, -r0]
    3b88:	470c0000 	strmi	r0, [ip, -r0]
    3b8c:	00010000 	andeq	r0, r1, r0
    3b90:	00470c5d 	subeq	r0, r7, sp, asr ip
    3b94:	0047d800 	subeq	sp, r7, r0, lsl #16
    3b98:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3b9c:	00000018 	andeq	r0, r0, r8, lsl r0
    3ba0:	00000000 	andeq	r0, r0, r0
    3ba4:	00470800 	subeq	r0, r7, r0, lsl #16
    3ba8:	00471c00 	subeq	r1, r7, r0, lsl #24
    3bac:	50000100 	andpl	r0, r0, r0, lsl #2
    3bb0:	0000471c 	andeq	r4, r0, ip, lsl r7
    3bb4:	000047d8 	ldrdeq	r4, [r0], -r8
    3bb8:	00540001 	subseq	r0, r4, r1
    3bbc:	00000000 	andeq	r0, r0, r0
    3bc0:	08000000 	stmdaeq	r0, {}
    3bc4:	20000047 	andcs	r0, r0, r7, asr #32
    3bc8:	01000047 	tsteq	r0, r7, asr #32
    3bcc:	47205100 	strmi	r5, [r0, -r0, lsl #2]!
    3bd0:	472c0000 	strmi	r0, [ip, -r0]!
    3bd4:	00010000 	andeq	r0, r1, r0
    3bd8:	00472c55 	subeq	r2, r7, r5, asr ip
    3bdc:	00473c00 	subeq	r3, r7, r0, lsl #24
    3be0:	51000100 	tstpl	r0, r0, lsl #2
    3be4:	0000473c 	andeq	r4, r0, ip, lsr r7
    3be8:	00004744 	andeq	r4, r0, r4, asr #14
    3bec:	44550001 	ldrbmi	r0, [r5], #-1
    3bf0:	48000047 	stmdami	r0, {r0, r1, r2, r6}
    3bf4:	01000047 	tsteq	r0, r7, asr #32
    3bf8:	47485100 	strbmi	r5, [r8, -r0, lsl #2]
    3bfc:	47d80000 	ldrbmi	r0, [r8, r0]
    3c00:	00010000 	andeq	r0, r1, r0
    3c04:	00000055 	andeq	r0, r0, r5, asr r0
    3c08:	00000000 	andeq	r0, r0, r0
    3c0c:	00470800 	subeq	r0, r7, r0, lsl #16
    3c10:	00472000 	subeq	r2, r7, r0
    3c14:	52000100 	andpl	r0, r0, #0
    3c18:	00004720 	andeq	r4, r0, r0, lsr #14
    3c1c:	00004788 	andeq	r4, r0, r8, lsl #15
    3c20:	9c560001 	mrrcls	0, 0, r0, r6, cr1
    3c24:	a0000047 	andge	r0, r0, r7, asr #32
    3c28:	01000047 	tsteq	r0, r7, asr #32
    3c2c:	47b45600 	ldrmi	r5, [r4, r0, lsl #12]!
    3c30:	47c80000 	strbmi	r0, [r8, r0]
    3c34:	00010000 	andeq	r0, r1, r0
    3c38:	00000056 	andeq	r0, r0, r6, asr r0
    3c3c:	00000000 	andeq	r0, r0, r0
    3c40:	00473c00 	subeq	r3, r7, r0, lsl #24
    3c44:	00474400 	subeq	r4, r7, r0, lsl #8
    3c48:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    3c4c:	00004750 	andeq	r4, r0, r0, asr r7
    3c50:	000047d8 	ldrdeq	r4, [r0], -r8
    3c54:	00570001 	subseq	r0, r7, r1
    3c58:	00000000 	andeq	r0, r0, r0
    3c5c:	d8000000 	stmdale	r0, {}
    3c60:	dc000047 	stcle	0, cr0, [r0], {71}	; 0x47
    3c64:	01000047 	tsteq	r0, r7, asr #32
    3c68:	47dc5d00 	ldrbmi	r5, [ip, r0, lsl #26]
    3c6c:	47e40000 	strbmi	r0, [r4, r0]!
    3c70:	00020000 	andeq	r0, r2, r0
    3c74:	47e40c7d 	undefined instruction 0x47e40c7d
    3c78:	48780000 	ldmdami	r8!, {}^
    3c7c:	00020000 	andeq	r0, r2, r0
    3c80:	0000187d 	andeq	r1, r0, sp, ror r8
    3c84:	00000000 	andeq	r0, r0, r0
    3c88:	47d80000 	ldrbmi	r0, [r8, r0]
    3c8c:	47e80000 	strbmi	r0, [r8, r0]!
    3c90:	00010000 	andeq	r0, r1, r0
    3c94:	0047e850 	subeq	lr, r7, r0, asr r8
    3c98:	00487800 	subeq	r7, r8, r0, lsl #16
    3c9c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    3ca8:	000047d8 	ldrdeq	r4, [r0], -r8
    3cac:	00004818 	andeq	r4, r0, r8, lsl r8
    3cb0:	6c510001 	mrrcvs	0, 0, r0, r1, cr1
    3cb4:	70000048 	andvc	r0, r0, r8, asr #32
    3cb8:	01000048 	tsteq	r0, r8, asr #32
    3cbc:	00005100 	andeq	r5, r0, r0, lsl #2
    3cc0:	00000000 	andeq	r0, r0, r0
    3cc4:	48780000 	ldmdami	r8!, {}^
    3cc8:	487c0000 	ldmdami	ip!, {}^
    3ccc:	00010000 	andeq	r0, r1, r0
    3cd0:	00487c5d 	subeq	r7, r8, sp, asr ip
    3cd4:	004a4400 	subeq	r4, sl, r0, lsl #8
    3cd8:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3cdc:	00000018 	andeq	r0, r0, r8, lsl r0
    3ce0:	00000000 	andeq	r0, r0, r0
    3ce4:	00487800 	subeq	r7, r8, r0, lsl #16
    3ce8:	00489000 	subeq	r9, r8, r0
    3cec:	50000100 	andpl	r0, r0, r0, lsl #2
    3cf0:	00004890 	muleq	r0, r0, r8
    3cf4:	000048a4 	andeq	r4, r0, r4, lsr #17
    3cf8:	a4540001 	ldrbge	r0, [r4], #-1
    3cfc:	f4000048 	vst4.16	{d0-d3}, [r0], r8
    3d00:	01000048 	tsteq	r0, r8, asr #32
    3d04:	48f45000 	ldmmi	r4!, {ip, lr}^
    3d08:	49c00000 	stmibmi	r0, {}^
    3d0c:	00010000 	andeq	r0, r1, r0
    3d10:	0049dc54 	subeq	sp, r9, r4, asr ip
    3d14:	004a4400 	subeq	r4, sl, r0, lsl #8
    3d18:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    3d24:	00004878 	andeq	r4, r0, r8, ror r8
    3d28:	00004890 	muleq	r0, r0, r8
    3d2c:	90510001 	subsls	r0, r1, r1
    3d30:	44000048 	strmi	r0, [r0], #-72	; 0x48
    3d34:	0100004a 	tsteq	r0, sl, asr #32
    3d38:	00005800 	andeq	r5, r0, r0, lsl #16
    3d3c:	00000000 	andeq	r0, r0, r0
    3d40:	48780000 	ldmdami	r8!, {}^
    3d44:	48900000 	ldmmi	r0, {}
    3d48:	00010000 	andeq	r0, r1, r0
    3d4c:	00489052 	subeq	r9, r8, r2, asr r0
    3d50:	004a4400 	subeq	r4, sl, r0, lsl #8
    3d54:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    3d60:	0000488c 	andeq	r4, r0, ip, lsl #17
    3d64:	000048c4 	andeq	r4, r0, r4, asr #17
    3d68:	d4560001 	ldrble	r0, [r6], #-1
    3d6c:	44000048 	strmi	r0, [r0], #-72	; 0x48
    3d70:	0100004a 	tsteq	r0, sl, asr #32
    3d74:	00005600 	andeq	r5, r0, r0, lsl #12
    3d78:	00000000 	andeq	r0, r0, r0
    3d7c:	48fc0000 	ldmmi	ip!, {}^
    3d80:	490c0000 	stmdbmi	ip, {}
    3d84:	00010000 	andeq	r0, r1, r0
    3d88:	00491c53 	subeq	r1, r9, r3, asr ip
    3d8c:	00499800 	subeq	r9, r9, r0, lsl #16
    3d90:	53000100 	movwpl	r0, #256	; 0x100
    3d94:	000049b0 	undefined instruction 0x000049b0
    3d98:	000049d4 	ldrdeq	r4, [r0], -r4
    3d9c:	dc510001 	mrrcle	0, 0, r0, r1, cr1
    3da0:	24000049 	strcs	r0, [r0], #-73	; 0x49
    3da4:	0100004a 	tsteq	r0, sl, asr #32
    3da8:	00005100 	andeq	r5, r0, r0, lsl #2
    3dac:	00000000 	andeq	r0, r0, r0
    3db0:	4a440000 	bmi	1103db8 <MEM_SIZE+0x903db8>
    3db4:	4a480000 	bmi	1203dbc <MEM_SIZE+0xa03dbc>
    3db8:	00010000 	andeq	r0, r1, r0
    3dbc:	004a485d 	subeq	r4, sl, sp, asr r8
    3dc0:	004a5000 	subeq	r5, sl, r0
    3dc4:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3dc8:	004a5014 	subeq	r5, sl, r4, lsl r0
    3dcc:	004ba400 	subeq	sl, fp, r0, lsl #8
    3dd0:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    3dd4:	00000020 	andeq	r0, r0, r0, lsr #32
    3dd8:	00000000 	andeq	r0, r0, r0
    3ddc:	004a4400 	subeq	r4, sl, r0, lsl #8
    3de0:	004a5800 	subeq	r5, sl, r0, lsl #16
    3de4:	50000100 	andpl	r0, r0, r0, lsl #2
    3de8:	00004a58 	andeq	r4, r0, r8, asr sl
    3dec:	00004a68 	andeq	r4, r0, r8, ror #20
    3df0:	68540001 	ldmdavs	r4, {r0}^
    3df4:	7c00004a 	stcvc	0, cr0, [r0], {74}	; 0x4a
    3df8:	0100004a 	tsteq	r0, sl, asr #32
    3dfc:	4a7c5000 	bmi	1f17e04 <MEM_SIZE+0x1717e04>
    3e00:	4a8c0000 	bmi	fe303e08 <rEINTPEND+0xa8303d60>
    3e04:	00010000 	andeq	r0, r1, r0
    3e08:	004a8c54 	subeq	r8, sl, r4, asr ip
    3e0c:	004aac00 	subeq	sl, sl, r0, lsl #24
    3e10:	50000100 	andpl	r0, r0, r0, lsl #2
    3e14:	00004aac 	andeq	r4, r0, ip, lsr #21
    3e18:	00004b8c 	andeq	r4, r0, ip, lsl #23
    3e1c:	94540001 	ldrbls	r0, [r4], #-1
    3e20:	a400004b 	strge	r0, [r0], #-75	; 0x4b
    3e24:	0100004b 	tsteq	r0, fp, asr #32
    3e28:	00005400 	andeq	r5, r0, r0, lsl #8
    3e2c:	00000000 	andeq	r0, r0, r0
    3e30:	4a440000 	bmi	1103e38 <MEM_SIZE+0x903e38>
    3e34:	4aa80000 	bmi	fea03e3c <rEINTPEND+0xa8a03d94>
    3e38:	00010000 	andeq	r0, r1, r0
    3e3c:	004ac051 	subeq	ip, sl, r1, asr r0
    3e40:	004af800 	subeq	pc, sl, r0, lsl #16
    3e44:	51000100 	tstpl	r0, r0, lsl #2
    3e48:	00004b04 	andeq	r4, r0, r4, lsl #22
    3e4c:	00004b10 	andeq	r4, r0, r0, lsl fp
    3e50:	1c510001 	mrrcne	0, 0, r0, r1, cr1
    3e54:	2000004b 	andcs	r0, r0, fp, asr #32
    3e58:	0100004b 	tsteq	r0, fp, asr #32
    3e5c:	4b2c5100 	blmi	b18264 <MEM_SIZE+0x318264>
    3e60:	4b3c0000 	blmi	f03e68 <MEM_SIZE+0x703e68>
    3e64:	00010000 	andeq	r0, r1, r0
    3e68:	004b5051 	subeq	r5, fp, r1, asr r0
    3e6c:	004b5c00 	subeq	r5, fp, r0, lsl #24
    3e70:	51000100 	tstpl	r0, r0, lsl #2
	...
    3e7c:	00004a44 	andeq	r4, r0, r4, asr #20
    3e80:	00004a58 	andeq	r4, r0, r8, asr sl
    3e84:	58520001 	ldmdapl	r2, {r0}^
    3e88:	a400004a 	strge	r0, [r0], #-74	; 0x4a
    3e8c:	0100004b 	tsteq	r0, fp, asr #32
    3e90:	00005500 	andeq	r5, r0, r0, lsl #10
    3e94:	00000000 	andeq	r0, r0, r0
    3e98:	4a7c0000 	bmi	1f03ea0 <MEM_SIZE+0x1703ea0>
    3e9c:	4a8c0000 	bmi	fe303ea4 <rEINTPEND+0xa8303dfc>
    3ea0:	00010000 	andeq	r0, r1, r0
    3ea4:	004ac457 	subeq	ip, sl, r7, asr r4
    3ea8:	004ba400 	subeq	sl, fp, r0, lsl #8
    3eac:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    3eb8:	00004ba4 	andeq	r4, r0, r4, lsr #23
    3ebc:	00004ba8 	andeq	r4, r0, r8, lsr #23
    3ec0:	a85d0001 	ldmdage	sp, {r0}^
    3ec4:	b400004b 	strlt	r0, [r0], #-75	; 0x4b
    3ec8:	0200004b 	andeq	r0, r0, #75	; 0x4b
    3ecc:	b4187d00 	ldrlt	r7, [r8], #-3328	; 0xd00
    3ed0:	4000004b 	andmi	r0, r0, fp, asr #32
    3ed4:	0200004d 	andeq	r0, r0, #77	; 0x4d
    3ed8:	00207d00 	eoreq	r7, r0, r0, lsl #26
    3edc:	00000000 	andeq	r0, r0, r0
    3ee0:	a4000000 	strge	r0, [r0]
    3ee4:	cc00004b 	stcgt	0, cr0, [r0], {75}	; 0x4b
    3ee8:	0100004b 	tsteq	r0, fp, asr #32
    3eec:	4bcc5000 	blmi	ff317ef4 <rEINTPEND+0xa9317e4c>
    3ef0:	4be00000 	blmi	ff803ef8 <rEINTPEND+0xa9803e50>
    3ef4:	00010000 	andeq	r0, r1, r0
    3ef8:	004be054 	subeq	lr, fp, r4, asr r0
    3efc:	004be800 	subeq	lr, fp, r0, lsl #16
    3f00:	50000100 	andpl	r0, r0, r0, lsl #2
    3f04:	00004be8 	andeq	r4, r0, r8, ror #23
    3f08:	00004bf4 	strdeq	r4, [r0], -r4
    3f0c:	f4540001 	undefined instruction 0xf4540001
    3f10:	0000004b 	andeq	r0, r0, fp, asr #32
    3f14:	0100004c 	tsteq	r0, ip, asr #32
    3f18:	4c185000 	ldcmi	0, cr5, [r8], {0}
    3f1c:	4c840000 	stcmi	0, cr0, [r4], {0}
    3f20:	00010000 	andeq	r0, r1, r0
    3f24:	004c9454 	subeq	r9, ip, r4, asr r4
    3f28:	004cfc00 	subeq	pc, ip, r0, lsl #24
    3f2c:	54000100 	strpl	r0, [r0], #-256	; 0x100
    3f30:	00004d20 	andeq	r4, r0, r0, lsr #26
    3f34:	00004d40 	andeq	r4, r0, r0, asr #26
    3f38:	00540001 	subseq	r0, r4, r1
    3f3c:	00000000 	andeq	r0, r0, r0
    3f40:	a4000000 	strge	r0, [r0]
    3f44:	f800004b 	undefined instruction 0xf800004b
    3f48:	0100004b 	tsteq	r0, fp, asr #32
    3f4c:	4c1c5100 	ldfmis	f5, [ip], {0}
    3f50:	4d240000 	stcmi	0, cr0, [r4]
    3f54:	00010000 	andeq	r0, r1, r0
    3f58:	004d2451 	subeq	r2, sp, r1, asr r4
    3f5c:	004d4000 	subeq	r4, sp, r0
    3f60:	51000100 	tstpl	r0, r0, lsl #2
	...
    3f6c:	00004ba4 	andeq	r4, r0, r4, lsr #23
    3f70:	00004bfc 	strdeq	r4, [r0], -ip
    3f74:	0c520001 	mrrceq	0, 0, r0, r2, cr1
    3f78:	7400004c 	strvc	r0, [r0], #-76	; 0x4c
    3f7c:	0100004c 	tsteq	r0, ip, asr #32
    3f80:	4c945200 	lfmmi	f5, 4, [r4], {0}	; (ldcmi 2, cr5, [r4], {0})
    3f84:	4cb00000 	ldcmi	0, cr0, [r0]
    3f88:	00010000 	andeq	r0, r1, r0
    3f8c:	004cbc52 	subeq	fp, ip, r2, asr ip
    3f90:	004cf000 	subeq	pc, ip, r0
    3f94:	52000100 	andpl	r0, r0, #0
    3f98:	00004d00 	andeq	r4, r0, r0, lsl #26
    3f9c:	00004d0c 	andeq	r4, r0, ip, lsl #26
    3fa0:	1c520001 	mrrcne	0, 0, r0, r2, cr1
    3fa4:	3400004d 	strcc	r0, [r0], #-77	; 0x4d
    3fa8:	0100004d 	tsteq	r0, sp, asr #32
    3fac:	00005200 	andeq	r5, r0, r0, lsl #4
    3fb0:	00000000 	andeq	r0, r0, r0
    3fb4:	4ba40000 	blmi	fe903fbc <rEINTPEND+0xa8903f14>
    3fb8:	4bbc0000 	blmi	fef03fc0 <rEINTPEND+0xa8f03f18>
    3fbc:	00010000 	andeq	r0, r1, r0
    3fc0:	004bbc53 	subeq	fp, fp, r3, asr ip
    3fc4:	004d4000 	subeq	r4, sp, r0
    3fc8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    3fd4:	00004be4 	andeq	r4, r0, r4, ror #23
    3fd8:	00004bf4 	strdeq	r4, [r0], -r4
    3fdc:	24560001 	ldrbcs	r0, [r6], #-1
    3fe0:	0000004c 	andeq	r0, r0, ip, asr #32
    3fe4:	0100004d 	tsteq	r0, sp, asr #32
    3fe8:	4d2c5600 	stcmi	6, cr5, [ip]
    3fec:	4d400000 	stclmi	0, cr0, [r0]
    3ff0:	00010000 	andeq	r0, r1, r0
    3ff4:	00000056 	andeq	r0, r0, r6, asr r0
    3ff8:	00000000 	andeq	r0, r0, r0
    3ffc:	004be400 	subeq	lr, fp, r0, lsl #8
    4000:	004bf400 	subeq	pc, fp, r0, lsl #8
    4004:	58000100 	stmdapl	r0, {r8}
    4008:	00004c30 	andeq	r4, r0, r0, lsr ip
    400c:	00004d00 	andeq	r4, r0, r0, lsl #26
    4010:	38580001 	ldmdacc	r8, {r0}^
    4014:	4000004d 	andmi	r0, r0, sp, asr #32
    4018:	0100004d 	tsteq	r0, sp, asr #32
    401c:	00005800 	andeq	r5, r0, r0, lsl #16
    4020:	00000000 	andeq	r0, r0, r0
    4024:	4c300000 	ldcmi	0, cr0, [r0]
    4028:	4c540000 	mrami	r0, r4, acc0
    402c:	00010000 	andeq	r0, r1, r0
    4030:	004c5c51 	subeq	r5, ip, r1, asr ip
    4034:	004c7400 	subeq	r7, ip, r0, lsl #8
    4038:	51000100 	tstpl	r0, r0, lsl #2
    403c:	00004c94 	muleq	r0, r4, ip
    4040:	00004c98 	muleq	r0, r8, ip
    4044:	a8510001 	ldmdage	r1, {r0}^
    4048:	b000004c 	andlt	r0, r0, ip, asr #32
    404c:	0100004c 	tsteq	r0, ip, asr #32
    4050:	4cbc5100 	ldfmis	f5, [ip]
    4054:	4cc00000 	stclmi	0, cr0, [r0], {0}
    4058:	00010000 	andeq	r0, r1, r0
    405c:	004cc851 	subeq	ip, ip, r1, asr r8
    4060:	004cd400 	subeq	sp, ip, r0, lsl #8
    4064:	51000100 	tstpl	r0, r0, lsl #2
    4068:	00004ce8 	andeq	r4, r0, r8, ror #25
    406c:	00004cf0 	strdeq	r4, [r0], -r0
    4070:	00510001 	subseq	r0, r1, r1
    4074:	00000000 	andeq	r0, r0, r0
    4078:	e4000000 	str	r0, [r0]
    407c:	f400004b 	vst4.16	{d0-d3}, [r0], fp
    4080:	0100004b 	tsteq	r0, fp, asr #32
    4084:	4c085700 	stcmi	7, cr5, [r8], {0}
    4088:	4d400000 	stclmi	0, cr0, [r0]
    408c:	00010000 	andeq	r0, r1, r0
    4090:	00000057 	andeq	r0, r0, r7, asr r0
    4094:	00000000 	andeq	r0, r0, r0
    4098:	004d4000 	subeq	r4, sp, r0
    409c:	004d4400 	subeq	r4, sp, r0, lsl #8
    40a0:	5d000100 	stfpls	f0, [r0]
    40a4:	00004d44 	andeq	r4, r0, r4, asr #26
    40a8:	00004d48 	andeq	r4, r0, r8, asr #26
    40ac:	207d0002 	rsbscs	r0, sp, r2
    40b0:	00004d48 	andeq	r4, r0, r8, asr #26
    40b4:	0000502c 	andeq	r5, r0, ip, lsr #32
    40b8:	c87d0003 	ldmdagt	sp!, {r0, r1}^
	...
    40c4:	004d4000 	subeq	r4, sp, r0
    40c8:	004d6400 	subeq	r6, sp, r0, lsl #8
    40cc:	50000100 	andpl	r0, r0, r0, lsl #2
    40d0:	00004d64 	andeq	r4, r0, r4, ror #26
    40d4:	00004d78 	andeq	r4, r0, r8, ror sp
    40d8:	78550001 	ldmdavc	r5, {r0}^
    40dc:	c400004d 	strgt	r0, [r0], #-77	; 0x4d
    40e0:	0100004d 	tsteq	r0, sp, asr #32
    40e4:	4dc45000 	stclmi	0, cr5, [r4]
    40e8:	4dd40000 	ldclmi	0, cr0, [r4]
    40ec:	00010000 	andeq	r0, r1, r0
    40f0:	004dd455 	subeq	sp, sp, r5, asr r4
    40f4:	004de800 	subeq	lr, sp, r0, lsl #16
    40f8:	50000100 	andpl	r0, r0, r0, lsl #2
    40fc:	00004de8 	andeq	r4, r0, r8, ror #27
    4100:	0000502c 	andeq	r5, r0, ip, lsr #32
    4104:	00550001 	subseq	r0, r5, r1
    4108:	00000000 	andeq	r0, r0, r0
    410c:	40000000 	andmi	r0, r0, r0
    4110:	dc00004d 	stcle	0, cr0, [r0], {77}	; 0x4d
    4114:	0100004d 	tsteq	r0, sp, asr #32
    4118:	4e145100 	mufmis	f5, f4, f0
    411c:	4e380000 	cdpmi	0, 3, cr0, cr8, cr0, {0}
    4120:	00010000 	andeq	r0, r1, r0
    4124:	004e4c51 	subeq	r4, lr, r1, asr ip
    4128:	004e6400 	subeq	r6, lr, r0, lsl #8
    412c:	51000100 	tstpl	r0, r0, lsl #2
    4130:	00004e6c 	andeq	r4, r0, ip, ror #28
    4134:	00004e84 	andeq	r4, r0, r4, lsl #29
    4138:	8c510001 	mrrchi	0, 0, r0, r1, cr1
    413c:	a000004e 	andge	r0, r0, lr, asr #32
    4140:	0100004e 	tsteq	r0, lr, asr #32
    4144:	4eb45100 	frdmis	f5, f4, f0
    4148:	4ec00000 	cdpmi	0, 12, cr0, cr0, cr0, {0}
    414c:	00010000 	andeq	r0, r1, r0
    4150:	004f5851 	subeq	r5, pc, r1, asr r8
    4154:	004f6400 	subeq	r6, pc, r0, lsl #8
    4158:	51000100 	tstpl	r0, r0, lsl #2
    415c:	00004fc4 	andeq	r4, r0, r4, asr #31
    4160:	00004fd0 	ldrdeq	r4, [r0], -r0
    4164:	e8510001 	ldmda	r1, {r0}^
    4168:	f400004f 	vst4.16	{d0-d3}, [r0]
    416c:	0100004f 	tsteq	r0, pc, asr #32
    4170:	00005100 	andeq	r5, r0, r0, lsl #2
    4174:	00000000 	andeq	r0, r0, r0
    4178:	4d400000 	stclmi	0, cr0, [r0]
    417c:	4d640000 	stclmi	0, cr0, [r4]
    4180:	00010000 	andeq	r0, r1, r0
    4184:	004d6452 	subeq	r6, sp, r2, asr r4
    4188:	00502c00 	subseq	r2, r0, r0, lsl #24
    418c:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    4198:	00004d40 	andeq	r4, r0, r0, asr #26
    419c:	00004d64 	andeq	r4, r0, r4, ror #26
    41a0:	64530001 	ldrbvs	r0, [r3], #-1
    41a4:	2c00004d 	stccs	0, cr0, [r0], {77}	; 0x4d
    41a8:	01000050 	qaddeq	r0, r0, r0
    41ac:	00005700 	andeq	r5, r0, r0, lsl #14
    41b0:	00000000 	andeq	r0, r0, r0
    41b4:	4d400000 	stclmi	0, cr0, [r0]
    41b8:	4d640000 	stclmi	0, cr0, [r4]
    41bc:	00020000 	andeq	r0, r2, r0
    41c0:	4d640091 	stclmi	0, cr0, [r4, #-580]!	; 0xfffffdbc
    41c4:	502c0000 	eorpl	r0, ip, r0
    41c8:	00010000 	andeq	r0, r1, r0
    41cc:	00000054 	andeq	r0, r0, r4, asr r0
    41d0:	00000000 	andeq	r0, r0, r0
    41d4:	004d6000 	subeq	r6, sp, r0
    41d8:	004d8000 	subeq	r8, sp, r0
    41dc:	59000100 	stmdbpl	r0, {r8}
    41e0:	00004d90 	muleq	r0, r0, sp
    41e4:	00004fac 	andeq	r4, r0, ip, lsr #31
    41e8:	c4590001 	ldrbgt	r0, [r9], #-1
    41ec:	2c00004f 	stccs	0, cr0, [r0], {79}	; 0x4f
    41f0:	01000050 	qaddeq	r0, r0, r0
    41f4:	00005900 	andeq	r5, r0, r0, lsl #18
    41f8:	00000000 	andeq	r0, r0, r0
    41fc:	4dc40000 	stclmi	0, cr0, [r4]
    4200:	4dd40000 	ldclmi	0, cr0, [r4]
    4204:	00010000 	andeq	r0, r1, r0
    4208:	004de45a 	subeq	lr, sp, sl, asr r4
    420c:	00502c00 	subseq	r2, r0, r0, lsl #24
    4210:	5a000100 	bpl	4618 <DISABLE_IRQ+0x4598>
	...
    421c:	00004dc4 	andeq	r4, r0, r4, asr #27
    4220:	00004dd4 	ldrdeq	r4, [r0], -r4
    4224:	f0580001 	undefined instruction 0xf0580001
    4228:	2c00004d 	stccs	0, cr0, [r0], {77}	; 0x4d
    422c:	01000050 	qaddeq	r0, r0, r0
    4230:	00005800 	andeq	r5, r0, r0, lsl #16
    4234:	00000000 	andeq	r0, r0, r0
    4238:	4f880000 	svcmi	0x00880000
    423c:	4fb80000 	svcmi	0x00b80000
    4240:	00010000 	andeq	r0, r1, r0
    4244:	00500c51 	subseq	r0, r0, r1, asr ip
    4248:	00502c00 	subseq	r2, r0, r0, lsl #24
    424c:	51000100 	tstpl	r0, r0, lsl #2
	...
    4258:	00004f8c 	andeq	r4, r0, ip, lsl #31
    425c:	00004fa8 	andeq	r4, r0, r8, lsr #31
    4260:	0c520001 	mrrceq	0, 0, r0, r2, cr1
    4264:	2c000050 	stccs	0, cr0, [r0], {80}	; 0x50
    4268:	01000050 	qaddeq	r0, r0, r0
    426c:	00005200 	andeq	r5, r0, r0, lsl #4
    4270:	00000000 	andeq	r0, r0, r0
    4274:	502c0000 	eorpl	r0, ip, r0
    4278:	50300000 	eorspl	r0, r0, r0
    427c:	00010000 	andeq	r0, r1, r0
    4280:	0050305d 	subseq	r3, r0, sp, asr r0
    4284:	00503800 	subseq	r3, r0, r0, lsl #16
    4288:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    428c:	00503818 	subseq	r3, r0, r8, lsl r8
    4290:	00518800 	subseq	r8, r1, r0, lsl #16
    4294:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    4298:	00000020 	andeq	r0, r0, r0, lsr #32
    429c:	00000000 	andeq	r0, r0, r0
    42a0:	00502c00 	subseq	r2, r0, r0, lsl #24
    42a4:	00504000 	subseq	r4, r0, r0
    42a8:	50000100 	andpl	r0, r0, r0, lsl #2
    42ac:	00005040 	andeq	r5, r0, r0, asr #32
    42b0:	00005050 	andeq	r5, r0, r0, asr r0
    42b4:	50540001 	subspl	r0, r4, r1
    42b8:	7c000050 	stcvc	0, cr0, [r0], {80}	; 0x50
    42bc:	01000050 	qaddeq	r0, r0, r0
    42c0:	507c5000 	rsbspl	r5, ip, r0
    42c4:	508c0000 	addpl	r0, ip, r0
    42c8:	00010000 	andeq	r0, r1, r0
    42cc:	00508c54 	subseq	r8, r0, r4, asr ip
    42d0:	00509400 	subseq	r9, r0, r0, lsl #8
    42d4:	50000100 	andpl	r0, r0, r0, lsl #2
    42d8:	00005094 	muleq	r0, r4, r0
    42dc:	00005160 	andeq	r5, r0, r0, ror #2
    42e0:	68540001 	ldmdavs	r4, {r0}^
    42e4:	88000051 	stmdahi	r0, {r0, r4, r6}
    42e8:	01000051 	qaddeq	r0, r1, r0
    42ec:	00005400 	andeq	r5, r0, r0, lsl #8
    42f0:	00000000 	andeq	r0, r0, r0
    42f4:	502c0000 	eorpl	r0, ip, r0
    42f8:	50900000 	addspl	r0, r0, r0
    42fc:	00010000 	andeq	r0, r1, r0
    4300:	0050a851 	subseq	sl, r0, r1, asr r8
    4304:	0050e000 	subseq	lr, r0, r0
    4308:	51000100 	tstpl	r0, r0, lsl #2
    430c:	000050ec 	andeq	r5, r0, ip, ror #1
    4310:	000050f8 	strdeq	r5, [r0], -r8
    4314:	04510001 	ldrbeq	r0, [r1], #-1
    4318:	14000051 	strne	r0, [r0], #-81	; 0x51
    431c:	01000051 	qaddeq	r0, r1, r0
    4320:	51245100 	teqpl	r4, r0, lsl #2
    4324:	51300000 	teqpl	r0, r0
    4328:	00010000 	andeq	r0, r1, r0
    432c:	00516851 	subseq	r6, r1, r1, asr r8
    4330:	00516c00 	subseq	r6, r1, r0, lsl #24
    4334:	51000100 	tstpl	r0, r0, lsl #2
	...
    4340:	0000502c 	andeq	r5, r0, ip, lsr #32
    4344:	00005040 	andeq	r5, r0, r0, asr #32
    4348:	40520001 	subsmi	r0, r2, r1
    434c:	88000050 	stmdahi	r0, {r4, r6}
    4350:	01000051 	qaddeq	r0, r1, r0
    4354:	00005500 	andeq	r5, r0, r0, lsl #10
    4358:	00000000 	andeq	r0, r0, r0
    435c:	507c0000 	rsbspl	r0, ip, r0
    4360:	508c0000 	addpl	r0, ip, r0
    4364:	00010000 	andeq	r0, r1, r0
    4368:	00510856 	subseq	r0, r1, r6, asr r8
    436c:	00516800 	subseq	r6, r1, r0, lsl #16
    4370:	56000100 	strpl	r0, [r0], -r0, lsl #2
    4374:	00005178 	andeq	r5, r0, r8, ror r1
    4378:	00005188 	andeq	r5, r0, r8, lsl #3
    437c:	00560001 	subseq	r0, r6, r1
    4380:	00000000 	andeq	r0, r0, r0
    4384:	7c000000 	stcvc	0, cr0, [r0], {0}
    4388:	8c000050 	stchi	0, cr0, [r0], {80}	; 0x50
    438c:	01000050 	qaddeq	r0, r0, r0
    4390:	50ac5800 	adcpl	r5, ip, r0, lsl #16
    4394:	51880000 	orrpl	r0, r8, r0
    4398:	00010000 	andeq	r0, r1, r0
    439c:	00000058 	andeq	r0, r0, r8, asr r0
    43a0:	00000000 	andeq	r0, r0, r0
    43a4:	00518800 	subseq	r8, r1, r0, lsl #16
    43a8:	00518c00 	subseq	r8, r1, r0, lsl #24
    43ac:	5d000100 	stfpls	f0, [r0]
    43b0:	0000518c 	andeq	r5, r0, ip, lsl #3
    43b4:	000051fc 	strdeq	r5, [r0], -ip
    43b8:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    43c4:	000051fc 	strdeq	r5, [r0], -ip
    43c8:	00005200 	andeq	r5, r0, r0, lsl #4
    43cc:	005d0001 	subseq	r0, sp, r1
    43d0:	10000052 	andne	r0, r0, r2, asr r0
    43d4:	02000053 	andeq	r0, r0, #83	; 0x53
    43d8:	00187d00 	andseq	r7, r8, r0, lsl #26
    43dc:	00000000 	andeq	r0, r0, r0
    43e0:	2c000000 	stccs	0, cr0, [r0], {0}
    43e4:	34000052 	strcc	r0, [r0], #-82	; 0x52
    43e8:	01000052 	qaddeq	r0, r2, r0
    43ec:	525c5400 	subspl	r5, ip, #0
    43f0:	53100000 	tstpl	r0, #0
    43f4:	00010000 	andeq	r0, r1, r0
    43f8:	00000054 	andeq	r0, r0, r4, asr r0
    43fc:	00000000 	andeq	r0, r0, r0
    4400:	00531000 	subseq	r1, r3, r0
    4404:	00531400 	subseq	r1, r3, r0, lsl #8
    4408:	5d000100 	stfpls	f0, [r0]
    440c:	00005314 	andeq	r5, r0, r4, lsl r3
    4410:	000053a0 	andeq	r5, r0, r0, lsr #7
    4414:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    4420:	00005338 	andeq	r5, r0, r8, lsr r3
    4424:	00005348 	andeq	r5, r0, r8, asr #6
    4428:	00530001 	subseq	r0, r3, r1
    442c:	00000000 	andeq	r0, r0, r0
    4430:	a0000000 	andge	r0, r0, r0
    4434:	a4000053 	strge	r0, [r0], #-83	; 0x53
    4438:	01000053 	qaddeq	r0, r3, r0
    443c:	53a45d00 	undefined instruction 0x53a45d00
    4440:	54a00000 	strtpl	r0, [r0]
    4444:	00020000 	andeq	r0, r2, r0
    4448:	0000087d 	andeq	r0, r0, sp, ror r8
    444c:	00000000 	andeq	r0, r0, r0
    4450:	54180000 	ldrpl	r0, [r8]
    4454:	542c0000 	strtpl	r0, [ip]
    4458:	00010000 	andeq	r0, r1, r0
    445c:	00000053 	andeq	r0, r0, r3, asr r0
    4460:	00000000 	andeq	r0, r0, r0
    4464:	0054a000 	subseq	sl, r4, r0
    4468:	0054a400 	subseq	sl, r4, r0, lsl #8
    446c:	5d000100 	stfpls	f0, [r0]
    4470:	000054a4 	andeq	r5, r0, r4, lsr #9
    4474:	000054a8 	andeq	r5, r0, r8, lsr #9
    4478:	187d0002 	ldmdane	sp!, {r1}^
    447c:	000054a8 	andeq	r5, r0, r8, lsr #9
    4480:	00005760 	andeq	r5, r0, r0, ror #14
    4484:	387d0002 	ldmdacc	sp!, {r1}^
	...
    4490:	00005584 	andeq	r5, r0, r4, lsl #11
    4494:	000055c4 	andeq	r5, r0, r4, asr #11
    4498:	00530001 	subseq	r0, r3, r1
    449c:	00000000 	andeq	r0, r0, r0
    44a0:	f0000000 	undefined instruction 0xf0000000
    44a4:	1c000055 	stcne	0, cr0, [r0], {85}	; 0x55
    44a8:	01000056 	qaddeq	r0, r6, r0
    44ac:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    44b8:	00080000 	andeq	r0, r8, r0
    44bc:	00010000 	andeq	r0, r1, r0
    44c0:	0000085d 	andeq	r0, r0, sp, asr r8
    44c4:	00007c00 	andeq	r7, r0, r0, lsl #24
    44c8:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    44cc:	00000008 	andeq	r0, r0, r8
    44d0:	00000000 	andeq	r0, r0, r0
    44d4:	00007c00 	andeq	r7, r0, r0, lsl #24
    44d8:	00008000 	andeq	r8, r0, r0
    44dc:	5d000100 	stfpls	f0, [r0]
    44e0:	00000080 	andeq	r0, r0, r0, lsl #1
    44e4:	00000098 	muleq	r0, r8, r0
    44e8:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    44f4:	0000007c 	andeq	r0, r0, ip, ror r0
    44f8:	00000084 	andeq	r0, r0, r4, lsl #1
    44fc:	00500001 	subseq	r0, r0, r1
    4500:	00000000 	andeq	r0, r0, r0
    4504:	98000000 	stmdals	r0, {}
    4508:	9c000000 	stcls	0, cr0, [r0], {0}
    450c:	01000000 	tsteq	r0, r0
    4510:	009c5d00 	addseq	r5, ip, r0, lsl #26
    4514:	00b40000 	adcseq	r0, r4, r0
    4518:	00020000 	andeq	r0, r2, r0
    451c:	0000087d 	andeq	r0, r0, sp, ror r8
    4520:	00000000 	andeq	r0, r0, r0
    4524:	00980000 	addseq	r0, r8, r0
    4528:	00a00000 	adceq	r0, r0, r0
    452c:	00010000 	andeq	r0, r1, r0
    4530:	00000050 	andeq	r0, r0, r0, asr r0
    4534:	00000000 	andeq	r0, r0, r0
    4538:	0000b400 	andeq	fp, r0, r0, lsl #8
    453c:	0000b800 	andeq	fp, r0, r0, lsl #16
    4540:	5d000100 	stfpls	f0, [r0]
    4544:	000000b8 	strheq	r0, [r0], -r8
    4548:	000000d0 	ldrdeq	r0, [r0], -r0
    454c:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    4558:	000000b4 	strheq	r0, [r0], -r4
    455c:	000000bc 	strheq	r0, [r0], -ip
    4560:	00500001 	subseq	r0, r0, r1
	...
    456c:	08000000 	stmdaeq	r0, {}
    4570:	01000000 	tsteq	r0, r0
    4574:	00085d00 	andeq	r5, r8, r0, lsl #26
    4578:	008c0000 	addeq	r0, ip, r0
    457c:	00020000 	andeq	r0, r2, r0
    4580:	0000087d 	andeq	r0, r0, sp, ror r8
    4584:	00000000 	andeq	r0, r0, r0
    4588:	008c0000 	addeq	r0, ip, r0
    458c:	00900000 	addseq	r0, r0, r0
    4590:	00010000 	andeq	r0, r1, r0
    4594:	0000905d 	andeq	r9, r0, sp, asr r0
    4598:	0000b800 	andeq	fp, r0, r0, lsl #16
    459c:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    45a0:	00000008 	andeq	r0, r0, r8
    45a4:	00000000 	andeq	r0, r0, r0
    45a8:	00008c00 	andeq	r8, r0, r0, lsl #24
    45ac:	00009800 	andeq	r9, r0, r0, lsl #16
    45b0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    45bc:	000000b8 	strheq	r0, [r0], -r8
    45c0:	000000bc 	strheq	r0, [r0], -ip
    45c4:	bc5d0001 	mrrclt	0, 0, r0, sp, cr1
    45c8:	c4000000 	strgt	r0, [r0]
    45cc:	02000000 	andeq	r0, r0, #0
    45d0:	c40c7d00 	strgt	r7, [ip], #-3328	; 0xd00
    45d4:	f4000000 	vst4.8	{d0-d3}, [r0], r0
    45d8:	02000000 	andeq	r0, r0, #0
    45dc:	00187d00 	andseq	r7, r8, r0, lsl #26
    45e0:	00000000 	andeq	r0, r0, r0
    45e4:	b8000000 	stmdalt	r0, {}
    45e8:	cc000000 	stcgt	0, cr0, [r0], {0}
    45ec:	01000000 	tsteq	r0, r0
    45f0:	00005000 	andeq	r5, r0, r0
	...
    45fc:	00040000 	andeq	r0, r4, r0
    4600:	00010000 	andeq	r0, r1, r0
    4604:	0000045d 	andeq	r0, r0, sp, asr r4
    4608:	00000c00 	andeq	r0, r0, r0, lsl #24
    460c:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    4610:	00000c04 	andeq	r0, r0, r4, lsl #24
    4614:	00009800 	andeq	r9, r0, r0, lsl #16
    4618:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    461c:	00000010 	andeq	r0, r0, r0, lsl r0
    4620:	00000000 	andeq	r0, r0, r0
    4624:	00009800 	andeq	r9, r0, r0, lsl #16
    4628:	00009c00 	andeq	r9, r0, r0, lsl #24
    462c:	5d000100 	stfpls	f0, [r0]
    4630:	0000009c 	muleq	r0, ip, r0
    4634:	000000c4 	andeq	r0, r0, r4, asr #1
    4638:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    4644:	00000098 	muleq	r0, r8, r0
    4648:	000000a4 	andeq	r0, r0, r4, lsr #1
    464c:	00500001 	subseq	r0, r0, r1
    4650:	00000000 	andeq	r0, r0, r0
    4654:	c4000000 	strgt	r0, [r0]
    4658:	c8000000 	stmdagt	r0, {}
    465c:	01000000 	tsteq	r0, r0
    4660:	00c85d00 	sbceq	r5, r8, r0, lsl #26
    4664:	00d00000 	sbcseq	r0, r0, r0
    4668:	00020000 	andeq	r0, r2, r0
    466c:	00d00c7d 	sbcseq	r0, r0, sp, ror ip
    4670:	01000000 	tsteq	r0, r0
    4674:	00020000 	andeq	r0, r2, r0
    4678:	0000187d 	andeq	r1, r0, sp, ror r8
    467c:	00000000 	andeq	r0, r0, r0
    4680:	00c40000 	sbceq	r0, r4, r0
    4684:	00d80000 	sbcseq	r0, r8, r0
    4688:	00010000 	andeq	r0, r1, r0
    468c:	00000050 	andeq	r0, r0, r0, asr r0
	...
    4698:	00000800 	andeq	r0, r0, r0, lsl #16
    469c:	5d000100 	stfpls	f0, [r0]
    46a0:	00000008 	andeq	r0, r0, r8
    46a4:	0000008c 	andeq	r0, r0, ip, lsl #1
    46a8:	087d0002 	ldmdaeq	sp!, {r1}^
	...
    46b4:	0000008c 	andeq	r0, r0, ip, lsl #1
    46b8:	00000090 	muleq	r0, r0, r0
    46bc:	905d0001 	subsls	r0, sp, r1
    46c0:	d8000000 	stmdale	r0, {}
    46c4:	02000000 	andeq	r0, r0, #0
    46c8:	00107d00 	andseq	r7, r0, r0, lsl #26
    46cc:	00000000 	andeq	r0, r0, r0
    46d0:	8c000000 	stchi	0, cr0, [r0], {0}
    46d4:	a0000000 	andge	r0, r0, r0
    46d8:	01000000 	tsteq	r0, r0
    46dc:	00005000 	andeq	r5, r0, r0
    46e0:	00000000 	andeq	r0, r0, r0
    46e4:	00d80000 	sbcseq	r0, r8, r0
    46e8:	00dc0000 	sbcseq	r0, ip, r0
    46ec:	00010000 	andeq	r0, r1, r0
    46f0:	0000dc5d 	andeq	sp, r0, sp, asr ip
    46f4:	0000e400 	andeq	lr, r0, r0, lsl #8
    46f8:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    46fc:	0000e40c 	andeq	lr, r0, ip, lsl #8
    4700:	00011800 	andeq	r1, r1, r0, lsl #16
    4704:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    4708:	00000018 	andeq	r0, r0, r8, lsl r0
    470c:	00000000 	andeq	r0, r0, r0
    4710:	0000d800 	andeq	sp, r0, r0, lsl #16
    4714:	0000f000 	andeq	pc, r0, r0
    4718:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    4728:	00000008 	andeq	r0, r0, r8
    472c:	085d0001 	ldmdaeq	sp, {r0}^
    4730:	30000000 	andcc	r0, r0, r0
    4734:	02000000 	andeq	r0, r0, #0
    4738:	00087d00 	andeq	r7, r8, r0, lsl #26
	...
    4744:	10000000 	andne	r0, r0, r0
    4748:	01000000 	tsteq	r0, r0
    474c:	00005000 	andeq	r5, r0, r0
	...
    4758:	00140000 	andseq	r0, r4, r0
    475c:	00010000 	andeq	r0, r1, r0
    4760:	00000051 	andeq	r0, r0, r1, asr r0
    4764:	00000000 	andeq	r0, r0, r0
    4768:	00003000 	andeq	r3, r0, r0
    476c:	00003400 	andeq	r3, r0, r0, lsl #8
    4770:	5d000100 	stfpls	f0, [r0]
    4774:	00000034 	andeq	r0, r0, r4, lsr r0
    4778:	0000003c 	andeq	r0, r0, ip, lsr r0
    477c:	047d0002 	ldrbteq	r0, [sp], #-2
    4780:	0000003c 	andeq	r0, r0, ip, lsr r0
    4784:	000000d4 	ldrdeq	r0, [r0], -r4
    4788:	207d0002 	rsbscs	r0, sp, r2
	...
    4794:	000000d4 	ldrdeq	r0, [r0], -r4
    4798:	000000d8 	ldrdeq	r0, [r0], -r8
    479c:	d85d0001 	ldmdale	sp, {r0}^
    47a0:	e0000000 	and	r0, r0, r0
    47a4:	02000000 	andeq	r0, r0, #0
    47a8:	e0047d00 	and	r7, r4, r0, lsl #26
    47ac:	14000000 	strne	r0, [r0]
    47b0:	02000001 	andeq	r0, r0, #1
    47b4:	00107d00 	andseq	r7, r0, r0, lsl #26
    47b8:	00000000 	andeq	r0, r0, r0
    47bc:	d4000000 	strle	r0, [r0]
    47c0:	e8000000 	stmda	r0, {}
    47c4:	01000000 	tsteq	r0, r0
    47c8:	00005000 	andeq	r5, r0, r0
	...
    47d4:	00080000 	andeq	r0, r8, r0
    47d8:	00010000 	andeq	r0, r1, r0
    47dc:	0000085d 	andeq	r0, r0, sp, asr r8
    47e0:	00009000 	andeq	r9, r0, r0
    47e4:	7d000200 	sfmvc	f0, 4, [r0]	; (stcvc 2, cr0, [r0])
    47e8:	00000008 	andeq	r0, r0, r8
    47ec:	00000000 	andeq	r0, r0, r0
    47f0:	00009000 	andeq	r9, r0, r0
    47f4:	00009400 	andeq	r9, r0, r0, lsl #8
    47f8:	5d000100 	stfpls	f0, [r0]
    47fc:	00000094 	muleq	r0, r4, r0
    4800:	0000009c 	muleq	r0, ip, r0
    4804:	0c7d0002 	ldcleq	0, cr0, [sp], #-8
    4808:	0000009c 	muleq	r0, ip, r0
    480c:	000000d0 	ldrdeq	r0, [r0], -r0
    4810:	187d0002 	ldmdane	sp!, {r1}^
	...
    481c:	00000090 	muleq	r0, r0, r0
    4820:	000000a8 	andeq	r0, r0, r8, lsr #1
    4824:	00500001 	subseq	r0, r0, r1
    4828:	00000000 	andeq	r0, r0, r0
    482c:	d0000000 	andle	r0, r0, r0
    4830:	d4000000 	strle	r0, [r0]
    4834:	01000000 	tsteq	r0, r0
    4838:	00d45d00 	sbcseq	r5, r4, r0, lsl #26
    483c:	01340000 	teqeq	r4, r0
    4840:	00020000 	andeq	r0, r2, r0
    4844:	0000107d 	andeq	r1, r0, sp, ror r0
    4848:	00000000 	andeq	r0, r0, r0
    484c:	00d00000 	sbcseq	r0, r0, r0
    4850:	00e40000 	rsceq	r0, r4, r0
    4854:	00010000 	andeq	r0, r1, r0
    4858:	00000050 	andeq	r0, r0, r0, asr r0
	...
    4864:	00000400 	andeq	r0, r0, r0, lsl #8
    4868:	5d000100 	stfpls	f0, [r0]
    486c:	00000004 	andeq	r0, r0, r4
    4870:	0000000c 	andeq	r0, r0, ip
    4874:	087d0002 	ldmdaeq	sp!, {r1}^
    4878:	0000000c 	andeq	r0, r0, ip
    487c:	00000084 	andeq	r0, r0, r4, lsl #1
    4880:	107d0002 	rsbsne	r0, sp, r2
	...
    488c:	00000084 	andeq	r0, r0, r4, lsl #1
    4890:	00000088 	andeq	r0, r0, r8, lsl #1
    4894:	885d0001 	ldmdahi	sp, {r0}^
    4898:	8c000000 	stchi	0, cr0, [r0], {0}
    489c:	02000000 	andeq	r0, r0, #0
    48a0:	8c107d00 	ldchi	13, cr7, [r0], {0}
    48a4:	e4000000 	str	r0, [r0]
    48a8:	02000000 	andeq	r0, r0, #0
    48ac:	00187d00 	andseq	r7, r8, r0, lsl #26
    48b0:	00000000 	andeq	r0, r0, r0
    48b4:	84000000 	strhi	r0, [r0]
    48b8:	9c000000 	stcls	0, cr0, [r0], {0}
    48bc:	01000000 	tsteq	r0, r0
    48c0:	00b85000 	adcseq	r5, r8, r0
    48c4:	00c00000 	sbceq	r0, r0, r0
    48c8:	00010000 	andeq	r0, r1, r0
    48cc:	00000050 	andeq	r0, r0, r0, asr r0
    48d0:	00000000 	andeq	r0, r0, r0
    48d4:	00009400 	andeq	r9, r0, r0, lsl #8
    48d8:	0000a000 	andeq	sl, r0, r0
    48dc:	54000100 	strpl	r0, [r0], #-256	; 0x100
    48e0:	000000a4 	andeq	r0, r0, r4, lsr #1
    48e4:	000000e4 	andeq	r0, r0, r4, ror #1
    48e8:	00540001 	subseq	r0, r4, r1
	...
    48f4:	0c000000 	stceq	0, cr0, [r0], {0}
    48f8:	01000000 	tsteq	r0, r0
    48fc:	000c5d00 	andeq	r5, ip, r0, lsl #26
    4900:	002c0000 	eoreq	r0, ip, r0
    4904:	00020000 	andeq	r0, r2, r0
    4908:	002c207d 	eoreq	r2, ip, sp, ror r0
    490c:	00c00000 	sbceq	r0, r0, r0
    4910:	00020000 	andeq	r0, r2, r0
    4914:	0000387d 	andeq	r3, r0, sp, ror r8
	...
    4920:	00240000 	eoreq	r0, r4, r0
    4924:	00010000 	andeq	r0, r1, r0
    4928:	00000050 	andeq	r0, r0, r0, asr r0
	...
    4934:	00000400 	andeq	r0, r0, r0, lsl #8
    4938:	53000100 	movwpl	r0, #256	; 0x100
	...
    4944:	00000004 	andeq	r0, r0, r4
    4948:	00000010 	andeq	r0, r0, r0, lsl r0
    494c:	10530001 	subsne	r0, r3, r1
    4950:	14000000 	strne	r0, [r0]
    4954:	01000000 	tsteq	r0, r0
    4958:	00145a00 	andseq	r5, r4, r0, lsl #20
    495c:	00180000 	andseq	r0, r8, r0
    4960:	00010000 	andeq	r0, r1, r0
    4964:	00001858 	andeq	r1, r0, r8, asr r8
    4968:	00001c00 	andeq	r1, r0, r0, lsl #24
    496c:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    4970:	0000001c 	andeq	r0, r0, ip, lsl r0
    4974:	00000020 	andeq	r0, r0, r0, lsr #32
    4978:	20560001 	subscs	r0, r6, r1
    497c:	28000000 	stmdacs	r0, {}
    4980:	01000000 	tsteq	r0, r0
    4984:	00285500 	eoreq	r5, r8, r0, lsl #10
    4988:	00300000 	eorseq	r0, r0, r0
    498c:	00010000 	andeq	r0, r1, r0
    4990:	00003059 	andeq	r3, r0, r9, asr r0
    4994:	0000a400 	andeq	sl, r0, r0, lsl #8
    4998:	5b000100 	blpl	4da0 <DISABLE_IRQ+0x4d20>
    499c:	000000a4 	andeq	r0, r0, r4, lsr #1
    49a0:	000000b4 	strheq	r0, [r0], -r4
    49a4:	00500001 	subseq	r0, r0, r1
    49a8:	00000000 	andeq	r0, r0, r0
    49ac:	e0000000 	and	r0, r0, r0
    49b0:	e4000000 	str	r0, [r0]
    49b4:	01000000 	tsteq	r0, r0
    49b8:	00e45d00 	rsceq	r5, r4, r0, lsl #26
    49bc:	00f80000 	rscseq	r0, r8, r0
    49c0:	00020000 	andeq	r0, r2, r0
    49c4:	0000087d 	andeq	r0, r0, sp, ror r8
    49c8:	00000000 	andeq	r0, r0, r0
    49cc:	00e00000 	rsceq	r0, r0, r0
    49d0:	00e80000 	rsceq	r0, r8, r0
    49d4:	00010000 	andeq	r0, r1, r0
    49d8:	00000050 	andeq	r0, r0, r0, asr r0
    49dc:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .debug_pubnames:

00000000 <.debug_pubnames>:
   0:	00000061 	andeq	r0, r0, r1, rrx
   4:	00ab0002 	adceq	r0, fp, r2
   8:	01700000 	cmneq	r0, r0
   c:	007a0000 	rsbseq	r0, sl, r0
  10:	65680000 	strbvs	r0, [r8]!
  14:	776f6c6c 	strbvc	r6, [pc, -ip, ror #24]!
  18:	646c726f 	strbtvs	r7, [ip], #-623	; 0x26f
  1c:	00009b00 	andeq	r9, r0, r0, lsl #22
  20:	73657400 	cmnvc	r5, #0
  24:	6d6d5f74 	stclvs	15, cr5, [sp, #-464]!	; 0xfffffe30
  28:	00b40075 	adcseq	r0, r4, r5, ror r0
  2c:	61720000 	cmnvs	r2, r0
  30:	00657369 	rsbeq	r7, r5, r9, ror #6
  34:	000000e0 	andeq	r0, r0, r0, ror #1
  38:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0x974
  3c:	6e695f72 	mcrvs	15, 3, r5, cr9, cr2, {3}
  40:	f5007469 	undefined instruction 0xf5007469
  44:	70000000 	andvc	r0, r0, r0
  48:	5f74616c 	svcpl	0x0074616c
  4c:	746f6f62 	strbtvc	r6, [pc], #3938	; 54 <DISABLE_FIQ+0x14>
  50:	00015d00 	andeq	r5, r1, r0, lsl #26
  54:	73657400 	cmnvc	r5, #0
  58:	77735f74 	undefined instruction 0x77735f74
  5c:	68637469 	stmdavs	r3!, {r0, r3, r5, r6, sl, ip, sp, lr}^
  60:	00000000 	andeq	r0, r0, r0
  64:	00005000 	andeq	r5, r0, r0
  68:	c8000200 	stmdagt	r0, {r9}
  6c:	33000002 	movwcc	r0, #2
  70:	73000001 	movwvc	r0, #1
  74:	73000000 	movwvc	r0, #0
  78:	74726174 	ldrbtvc	r6, [r2], #-372	; 0x174
  7c:	756d6d5f 	strbvc	r6, [sp, #-3423]!	; 0xd5f
  80:	00009600 	andeq	r9, r0, r0, lsl #12
  84:	6e656700 	cdpvs	7, 6, cr6, cr5, cr0, {0}
  88:	5f316c5f 	svcpl	0x00316c5f
  8c:	00657470 	rsbeq	r7, r5, r0, ror r4
  90:	000000b3 	strheq	r0, [r0], -r3
  94:	5f6e6567 	svcpl	0x006e6567
  98:	705f316c 	subsvc	r3, pc, ip, ror #2
  9c:	615f6574 	cmpvs	pc, r4, ror r5
  a0:	00726464 	rsbseq	r6, r2, r4, ror #8
  a4:	000000d9 	ldrdeq	r0, [r0], -r9
  a8:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
  ac:	7379735f 	cmnvc	r9, #2080374785	; 0x7c000001
  b0:	756d6d5f 	strbvc	r6, [sp, #-3423]!	; 0xd5f
  b4:	00000000 	andeq	r0, r0, r0
  b8:	00008500 	andeq	r8, r0, r0, lsl #10
  bc:	fb000200 	blx	8c6 <DISABLE_IRQ+0x846>
  c0:	fb000003 	blx	d6 <DISABLE_IRQ+0x56>
  c4:	b1000003 	tstlt	r0, r3
  c8:	6d000000 	stcvs	0, cr0, [r0]
  cc:	70636d65 	rsbvc	r6, r3, r5, ror #26
  d0:	00e60079 	rsceq	r0, r6, r9, ror r0
  d4:	756e0000 	strbvc	r0, [lr]!
  d8:	7265626d 	rsbvc	r6, r5, #-805306362	; 0xd0000006
  dc:	00019200 	andeq	r9, r1, r0, lsl #4
  e0:	726f6600 	rsbvc	r6, pc, #0
  e4:	5f74616d 	svcpl	0x0074616d
  e8:	6f636564 	svcvs	0x00636564
  ec:	e6006564 	str	r6, [r0], -r4, ror #10
  f0:	76000001 	strvc	r0, [r0], -r1
  f4:	72706e73 	rsbsvc	r6, r0, #1840	; 0x730
  f8:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
  fc:	0002f600 	andeq	pc, r2, r0, lsl #12
 100:	705f5f00 	subsvc	r5, pc, r0, lsl #30
 104:	635f7475 	cmpvs	pc, #1962934272	; 0x75000000
 108:	00726168 	rsbseq	r6, r2, r8, ror #2
 10c:	00000337 	andeq	r0, r0, r7, lsr r3
 110:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
 114:	93006b74 	movwls	r6, #2932	; 0xb74
 118:	74000003 	strvc	r0, [r0], #-3
 11c:	5f747365 	svcpl	0x00747365
 120:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
 124:	d6006b74 	undefined instruction 0xd6006b74
 128:	64000003 	strvs	r0, [r0], #-3
 12c:	74696769 	strbtvc	r6, [r9], #-1897	; 0x769
 130:	03e80073 	mvneq	r0, #115	; 0x73
 134:	756e0000 	strbvc	r0, [lr]!
 138:	7265626d 	rsbvc	r6, r5, #-805306362	; 0xd0000006
 13c:	00000073 	andeq	r0, r0, r3, ror r0
 140:	00520000 	subseq	r0, r2, r0
 144:	00020000 	andeq	r0, r2, r0
 148:	000007f6 	strdeq	r0, [r0], -r6
 14c:	000000a1 	andeq	r0, r0, r1, lsr #1
 150:	00000025 	andeq	r0, r0, r5, lsr #32
 154:	62616e65 	rsbvs	r6, r1, #1616	; 0x650
 158:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^
 15c:	3a007172 	bcc	1c72c <DISABLE_IRQ+0x1c6ac>
 160:	64000000 	strvs	r0, [r0]
 164:	62617369 	rsbvs	r7, r1, #-1543503871	; 0xa4000001
 168:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^
 16c:	4f007172 	svcmi	0x00007172
 170:	75000000 	strvc	r0, [r0]
 174:	6b73616d 	blvs	1cd8730 <MEM_SIZE+0x14d8730>
 178:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
 17c:	00007b00 	andeq	r7, r0, r0, lsl #22
 180:	6d6f6300 	stclvs	3, cr6, [pc]
 184:	5f6e6f6d 	svcpl	0x006e6f6d
 188:	5f717269 	svcpl	0x00717269
 18c:	646e6168 	strbtvs	r6, [lr], #-360	; 0x168
 190:	0072656c 	rsbseq	r6, r2, ip, ror #10
 194:	00000000 	andeq	r0, r0, r0
 198:	00000c66 	andeq	r0, r0, r6, ror #24
 19c:	08970002 	ldmeq	r7, {r1}
 1a0:	3ff60000 	svccc	0x00f60000
 1a4:	0b460000 	bleq	11801ac <MEM_SIZE+0x9801ac>
 1a8:	534f0000 	movtpl	r0, #61440	; 0xf000
 1ac:	45746e49 	ldrbmi	r6, [r4, #-3657]!	; 0xe49
 1b0:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
 1b4:	000b5a00 	andeq	r5, fp, r0, lsl #20
 1b8:	56534f00 	ldrbpl	r4, [r3], -r0, lsl #30
 1bc:	69737265 	ldmdbvs	r3!, {r0, r2, r5, r6, r9, ip, sp, lr}^
 1c0:	72006e6f 	andvc	r6, r0, #1776	; 0x6f0
 1c4:	4f00000b 	svcmi	0x0000000b
 1c8:	75445f53 	strbvc	r5, [r4, #-3923]	; 0xf53
 1cc:	00796d6d 	rsbseq	r6, r9, sp, ror #26
 1d0:	00000b81 	andeq	r0, r0, r1, lsl #23
 1d4:	455f534f 	ldrbmi	r5, [pc, #-847]	; fffffe8d <rEINTPEND+0xa9fffde5>
 1d8:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
 1dc:	6b736154 	blvs	1cd8734 <MEM_SIZE+0x14d8734>
 1e0:	00796452 	rsbseq	r6, r9, r2, asr r4
 1e4:	00000c28 	andeq	r0, r0, r8, lsr #24
 1e8:	455f534f 	ldrbmi	r5, [pc, #-847]	; fffffea1 <rEINTPEND+0xa9fffdf9>
 1ec:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
 1f0:	6b736154 	blvs	1cd8748 <MEM_SIZE+0x14d8748>
 1f4:	74696157 	strbtvc	r6, [r9], #-343	; 0x157
 1f8:	000c4a00 	andeq	r4, ip, r0, lsl #20
 1fc:	5f534f00 	svcpl	0x00534f00
 200:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
 204:	004f5474 	subeq	r5, pc, r4, ror r4
 208:	00000c6a 	andeq	r0, r0, sl, ror #24
 20c:	455f534f 	ldrbmi	r5, [pc, #-847]	; fffffec5 <rEINTPEND+0xa9fffe1d>
 210:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
 214:	74696157 	strbtvc	r6, [r9], #-343	; 0x157
 218:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
 21c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
 220:	000c9300 	andeq	r9, ip, r0, lsl #6
 224:	5f534f00 	svcpl	0x00534f00
 228:	436d654d 	cmnmi	sp, #322961408	; 0x13400000
 22c:	b700726c 	strlt	r7, [r0, -ip, ror #4]
 230:	4f00000c 	svcmi	0x0000000c
 234:	654d5f53 	strbvs	r5, [sp, #-3923]	; 0xf53
 238:	706f436d 	rsbvc	r4, pc, sp, ror #6
 23c:	0ce20079 	stcleq	0, cr0, [r2], #484	; 0x1e4
 240:	534f0000 	movtpl	r0, #61440	; 0xf000
 244:	7274535f 	rsbsvc	r5, r4, #2080374785	; 0x7c000001
 248:	79706f43 	ldmdbvc	r0!, {r0, r1, r6, r8, r9, sl, fp, sp, lr}^
 24c:	000d1100 	andeq	r1, sp, r0, lsl #2
 250:	5f534f00 	svcpl	0x00534f00
 254:	4c727453 	cfldrdmi	mvd7, [r2], #-332	; 0xfffffeb4
 258:	bb006e65 	bllt	1bbf4 <DISABLE_IRQ+0x1bb74>
 25c:	4f00000d 	svcmi	0x0000000d
 260:	6c465f53 	mcrrvs	15, 5, r5, r6, cr3
 264:	6e496761 	cdpvs	7, 4, cr6, cr9, cr1, {3}
 268:	ab007469 	blge	1d414 <DISABLE_IRQ+0x1d394>
 26c:	4f00000e 	svcmi	0x0000000e
 270:	6c465f53 	mcrrvs	15, 5, r5, r6, cr3
 274:	6e556761 	cdpvs	7, 5, cr6, cr5, cr1, {3}
 278:	6b6e696c 	blvs	1b9a830 <MEM_SIZE+0x139a830>
 27c:	000ee200 	andeq	lr, lr, r0, lsl #4
 280:	5f534f00 	svcpl	0x00534f00
 284:	496d654d 	stmdbmi	sp!, {r0, r2, r3, r6, r8, sl, sp, lr}^
 288:	0074696e 	rsbseq	r6, r4, lr, ror #18
 28c:	00000f34 	andeq	r0, r0, r4, lsr pc
 290:	515f534f 	cmppl	pc, pc, asr #6
 294:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
 298:	000f9000 	andeq	r9, pc, r0
 29c:	5f534f00 	svcpl	0x00534f00
 2a0:	6b736154 	blvs	1cd87f8 <MEM_SIZE+0x14d87f8>
 2a4:	436b7453 	cmnmi	fp, #1392508928	; 0x53000000
 2a8:	8100726c 	tsthi	r0, ip, ror #4
 2ac:	4f000010 	svcmi	0x00000010
 2b0:	62654453 	rsbvs	r4, r5, #1392508928	; 0x53000000
 2b4:	6e496775 	mcrvs	7, 2, r6, cr9, cr5, {3}
 2b8:	9a007469 	bls	1d464 <DISABLE_IRQ+0x1d3e4>
 2bc:	4f000010 	svcmi	0x00000010
 2c0:	6d695453 	cfstrdvs	mvd5, [r9, #-332]!	; 0xfffffeb4
 2c4:	74655365 	strbtvc	r5, [r5], #-869	; 0x365
 2c8:	0010ce00 	andseq	ip, r0, r0, lsl #28
 2cc:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 2d0:	47656d69 	strbmi	r6, [r5, -r9, ror #26]!
 2d4:	04007465 	streq	r7, [r0], #-1125	; 0x465
 2d8:	4f000011 	svcmi	0x00000011
 2dc:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 2e0:	6575516b 	ldrbvs	r5, [r5, #-363]!	; 0x16b
 2e4:	81007972 	tsthi	r0, r2, ror r9
 2e8:	4f000011 	svcmi	0x00000011
 2ec:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 2f0:	6b74536b 	blvs	1d150a4 <MEM_SIZE+0x15150a4>
 2f4:	006b6843 	rsbeq	r6, fp, r3, asr #16
 2f8:	00001214 	andeq	r1, r0, r4, lsl r2
 2fc:	545f534f 	ldrbpl	r5, [pc], #847	; 304 <DISABLE_IRQ+0x284>
 300:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
 304:	53746174 	cmnpl	r4, #29
 308:	68436b74 	stmdavs	r3, {r2, r4, r5, r6, r8, r9, fp, sp, lr}^
 30c:	126a006b 	rsbne	r0, sl, #107	; 0x6b
 310:	534f0000 	movtpl	r0, #61440	; 0xf000
 314:	6b736154 	blvs	1cd886c <MEM_SIZE+0x14d886c>
 318:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
 31c:	00746553 	rsbseq	r6, r4, r3, asr r5
 320:	00001336 	andeq	r1, r0, r6, lsr r3
 324:	6154534f 	cmpvs	r4, pc, asr #6
 328:	614e6b73 	cmpvs	lr, r3, ror fp
 32c:	6547656d 	strbvs	r6, [r7, #-1389]	; 0x56d
 330:	13dd0074 	bicsne	r0, sp, #116	; 0x74
 334:	534f0000 	movtpl	r0, #61440	; 0xf000
 338:	6b736154 	blvs	1cd8890 <MEM_SIZE+0x14d8890>
 33c:	526c6544 	rsbpl	r6, ip, #285212672	; 0x11000000
 340:	36007165 	strcc	r7, [r0], -r5, ror #2
 344:	4f000014 	svcmi	0x00000014
 348:	6d655353 	stclvs	3, cr5, [r5, #-332]!	; 0xfffffeb4
 34c:	00746553 	rsbseq	r6, r4, r3, asr r5
 350:	0000148d 	andeq	r1, r0, sp, lsl #9
 354:	6553534f 	ldrbvs	r5, [r3, #-847]	; 0x34f
 358:	6575516d 	ldrbvs	r5, [r5, #-365]!	; 0x16d
 35c:	08007972 	stmdaeq	r0, {r1, r4, r5, r6, r8, fp, ip, sp, lr}
 360:	4f000015 	svcmi	0x00000015
 364:	6d655353 	stclvs	3, cr5, [r5, #-332]!	; 0xfffffeb4
 368:	61657243 	cmnvs	r5, r3, asr #4
 36c:	76006574 	undefined instruction 0x76006574
 370:	4f000015 	svcmi	0x00000015
 374:	6d655353 	stclvs	3, cr5, [r5, #-332]!	; 0xfffffeb4
 378:	65636341 	strbvs	r6, [r3, #-833]!	; 0x341
 37c:	bd007470 	cfstrslt	mvf7, [r0, #-448]	; 0xfffffe40
 380:	4f000015 	svcmi	0x00000015
 384:	75515153 	ldrbvc	r5, [r1, #-339]	; 0x153
 388:	00797265 	rsbseq	r7, r9, r5, ror #4
 38c:	00001647 	andeq	r1, r0, r7, asr #12
 390:	4651534f 	ldrbmi	r5, [r1], -pc, asr #6
 394:	6873756c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
 398:	00169100 	andseq	r9, r6, r0, lsl #2
 39c:	51534f00 	cmppl	r3, r0, lsl #30
 3a0:	61657243 	cmnvs	r5, r3, asr #4
 3a4:	1c006574 	cfstr32ne	mvfx6, [r0], {116}	; 0x74
 3a8:	4f000017 	svcmi	0x00000017
 3ac:	63415153 	movtvs	r5, #4435	; 0x1153
 3b0:	74706563 	ldrbtvc	r6, [r0], #-1379	; 0x563
 3b4:	00177e00 	andseq	r7, r7, r0, lsl #28
 3b8:	4d534f00 	ldclmi	15, cr4, [r3]
 3bc:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
 3c0:	72657551 	rsbvc	r7, r5, #339738624	; 0x14400000
 3c4:	17f50079 	undefined instruction 0x17f50079
 3c8:	534f0000 	movtpl	r0, #61440	; 0xf000
 3cc:	6574754d 	ldrbvs	r7, [r4, #-1357]!	; 0x54d
 3d0:	65724378 	ldrbvs	r4, [r2, #-888]!	; 0x378
 3d4:	00657461 	rsbeq	r7, r5, r1, ror #8
 3d8:	00001874 	andeq	r1, r0, r4, ror r8
 3dc:	754d534f 	strbvc	r5, [sp, #-847]	; 0x34f
 3e0:	41786574 	cmnmi	r8, r4, ror r5
 3e4:	70656363 	rsbvc	r6, r5, r3, ror #6
 3e8:	18c60074 	stmiane	r6, {r2, r4, r5, r6}^
 3ec:	534f0000 	movtpl	r0, #61440	; 0xf000
 3f0:	516d654d 	cmnpl	sp, sp, asr #10
 3f4:	79726575 	ldmdbvc	r2!, {r0, r2, r4, r5, r6, r8, sl, sp, lr}^
 3f8:	00191700 	andseq	r1, r9, r0, lsl #14
 3fc:	4d534f00 	ldclmi	15, cr4, [r3]
 400:	75506d65 	ldrbvc	r6, [r0, #-3429]	; 0xd65
 404:	19620074 	stmdbne	r2!, {r2, r4, r5, r6}^
 408:	534f0000 	movtpl	r0, #61440	; 0xf000
 40c:	4e6d654d 	cdpmi	5, 6, cr6, cr13, cr13, {2}
 410:	53656d61 	cmnpl	r5, #6208	; 0x1840
 414:	1a007465 	bne	1d5b0 <DISABLE_IRQ+0x1d530>
 418:	4f00001a 	svcmi	0x0000001a
 41c:	6d654d53 	stclvs	13, cr4, [r5, #-332]!	; 0xfffffeb4
 420:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
 424:	00746547 	rsbseq	r6, r4, r7, asr #10
 428:	00001aac 	andeq	r1, r0, ip, lsr #21
 42c:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
 430:	7465476d 	strbtvc	r4, [r5], #-1901	; 0x76d
 434:	001b0000 	andseq	r0, fp, r0
 438:	4d534f00 	ldclmi	15, cr4, [r3]
 43c:	72436d65 	subvc	r6, r3, #6464	; 0x1940
 440:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
 444:	001b9f00 	andseq	r9, fp, r0, lsl #30
 448:	4d534f00 	ldclmi	15, cr4, [r3]
 44c:	51786f62 	cmnpl	r8, r2, ror #30
 450:	79726575 	ldmdbvc	r2!, {r0, r2, r4, r5, r6, r8, sl, sp, lr}^
 454:	001c1a00 	andseq	r1, ip, r0, lsl #20
 458:	4d534f00 	ldclmi	15, cr4, [r3]
 45c:	43786f62 	cmnmi	r8, #392	; 0x188
 460:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
 464:	1c880065 	stcne	0, cr0, [r8], {101}	; 0x65
 468:	534f0000 	movtpl	r0, #61440	; 0xf000
 46c:	786f624d 	stmdavc	pc!, {r0, r2, r3, r6, r9, sp, lr}^
 470:	65636341 	strbvs	r6, [r3, #-833]!	; 0x341
 474:	cf007470 	svcgt	0x00007470
 478:	4f00001c 	svcmi	0x0000001c
 47c:	616c4653 	cmnvs	ip, r3, asr r6
 480:	65755167 	ldrbvs	r5, [r5, #-359]!	; 0x167
 484:	28007972 	stmdacs	r0, {r1, r4, r5, r6, r8, fp, ip, sp, lr}
 488:	4f00001d 	svcmi	0x0000001d
 48c:	616c4653 	cmnvs	ip, r3, asr r6
 490:	6e655067 	cdpvs	0, 6, cr5, cr5, cr7, {3}
 494:	74654764 	strbtvc	r4, [r5], #-1892	; 0x764
 498:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
 49c:	79645273 	stmdbvc	r4!, {r0, r1, r4, r5, r6, r9, ip, lr}^
 4a0:	001d6100 	andseq	r6, sp, r0, lsl #2
 4a4:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
 4a8:	4e67616c 	powmisz	f6, f7, #4.0
 4ac:	53656d61 	cmnpl	r5, #6208	; 0x1840
 4b0:	1f007465 	svcne	0x00007465
 4b4:	4f00001e 	svcmi	0x0000001e
 4b8:	616c4653 	cmnvs	ip, r3, asr r6
 4bc:	6d614e67 	stclvs	14, cr4, [r1, #-412]!	; 0xfffffe64
 4c0:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
 4c4:	001eb800 	andseq	fp, lr, r0, lsl #16
 4c8:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
 4cc:	4367616c 	cmnmi	r7, #27
 4d0:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
 4d4:	1f0c0065 	svcne	0x000c0065
 4d8:	534f0000 	movtpl	r0, #61440	; 0xf000
 4dc:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
 4e0:	65636341 	strbvs	r6, [r3, #-833]!	; 0x341
 4e4:	9c007470 	cfstrsls	mvf7, [r0], {112}	; 0x70
 4e8:	4f00001f 	svcmi	0x0000001f
 4ec:	68635353 	stmdavs	r3!, {r0, r1, r4, r6, r8, r9, ip, lr}^
 4f0:	6f4c6465 	svcvs	0x004c6465
 4f4:	c3006b63 	movwgt	r6, #2915	; 0xb63
 4f8:	4f00001f 	svcmi	0x0000001f
 4fc:	65764553 	ldrbvs	r4, [r6, #-1363]!	; 0x553
 500:	614e746e 	cmpvs	lr, lr, ror #8
 504:	6553656d 	ldrbvs	r6, [r3, #-1389]	; 0x56d
 508:	207b0074 	rsbscs	r0, fp, r4, ror r0
 50c:	534f0000 	movtpl	r0, #61440	; 0xf000
 510:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
 514:	6d614e74 	stclvs	14, cr4, [r1, #-464]!	; 0xfffffe30
 518:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
 51c:	00210900 	eoreq	r0, r1, r0, lsl #18
 520:	5f534f00 	svcpl	0x00534f00
 524:	49424354 	stmdbmi	r2, {r2, r4, r6, r8, r9, lr}^
 528:	0074696e 	rsbseq	r6, r4, lr, ror #18
 52c:	000021af 	andeq	r2, r0, pc, lsr #3
 530:	545f534f 	ldrbpl	r5, [pc], #847	; 538 <DISABLE_IRQ+0x4b8>
 534:	496b7361 	stmdbmi	fp!, {r0, r5, r6, r8, r9, ip, sp, lr}^
 538:	00656c64 	rsbeq	r6, r5, r4, ror #24
 53c:	000021e6 	andeq	r2, r0, r6, ror #3
 540:	535f534f 	cmppl	pc, #1006632961	; 0x3c000001
 544:	64656863 	strbtvs	r6, [r5], #-2147	; 0x863
 548:	00222d00 	eoreq	r2, r2, r0, lsl #26
 54c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 550:	44656d69 	strbtmi	r6, [r5], #-3433	; 0xd69
 554:	6552796c 	ldrbvs	r7, [r2, #-2412]	; 0x96c
 558:	656d7573 	strbvs	r7, [sp, #-1395]!	; 0x573
 55c:	00227800 	eoreq	r7, r2, r0, lsl #16
 560:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 564:	44656d69 	strbtmi	r6, [r5], #-3433	; 0xd69
 568:	b500796c 	strlt	r7, [r0, #-2412]	; 0x96c
 56c:	4f000022 	svcmi	0x00000022
 570:	6d695453 	cfstrdvs	mvd5, [r9, #-332]!	; 0xfffffeb4
 574:	796c4465 	stmdbvc	ip!, {r0, r2, r5, r6, sl, lr}^
 578:	4d534d48 	ldclmi	13, cr4, [r3, #-288]	; 0xfffffee0
 57c:	00232d00 	eoreq	r2, r3, r0, lsl #26
 580:	5f534f00 	svcpl	0x00534f00
 584:	6b736154 	blvs	1cd8adc <MEM_SIZE+0x14d8adc>
 588:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
 58c:	00238e00 	eoreq	r8, r3, r0, lsl #28
 590:	53534f00 	cmppl	r3, #0
 594:	49746174 	ldmdbmi	r4!, {r2, r4, r5, r6, r8, sp, lr}^
 598:	0074696e 	rsbseq	r6, r4, lr, ror #18
 59c:	000023b5 	undefined instruction 0x000023b5
 5a0:	6154534f 	cmpvs	r4, pc, asr #6
 5a4:	75536b73 	ldrbvc	r6, [r3, #-2931]	; 0xb73
 5a8:	6e657073 	mcrvs	0, 3, r7, cr5, cr3, {3}
 5ac:	241c0064 	ldrcs	r0, [ip], #-100	; 0x64
 5b0:	534f0000 	movtpl	r0, #61440	; 0xf000
 5b4:	6b736154 	blvs	1cd8b0c <MEM_SIZE+0x14d8b0c>
 5b8:	75736552 	ldrbvc	r6, [r3, #-1362]!	; 0x552
 5bc:	6700656d 	strvs	r6, [r0, -sp, ror #10]
 5c0:	4f000024 	svcmi	0x00000024
 5c4:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 5c8:	6c65446b 	cfstrdvs	mvd4, [r5], #-428	; 0xfffffe54
 5cc:	00251600 	eoreq	r1, r5, r0, lsl #12
 5d0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 5d4:	436b7361 	cmnmi	fp, #-2080374783	; 0x84000001
 5d8:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
 5dc:	74784565 	ldrbtvc	r4, [r8], #-1381	; 0x565
 5e0:	00262000 	eoreq	r2, r6, r0
 5e4:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 5e8:	495f726d 	ldmdbmi	pc, {r0, r2, r3, r5, r6, r9, ip, sp, lr}^
 5ec:	0074696e 	rsbseq	r6, r4, lr, ror #18
 5f0:	000026d1 	ldrdeq	r2, [r0], -r1
 5f4:	6154534f 	cmpvs	r4, pc, asr #6
 5f8:	72436b73 	subvc	r6, r3, #117760	; 0x1cc00
 5fc:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
 600:	00275200 	eoreq	r5, r7, r0, lsl #4
 604:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 608:	436b7361 	cmnmi	fp, #-2080374783	; 0x84000001
 60c:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
 610:	69725065 	ldmdbvs	r2!, {r0, r2, r5, r6, ip, lr}^
 614:	27fe006f 	ldrbcs	r0, [lr, pc, rrx]!
 618:	534f0000 	movtpl	r0, #61440	; 0xf000
 61c:	506d6553 	rsbpl	r6, sp, r3, asr r5
 620:	0074736f 	rsbseq	r7, r4, pc, ror #6
 624:	0000284c 	andeq	r2, r0, ip, asr #16
 628:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 62c:	67695372 	undefined instruction 0x67695372
 630:	006c616e 	rsbeq	r6, ip, lr, ror #2
 634:	00002875 	andeq	r2, r0, r5, ror r8
 638:	6553534f 	ldrbvs	r5, [r3, #-847]	; 0x34f
 63c:	6e65506d 	cdpvs	0, 6, cr5, cr5, cr13, {3}
 640:	29430064 	stmdbcs	r3, {r2, r5, r6}^
 644:	534f0000 	movtpl	r0, #61440	; 0xf000
 648:	53726d54 	cmnpl	r2, #5376	; 0x1500
 64c:	00706f74 	rsbseq	r6, r0, r4, ror pc
 650:	000029b2 	undefined instruction 0x000029b2
 654:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 658:	61745372 	cmnvs	r4, r2, ror r3
 65c:	f1007472 	undefined instruction 0xf1007472
 660:	4f000029 	svcmi	0x00000029
 664:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
 668:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
 66c:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
 670:	002a4000 	eoreq	r4, sl, r0
 674:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 678:	6552726d 	ldrbvs	r7, [r2, #-621]	; 0x26d
 67c:	6e69616d 	powvsez	f6, f1, #5.0
 680:	00746547 	rsbseq	r6, r4, r7, asr #10
 684:	00002a8f 	andeq	r2, r0, pc, lsl #21
 688:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 68c:	6d614e72 	stclvs	14, cr4, [r1, #-456]!	; 0xfffffe38
 690:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
 694:	002b1800 	eoreq	r1, fp, r0, lsl #16
 698:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 69c:	6544726d 	strbvs	r7, [r4, #-621]	; 0x26d
 6a0:	2b69006c 	blcs	1a40858 <MEM_SIZE+0x1240858>
 6a4:	534f0000 	movtpl	r0, #61440	; 0xf000
 6a8:	43726d54 	cmnmi	r2, #5376	; 0x1500
 6ac:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
 6b0:	2cfd0065 	ldclcs	0, cr0, [sp], #404	; 0x194
 6b4:	534f0000 	movtpl	r0, #61440	; 0xf000
 6b8:	446d6553 	strbtmi	r6, [sp], #-1363	; 0x553
 6bc:	6d006c65 	stcvs	12, cr6, [r0, #-404]	; 0xfffffe6c
 6c0:	4f00002d 	svcmi	0x0000002d
 6c4:	6f505153 	svcvs	0x00505153
 6c8:	704f7473 	subvc	r7, pc, r3, ror r4
 6cc:	2ddb0074 	ldclcs	0, cr0, [fp, #464]	; 0x1d0
 6d0:	534f0000 	movtpl	r0, #61440	; 0xf000
 6d4:	736f5051 	cmnvc	pc, #81	; 0x51
 6d8:	6f724674 	svcvs	0x00724674
 6dc:	3900746e 	stmdbcc	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
 6e0:	4f00002e 	svcmi	0x0000002e
 6e4:	6f505153 	svcvs	0x00505153
 6e8:	97007473 	smlsdxls	r0, r3, r4, r7
 6ec:	4f00002e 	svcmi	0x0000002e
 6f0:	65505153 	ldrbvs	r5, [r0, #-339]	; 0x153
 6f4:	5f00646e 	svcpl	0x0000646e
 6f8:	4f00002f 	svcmi	0x0000002f
 6fc:	65445153 	strbvs	r5, [r4, #-339]	; 0x153
 700:	2fdd006c 	svccs	0x00dd006c
 704:	534f0000 	movtpl	r0, #61440	; 0xf000
 708:	6574754d 	ldrbvs	r7, [r4, #-1357]!	; 0x54d
 70c:	736f5078 	cmnvc	pc, #120	; 0x78
 710:	30620074 	rsbcc	r0, r2, r4, ror r0
 714:	534f0000 	movtpl	r0, #61440	; 0xf000
 718:	6574754d 	ldrbvs	r7, [r4, #-1357]!	; 0x54d
 71c:	6e655078 	mcrvs	0, 3, r5, cr5, cr8, {3}
 720:	31590064 	cmpcc	r9, r4, rrx
 724:	534f0000 	movtpl	r0, #61440	; 0xf000
 728:	6574754d 	ldrbvs	r7, [r4, #-1357]!	; 0x54d
 72c:	6c654478 	cfstrdvs	mvd4, [r5], #-480	; 0xfffffe20
 730:	00321a00 	eorseq	r1, r2, r0, lsl #20
 734:	4d534f00 	ldclmi	15, cr4, [r3]
 738:	50786f62 	rsbspl	r6, r8, r2, ror #30
 73c:	4f74736f 	svcmi	0x0074736f
 740:	79007470 	stmdbvc	r0, {r4, r5, r6, sl, ip, sp, lr}
 744:	4f000032 	svcmi	0x00000032
 748:	6f624d53 	svcvs	0x00624d53
 74c:	736f5078 	cmnvc	pc, #120	; 0x78
 750:	32c40074 	sbccc	r0, r4, #116	; 0x74
 754:	534f0000 	movtpl	r0, #61440	; 0xf000
 758:	786f624d 	stmdavc	pc!, {r0, r2, r3, r6, r9, sp, lr}^
 75c:	646e6550 	strbtvs	r6, [lr], #-1360	; 0x550
 760:	00337d00 	eorseq	r7, r3, r0, lsl #26
 764:	4d534f00 	ldclmi	15, cr4, [r3]
 768:	44786f62 	ldrbtmi	r6, [r8], #-3938	; 0xf62
 76c:	ed006c65 	stc	12, cr6, [r0, #-404]	; 0xfffffe6c
 770:	4f000033 	svcmi	0x00000033
 774:	616c4653 	cmnvs	ip, r3, asr r6
 778:	736f5067 	cmnvc	pc, #103	; 0x67
 77c:	34a60074 	strtcc	r0, [r6], #116	; 0x74
 780:	534f0000 	movtpl	r0, #61440	; 0xf000
 784:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
 788:	646e6550 	strbtvs	r6, [lr], #-1360	; 0x550
 78c:	00359800 	eorseq	r9, r5, r0, lsl #16
 790:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
 794:	4467616c 	strbtmi	r6, [r7], #-364	; 0x16c
 798:	1f006c65 	svcne	0x00006c65
 79c:	4f000036 	svcmi	0x00000036
 7a0:	68635353 	stmdavs	r3!, {r0, r1, r4, r6, r8, r9, ip, lr}^
 7a4:	6e556465 	cdpvs	4, 5, cr6, cr5, cr5, {3}
 7a8:	6b636f6c 	blvs	18dc560 <MEM_SIZE+0x10dc560>
 7ac:	00364600 	eorseq	r4, r6, r0, lsl #12
 7b0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 7b4:	54656d69 	strbtpl	r6, [r5], #-3433	; 0xd69
 7b8:	006b6369 	rsbeq	r6, fp, r9, ror #6
 7bc:	00003689 	andeq	r3, r0, r9, lsl #13
 7c0:	7453534f 	ldrbvc	r5, [r3], #-847	; 0x34f
 7c4:	00747261 	rsbseq	r7, r4, r1, ror #4
 7c8:	000036c4 	andeq	r3, r0, r4, asr #13
 7cc:	6e49534f 	cdpvs	3, 4, cr5, cr9, cr15, {2}
 7d0:	69784574 	ldmdbvs	r8!, {r2, r4, r5, r6, r8, sl, lr}^
 7d4:	370b0074 	smlsdxcc	fp, r4, r0, r0
 7d8:	534f0000 	movtpl	r0, #61440	; 0xf000
 7dc:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
 7e0:	00385800 	eorseq	r5, r8, r0, lsl #16
 7e4:	43534f00 	cmpmi	r3, #0
 7e8:	77537874 	undefined instruction 0x77537874
 7ec:	00727443 	rsbseq	r7, r2, r3, asr #8
 7f0:	0000386b 	andeq	r3, r0, fp, ror #16
 7f4:	7645534f 	strbvc	r5, [r5], -pc, asr #6
 7f8:	46746e65 	ldrbtmi	r6, [r4], -r5, ror #28
 7fc:	4c656572 	cfstr64mi	mvdx6, [r5], #-456	; 0xfffffe38
 800:	00747369 	rsbseq	r7, r4, r9, ror #6
 804:	0000388e 	andeq	r3, r0, lr, lsl #17
 808:	7645534f 	strbvc	r5, [r5], -pc, asr #6
 80c:	54746e65 	ldrbtpl	r6, [r4], #-3685	; 0xe65
 810:	b1006c62 	tstlt	r0, r2, ror #24
 814:	4f000038 	svcmi	0x00000038
 818:	616c4653 	cmnvs	ip, r3, asr r6
 81c:	6c625467 	cfstrdvs	mvd5, [r2], #-412	; 0xfffffe64
 820:	0038c400 	eorseq	ip, r8, r0, lsl #8
 824:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
 828:	4667616c 	strbtmi	r6, [r7], -ip, ror #2
 82c:	4c656572 	cfstr64mi	mvdx6, [r5], #-456	; 0xfffffe38
 830:	00747369 	rsbseq	r7, r4, r9, ror #6
 834:	000038d7 	ldrdeq	r3, [r0], -r7
 838:	5043534f 	subpl	r5, r3, pc, asr #6
 83c:	61735555 	cmnvs	r3, r5, asr r5
 840:	ea006567 	b	19de4 <DISABLE_IRQ+0x19d64>
 844:	4f000038 	svcmi	0x00000038
 848:	6c644953 	stclvs	9, cr4, [r4], #-332	; 0xfffffeb4
 84c:	72744365 	rsbsvc	r4, r4, #-1811939327	; 0x94000001
 850:	0078614d 	rsbseq	r6, r8, sp, asr #2
 854:	000038fd 	strdeq	r3, [r0], -sp
 858:	6449534f 	strbvs	r5, [r9], #-847	; 0x34f
 85c:	7443656c 	strbvc	r6, [r3], #-1388	; 0x56c
 860:	6e755272 	mrcvs	2, 3, r5, cr5, cr2, {3}
 864:	00391000 	eorseq	r1, r9, r0
 868:	53534f00 	cmppl	r3, #0
 86c:	52746174 	rsbspl	r6, r4, #29
 870:	33007964 	movwcc	r7, #2404	; 0x964
 874:	4f000039 	svcmi	0x00000039
 878:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 87c:	6174536b 	cmnvs	r4, fp, ror #6
 880:	6b745374 	blvs	1d15658 <MEM_SIZE+0x1515658>
 884:	00394600 	eorseq	r4, r9, r0, lsl #12
 888:	49534f00 	ldmdbmi	r3, {r8, r9, sl, fp, lr}^
 88c:	654e746e 	strbvs	r7, [lr, #-1134]	; 0x46e
 890:	6e697473 	mcrvs	4, 3, r7, cr9, cr3, {3}
 894:	39590067 	ldmdbcc	r9, {r0, r1, r2, r5, r6}^
 898:	534f0000 	movtpl	r0, #61440	; 0xf000
 89c:	6b636f4c 	blvs	18dc5d4 <MEM_SIZE+0x10dc5d4>
 8a0:	7473654e 	ldrbtvc	r6, [r3], #-1358	; 0x54e
 8a4:	00676e69 	rsbeq	r6, r7, r9, ror #28
 8a8:	0000396c 	andeq	r3, r0, ip, ror #18
 8ac:	7250534f 	subsvc	r5, r0, #1006632961	; 0x3c000001
 8b0:	75436f69 	strbvc	r6, [r3, #-3945]	; 0xf69
 8b4:	397f0072 	ldmdbcc	pc!, {r1, r4, r5, r6}^
 8b8:	534f0000 	movtpl	r0, #61440	; 0xf000
 8bc:	6f697250 	svcvs	0x00697250
 8c0:	68676948 	stmdavs	r7!, {r3, r6, r8, fp, sp, lr}^
 8c4:	00796452 	rsbseq	r6, r9, r2, asr r4
 8c8:	00003992 	muleq	r0, r2, r9
 8cc:	6452534f 	ldrbvs	r5, [r2], #-847	; 0x34f
 8d0:	70724779 	rsbsvc	r4, r2, r9, ror r7
 8d4:	0039a500 	eorseq	sl, r9, r0, lsl #10
 8d8:	52534f00 	subspl	r4, r3, #0
 8dc:	62547964 	subsvs	r7, r4, #1638400	; 0x190000
 8e0:	39b8006c 	ldmibcc	r8!, {r2, r3, r5, r6}
 8e4:	534f0000 	movtpl	r0, #61440	; 0xf000
 8e8:	6e6e7552 	mcrvs	5, 3, r7, cr14, cr2, {2}
 8ec:	00676e69 	rsbeq	r6, r7, r9, ror #28
 8f0:	000039cb 	andeq	r3, r0, fp, asr #19
 8f4:	6154534f 	cmpvs	r4, pc, asr #6
 8f8:	74436b73 	strbvc	r6, [r3], #-2931	; 0xb73
 8fc:	39de0072 	ldmibcc	lr, {r1, r4, r5, r6}^
 900:	534f0000 	movtpl	r0, #61440	; 0xf000
 904:	656c6449 	strbvs	r6, [ip, #-1097]!	; 0x449
 908:	00727443 	rsbseq	r7, r2, r3, asr #8
 90c:	000039f6 	strdeq	r3, [r0], -r6
 910:	6154534f 	cmpvs	r4, pc, asr #6
 914:	64496b73 	strbvs	r6, [r9], #-2931	; 0xb73
 918:	7453656c 	ldrbvc	r6, [r3], #-1388	; 0x56c
 91c:	3a09006b 	bcc	240ad0 <DISABLE_IRQ+0x240a50>
 920:	534f0000 	movtpl	r0, #61440	; 0xf000
 924:	43424354 	movtmi	r4, #9044	; 0x2354
 928:	1c007275 	sfmne	f7, 4, [r0], {117}	; (stcne 2, cr7, [r0], {117})	; 0x75
 92c:	4f00003a 	svcmi	0x0000003a
 930:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
 934:	65657246 	strbvs	r7, [r5, #-582]!	; 0x246
 938:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
 93c:	003a2f00 	eorseq	r2, sl, r0, lsl #30
 940:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 944:	69484243 	stmdbvs	r8, {r0, r1, r6, r9, lr}^
 948:	64526867 	ldrbvs	r6, [r2], #-2151	; 0x867
 94c:	3a420079 	bcc	1080b38 <MEM_SIZE+0x880b38>
 950:	534f0000 	movtpl	r0, #61440	; 0xf000
 954:	4c424354 	mcrrmi	3, 5, r4, r2, cr4
 958:	00747369 	rsbseq	r7, r4, r9, ror #6
 95c:	00003a65 	andeq	r3, r0, r5, ror #20
 960:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
 964:	69725042 	ldmdbvs	r2!, {r1, r6, ip, lr}^
 968:	6c62546f 	cfstrdvs	mvd5, [r2], #-444	; 0xfffffe44
 96c:	003a8800 	eorseq	r8, sl, r0, lsl #16
 970:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 974:	62544243 	subsvs	r4, r4, #805306372	; 0x30000004
 978:	3a9b006c 	bcc	fe6c0b30 <rEINTPEND+0xa86c0a88>
 97c:	534f0000 	movtpl	r0, #61440	; 0xf000
 980:	6b636954 	blvs	18daed8 <MEM_SIZE+0x10daed8>
 984:	70657453 	rsbvc	r7, r5, r3, asr r4
 988:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
 98c:	3aae0065 	bcc	feb80b28 <rEINTPEND+0xa8b80a80>
 990:	534f0000 	movtpl	r0, #61440	; 0xf000
 994:	466d654d 	strbtmi	r6, [sp], -sp, asr #10
 998:	4c656572 	cfstr64mi	mvdx6, [r5], #-456	; 0xfffffe38
 99c:	00747369 	rsbseq	r7, r4, r9, ror #6
 9a0:	00003ad1 	ldrdeq	r3, [r0], -r1
 9a4:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
 9a8:	6c62546d 	cfstrdvs	mvd5, [r2], #-436	; 0xfffffe4c
 9ac:	003ae400 	eorseq	lr, sl, r0, lsl #8
 9b0:	51534f00 	cmppl	r3, r0, lsl #30
 9b4:	65657246 	strbvs	r7, [r5, #-582]!	; 0x246
 9b8:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
 9bc:	003b0700 	eorseq	r0, fp, r0, lsl #14
 9c0:	51534f00 	cmppl	r3, r0, lsl #30
 9c4:	006c6254 	rsbeq	r6, ip, r4, asr r2
 9c8:	00003b1a 	andeq	r3, r0, sl, lsl fp
 9cc:	6954534f 	ldmdbvs	r4, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
 9d0:	2d00656d 	cfstr32cs	mvfx6, [r0, #-436]	; 0xfffffe4c
 9d4:	4f00003b 	svcmi	0x0000003b
 9d8:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
 9dc:	65657246 	strbvs	r7, [r5, #-582]!	; 0x246
 9e0:	003b4000 	eorseq	r4, fp, r0
 9e4:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 9e8:	7355726d 	cmpvc	r5, #-805306362	; 0xd0000006
 9ec:	53006465 	movwpl	r6, #1125	; 0x465
 9f0:	4f00003b 	svcmi	0x0000003b
 9f4:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
 9f8:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
 9fc:	003b6600 	eorseq	r6, fp, r0, lsl #12
 a00:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 a04:	6553726d 	ldrbvs	r7, [r3, #-621]	; 0x26d
 a08:	3b79006d 	blcc	1e40bc4 <MEM_SIZE+0x1640bc4>
 a0c:	534f0000 	movtpl	r0, #61440	; 0xf000
 a10:	53726d54 	cmnpl	r2, #5376	; 0x1500
 a14:	69536d65 	ldmdbvs	r3, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
 a18:	6c616e67 	stclvs	14, cr6, [r1], #-412	; 0xfffffe64
 a1c:	003b9c00 	eorseq	r9, fp, r0, lsl #24
 a20:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 a24:	6254726d 	subsvs	r7, r4, #-805306362	; 0xd0000006
 a28:	3baf006c 	blcc	febc0be0 <rEINTPEND+0xa8bc0b38>
 a2c:	534f0000 	movtpl	r0, #61440	; 0xf000
 a30:	46726d54 	undefined instruction 0x46726d54
 a34:	4c656572 	cfstr64mi	mvdx6, [r5], #-456	; 0xfffffe38
 a38:	00747369 	rsbseq	r7, r4, r9, ror #6
 a3c:	00003bc2 	andeq	r3, r0, r2, asr #23
 a40:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 a44:	73615472 	cmnvc	r1, #1912602624	; 0x72000000
 a48:	6b74536b 	blvs	1d157fc <MEM_SIZE+0x15157fc>
 a4c:	003be500 	eorseq	lr, fp, r0, lsl #10
 a50:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 a54:	6857726d 	ldmdavs	r7, {r0, r2, r3, r5, r6, r9, ip, sp, lr}^
 a58:	546c6565 	strbtpl	r6, [ip], #-1381	; 0x565
 a5c:	08006c62 	stmdaeq	r0, {r1, r5, r6, sl, fp, sp, lr}
 a60:	4f00003c 	svcmi	0x0000003c
 a64:	4d6e5553 	cfstr64mi	mvdx5, [lr, #-332]!	; 0xfffffeb4
 a68:	62547061 	subsvs	r7, r4, #97	; 0x61
 a6c:	3c1f006c 	ldccc	0, cr0, [pc], {108}	; 0x6c
 a70:	534f0000 	movtpl	r0, #61440	; 0xf000
 a74:	75626544 	strbvc	r6, [r2, #-1348]!	; 0x544
 a78:	006e4567 	rsbeq	r4, lr, r7, ror #10
 a7c:	00003c36 	andeq	r3, r0, r6, lsr ip
 a80:	6e45534f 	cdpvs	3, 4, cr5, cr5, cr15, {2}
 a84:	6e616964 	cdpvs	9, 6, cr6, cr1, cr4, {3}
 a88:	7373656e 	cmnvc	r3, #461373440	; 0x1b800000
 a8c:	74736554 	ldrbtvc	r6, [r3], #-1364	; 0x554
 a90:	003c4d00 	eorseq	r4, ip, r0, lsl #26
 a94:	45534f00 	ldrbmi	r4, [r3, #-3840]	; 0xf00
 a98:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
 a9c:	5f006e45 	svcpl	0x00006e45
 aa0:	4f00003c 	svcmi	0x0000003c
 aa4:	65764553 	ldrbvs	r4, [r6, #-1363]!	; 0x553
 aa8:	614d746e 	cmpvs	sp, lr, ror #8
 aac:	3c710078 	ldclcc	0, cr0, [r1], #-480	; 0xfffffe20
 ab0:	534f0000 	movtpl	r0, #61440	; 0xf000
 ab4:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
 ab8:	6d614e74 	stclvs	14, cr4, [r1, #-464]!	; 0xfffffe30
 abc:	7a695365 	bvc	1a55858 <MEM_SIZE+0x1255858>
 ac0:	3c830065 	stccc	0, cr0, [r3], {101}	; 0x65
 ac4:	534f0000 	movtpl	r0, #61440	; 0xf000
 ac8:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
 acc:	7a695374 	bvc	1a558a4 <MEM_SIZE+0x12558a4>
 ad0:	3c950065 	ldccc	0, cr0, [r5], {101}	; 0x65
 ad4:	534f0000 	movtpl	r0, #61440	; 0xf000
 ad8:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
 adc:	6c625474 	cfstrdvs	mvd5, [r2], #-464	; 0xfffffe30
 ae0:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 ae4:	003ca700 	eorseq	sl, ip, r0, lsl #14
 ae8:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
 aec:	4567616c 	strbmi	r6, [r7, #-364]!	; 0x16c
 af0:	3cb9006e 	ldccc	0, cr0, [r9], #440	; 0x1b8
 af4:	534f0000 	movtpl	r0, #61440	; 0xf000
 af8:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
 afc:	53707247 	cmnpl	r0, #1879048196	; 0x70000004
 b00:	00657a69 	rsbeq	r7, r5, r9, ror #20
 b04:	00003ccb 	andeq	r3, r0, fp, asr #25
 b08:	6c46534f 	mcrrvs	3, 4, r5, r6, cr15
 b0c:	6f4e6761 	svcvs	0x004e6761
 b10:	69536564 	ldmdbvs	r3, {r2, r5, r6, r8, sl, sp, lr}^
 b14:	dd00657a 	cfstr32le	mvfx6, [r0, #-488]	; 0xfffffe18
 b18:	4f00003c 	svcmi	0x0000003c
 b1c:	616c4653 	cmnvs	ip, r3, asr r6
 b20:	64695767 	strbtvs	r5, [r9], #-1895	; 0x767
 b24:	ef006874 	svc	0x00006874
 b28:	4f00003c 	svcmi	0x0000003c
 b2c:	616c4653 	cmnvs	ip, r3, asr r6
 b30:	78614d67 	stmdavc	r1!, {r0, r1, r2, r5, r6, r8, sl, fp, lr}^
 b34:	003d0100 	eorseq	r0, sp, r0, lsl #2
 b38:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
 b3c:	4e67616c 	powmisz	f6, f7, #4.0
 b40:	53656d61 	cmnpl	r5, #6208	; 0x1840
 b44:	00657a69 	rsbeq	r7, r5, r9, ror #20
 b48:	00003d13 	andeq	r3, r0, r3, lsl sp
 b4c:	6f4c534f 	svcvs	0x004c534f
 b50:	74736577 	ldrbtvc	r6, [r3], #-1399	; 0x577
 b54:	6f697250 	svcvs	0x00697250
 b58:	003d2500 	eorseq	r2, sp, r0, lsl #10
 b5c:	4d534f00 	ldclmi	15, cr4, [r3]
 b60:	45786f62 	ldrbmi	r6, [r8, #-3938]!	; 0xf62
 b64:	3d37006e 	ldccc	0, cr0, [r7, #-440]!	; 0xfffffe48
 b68:	534f0000 	movtpl	r0, #61440	; 0xf000
 b6c:	456d654d 	strbmi	r6, [sp, #-1357]!	; 0x54d
 b70:	3d49006e 	stclcc	0, cr0, [r9, #-440]	; 0xfffffe48
 b74:	534f0000 	movtpl	r0, #61440	; 0xf000
 b78:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
 b7c:	5b007861 	blpl	1ed08 <DISABLE_IRQ+0x1ec88>
 b80:	4f00003d 	svcmi	0x0000003d
 b84:	6d654d53 	stclvs	13, cr4, [r5, #-332]!	; 0xfffffeb4
 b88:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
 b8c:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 b90:	003d6d00 	eorseq	r6, sp, r0, lsl #26
 b94:	4d534f00 	ldclmi	15, cr4, [r3]
 b98:	69536d65 	ldmdbvs	r3, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
 b9c:	7f00657a 	svcvc	0x0000657a
 ba0:	4f00003d 	svcmi	0x0000003d
 ba4:	6d654d53 	stclvs	13, cr4, [r5, #-332]!	; 0xfffffeb4
 ba8:	536c6254 	cmnpl	ip, #1073741829	; 0x40000005
 bac:	00657a69 	rsbeq	r7, r5, r9, ror #20
 bb0:	00003d91 	muleq	r0, r1, sp
 bb4:	754d534f 	strbvc	r5, [sp, #-847]	; 0x34f
 bb8:	45786574 	ldrbmi	r6, [r8, #-1396]!	; 0x574
 bbc:	3da3006e 	stccc	0, cr0, [r3, #440]!	; 0x1b8
 bc0:	534f0000 	movtpl	r0, #61440	; 0xf000
 bc4:	53727450 	cmnpl	r2, #1342177280	; 0x50000000
 bc8:	00657a69 	rsbeq	r7, r5, r9, ror #20
 bcc:	00003db5 	undefined instruction 0x00003db5
 bd0:	4551534f 	ldrbmi	r5, [r1, #-847]	; 0x34f
 bd4:	3dc7006e 	stclcc	0, cr0, [r7, #440]	; 0x1b8
 bd8:	534f0000 	movtpl	r0, #61440	; 0xf000
 bdc:	78614d51 	stmdavc	r1!, {r0, r4, r6, r8, sl, fp, lr}^
 be0:	003dd900 	eorseq	sp, sp, r0, lsl #18
 be4:	51534f00 	cmppl	r3, r0, lsl #30
 be8:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 bec:	003deb00 	eorseq	lr, sp, r0, lsl #22
 bf0:	52534f00 	subspl	r4, r3, #0
 bf4:	62547964 	subsvs	r7, r4, #1638400	; 0x190000
 bf8:	7a69536c 	bvc	1a559b0 <MEM_SIZE+0x12559b0>
 bfc:	3dfd0065 	ldclcc	0, cr0, [sp, #404]!	; 0x194
 c00:	534f0000 	movtpl	r0, #61440	; 0xf000
 c04:	456d6553 	strbmi	r6, [sp, #-1363]!	; 0x553
 c08:	3e0f006e 	cdpcc	0, 0, cr0, cr15, cr14, {3}
 c0c:	534f0000 	movtpl	r0, #61440	; 0xf000
 c10:	576b7453 	undefined instruction 0x576b7453
 c14:	68746469 	ldmdavs	r4!, {r0, r3, r5, r6, sl, sp, lr}^
 c18:	003e2100 	eorseq	r2, lr, r0, lsl #2
 c1c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 c20:	436b7361 	cmnmi	fp, #-2080374783	; 0x84000001
 c24:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
 c28:	006e4565 	rsbeq	r4, lr, r5, ror #10
 c2c:	00003e33 	andeq	r3, r0, r3, lsr lr
 c30:	6154534f 	cmpvs	r4, pc, asr #6
 c34:	72436b73 	subvc	r6, r3, #117760	; 0x1cc00
 c38:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
 c3c:	45747845 	ldrbmi	r7, [r4, #-2117]!	; 0x845
 c40:	3e45006e 	cdpcc	0, 4, cr0, cr5, cr14, {3}
 c44:	534f0000 	movtpl	r0, #61440	; 0xf000
 c48:	6b736154 	blvs	1cd91a0 <MEM_SIZE+0x14d91a0>
 c4c:	456c6544 	strbmi	r6, [ip, #-1348]!	; 0x544
 c50:	3e57006e 	cdpcc	0, 5, cr0, cr7, cr14, {3}
 c54:	534f0000 	movtpl	r0, #61440	; 0xf000
 c58:	6b736154 	blvs	1cd91b0 <MEM_SIZE+0x14d91b0>
 c5c:	656c6449 	strbvs	r6, [ip, #-1097]!	; 0x449
 c60:	536b7453 	cmnpl	fp, #1392508928	; 0x53000000
 c64:	00657a69 	rsbeq	r7, r5, r9, ror #20
 c68:	00003e69 	andeq	r3, r0, r9, ror #28
 c6c:	6154534f 	cmpvs	r4, pc, asr #6
 c70:	72506b73 	subsvc	r6, r0, #117760	; 0x1cc00
 c74:	6c69666f 	stclvs	6, cr6, [r9], #-444	; 0xfffffe44
 c78:	006e4565 	rsbeq	r4, lr, r5, ror #10
 c7c:	00003e7b 	andeq	r3, r0, fp, ror lr
 c80:	6154534f 	cmpvs	r4, pc, asr #6
 c84:	614d6b73 	cmpvs	sp, r3, ror fp
 c88:	3e8d0078 	mcrcc	0, 4, r0, cr13, cr8, {3}
 c8c:	534f0000 	movtpl	r0, #61440	; 0xf000
 c90:	6b736154 	blvs	1cd91e8 <MEM_SIZE+0x14d91e8>
 c94:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
 c98:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 c9c:	003e9f00 	eorseq	r9, lr, r0, lsl #30
 ca0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 ca4:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
 ca8:	45746174 	ldrbmi	r6, [r4, #-372]!	; 0x174
 cac:	3eb1006e 	cdpcc	0, 11, cr0, cr1, cr14, {3}
 cb0:	534f0000 	movtpl	r0, #61440	; 0xf000
 cb4:	6b736154 	blvs	1cd920c <MEM_SIZE+0x14d920c>
 cb8:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
 cbc:	536b7453 	cmnpl	fp, #1392508928	; 0x53000000
 cc0:	00657a69 	rsbeq	r7, r5, r9, ror #20
 cc4:	00003ec3 	andeq	r3, r0, r3, asr #29
 cc8:	6154534f 	cmpvs	r4, pc, asr #6
 ccc:	74536b73 	ldrbvc	r6, [r3], #-2931	; 0xb73
 cd0:	74537461 	ldrbvc	r7, [r3], #-1121	; 0x461
 cd4:	6b68436b 	blvs	1a11a88 <MEM_SIZE+0x1211a88>
 cd8:	d5006e45 	strle	r6, [r0, #-3653]	; 0xe45
 cdc:	4f00003e 	svcmi	0x0000003e
 ce0:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 ce4:	4877536b 	ldmdami	r7!, {r0, r1, r3, r5, r6, r8, r9, ip, lr}^
 ce8:	456b6f6f 	strbmi	r6, [fp, #-3951]!	; 0xf6f
 cec:	3ee7006e 	cdpcc	0, 14, cr0, cr7, cr14, {3}
 cf0:	534f0000 	movtpl	r0, #61440	; 0xf000
 cf4:	50424354 	subpl	r4, r2, r4, asr r3
 cf8:	546f6972 	strbtpl	r6, [pc], #2418	; d00 <DISABLE_IRQ+0xc80>
 cfc:	614d6c62 	cmpvs	sp, r2, ror #24
 d00:	3ef90078 	mrccc	0, 7, r0, cr9, cr8, {3}
 d04:	534f0000 	movtpl	r0, #61440	; 0xf000
 d08:	53424354 	movtpl	r4, #9044	; 0x2354
 d0c:	00657a69 	rsbeq	r7, r5, r9, ror #20
 d10:	00003f0b 	andeq	r3, r0, fp, lsl #30
 d14:	6954534f 	ldmdbvs	r4, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
 d18:	50736b63 	rsbspl	r6, r3, r3, ror #22
 d1c:	65537265 	ldrbvs	r7, [r3, #-613]	; 0x265
 d20:	3f1d0063 	svccc	0x001d0063
 d24:	534f0000 	movtpl	r0, #61440	; 0xf000
 d28:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
 d2c:	6b636954 	blvs	18db284 <MEM_SIZE+0x10db284>
 d30:	6b6f6f48 	blvs	1bdca58 <MEM_SIZE+0x13dca58>
 d34:	2f006e45 	svccs	0x00006e45
 d38:	4f00003f 	svcmi	0x0000003f
 d3c:	72655653 	rsbvc	r5, r5, #87031808	; 0x5300000
 d40:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
 d44:	0072624e 	rsbseq	r6, r2, lr, asr #4
 d48:	00003f41 	andeq	r3, r0, r1, asr #30
 d4c:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 d50:	006e4572 	rsbeq	r4, lr, r2, ror r5
 d54:	00003f53 	andeq	r3, r0, r3, asr pc
 d58:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 d5c:	67664372 	undefined instruction 0x67664372
 d60:	0078614d 	rsbseq	r6, r8, sp, asr #2
 d64:	00003f65 	andeq	r3, r0, r5, ror #30
 d68:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
 d6c:	67664372 	undefined instruction 0x67664372
 d70:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
 d74:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 d78:	003f7700 	eorseq	r7, pc, r0, lsl #14
 d7c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 d80:	6643726d 	strbvs	r7, [r3], -sp, ror #4
 d84:	65685767 	strbvs	r5, [r8, #-1895]!	; 0x767
 d88:	69536c65 	ldmdbvs	r3, {r0, r2, r5, r6, sl, fp, sp, lr}^
 d8c:	8900657a 	stmdbhi	r0, {r1, r3, r4, r5, r6, r8, sl, sp, lr}
 d90:	4f00003f 	svcmi	0x0000003f
 d94:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
 d98:	54676643 	strbtpl	r6, [r7], #-1603	; 0x643
 d9c:	736b6369 	cmnvc	fp, #-1543503871	; 0xa4000001
 da0:	53726550 	cmnpl	r2, #335544320	; 0x14000000
 da4:	9b006365 	blls	19b40 <DISABLE_IRQ+0x19ac0>
 da8:	4f00003f 	svcmi	0x0000003f
 dac:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
 db0:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 db4:	003fad00 	eorseq	sl, pc, r0, lsl #26
 db8:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 dbc:	6254726d 	subsvs	r7, r4, #-805306362	; 0xd0000006
 dc0:	7a69536c 	bvc	1a55b78 <MEM_SIZE+0x1255b78>
 dc4:	3fbf0065 	svccc	0x00bf0065
 dc8:	534f0000 	movtpl	r0, #61440	; 0xf000
 dcc:	57726d54 	undefined instruction 0x57726d54
 dd0:	6c656568 	cfstr64vs	mvdx6, [r5], #-416	; 0xfffffe60
 dd4:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 dd8:	003fd100 	eorseq	sp, pc, r0, lsl #2
 ddc:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 de0:	6857726d 	ldmdavs	r7, {r0, r2, r3, r5, r6, r9, ip, sp, lr}^
 de4:	546c6565 	strbtpl	r6, [ip], #-1381	; 0x565
 de8:	69536c62 	ldmdbvs	r3, {r1, r5, r6, sl, fp, sp, lr}^
 dec:	e300657a 	movw	r6, #1402	; 0x57a
 df0:	4f00003f 	svcmi	0x0000003f
 df4:	74614453 	strbtvc	r4, [r1], #-1107	; 0x453
 df8:	7a695361 	bvc	1a55b84 <MEM_SIZE+0x1255b84>
 dfc:	00000065 	andeq	r0, r0, r5, rrx
 e00:	001c0000 	andseq	r0, ip, r0
 e04:	00020000 	andeq	r0, r2, r0
 e08:	0000488d 	andeq	r4, r0, sp, lsl #17
 e0c:	00000136 	andeq	r0, r0, r6, lsr r1
 e10:	00000051 	andeq	r0, r0, r1, asr r0
 e14:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
 e18:	7361745f 	cmnvc	r1, #1593835520	; 0x5f000000
 e1c:	0000006b 	andeq	r0, r0, fp, rrx
 e20:	001b0000 	andseq	r0, fp, r0
 e24:	00020000 	andeq	r0, r2, r0
 e28:	000049c3 	andeq	r4, r0, r3, asr #19
 e2c:	000001cc 	andeq	r0, r0, ip, asr #3
 e30:	00000101 	andeq	r0, r0, r1, lsl #2
 e34:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
 e38:	6d65735f 	stclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
 e3c:	00000000 	andeq	r0, r0, r0
 e40:	00001d00 	andeq	r1, r0, r0, lsl #26
 e44:	8f000200 	svchi	0x00000200
 e48:	df00004b 	svcle	0x0000004b
 e4c:	01000001 	tsteq	r0, r1
 e50:	74000001 	strvc	r0, [r0], #-1
 e54:	5f747365 	svcpl	0x00747365
 e58:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0x56d
 e5c:	00000078 	andeq	r0, r0, r8, ror r0
 e60:	001c0000 	andseq	r0, ip, r0
 e64:	00020000 	andeq	r0, r2, r0
 e68:	00004d6e 	andeq	r4, r0, lr, ror #26
 e6c:	000001f9 	strdeq	r0, [r0], -r9
 e70:	0000010c 	andeq	r0, r0, ip, lsl #2
 e74:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
 e78:	6f626d5f 	svcvs	0x00626d5f
 e7c:	00000078 	andeq	r0, r0, r8, ror r0
 e80:	001b0000 	andseq	r0, fp, r0
 e84:	00020000 	andeq	r0, r2, r0
 e88:	00004f67 	andeq	r4, r0, r7, ror #30
 e8c:	0000024c 	andeq	r0, r0, ip, asr #4
 e90:	000001a7 	andeq	r0, r0, r7, lsr #3
 e94:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
 e98:	726d745f 	rsbvc	r7, sp, #1593835520	; 0x5f000000
 e9c:	00000000 	andeq	r0, r0, r0
 ea0:	00001900 	andeq	r1, r0, r0, lsl #18
 ea4:	b3000200 	movwlt	r0, #512	; 0x200
 ea8:	14000051 	strne	r0, [r0], #-81	; 0x51
 eac:	0c000002 	stceq	0, cr0, [r0], {2}
 eb0:	74000001 	strvc	r0, [r0], #-1
 eb4:	5f747365 	svcpl	0x00747365
 eb8:	00000071 	andeq	r0, r0, r1, ror r0
 ebc:	00190000 	andseq	r0, r9, r0
 ec0:	00020000 	andeq	r0, r2, r0
 ec4:	000053c7 	andeq	r5, r0, r7, asr #7
 ec8:	000001e2 	andeq	r0, r0, r2, ror #3
 ecc:	000000eb 	andeq	r0, r0, fp, ror #1
 ed0:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
 ed4:	00006d5f 	andeq	r6, r0, pc, asr sp
 ed8:	c9000000 	stmdbgt	r0, {}
 edc:	02000000 	andeq	r0, r0, #0
 ee0:	0055a900 	subseq	sl, r5, r0, lsl #18
 ee4:	0004c800 	andeq	ip, r4, r0, lsl #16
 ee8:	00035800 	andeq	r5, r3, r0, lsl #16
 eec:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 ef0:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
 ef4:	6e496b74 	vmovvs.8	d9[3], r6
 ef8:	e0007469 	and	r7, r0, r9, ror #8
 efc:	4f000003 	svcmi	0x00000003
 f00:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 f04:	6c65446b 	cfstrdvs	mvd4, [r5], #-428	; 0xfffffe54
 f08:	6b6f6f48 	blvs	1bdcc30 <MEM_SIZE+0x13dcc30>
 f0c:	00040b00 	andeq	r0, r4, r0, lsl #22
 f10:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
 f14:	496b7361 	stmdbmi	fp!, {r0, r5, r6, r8, r9, ip, sp, lr}^
 f18:	48656c64 	stmdami	r5!, {r2, r5, r6, sl, fp, sp, lr}^
 f1c:	006b6f6f 	rsbeq	r6, fp, pc, ror #30
 f20:	0000041e 	andeq	r0, r0, lr, lsl r4
 f24:	6954534f 	ldmdbvs	r4, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
 f28:	6954656d 	ldmdbvs	r4, {r0, r2, r3, r5, r6, r8, sl, sp, lr}^
 f2c:	6f486b63 	svcvs	0x00486b63
 f30:	31006b6f 	tstcc	r0, pc, ror #22
 f34:	4f000004 	svcmi	0x00000004
 f38:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
 f3c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
 f40:	6b6f6f48 	blvs	1bdcc68 <MEM_SIZE+0x13dcc68>
 f44:	00045600 	andeq	r5, r4, r0, lsl #12
 f48:	49534f00 	ldmdbmi	r3, {r8, r9, sl, fp, lr}^
 f4c:	4874696e 	ldmdami	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
 f50:	426b6f6f 	rsbmi	r6, fp, #444	; 0x1bc
 f54:	6e696765 	cdpvs	7, 6, cr6, cr9, cr5, {3}
 f58:	00046900 	andeq	r6, r4, r0, lsl #18
 f5c:	49534f00 	ldmdbmi	r3, {r8, r9, sl, fp, lr}^
 f60:	4874696e 	ldmdami	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
 f64:	456b6f6f 	strbmi	r6, [fp, #-3951]!	; 0xf6f
 f68:	7c00646e 	cfstrsvc	mvf6, [r0], {110}	; 0x6e
 f6c:	4f000004 	svcmi	0x00000004
 f70:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 f74:	6174536b 	cmnvs	r4, fp, ror #6
 f78:	6f6f4874 	svcvs	0x006f4874
 f7c:	048f006b 	streq	r0, [pc], #107	; f84 <DISABLE_IRQ+0xf04>
 f80:	534f0000 	movtpl	r0, #61440	; 0xf000
 f84:	6b736154 	blvs	1cd94dc <MEM_SIZE+0x14d94dc>
 f88:	6f487753 	svcvs	0x00487753
 f8c:	a2006b6f 	andge	r6, r0, #113664	; 0x1bc00
 f90:	4f000004 	svcmi	0x00000004
 f94:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
 f98:	6572436b 	ldrbvs	r4, [r2, #-875]!	; 0x36b
 f9c:	48657461 	stmdami	r5!, {r0, r5, r6, sl, ip, sp, lr}^
 fa0:	006b6f6f 	rsbeq	r6, fp, pc, ror #30
 fa4:	00000000 	andeq	r0, r0, r0

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	; 0xfffffe60
       4:	726f776f 	rsbvc	r7, pc, #29097984	; 0x1bc0000
       8:	6200646c 	andvs	r6, r0, #1811939328	; 0x6c000000
       c:	2e746f6f 	cdpcs	15, 7, cr6, cr4, cr15, {3}
      10:	6e690063 	cdpvs	0, 6, cr0, cr9, cr3, {3}
      14:	665f7469 	ldrbvs	r7, [pc], -r9, ror #8
      18:	00636e75 	rsbeq	r6, r3, r5, ror lr
      1c:	74616c70 	strbtvc	r6, [r1], #-3184	; 0xc70
      20:	6f6f625f 	svcvs	0x006f625f
      24:	682f0074 	stmdavs	pc!, {r2, r4, r5, r6}
      28:	2f656d6f 	svccs	0x00656d6f
      2c:	6c616572 	cfstr64vs	mvdx6, [r1], #-456	; 0xfffffe38
      30:	2f6c6973 	svccs	0x006c6973
      34:	6b736544 	blvs	1cd954c <MEM_SIZE+0x14d954c>
      38:	2f706f74 	svccs	0x00706f74
      3c:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xf63
      40:	7469672f 	strbtvc	r6, [r9], #-1839	; 0x72f
      44:	2f627568 	svccs	0x00627568
      48:	736f6375 	cmnvc	pc, #-738197503	; 0xd4000001
      4c:	69740032 	ldmdbvs	r4!, {r1, r4, r5}^
      50:	5f72656d 	svcpl	0x0072656d
      54:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
      58:	73657400 	cmnvc	r5, #0
      5c:	6d6d5f74 	stclvs	15, cr5, [sp, #-464]!	; 0xfffffe30
      60:	6e750075 	mrcvs	0, 3, r0, cr5, cr5, {3}
      64:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
      68:	63206465 	teqvs	r0, #1694498816	; 0x65000000
      6c:	00726168 	rsbseq	r6, r2, r8, ror #2
      70:	726f6873 	rsbvc	r6, pc, #7536640	; 0x730000
      74:	6e752074 	mrcvs	0, 3, r2, cr5, cr4, {3}
      78:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
      7c:	69206465 	stmdbvs	r0!, {r0, r2, r5, r6, sl, sp, lr}
      80:	7400746e 	strvc	r7, [r0], #-1134	; 0x46e
      84:	5f747365 	svcpl	0x00747365
      88:	74697773 	strbtvc	r7, [r9], #-1907	; 0x773
      8c:	47006863 	strmi	r6, [r0, -r3, ror #16]
      90:	4320554e 	teqmi	r0, #327155712	; 0x13800000
      94:	342e3420 	strtcc	r3, [lr], #-1056	; 0x420
      98:	7200332e 	andvc	r3, r0, #-1207959552	; 0xb8000000
      9c:	65736961 	ldrbvs	r6, [r3, #-2401]!	; 0x961
      a0:	64616200 	strbtvs	r6, [r1], #-512	; 0x200
      a4:	73007264 	movwvc	r7, #612	; 0x264
      a8:	74726174 	ldrbtvc	r6, [r2], #-372	; 0x174
      ac:	756d6d5f 	strbvc	r6, [sp, #-3423]!	; 0xd5f
      b0:	696e6900 	stmdbvs	lr!, {r8, fp, sp, lr}^
      b4:	79735f74 	ldmdbvc	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
      b8:	6d6d5f73 	stclvs	15, cr5, [sp, #-460]!	; 0xfffffe34
      bc:	6d6d0075 	stclvs	0, cr0, [sp, #-468]!	; 0xfffffe2c
      c0:	00632e75 	rsbeq	r2, r3, r5, ror lr
      c4:	5f6e6567 	svcpl	0x006e6567
      c8:	705f316c 	subsvc	r3, pc, ip, ror #2
      cc:	615f6574 	cmpvs	pc, r4, ror r5
      d0:	00726464 	rsbseq	r6, r2, r4, ror #8
      d4:	5f6e6567 	svcpl	0x006e6567
      d8:	705f316c 	subsvc	r3, pc, ip, ror #2
      dc:	76006574 	undefined instruction 0x76006574
      e0:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
      e4:	64617000 	strbtvs	r7, [r1]
      e8:	70007264 	andvc	r7, r0, r4, ror #4
      ec:	746e6972 	strbtvc	r6, [lr], #-2418	; 0x972
      f0:	6600632e 	strvs	r6, [r0], -lr, lsr #6
      f4:	616d726f 	cmnvs	sp, pc, ror #4
      f8:	65645f74 	strbvs	r5, [r4, #-3956]!	; 0xf74
      fc:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xf63
     100:	73657400 	cmnvc	r5, #0
     104:	72705f74 	rsbsvc	r5, r0, #464	; 0x1d0
     108:	6b746e69 	blvs	1d1bab4 <MEM_SIZE+0x151bab4>
     10c:	5f534f00 	svcpl	0x00534f00
     110:	5f555043 	svcpl	0x00555043
     114:	6d005253 	sfmvs	f5, 4, [r0, #-332]	; (stcvs 2, cr5, [r0, #-332])	; 0xfffffeb4
     118:	70636d65 	rsbvc	r6, r3, r5, ror #26
     11c:	61760079 	cmnvs	r6, r9, ror r0
     120:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
     124:	5f5f0074 	svcpl	0x005f0074
     128:	00736572 	rsbseq	r6, r3, r2, ror r5
     12c:	626d756e 	rsbvs	r7, sp, #461373440	; 0x1b800000
     130:	00737265 	rsbseq	r7, r3, r5, ror #4
     134:	75705f5f 	ldrbvc	r5, [r0, #-3935]!	; 0xf5f
     138:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     13c:	72007261 	andvc	r7, r0, #268435462	; 0x10000006
     140:	00646165 	rsbeq	r6, r4, r5, ror #2
     144:	63657073 	cmnvs	r5, #115	; 0x73
     148:	67696400 	strbvs	r6, [r9, -r0, lsl #8]!
     14c:	00737469 	rsbseq	r7, r3, r9, ror #8
     150:	5f646c6f 	svcpl	0x00646c6f
     154:	00746d66 	rsbseq	r6, r4, r6, ror #26
     158:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
     15c:	72610073 	rsbvc	r0, r1, #115	; 0x73
     160:	73007367 	movwvc	r7, #871	; 0x367
     164:	74726174 	ldrbtvc	r6, [r2], #-372	; 0x174
     168:	6e737600 	cdpvs	6, 7, cr7, cr3, cr0, {0}
     16c:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     170:	70006674 	andvc	r6, r0, r4, ror r6
     174:	746e6972 	strbtvc	r6, [lr], #-2418	; 0x972
     178:	6675625f 	undefined instruction 0x6675625f
     17c:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
     180:	6f63006e 	svcvs	0x0063006e
     184:	00746e75 	rsbseq	r6, r4, r5, ror lr
     188:	79706f63 	ldmdbvc	r0!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
     18c:	75706300 	ldrbvc	r6, [r0, #-768]!	; 0x300
     190:	0072735f 	rsbseq	r7, r2, pc, asr r3
     194:	626d756e 	rsbvs	r7, sp, #461373440	; 0x1b800000
     198:	62007265 	andvs	r7, r0, #1342177286	; 0x50000006
     19c:	00657361 	rsbeq	r7, r5, r1, ror #6
     1a0:	62616e65 	rsbvs	r6, r1, #1616	; 0x650
     1a4:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^
     1a8:	69007172 	stmdbvs	r0, {r1, r4, r5, r6, r8, ip, sp, lr}
     1ac:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     1b0:	74707572 	ldrbtvc	r7, [r0], #-1394	; 0x572
     1b4:	7500632e 	strvc	r6, [r0, #-814]	; 0x32e
     1b8:	6b73616d 	blvs	1cd8774 <MEM_SIZE+0x14d8774>
     1bc:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
     1c0:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
     1c4:	00746573 	rsbseq	r6, r4, r3, ror r5
     1c8:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
     1cc:	695f6e6f 	ldmdbvs	pc, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
     1d0:	685f7172 	ldmdavs	pc, {r1, r4, r5, r6, r8, ip, sp, lr}^
     1d4:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
     1d8:	64007265 	strvs	r7, [r0], #-613	; 0x265
     1dc:	62617369 	rsbvs	r7, r1, #-1543503871	; 0xa4000001
     1e0:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^
     1e4:	70007172 	andvc	r7, r0, r2, ror r1
     1e8:	74636e66 	strbtvc	r6, [r3], #-3686	; 0xe66
     1ec:	5f736f00 	svcpl	0x00736f00
     1f0:	00626374 	rsbeq	r6, r2, r4, ror r3
     1f4:	6154534f 	cmpvs	r4, pc, asr #6
     1f8:	72436b73 	subvc	r6, r3, #117760	; 0x1cc00
     1fc:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
     200:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     204:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
     208:	6f6f4877 	svcvs	0x006f4877
     20c:	006e456b 	rsbeq	r4, lr, fp, ror #10
     210:	646f6e70 	strbtvs	r6, [pc], #3696	; 218 <DISABLE_IRQ+0x198>
     214:	72705f65 	rsbsvc	r5, r0, #404	; 0x194
     218:	4f007665 	svcmi	0x00007665
     21c:	54535f53 	ldrbpl	r5, [r3], #-3923	; 0xf53
     220:	41445f4b 	cmpmi	r4, fp, asr #30
     224:	4f004154 	svcmi	0x00004154
     228:	69725053 	ldmdbvs	r2!, {r0, r1, r4, r6, ip, lr}^
     22c:	6769486f 	strbvs	r4, [r9, -pc, ror #16]!
     230:	79645268 	stmdbvc	r4!, {r3, r5, r6, r9, ip, lr}^
     234:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     238:	4e67616c 	powmisz	f6, f7, #4.0
     23c:	00656d61 	rsbeq	r6, r5, r1, ror #26
     240:	754d534f 	strbvc	r5, [sp, #-847]	; 0x34f
     244:	44786574 	ldrbtmi	r6, [r8], #-1396	; 0x574
     248:	49006c65 	stmdbmi	r0, {r0, r2, r5, r6, sl, fp, sp, lr}
     24c:	3631544e 	ldrtcc	r5, [r1], -lr, asr #8
     250:	534f0055 	movtpl	r0, #61525	; 0xf055
     254:	746e4551 	strbtvc	r4, [lr], #-1361	; 0x551
     258:	73656972 	cmnvc	r5, #1867776	; 0x1c8000
     25c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     260:	506b7361 	rsbpl	r7, fp, r1, ror #6
     264:	69666f72 	stmdbvs	r6!, {r1, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
     268:	6e45656c 	cdpvs	5, 4, cr6, cr5, cr12, {3}
     26c:	45534f00 	ldrbmi	r4, [r3, #-3840]	; 0xf00
     270:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     274:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
     278:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     27c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     280:	65504243 	ldrbvs	r4, [r0, #-579]	; 0x243
     284:	4f54646e 	svcmi	0x0054646e
     288:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     28c:	6553726d 	ldrbvs	r7, [r3, #-621]	; 0x26d
     290:	6769536d 	strbvs	r5, [r9, -sp, ror #6]!
     294:	006c616e 	rsbeq	r6, ip, lr, ror #2
     298:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
     29c:	6575516d 	ldrbvs	r5, [r5, #-365]!	; 0x16d
     2a0:	70007972 	andvc	r7, r0, r2, ror r9
     2a4:	6b74735f 	blvs	1d1d028 <MEM_SIZE+0x151d028>
     2a8:	7461645f 	strbtvc	r6, [r1], #-1119	; 0x45f
     2ac:	534f0061 	movtpl	r0, #61537	; 0xf061
     2b0:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     2b4:	65646f4e 	strbvs	r6, [r4, #-3918]!	; 0xf4e
     2b8:	76657250 	undefined instruction 0x76657250
     2bc:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     2c0:	44656d69 	strbtmi	r6, [r5], #-3433	; 0xd69
     2c4:	4f00796c 	svcmi	0x0000796c
     2c8:	6d655353 	stclvs	3, cr5, [r5, #-332]!	; 0xfffffeb4
     2cc:	00746553 	rsbseq	r6, r4, r3, asr r5
     2d0:	666c6573 	undefined instruction 0x666c6573
     2d4:	53534f00 	cmppl	r3, #0
     2d8:	64656863 	strbtvs	r6, [r5], #-2147	; 0x863
     2dc:	6f6c6e55 	svcvs	0x006c6e55
     2e0:	4f006b63 	svcmi	0x00006b63
     2e4:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
     2e8:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     2ec:	65646f4e 	strbvs	r6, [r4, #-3918]!	; 0xf4e
     2f0:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     2f4:	5067616c 	rsbpl	r6, r7, ip, ror #2
     2f8:	0074736f 	rsbseq	r7, r4, pc, ror #6
     2fc:	646f6e70 	strbtvs	r6, [pc], #3696	; 304 <DISABLE_IRQ+0x284>
     300:	534f0065 	movtpl	r0, #61541	; 0xf065
     304:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     308:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
     30c:	00746553 	rsbseq	r6, r4, r3, asr r5
     310:	7453534f 	ldrbvc	r5, [r3], #-847	; 0x34f
     314:	6469576b 	strbtvs	r5, [r9], #-1899	; 0x76b
     318:	4f006874 	svcmi	0x00006874
     31c:	746e4953 	strbtvc	r4, [lr], #-2387	; 0x953
     320:	74697845 	strbtvc	r7, [r9], #-2117	; 0x845
     324:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     328:	4367616c 	cmnmi	r7, #27
     32c:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
     330:	534f0065 	movtpl	r0, #61541	; 0xf065
     334:	53424354 	movtpl	r4, #9044	; 0x2354
     338:	74506b74 	ldrbvc	r6, [r0], #-2932	; 0xb74
     33c:	534f0072 	movtpl	r0, #61554	; 0xf072
     340:	6e655051 	mcrvs	0, 3, r5, cr5, cr1, {2}
     344:	534f0064 	movtpl	r0, #61540	; 0xf064
     348:	4556455f 	ldrbmi	r4, [r6, #-1375]	; 0x55f
     34c:	4f00544e 	svcmi	0x0000544e
     350:	4d545f53 	ldclmi	15, cr5, [r4, #-332]	; 0xfffffeb4
     354:	41435f52 	cmpmi	r3, r2, asr pc
     358:	41424c4c 	cmpmi	r2, ip, asr #24
     35c:	70004b43 	andvc	r4, r0, r3, asr #22
     360:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
     364:	534f0074 	movtpl	r0, #61556	; 0xf074
     368:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     36c:	65646f4e 	strbvs	r6, [r4, #-3918]!	; 0xf4e
     370:	74696157 	strbtvc	r6, [r9], #-343	; 0x157
     374:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
     378:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     37c:	4d6b7361 	stclmi	3, cr7, [fp, #-388]!	; 0xfffffe7c
     380:	4f007861 	svcmi	0x00007861
     384:	76455f53 	undefined instruction 0x76455f53
     388:	54746e65 	ldrbtpl	r6, [r4], #-3685	; 0xe65
     38c:	534f004f 	movtpl	r0, #61519	; 0xf04f
     390:	53787443 	cmnpl	r8, #1124073472	; 0x43000000
     394:	72744377 	rsbsvc	r4, r4, #-603979775	; 0xdc000001
     398:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     39c:	6550726d 	ldrbvs	r7, [r0, #-621]	; 0x26d
     3a0:	646f6972 	strbtvs	r6, [pc], #2418	; 3a8 <DISABLE_IRQ+0x328>
     3a4:	616e7000 	cmnvs	lr, r0
     3a8:	4f00656d 	svcmi	0x0000656d
     3ac:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
     3b0:	426b7453 	rsbmi	r7, fp, #1392508928	; 0x53000000
     3b4:	00657361 	rsbeq	r7, r5, r1, ror #6
     3b8:	6154534f 	cmpvs	r4, pc, asr #6
     3bc:	72436b73 	subvc	r6, r3, #117760	; 0x1cc00
     3c0:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
     3c4:	4f006e45 	svcmi	0x00006e45
     3c8:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
     3cc:	636f4c5f 	cmnvs	pc, #24320	; 0x5f00
     3d0:	534f006b 	movtpl	r0, #61547	; 0xf06b
     3d4:	43424354 	movtmi	r4, #9044	; 0x2354
     3d8:	656c6379 	strbvs	r6, [ip, #-889]!	; 0x379
     3dc:	746f5473 	strbtvc	r5, [pc], #1139	; 3e4 <DISABLE_IRQ+0x364>
     3e0:	49534f00 	ldmdbmi	r3, {r8, r9, sl, fp, lr}^
     3e4:	6e45746e 	cdpvs	4, 4, cr7, cr5, cr14, {3}
     3e8:	00726574 	rsbseq	r6, r2, r4, ror r5
     3ec:	6c46534f 	mcrrvs	3, 4, r5, r6, cr15
     3f0:	6f4e6761 	svcvs	0x004e6761
     3f4:	6c466564 	cfstr64vs	mvdx6, [r6], {100}	; 0x64
     3f8:	72476761 	subvc	r6, r7, #25427968	; 0x1840000
     3fc:	534f0070 	movtpl	r0, #61552	; 0xf070
     400:	6b736154 	blvs	1cd8958 <MEM_SIZE+0x14d8958>
     404:	456c6544 	strbmi	r6, [ip, #-1348]!	; 0x544
     408:	534f006e 	movtpl	r0, #61550	; 0xf06e
     40c:	50424354 	subpl	r4, r2, r4, asr r3
     410:	546f6972 	strbtpl	r6, [pc], #2418	; 418 <DISABLE_IRQ+0x398>
     414:	614d6c62 	cmpvs	sp, r2, ror #24
     418:	6f680078 	svcvs	0x00680078
     41c:	00737275 	rsbseq	r7, r3, r5, ror r2
     420:	6553534f 	ldrbvs	r5, [r3, #-847]	; 0x34f
     424:	006e456d 	rsbeq	r4, lr, sp, ror #10
     428:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     42c:	78654e72 	stmdavc	r5!, {r1, r4, r5, r6, r9, sl, fp, lr}^
     430:	534f0074 	movtpl	r0, #61556	; 0xf074
     434:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     438:	4f4f4200 	svcmi	0x004f4200
     43c:	4e41454c 	cdpmi	5, 4, cr4, cr1, cr12, {2}
     440:	51534f00 	cmppl	r3, r0, lsl #30
     444:	0078614d 	rsbseq	r6, r8, sp, asr #2
     448:	7645534f 	strbvc	r5, [r5], -pc, asr #6
     44c:	47746e65 	ldrbmi	r6, [r4, -r5, ror #28]!
     450:	70007072 	andvc	r7, r0, r2, ror r0
     454:	7361745f 	cmnvc	r1, #1593835520	; 0x5f000000
     458:	61645f6b 	cmnvs	r4, fp, ror #30
     45c:	4f006174 	svcmi	0x00006174
     460:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
     464:	7365526b 	cmnvc	r5, #-1342177274	; 0xb0000006
     468:	00656d75 	rsbeq	r6, r5, r5, ror sp
     46c:	455f534f 	ldrbmi	r5, [pc, #-847]	; 125 <DISABLE_IRQ+0xa5>
     470:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     474:	6b736154 	blvs	1cd89cc <MEM_SIZE+0x14d89cc>
     478:	74696157 	strbtvc	r6, [r9], #-343	; 0x157
     47c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     480:	555f726d 	ldrbpl	r7, [pc, #-621]	; 21b <DISABLE_IRQ+0x19b>
     484:	636f6c6e 	cmnvs	pc, #28160	; 0x6e00
     488:	534f006b 	movtpl	r0, #61547	; 0xf06b
     48c:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     490:	65646f4e 	strbvs	r6, [r4, #-3918]!	; 0xf4e
     494:	00424354 	subeq	r4, r2, r4, asr r3
     498:	6d656d70 	stclvs	13, cr6, [r5, #-448]!	; 0xfffffe40
     49c:	4d534f00 	ldclmi	15, cr4, [r3]
     4a0:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
     4a4:	65636341 	strbvs	r6, [r3, #-833]!	; 0x341
     4a8:	4f007470 	svcmi	0x00007470
     4ac:	6d695453 	cfstrdvs	mvd5, [r9, #-332]!	; 0xfffffeb4
     4b0:	74655365 	strbtvc	r5, [r5], #-869	; 0x365
     4b4:	53534f00 	cmppl	r3, #0
     4b8:	6f506d65 	svcvs	0x00506d65
     4bc:	4f007473 	svcmi	0x00007473
     4c0:	79645253 	stmdbvc	r4!, {r0, r1, r4, r6, r9, ip, lr}^
     4c4:	00707247 	rsbseq	r7, r0, r7, asr #4
     4c8:	6d657470 	cfstrdvs	mvd7, [r5, #-448]!	; 0xfffffe40
     4cc:	534f0070 	movtpl	r0, #61552	; 0xf070
     4d0:	65724651 	ldrbvs	r4, [r2, #-1617]!	; 0x651
     4d4:	73694c65 	cmnvc	r9, #25856	; 0x6500
     4d8:	534f0074 	movtpl	r0, #61556	; 0xf074
     4dc:	57726d54 	undefined instruction 0x57726d54
     4e0:	6c656568 	cfstr64vs	mvdx6, [r5], #-416	; 0xfffffe60
     4e4:	536c6254 	cmnpl	ip, #1073741829	; 0x40000005
     4e8:	00657a69 	rsbeq	r7, r5, r9, ror #20
     4ec:	6154534f 	cmpvs	r4, pc, asr #6
     4f0:	74536b73 	ldrbvc	r6, [r3], #-2931	; 0xb73
     4f4:	74537461 	ldrbvc	r7, [r3], #-1121	; 0x461
     4f8:	534f006b 	movtpl	r0, #61547	; 0xf06b
     4fc:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
     500:	79645274 	stmdbvc	r4!, {r2, r4, r5, r6, r9, ip, lr}^
     504:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
     508:	45534f00 	ldrbmi	r4, [r3, #-3840]	; 0xf00
     50c:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     510:	65657246 	strbvs	r7, [r5, #-582]!	; 0x246
     514:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
     518:	51534f00 	cmppl	r3, r0, lsl #30
     51c:	74736f50 	ldrbtvc	r6, [r3], #-3920	; 0xf50
     520:	6e6f7246 	cdpvs	2, 6, cr7, cr15, cr6, {2}
     524:	534f0074 	movtpl	r0, #61556	; 0xf074
     528:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
     52c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     530:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     534:	6946726d 	stmdbvs	r6, {r0, r2, r3, r5, r6, r9, ip, sp, lr}^
     538:	00747372 	rsbseq	r7, r4, r2, ror r3
     53c:	5351534f 	cmppl	r1, #1006632961	; 0x3c000001
     540:	00657a69 	rsbeq	r7, r5, r9, ror #20
     544:	6544534f 	strbvs	r5, [r4, #-847]	; 0x34f
     548:	49677562 	stmdbmi	r7!, {r1, r5, r6, r8, sl, ip, sp, lr}^
     54c:	0074696e 	rsbseq	r6, r4, lr, ror #18
     550:	7645534f 	strbvc	r5, [r5], -pc, asr #6
     554:	54746e65 	ldrbtpl	r6, [r4], #-3685	; 0xe65
     558:	69536c62 	ldmdbvs	r3, {r1, r5, r6, sl, fp, sp, lr}^
     55c:	7000657a 	andvc	r6, r0, sl, ror r5
     560:	6b6e696c 	blvs	1b9ab18 <MEM_SIZE+0x139ab18>
     564:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     568:	5467616c 	strbtpl	r6, [r7], #-364	; 0x16c
     56c:	00657079 	rsbeq	r7, r5, r9, ror r0
     570:	624d534f 	subvs	r5, sp, #1006632961	; 0x3c000001
     574:	6e45786f 	cdpvs	8, 4, cr7, cr5, cr15, {3}
     578:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     57c:	4e67616c 	powmisz	f6, f7, #4.0
     580:	53656d61 	cmnpl	r5, #6208	; 0x1840
     584:	00657a69 	rsbeq	r7, r5, r9, ror #20
     588:	554e534f 	strbpl	r5, [lr, #-847]	; 0x34f
     58c:	00646573 	rsbeq	r6, r4, r3, ror r5
     590:	6c46534f 	mcrrvs	3, 4, r5, r6, cr15
     594:	69576761 	ldmdbvs	r7, {r0, r5, r6, r8, r9, sl, sp, lr}^
     598:	00687464 	rsbeq	r7, r8, r4, ror #8
     59c:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     5a0:	67664372 	undefined instruction 0x67664372
     5a4:	65656857 	strbvs	r6, [r5, #-2135]!	; 0x857
     5a8:	7a69536c 	bvc	1a55360 <MEM_SIZE+0x1255360>
     5ac:	534f0065 	movtpl	r0, #61541	; 0xf065
     5b0:	57726d54 	undefined instruction 0x57726d54
     5b4:	6c656568 	cfstr64vs	mvdx6, [r5], #-416	; 0xfffffe60
     5b8:	006c6254 	rsbeq	r6, ip, r4, asr r2
     5bc:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     5c0:	6d614e72 	stclvs	14, cr4, [r1, #-456]!	; 0xfffffe38
     5c4:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
     5c8:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     5cc:	4d67616c 	stfmie	f6, [r7, #-432]!	; 0xfffffe50
     5d0:	4f007861 	svcmi	0x00007861
     5d4:	64644153 	strbtvs	r4, [r4], #-339	; 0x153
     5d8:	534f0072 	movtpl	r0, #61554	; 0xf072
     5dc:	00746e43 	rsbseq	r6, r4, r3, asr #28
     5e0:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     5e4:	6f745372 	svcvs	0x00745372
     5e8:	534f0070 	movtpl	r0, #61552	; 0xf070
     5ec:	6b736154 	blvs	1cd8b44 <MEM_SIZE+0x14d8b44>
     5f0:	00727443 	rsbseq	r7, r2, r3, asr #8
     5f4:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     5f8:	00644942 	rsbeq	r4, r4, r2, asr #18
     5fc:	736e6f63 	cmnvc	lr, #396	; 0x18c
     600:	00656d75 	rsbeq	r6, r5, r5, ror sp
     604:	6154534f 	cmpvs	r4, pc, asr #6
     608:	72436b73 	subvc	r6, r3, #117760	; 0x1cc00
     60c:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
     610:	45747845 	ldrbmi	r7, [r4, #-2117]!	; 0x845
     614:	534f006e 	movtpl	r0, #61550	; 0xf06e
     618:	74754f51 	ldrbtvc	r4, [r5], #-3921	; 0xf51
     61c:	78657000 	stmdavc	r5!, {ip, sp, lr}^
     620:	534f0074 	movtpl	r0, #61556	; 0xf074
     624:	69646e45 	stmdbvs	r4!, {r0, r2, r6, r9, sl, fp, sp, lr}^
     628:	656e6e61 	strbvs	r6, [lr, #-3681]!	; 0xe61
     62c:	65547373 	ldrbvs	r7, [r4, #-883]	; 0x373
     630:	4f007473 	svcmi	0x00007473
     634:	65764553 	ldrbvs	r4, [r6, #-1363]!	; 0x553
     638:	6254746e 	subsvs	r7, r4, #1845493760	; 0x6e000000
     63c:	6572006c 	ldrbvs	r0, [r2, #-108]!	; 0x6c
     640:	746c7573 	strbtvc	r7, [ip], #-1395	; 0x573
     644:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     648:	6e45726d 	cdpvs	2, 4, cr7, cr5, cr13, {3}
     64c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     650:	6953726d 	ldmdbvs	r3, {r0, r2, r3, r5, r6, r9, ip, sp, lr}^
     654:	6c616e67 	stclvs	14, cr6, [r1], #-412	; 0xfffffe64
     658:	51534f00 	cmppl	r3, r0, lsl #30
     65c:	61657243 	cmnvs	r5, r3, asr #4
     660:	70006574 	andvc	r6, r0, r4, ror r5
     664:	006b6c62 	rsbeq	r6, fp, r2, ror #24
     668:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     66c:	796c4442 	stmdbvc	ip!, {r1, r6, sl, lr}^
     670:	5f534f00 	svcpl	0x00534f00
     674:	6d6d7544 	cfstr64vs	mvdx7, [sp, #-272]!	; 0xfffffef0
     678:	534f0079 	movtpl	r0, #61561	; 0xf079
     67c:	4e6d654d 	cdpmi	5, 6, cr6, cr13, cr13, {2}
     680:	65657246 	strbvs	r7, [r5, #-582]!	; 0x246
     684:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     688:	7246726d 	subvc	r7, r6, #-805306362	; 0xd0000006
     68c:	4f006565 	svcmi	0x00006565
     690:	4d6e5553 	cfstr64mi	mvdx5, [lr, #-332]!	; 0xfffffeb4
     694:	62547061 	subsvs	r7, r4, #97	; 0x61
     698:	534f006c 	movtpl	r0, #61548	; 0xf06c
     69c:	6574754d 	ldrbvs	r7, [r4, #-1357]!	; 0x54d
     6a0:	65724378 	ldrbvs	r4, [r2, #-888]!	; 0x378
     6a4:	00657461 	rsbeq	r7, r5, r1, ror #8
     6a8:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     6ac:	67734d42 	ldrbvs	r4, [r3, -r2, asr #26]!
     6b0:	77656e00 	strbvc	r6, [r5, -r0, lsl #28]!
     6b4:	6f697270 	svcvs	0x00697270
     6b8:	5f534f00 	svcpl	0x00534f00
     6bc:	43727453 	cmnmi	r2, #1392508928	; 0x53000000
     6c0:	0079706f 	rsbseq	r7, r9, pc, rrx
     6c4:	6556534f 	ldrbvs	r5, [r6, #-847]	; 0x34f
     6c8:	6f697372 	svcvs	0x00697372
     6cc:	72624e6e 	rsbvc	r4, r2, #1760	; 0x6e0
     6d0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     6d4:	4e6b7361 	cdpmi	3, 6, cr7, cr11, cr1, {3}
     6d8:	47656d61 	strbmi	r6, [r5, -r1, ror #26]!
     6dc:	4f007465 	svcmi	0x00007465
     6e0:	6c644953 	stclvs	9, cr4, [r4], #-332	; 0xfffffeb4
     6e4:	72744365 	rsbsvc	r4, r4, #-1811939327	; 0x94000001
     6e8:	006e7552 	rsbeq	r7, lr, r2, asr r5
     6ec:	6b6c626e 	blvs	1b190ac <MEM_SIZE+0x13190ac>
     6f0:	534f0073 	movtpl	r0, #61555	; 0xf073
     6f4:	53424354 	movtpl	r4, #9044	; 0x2354
     6f8:	73556b74 	cmpvc	r5, #118784	; 0x1d000
     6fc:	4f006465 	svcmi	0x00006465
     700:	65764553 	ldrbvs	r4, [r6, #-1363]!	; 0x553
     704:	6e43746e 	cdpvs	4, 4, cr7, cr3, cr14, {3}
     708:	534f0074 	movtpl	r0, #61556	; 0xf074
     70c:	54726d54 	ldrbtpl	r6, [r2], #-3412	; 0xd54
     710:	00656d69 	rsbeq	r6, r5, r9, ror #26
     714:	6c627470 	cfstrdvs	mvd7, [r2], #-448	; 0xfffffe40
     718:	4d534f00 	ldclmi	15, cr4, [r3]
     71c:	50786f62 	rsbspl	r6, r8, r2, ror #30
     720:	00646e65 	rsbeq	r6, r4, r5, ror #28
     724:	6154534f 	cmpvs	r4, pc, asr #6
     728:	65446b73 	strbvs	r6, [r4, #-2931]	; 0xb73
     72c:	7165526c 	cmnvc	r5, ip, ror #4
     730:	715f7000 	cmpvc	pc, r0
     734:	7461645f 	strbtvc	r6, [r1], #-1119	; 0x45f
     738:	534f0061 	movtpl	r0, #61537	; 0xf061
     73c:	55555043 	ldrbpl	r5, [r5, #-67]	; 0x43
     740:	65676173 	strbvs	r6, [r7, #-371]!	; 0x173
     744:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     748:	6c44726d 	sfmvs	f7, 2, [r4], {109}	; (stclvs 2, cr7, [r4], {109})	; 0x6d
     74c:	74730079 	ldrbtvc	r0, [r3], #-121	; 0x79
     750:	4f007461 	svcmi	0x00007461
     754:	69725053 	ldmdbvs	r2!, {r0, r1, r4, r6, ip, lr}^
     758:	7275436f 	rsbsvc	r4, r5, #-1140850687	; 0xbc000001
     75c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     760:	536b6369 	cmnpl	fp, #-1543503871	; 0xa4000001
     764:	53706574 	cmnpl	r0, #486539264	; 0x1d000000
     768:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
     76c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     770:	7453726d 	ldrbvc	r7, [r3], #-621	; 0x26d
     774:	00657461 	rsbeq	r7, r5, r1, ror #8
     778:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
     77c:	78614d6d 	stmdavc	r1!, {r0, r2, r3, r5, r6, r8, sl, fp, lr}^
     780:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     784:	7355726d 	cmpvc	r5, #-805306362	; 0xd0000006
     788:	70006465 	andvc	r6, r0, r5, ror #8
     78c:	74756d5f 	ldrbtvc	r6, [r5], #-3423	; 0xd5f
     790:	645f7865 	ldrbvs	r7, [pc], #2149	; 798 <DISABLE_IRQ+0x718>
     794:	00617461 	rsbeq	r7, r1, r1, ror #8
     798:	754d534f 	strbvc	r5, [sp, #-847]	; 0x34f
     79c:	50786574 	rsbspl	r6, r8, r4, ror r5
     7a0:	0074736f 	rsbseq	r7, r4, pc, ror #6
     7a4:	6c46534f 	mcrrvs	3, 4, r5, r6, cr15
     7a8:	61576761 	cmpvs	r7, r1, ror #14
     7ac:	694c7469 	stmdbvs	ip, {r0, r3, r5, r6, sl, ip, sp, lr}^
     7b0:	4f007473 	svcmi	0x00007473
     7b4:	5f515f53 	svcpl	0x00515f53
     7b8:	41544144 	cmpmi	r4, r4, asr #2
     7bc:	6b6c6200 	blvs	1b18fc4 <MEM_SIZE+0x1318fc4>
     7c0:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0x973
     7c4:	5f534f00 	svcpl	0x00534f00
     7c8:	65686353 	strbvs	r6, [r8, #-851]!	; 0x353
     7cc:	534f0064 	movtpl	r0, #61540	; 0xf064
     7d0:	4e6d654d 	cdpmi	5, 6, cr6, cr13, cr13, {2}
     7d4:	53656d61 	cmnpl	r5, #6208	; 0x1840
     7d8:	00657a69 	rsbeq	r7, r5, r9, ror #20
     7dc:	6c46534f 	mcrrvs	3, 4, r5, r6, cr15
     7e0:	63416761 	movtvs	r6, #5985	; 0x1761
     7e4:	74706563 	ldrbtvc	r6, [r0], #-1379	; 0x563
     7e8:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     7ec:	79434243 	stmdbvc	r3, {r0, r1, r6, r9, lr}^
     7f0:	73656c63 	cmnvc	r5, #25344	; 0x6300
     7f4:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
     7f8:	534f0074 	movtpl	r0, #61556	; 0xf074
     7fc:	54726d54 	ldrbtpl	r6, [r2], #-3412	; 0xd54
     800:	69536c62 	ldmdbvs	r3, {r1, r5, r6, sl, fp, sp, lr}^
     804:	4f00657a 	svcmi	0x0000657a
     808:	454d5f53 	strbmi	r5, [sp, #-3923]	; 0xf53
     80c:	534f004d 	movtpl	r0, #61517	; 0xf04d
     810:	786f624d 	stmdavc	pc!, {r0, r2, r3, r6, r9, sp, lr}^
     814:	74736f50 	ldrbtvc	r6, [r3], #-3920	; 0xf50
     818:	0074704f 	rsbseq	r7, r4, pc, asr #32
     81c:	535f534f 	cmppl	pc, #1006632961	; 0x3c000001
     820:	654c7274 	strbvs	r7, [ip, #-628]	; 0x274
     824:	6470006e 	ldrbtvs	r0, [r0], #-110	; 0x6e
     828:	00747365 	rsbseq	r7, r4, r5, ror #6
     82c:	4951534f 	ldmdbmi	r1, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
     830:	6375006e 	cmnvs	r5, #110	; 0x6e
     834:	695f736f 	ldmdbvs	pc, {r0, r1, r2, r3, r5, r6, r8, r9, ip, sp, lr}^
     838:	00632e69 	rsbeq	r2, r3, r9, ror #28
     83c:	6d5f736f 	ldclvs	3, cr7, [pc, #-444]	; 0xfffffe44
     840:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
     844:	7461645f 	strbtvc	r6, [r1], #-1119	; 0x45f
     848:	534f0061 	movtpl	r0, #61537	; 0xf061
     84c:	43726d54 	cmnmi	r2, #5376	; 0x1500
     850:	74616572 	strbtvc	r6, [r1], #-1394	; 0x572
     854:	534f0065 	movtpl	r0, #61541	; 0xf065
     858:	006e4551 	rsbeq	r4, lr, r1, asr r5
     85c:	465f534f 	ldrbmi	r5, [pc], -pc, asr #6
     860:	4967616c 	stmdbmi	r7!, {r2, r3, r5, r6, r8, sp, lr}^
     864:	0074696e 	rsbseq	r6, r4, lr, ror #18
     868:	6154534f 	cmpvs	r4, pc, asr #6
     86c:	64496b73 	strbvs	r6, [r9], #-2931	; 0xb73
     870:	7453656c 	ldrbvc	r6, [r3], #-1388	; 0x56c
     874:	534f006b 	movtpl	r0, #61547	; 0xf06b
     878:	43726d54 	cmnmi	r2, #5376	; 0x1500
     87c:	626c6c61 	rsbvs	r6, ip, #24832	; 0x6100
     880:	006b6361 	rsbeq	r6, fp, r1, ror #6
     884:	65657266 	strbvs	r7, [r5, #-614]!	; 0x266
     888:	5f534f00 	svcpl	0x00534f00
     88c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     890:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
     894:	73694c74 	cmnvc	r9, #29696	; 0x7400
     898:	534f0074 	movtpl	r0, #61556	; 0xf074
     89c:	52726d54 	rsbspl	r6, r2, #5376	; 0x1500
     8a0:	69616d65 	stmdbvs	r1!, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
     8a4:	7465476e 	strbtvc	r4, [r5], #-1902	; 0x76e
     8a8:	5f736f00 	svcpl	0x00736f00
     8ac:	006d656d 	rsbeq	r6, sp, sp, ror #10
     8b0:	495f534f 	ldmdbmi	pc, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
     8b4:	5474696e 	ldrbtpl	r6, [r4], #-2414	; 0x96e
     8b8:	496b7361 	stmdbmi	fp!, {r0, r5, r6, r8, r9, ip, sp, lr}^
     8bc:	00656c64 	rsbeq	r6, r5, r4, ror #24
     8c0:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     8c4:	72465f72 	subvc	r5, r6, #456	; 0x1c8
     8c8:	4f006565 	svcmi	0x00006565
     8cc:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
     8d0:	6b736154 	blvs	1cd8e28 <MEM_SIZE+0x14d8e28>
     8d4:	006b7453 	rsbeq	r7, fp, r3, asr r4
     8d8:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     8dc:	78654e42 	stmdavc	r5!, {r1, r6, r9, sl, fp, lr}^
     8e0:	534f0074 	movtpl	r0, #61556	; 0xf074
     8e4:	7200515f 	andvc	r5, r0, #-1073741801	; 0xc0000017
     8e8:	69616d65 	stmdbvs	r1!, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
     8ec:	534f006e 	movtpl	r0, #61550	; 0xf06e
     8f0:	756c6156 	strbvc	r6, [ip, #-342]!	; 0x156
     8f4:	534f0065 	movtpl	r0, #61541	; 0xf065
     8f8:	7361545f 	cmnvc	r1, #1593835520	; 0x5f000000
     8fc:	6174536b 	cmnvs	r4, fp, ror #6
     900:	534f0074 	movtpl	r0, #61556	; 0xf074
     904:	506d654d 	rsbpl	r6, sp, sp, asr #10
     908:	4f007475 	svcmi	0x00007475
     90c:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
     910:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
     914:	73615474 	cmnvc	r1, #1946157056	; 0x74000000
     918:	534f006b 	movtpl	r0, #61547	; 0xf06b
     91c:	6b636f4c 	blvs	18dc654 <MEM_SIZE+0x10dc654>
     920:	7473654e 	ldrbtvc	r6, [r3], #-1358	; 0x54e
     924:	00676e69 	rsbeq	r6, r7, r9, ror #28
     928:	5051534f 	subspl	r5, r1, pc, asr #6
     92c:	0074736f 	rsbseq	r7, r4, pc, ror #6
     930:	6954534f 	ldmdbvs	r4, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
     934:	6954656d 	ldmdbvs	r4, {r0, r2, r3, r5, r6, r8, sl, sp, lr}^
     938:	74006b63 	strvc	r6, [r0], #-2915	; 0xb63
     93c:	736b6369 	cmnvc	fp, #-1543503871	; 0xa4000001
     940:	5f534f00 	svcpl	0x00534f00
     944:	6b736154 	blvs	1cd8e9c <MEM_SIZE+0x14d8e9c>
     948:	656c6449 	strbvs	r6, [ip, #-1097]!	; 0x449
     94c:	4d534f00 	ldclmi	15, cr4, [r3]
     950:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
     954:	72657551 	rsbvc	r7, r5, #339738624	; 0x14400000
     958:	534f0079 	movtpl	r0, #61561	; 0xf079
     95c:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
     960:	78614d74 	stmdavc	r1!, {r2, r4, r5, r6, r8, sl, fp, lr}^
     964:	64727000 	ldrbtvs	r7, [r2]
     968:	6c627479 	cfstrdvs	mvd7, [r2], #-484	; 0xfffffe1c
     96c:	42534f00 	subsmi	r4, r3, #0
     970:	69536b6c 	ldmdbvs	r3, {r2, r3, r5, r6, r8, r9, fp, sp, lr}^
     974:	4f00657a 	svcmi	0x0000657a
     978:	6f624d53 	svcvs	0x00624d53
     97c:	65724378 	ldrbvs	r4, [r2, #-888]!	; 0x378
     980:	00657461 	rsbeq	r7, r5, r1, ror #8
     984:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     988:	6c654472 	cfstrdvs	mvd4, [r5], #-456	; 0xfffffe38
     98c:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
     990:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     994:	4f006570 	svcmi	0x00006570
     998:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
     99c:	76657250 	undefined instruction 0x76657250
     9a0:	68637000 	stmdavs	r3!, {ip, sp, lr}^
     9a4:	534f006b 	movtpl	r0, #61547	; 0xf06b
     9a8:	6b736154 	blvs	1cd8f00 <MEM_SIZE+0x14d8f00>
     9ac:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
     9b0:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     9b4:	53534f00 	cmppl	r3, #0
     9b8:	72436d65 	subvc	r6, r3, #6464	; 0x1940
     9bc:	65746165 	ldrbvs	r6, [r4, #-357]!	; 0x165
     9c0:	6f627000 	svcvs	0x00627000
     9c4:	736f0073 	cmnvc	pc, #115	; 0x73
     9c8:	616c665f 	cmnvs	ip, pc, asr r6
     9cc:	72675f67 	rsbvc	r5, r7, #412	; 0x19c
     9d0:	73750070 	cmnvc	r5, #112	; 0x70
     9d4:	00656761 	rsbeq	r6, r5, r1, ror #14
     9d8:	726d7470 	rsbvc	r7, sp, #1879048192	; 0x70000000
     9dc:	5f534f00 	svcpl	0x00534f00
     9e0:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
     9e4:	69615774 	stmdbvs	r1!, {r2, r4, r5, r6, r8, r9, sl, ip, lr}^
     9e8:	73694c74 	cmnvc	r9, #29696	; 0x7400
     9ec:	696e4974 	stmdbvs	lr!, {r2, r4, r5, r6, r8, fp, lr}^
     9f0:	534f0074 	movtpl	r0, #61556	; 0xf074
     9f4:	53726d54 	cmnpl	r2, #5376	; 0x1500
     9f8:	4f006d65 	svcmi	0x00006d65
     9fc:	75515153 	ldrbvc	r5, [r1, #-339]	; 0x153
     a00:	00797265 	rsbseq	r7, r9, r5, ror #4
     a04:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     a08:	74784542 	ldrbtvc	r4, [r8], #-1346	; 0x542
     a0c:	00727450 	rsbseq	r7, r2, r0, asr r4
     a10:	515f534f 	cmppl	pc, pc, asr #6
     a14:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     a18:	6d747000 	ldclvs	0, cr7, [r4]
     a1c:	656e5f72 	strbvs	r5, [lr, #-3954]!	; 0xf72
     a20:	4f007478 	svcmi	0x00007478
     a24:	43545f53 	cmpmi	r4, #332	; 0x14c
     a28:	696e4942 	stmdbvs	lr!, {r1, r6, r8, fp, lr}^
     a2c:	65700074 	ldrbvs	r0, [r0, #-116]!	; 0x74
     a30:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     a34:	65700031 	ldrbvs	r0, [r0, #-49]!	; 0x31
     a38:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     a3c:	534f0032 	movtpl	r0, #61490	; 0xf032
     a40:	4c424354 	mcrrmi	3, 5, r4, r2, cr4
     a44:	00747369 	rsbseq	r7, r4, r9, ror #6
     a48:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
     a4c:	7a69536d 	bvc	1a55808 <MEM_SIZE+0x1255808>
     a50:	69620065 	stmdbvs	r2!, {r0, r2, r5, r6}^
     a54:	62007874 	andvs	r7, r0, #7602176	; 0x740000
     a58:	00797469 	rsbseq	r7, r9, r9, ror #8
     a5c:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     a60:	6e555f72 	mrcvs	15, 2, r5, cr5, cr2, {3}
     a64:	6b6e696c 	blvs	1b9b01c <MEM_SIZE+0x139b01c>
     a68:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     a6c:	4467616c 	strbtmi	r6, [r7], #-364	; 0x16c
     a70:	4f006c65 	svcmi	0x00006c65
     a74:	67734d53 	undefined instruction 0x67734d53
     a78:	4c534f00 	mrrcmi	15, 0, r4, r3, cr0
     a7c:	7365776f 	cmnvc	r5, #29097984	; 0x1bc0000
     a80:	69725074 	ldmdbvs	r2!, {r2, r4, r5, r6, ip, lr}^
     a84:	534f006f 	movtpl	r0, #61551	; 0xf06f
     a88:	54424354 	strbpl	r4, [r2], #-852	; 0x354
     a8c:	4e6b7361 	cdpmi	3, 6, cr7, cr11, cr1, {3}
     a90:	00656d61 	rsbeq	r6, r5, r1, ror #26
     a94:	4651534f 	ldrbmi	r5, [r1], -pc, asr #6
     a98:	6873756c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
     a9c:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     aa0:	5167616c 	cmnpl	r7, ip, ror #2
     aa4:	79726575 	ldmdbvc	r2!, {r0, r2, r4, r5, r6, r8, sl, sp, lr}^
     aa8:	4e534f00 	cdpmi	15, 5, cr4, cr3, cr0, {0}
     aac:	7367734d 	cmnvc	r7, #872415233	; 0x34000001
     ab0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     ab4:	6643726d 	strbvs	r7, [r3], -sp, ror #4
     ab8:	63695467 	cmnvs	r9, #1728053248	; 0x67000000
     abc:	6550736b 	ldrbvs	r7, [r0, #-875]	; 0x36b
     ac0:	63655372 	cmnvs	r5, #-939524095	; 0xc8000001
     ac4:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     ac8:	4667616c 	strbtmi	r6, [r7], -ip, ror #2
     acc:	4c656572 	cfstr64mi	mvdx6, [r5], #-456	; 0xfffffe38
     ad0:	00747369 	rsbseq	r7, r4, r9, ror #6
     ad4:	7552534f 	ldrbvc	r5, [r2, #-847]	; 0x34f
     ad8:	6e696e6e 	cdpvs	14, 6, cr6, cr9, cr14, {3}
     adc:	534f0067 	movtpl	r0, #61543	; 0xf067
     ae0:	43726d54 	cmnmi	r2, #5376	; 0x1500
     ae4:	614d6766 	cmpvs	sp, r6, ror #14
     ae8:	534f0078 	movtpl	r0, #61560	; 0xf078
     aec:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     af0:	53707247 	cmnpl	r0, #1879048196	; 0x70000004
     af4:	00657a69 	rsbeq	r7, r5, r9, ror #20
     af8:	6954534f 	ldmdbvs	r4, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
     afc:	6547656d 	strbvs	r6, [r7, #-1389]	; 0x56d
     b00:	534f0074 	movtpl	r0, #61556	; 0xf074
     b04:	54554d5f 	ldrbpl	r4, [r5], #-3423	; 0xd5f
     b08:	445f5845 	ldrbmi	r5, [pc], #2117	; b10 <DISABLE_IRQ+0xa90>
     b0c:	00415441 	subeq	r5, r1, r1, asr #8
     b10:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     b14:	6c415f72 	mcrrvs	15, 7, r5, r1, cr2
     b18:	00636f6c 	rsbeq	r6, r3, ip, ror #30
     b1c:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     b20:	6b745342 	blvs	1d15830 <MEM_SIZE+0x1515830>
     b24:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     b28:	53534f00 	cmppl	r3, #0
     b2c:	63416d65 	movtvs	r6, #7525	; 0x1d65
     b30:	74706563 	ldrbtvc	r6, [r0], #-1379	; 0x563
     b34:	45534f00 	ldrbmi	r4, [r3, #-3840]	; 0xf00
     b38:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     b3c:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
     b40:	00746553 	rsbseq	r6, r4, r3, asr r5
     b44:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     b48:	616c4642 	cmnvs	ip, r2, asr #12
     b4c:	64527367 	ldrbvs	r7, [r2], #-871	; 0x367
     b50:	4e490079 	mcrmi	0, 2, r0, cr9, cr9, {3}
     b54:	55323354 	ldrpl	r3, [r2, #-852]!	; 0x354
     b58:	5f534f00 	svcpl	0x00534f00
     b5c:	5f524d54 	svcpl	0x00524d54
     b60:	45454857 	strbmi	r4, [r5, #-2135]	; 0x857
     b64:	6c66004c 	stclvs	0, cr0, [r6], #-304	; 0xfffffed0
     b68:	5f736761 	svcpl	0x00736761
     b6c:	00796472 	rsbseq	r6, r9, r2, ror r4
     b70:	70657473 	rsbvc	r7, r5, r3, ror r4
     b74:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     b78:	4c5f726d 	lfmmi	f7, 2, [pc], {109}	; (ldclmi 2, cr7, [pc], {109})	; 0x6d
     b7c:	006b6e69 	rsbeq	r6, fp, r9, ror #28
     b80:	5051534f 	subspl	r5, r1, pc, asr #6
     b84:	4f007274 	svcmi	0x00007274
     b88:	6d654d53 	stclvs	13, cr4, [r5, #-332]!	; 0xfffffeb4
     b8c:	536c6254 	cmnpl	ip, #1073741829	; 0x40000005
     b90:	00657a69 	rsbeq	r7, r5, r9, ror #20
     b94:	6449534f 	strbvs	r5, [r9], #-847	; 0x34f
     b98:	7443656c 	strbvc	r6, [r3], #-1388	; 0x56c
     b9c:	736f0072 	cmnvc	pc, #114	; 0x72
     ba0:	4f00715f 	svcmi	0x0000715f
     ba4:	616c4653 	cmnvs	ip, r3, asr r6
     ba8:	646f4e67 	strbtvs	r4, [pc], #3687	; bb0 <DISABLE_IRQ+0xb30>
     bac:	7a695365 	bvc	1a55948 <MEM_SIZE+0x1255948>
     bb0:	696d0065 	stmdbvs	sp!, {r0, r2, r5, r6}^
     bb4:	00696c6c 	rsbeq	r6, r9, ip, ror #24
     bb8:	7450534f 	ldrbvc	r5, [r0], #-847	; 0x34f
     bbc:	7a695372 	bvc	1a5598c <MEM_SIZE+0x125598c>
     bc0:	534f0065 	movtpl	r0, #61541	; 0xf065
     bc4:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
     bc8:	42435474 	submi	r5, r3, #1946157056	; 0x74000000
     bcc:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
     bd0:	72737000 	rsbsvc	r7, r3, #0
     bd4:	65730063 	ldrbvs	r0, [r3, #-99]!	; 0x63
     bd8:	646e6f63 	strbtvs	r6, [lr], #-3939	; 0xf63
     bdc:	534f0073 	movtpl	r0, #61555	; 0xf073
     be0:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
     be4:	79706f43 	ldmdbvc	r0!, {r0, r1, r6, r8, r9, sl, fp, sp, lr}^
     be8:	63747000 	cmnvs	r4, #0
     bec:	70003162 	andvc	r3, r0, r2, ror #2
     bf0:	32626374 	rsbcc	r6, r2, #-805306367	; 0xd0000001
     bf4:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     bf8:	72504243 	subsvc	r4, r0, #805306372	; 0x30000004
     bfc:	62546f69 	subsvs	r6, r4, #420	; 0x1a4
     c00:	4e49006c 	cdpmi	0, 4, cr0, cr9, cr12, {3}
     c04:	00533854 	subseq	r3, r3, r4, asr r8
     c08:	736f7470 	cmnvc	pc, #1879048192	; 0x70000000
     c0c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     c10:	4f005538 	svcmi	0x00005538
     c14:	74535153 	ldrbvc	r5, [r3], #-339	; 0x153
     c18:	00747261 	rsbseq	r7, r4, r1, ror #4
     c1c:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     c20:	61545f72 	cmpvs	r4, r2, ror pc
     c24:	70006b73 	andvc	r6, r0, r3, ror fp
     c28:	31726d74 	cmncc	r2, r4, ror sp
     c2c:	6d747000 	ldclvs	0, cr7, [r4]
     c30:	4f003272 	svcmi	0x00003272
     c34:	61545f53 	cmpvs	r4, r3, asr pc
     c38:	74536b73 	ldrbvc	r6, [r3], #-2931	; 0xb73
     c3c:	726c436b 	rsbvc	r4, ip, #-1409286143	; 0xac000001
     c40:	51534f00 	cmppl	r3, r0, lsl #30
     c44:	65636341 	strbvs	r6, [r3, #-833]!	; 0x341
     c48:	4f007470 	svcmi	0x00007470
     c4c:	74754d53 	ldrbtvc	r4, [r5], #-3411	; 0xd53
     c50:	525f7865 	subspl	r7, pc, #6619136	; 0x650000
     c54:	74417964 	strbvc	r7, [r1], #-2404	; 0x964
     c58:	6f697250 	svcvs	0x00697250
     c5c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     c60:	54656d69 	strbtpl	r6, [r5], #-3433	; 0xd69
     c64:	486b6369 	stmdami	fp!, {r0, r3, r5, r6, r8, r9, sp, lr}^
     c68:	456b6f6f 	strbmi	r6, [fp, #-3951]!	; 0xf6f
     c6c:	534f006e 	movtpl	r0, #61550	; 0xf06e
     c70:	6b736154 	blvs	1cd91c8 <MEM_SIZE+0x14d91c8>
     c74:	61657243 	cmnvs	r5, r3, asr #4
     c78:	78456574 	stmdavc	r5, {r2, r4, r5, r6, r8, sl, sp, lr}^
     c7c:	534f0074 	movtpl	r0, #61556	; 0xf074
     c80:	546d654d 	strbtpl	r6, [sp], #-1357	; 0x54d
     c84:	4f006c62 	svcmi	0x00006c62
     c88:	74754d53 	ldrbtvc	r4, [r5], #-3411	; 0xd53
     c8c:	65507865 	ldrbvs	r7, [r0, #-2149]	; 0x865
     c90:	4f00646e 	svcmi	0x0000646e
     c94:	63535f53 	cmpvs	r3, #332	; 0x14c
     c98:	4e646568 	cdpmi	5, 6, cr6, cr4, cr8, {3}
     c9c:	70007765 	andvc	r7, r0, r5, ror #14
     ca0:	00707267 	rsbseq	r7, r0, r7, ror #4
     ca4:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     ca8:	78744342 	ldmdavc	r4!, {r1, r6, r8, r9, lr}^
     cac:	74437753 	strbvc	r7, [r3], #-1875	; 0x753
     cb0:	534f0072 	movtpl	r0, #61554	; 0xf072
     cb4:	524d545f 	subpl	r5, sp, #1593835520	; 0x5f000000
     cb8:	5f736f00 	svcpl	0x00736f00
     cbc:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
     cc0:	534f0074 	movtpl	r0, #61556	; 0xf074
     cc4:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     cc8:	4f006e45 	svcmi	0x00006e45
     ccc:	6d654d53 	stclvs	13, cr4, [r5, #-332]!	; 0xfffffeb4
     cd0:	65657246 	strbvs	r7, [r5, #-582]!	; 0x246
     cd4:	7473694c 	ldrbtvc	r6, [r3], #-2380	; 0x94c
     cd8:	45534f00 	ldrbmi	r4, [r3, #-3840]	; 0xf00
     cdc:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     ce0:	4f006e45 	svcmi	0x00006e45
     ce4:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
     ce8:	526c6544 	rsbpl	r6, ip, #285212672	; 0x11000000
     cec:	4f007165 	svcmi	0x00007165
     cf0:	6c424e53 	mcrrvs	14, 5, r4, r2, cr3
     cf4:	7000736b 	andvc	r7, r0, fp, ror #6
     cf8:	6d65735f 	stclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
     cfc:	7461645f 	strbtvc	r6, [r1], #-1119	; 0x45f
     d00:	534f0061 	movtpl	r0, #61537	; 0xf061
     d04:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
     d08:	48796c44 	ldmdami	r9!, {r2, r6, sl, fp, sp, lr}^
     d0c:	004d534d 	subeq	r5, sp, sp, asr #6
     d10:	7645534f 	strbvc	r5, [r5], -pc, asr #6
     d14:	53746e65 	cmnpl	r4, #1616	; 0x650
     d18:	00657a69 	rsbeq	r7, r5, r9, ror #20
     d1c:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     d20:	6d614e72 	stclvs	14, cr4, [r1, #-456]!	; 0xfffffe38
     d24:	534f0065 	movtpl	r0, #61541	; 0xf065
     d28:	4e6d654d 	cdpmi	5, 6, cr6, cr13, cr13, {2}
     d2c:	00656d61 	rsbeq	r6, r5, r1, ror #26
     d30:	5f6b7473 	svcpl	0x006b7473
     d34:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0x973
     d38:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     d3c:	7453726d 	ldrbvc	r7, [r3], #-621	; 0x26d
     d40:	00747261 	rsbseq	r7, r4, r1, ror #4
     d44:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     d48:	6b745342 	blvs	1d15a58 <MEM_SIZE+0x1515a58>
     d4c:	74746f42 	ldrbtvc	r6, [r4], #-3906	; 0xf42
     d50:	4f006d6f 	svcmi	0x00006d6f
     d54:	6d654d53 	stclvs	13, cr4, [r5, #-332]!	; 0xfffffeb4
     d58:	00746547 	rsbseq	r6, r4, r7, asr #10
     d5c:	6144534f 	cmpvs	r4, pc, asr #6
     d60:	69536174 	ldmdbvs	r3, {r2, r4, r5, r6, r8, sp, lr}^
     d64:	4f00657a 	svcmi	0x0000657a
     d68:	6d695453 	cfstrdvs	mvd5, [r9, #-332]!	; 0xfffffeb4
     d6c:	796c4465 	stmdbvc	ip!, {r0, r2, r5, r6, sl, lr}^
     d70:	75736552 	ldrbvc	r6, [r3, #-1362]!	; 0x552
     d74:	4f00656d 	svcmi	0x0000656d
     d78:	6f624d53 	svcvs	0x00624d53
     d7c:	63634178 	cmnvs	r3, #30
     d80:	00747065 	rsbseq	r7, r4, r5, rrx
     d84:	5051534f 	subspl	r5, r1, pc, asr #6
     d88:	4f74736f 	svcmi	0x0074736f
     d8c:	4f007470 	svcmi	0x00007470
     d90:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
     d94:	6174536b 	cmnvs	r4, fp, ror #6
     d98:	006e4574 	rsbeq	r4, lr, r4, ror r5
     d9c:	745f736f 	ldrbvc	r7, [pc], #879	; da4 <DISABLE_IRQ+0xd24>
     da0:	4f00726d 	svcmi	0x0000726d
     da4:	61745353 	cmnvs	r4, r3, asr r3
     da8:	79645274 	stmdbvc	r4!, {r2, r4, r5, r6, r9, ip, lr}^
     dac:	5f534f00 	svcpl	0x00534f00
     db0:	5f4d454d 	svcpl	0x004d454d
     db4:	41544144 	cmpmi	r4, r4, asr #2
     db8:	4d534f00 	ldclmi	15, cr4, [r3]
     dbc:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
     dc0:	4f006e45 	svcmi	0x00006e45
     dc4:	61545f53 	cmpvs	r4, r3, asr pc
     dc8:	74536b73 	ldrbvc	r6, [r3], #-2931	; 0xb73
     dcc:	74537461 	ldrbvc	r7, [r3], #-1121	; 0x461
     dd0:	6b68436b 	blvs	1a11b84 <MEM_SIZE+0x1211b84>
     dd4:	5f534f00 	svcpl	0x00534f00
     dd8:	004b5453 	subeq	r5, fp, r3, asr r4
     ddc:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
     de0:	65724672 	ldrbvs	r4, [r2, #-1650]!	; 0x672
     de4:	73694c65 	cmnvc	r9, #25856	; 0x6500
     de8:	5f790074 	svcpl	0x00790074
     dec:	00646c6f 	rsbeq	r6, r4, pc, ror #24
     df0:	626d5f70 	rsbvs	r5, sp, #448	; 0x1c0
     df4:	645f786f 	ldrbvs	r7, [pc], #2159	; dfc <DISABLE_IRQ+0xd7c>
     df8:	00617461 	rsbeq	r7, r1, r1, ror #8
     dfc:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     e00:	69725042 	ldmdbvs	r2!, {r1, r6, ip, lr}^
     e04:	534f006f 	movtpl	r0, #61551	; 0xf06f
     e08:	6b736154 	blvs	1cd9360 <MEM_SIZE+0x14d9360>
     e0c:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
     e10:	536b7453 	cmnpl	fp, #1392508928	; 0x53000000
     e14:	00657a69 	rsbeq	r7, r5, r9, ror #20
     e18:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     e1c:	67694842 	strbvs	r4, [r9, -r2, asr #16]!
     e20:	79645268 	stmdbvc	r4!, {r3, r5, r6, r9, ip, lr}^
     e24:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     e28:	74534243 	ldrbvc	r4, [r3], #-579	; 0x243
     e2c:	4f007461 	svcmi	0x00007461
     e30:	616c4653 	cmnvs	ip, r3, asr r6
     e34:	6c625467 	cfstrdvs	mvd5, [r2], #-412	; 0xfffffe64
     e38:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
     e3c:	00656572 	rsbeq	r6, r5, r2, ror r5
     e40:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     e44:	65764542 	ldrbvs	r4, [r6, #-1346]!	; 0x542
     e48:	7450746e 	ldrbvc	r7, [r0], #-1134	; 0x46e
     e4c:	696d0072 	stmdbvs	sp!, {r1, r4, r5, r6}^
     e50:	6574756e 	ldrbvs	r7, [r4, #-1390]!	; 0x56e
     e54:	5f700073 	svcpl	0x00700073
     e58:	5f6d656d 	svcpl	0x006d656d
     e5c:	61746164 	cmnvs	r4, r4, ror #2
     e60:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     e64:	704f726d 	subvc	r7, pc, sp, ror #4
     e68:	6c660074 	stclvs	0, cr0, [r6], #-464	; 0xfffffe30
     e6c:	5f736761 	svcpl	0x00736761
     e70:	00727563 	rsbseq	r7, r2, r3, ror #10
     e74:	6b736174 	blvs	1cd944c <MEM_SIZE+0x14d944c>
     e78:	61775f73 	cmnvs	r7, r3, ror pc
     e7c:	6e697469 	cdpvs	4, 6, cr7, cr9, cr9, {3}
     e80:	6c6f0067 	stclvs	0, cr0, [pc], #-412	; 0xfffffe64
     e84:	69727064 	ldmdbvs	r2!, {r2, r5, r6, ip, sp, lr}^
     e88:	534f006f 	movtpl	r0, #61551	; 0xf06f
     e8c:	57726d54 	undefined instruction 0x57726d54
     e90:	6c656568 	cfstr64vs	mvdx6, [r5], #-416	; 0xfffffe60
     e94:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     e98:	4d534f00 	ldclmi	15, cr4, [r3]
     e9c:	614e6d65 	cmpvs	lr, r5, ror #26
     ea0:	6547656d 	strbvs	r6, [r7, #-1389]	; 0x56d
     ea4:	534f0074 	movtpl	r0, #61556	; 0xf074
     ea8:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     eac:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
     eb0:	00746547 	rsbseq	r6, r4, r7, asr #10
     eb4:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
     eb8:	6572436d 	ldrbvs	r4, [r2, #-877]!	; 0x36d
     ebc:	00657461 	rsbeq	r7, r5, r1, ror #8
     ec0:	665f736f 	ldrbvs	r7, [pc], -pc, ror #6
     ec4:	5f67616c 	svcpl	0x0067616c
     ec8:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xf6e
     ecc:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     ed0:	6143726d 	cmpvs	r3, sp, ror #4
     ed4:	61626c6c 	cmnvs	r2, ip, ror #24
     ed8:	72416b63 	subvc	r6, r1, #101376	; 0x18c00
     edc:	534f0067 	movtpl	r0, #61543	; 0xf067
     ee0:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
     ee4:	5f736f00 	svcpl	0x00736f00
     ee8:	61645f71 	smcvs	17905	; 0x45f1
     eec:	4f006174 	svcmi	0x00006174
     ef0:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
     ef4:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     ef8:	45534f00 	ldrbmi	r4, [r3, #-3840]	; 0xf00
     efc:	746e6576 	strbtvc	r6, [lr], #-1398	; 0x576
     f00:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
     f04:	5f534f00 	svcpl	0x00534f00
     f08:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
     f0c:	636f6c42 	cmnvs	pc, #16896	; 0x4200
     f10:	534f006b 	movtpl	r0, #61547	; 0xf06b
     f14:	42424354 	submi	r4, r2, #1342177281	; 0x50000001
     f18:	00587469 	subseq	r7, r8, r9, ror #8
     f1c:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
     f20:	74694242 	strbtvc	r4, [r9], #-578	; 0x242
     f24:	534f0059 	movtpl	r0, #61529	; 0xf059
     f28:	64657355 	strbtvs	r7, [r5], #-853	; 0x355
     f2c:	53534f00 	cmppl	r3, #0
     f30:	64656863 	strbtvs	r6, [r5], #-2147	; 0x863
     f34:	6b636f4c 	blvs	18dcc6c <MEM_SIZE+0x10dcc6c>
     f38:	5f534f00 	svcpl	0x00534f00
     f3c:	47414c46 	strbmi	r4, [r1, -r6, asr #24]
     f40:	444f4e5f 	strbmi	r4, [pc], #3679	; f48 <DISABLE_IRQ+0xec8>
     f44:	534f0045 	movtpl	r0, #61509	; 0xf045
     f48:	5f726d54 	svcpl	0x00726d54
     f4c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     f50:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     f54:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
     f58:	53746174 	cmnpl	r4, #29
     f5c:	68436b74 	stmdavs	r3, {r2, r4, r5, r6, r8, r9, fp, sp, lr}^
     f60:	006e456b 	rsbeq	r4, lr, fp, ror #10
     f64:	654d534f 	strbvs	r5, [sp, #-847]	; 0x34f
     f68:	6464416d 	strbtvs	r4, [r4], #-365	; 0x16d
     f6c:	534f0072 	movtpl	r0, #61554	; 0xf072
     f70:	6b736154 	blvs	1cd94c8 <MEM_SIZE+0x14d94c8>
     f74:	006c6544 	rsbeq	r6, ip, r4, asr #10
     f78:	6553534f 	ldrbvs	r5, [r3, #-847]	; 0x34f
     f7c:	6c65446d 	cfstrdvs	mvd4, [r5], #-436	; 0xfffffe4c
     f80:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
     f84:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
     f88:	68436b74 	stmdavs	r3, {r2, r4, r5, r6, r8, r9, fp, sp, lr}^
     f8c:	534f006b 	movtpl	r0, #61547	; 0xf06b
     f90:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
     f94:	73615474 	cmnvc	r1, #1946157056	; 0x74000000
     f98:	6174536b 	cmnvs	r4, fp, ror #6
     f9c:	5f700074 	svcpl	0x00700074
     fa0:	00677261 	rsbeq	r7, r7, r1, ror #4
     fa4:	6d5f736f 	ldclvs	3, cr7, [pc, #-444]	; 0xfffffe44
     fa8:	645f6d65 	ldrbvs	r6, [pc], #3429	; fb0 <DISABLE_IRQ+0xf30>
     fac:	00617461 	rsbeq	r7, r1, r1, ror #8
     fb0:	6544534f 	strbvs	r5, [r4, #-847]	; 0x34f
     fb4:	45677562 	strbmi	r7, [r7, #-1378]!	; 0x562
     fb8:	7470006e 	ldrbtvc	r0, [r0], #-110	; 0x6e
     fbc:	4f006263 	svcmi	0x00006263
     fc0:	65764553 	ldrbvs	r4, [r6, #-1363]!	; 0x553
     fc4:	614e746e 	cmpvs	lr, lr, ror #8
     fc8:	6547656d 	strbvs	r6, [r7, #-1389]	; 0x56d
     fcc:	534f0074 	movtpl	r0, #61556	; 0xf074
     fd0:	646e4551 	strbtvs	r4, [lr], #-1361	; 0x551
     fd4:	72706d00 	rsbsvc	r6, r0, #0
     fd8:	4f006f69 	svcmi	0x00006f69
     fdc:	616c4653 	cmnvs	ip, r3, asr r6
     fe0:	646f4e67 	strbtvs	r4, [pc], #3687	; fe8 <DISABLE_IRQ+0xf68>
     fe4:	616c4665 	cmnvs	ip, r5, ror #12
     fe8:	4f007367 	svcmi	0x00007367
     fec:	79645253 	stmdbvc	r4!, {r0, r1, r4, r6, r9, ip, lr}^
     ff0:	536c6254 	cmnpl	ip, #1073741829	; 0x40000005
     ff4:	00657a69 	rsbeq	r7, r5, r9, ror #20
     ff8:	6154534f 	cmpvs	r4, pc, asr #6
     ffc:	614e6b73 	cmpvs	lr, r3, ror fp
    1000:	6553656d 	ldrbvs	r6, [r3, #-1389]	; 0x56d
    1004:	534f0074 	movtpl	r0, #61556	; 0xf074
    1008:	6c654451 	cfstrdvs	mvd4, [r5], #-324	; 0xfffffebc
    100c:	5f534f00 	svcpl	0x00534f00
    1010:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
    1014:	73615474 	cmnvc	r1, #1946157056	; 0x74000000
    1018:	7964526b 	stmdbvc	r4!, {r0, r1, r3, r5, r6, r9, ip, lr}^
    101c:	5f534f00 	svcpl	0x00534f00
    1020:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    1024:	696c6e55 	stmdbvs	ip!, {r0, r2, r4, r6, r9, sl, fp, sp, lr}^
    1028:	4f006b6e 	svcmi	0x00006b6e
    102c:	616c4653 	cmnvs	ip, r3, asr r6
    1030:	6e655067 	cdpvs	0, 6, cr5, cr5, cr7, {3}
    1034:	534f0064 	movtpl	r0, #61540	; 0xf064
    1038:	4d45535f 	stclmi	3, cr5, [r5, #-380]	; 0xfffffe84
    103c:	5441445f 	strbpl	r4, [r1], #-1119	; 0x45f
    1040:	534f0041 	movtpl	r0, #61505	; 0xf041
    1044:	616c465f 	cmnvs	ip, pc, asr r6
    1048:	73615467 	cmnvc	r1, #1728053248	; 0x67000000
    104c:	7964526b 	stmdbvc	r4!, {r0, r1, r3, r5, r6, r9, ip, lr}^
    1050:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    1054:	00584243 	subseq	r4, r8, r3, asr #4
    1058:	4354534f 	cmpmi	r4, #1006632961	; 0x3c000001
    105c:	4f005942 	svcmi	0x00005942
    1060:	6e495f53 	mcrvs	15, 2, r5, cr9, cr3, {2}
    1064:	694d7469 	stmdbvs	sp, {r0, r3, r5, r6, sl, ip, sp, lr}^
    1068:	4f006373 	svcmi	0x00006373
    106c:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
    1070:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1074:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
    1078:	4667616c 	strbtmi	r6, [r7], -ip, ror #2
    107c:	7367616c 	cmnvc	r7, #27
    1080:	72657000 	rsbvc	r7, r5, #0
    1084:	534f0072 	movtpl	r0, #61554	; 0xf072
    1088:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
    108c:	72745074 	rsbsvc	r5, r4, #116	; 0x74
    1090:	4d534f00 	ldclmi	15, cr4, [r3]
    1094:	44786f62 	ldrbtmi	r6, [r8], #-3938	; 0xf62
    1098:	6c006c65 	stcvs	12, cr6, [r0], {101}	; 0x65
    109c:	73706f6f 	cmnvc	r0, #444	; 0x1bc
    10a0:	53534f00 	cmppl	r3, #0
    10a4:	74726174 	ldrbtvc	r6, [r2], #-372	; 0x174
    10a8:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    10ac:	6e45726d 	cdpvs	2, 4, cr7, cr5, cr13, {3}
    10b0:	65697274 	strbvs	r7, [r9, #-628]!	; 0x274
    10b4:	69740073 	ldmdbvs	r4!, {r0, r1, r4, r5, r6}^
    10b8:	756f656d 	strbvc	r6, [pc, #-1389]!	; b53 <DISABLE_IRQ+0xad3>
    10bc:	534f0074 	movtpl	r0, #61556	; 0xf074
    10c0:	506d6553 	rsbpl	r6, sp, r3, asr r5
    10c4:	00646e65 	rsbeq	r6, r4, r5, ror #28
    10c8:	6553534f 	ldrbvs	r5, [r3, #-847]	; 0x34f
    10cc:	6575516d 	ldrbvs	r5, [r5, #-365]!	; 0x16d
    10d0:	63007972 	movwvs	r7, #2418	; 0x972
    10d4:	626c6c61 	rsbvs	r6, ip, #24832	; 0x6100
    10d8:	5f6b6361 	svcpl	0x006b6361
    10dc:	00677261 	rsbeq	r7, r7, r1, ror #4
    10e0:	65686373 	strbvs	r6, [r8, #-883]!	; 0x373
    10e4:	534f0064 	movtpl	r0, #61540	; 0xf064
    10e8:	4d726d54 	ldclmi	13, cr6, [r2, #-336]!	; 0xfffffeb0
    10ec:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
    10f0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    10f4:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
    10f8:	65707375 	ldrbvs	r7, [r0, #-885]!	; 0x375
    10fc:	4f00646e 	svcmi	0x0000646e
    1100:	6e774f53 	mrcvs	15, 3, r4, cr7, cr3, {2}
    1104:	72507265 	subsvc	r7, r0, #1342177286	; 0x50000006
    1108:	4f006f69 	svcmi	0x00006f69
    110c:	65724653 	ldrbvs	r4, [r2, #-1619]!	; 0x653
    1110:	73694c65 	cmnvc	r9, #25856	; 0x6500
    1114:	74730074 	ldrbtvc	r0, [r3], #-116	; 0x74
    1118:	00657461 	rsbeq	r7, r5, r1, ror #8
    111c:	6452534f 	ldrbvs	r5, [r2], #-847	; 0x34f
    1120:	6c625479 	cfstrdvs	mvd5, [r2], #-484	; 0xfffffe1c
    1124:	6c616300 	stclvs	3, cr6, [r1]
    1128:	6361626c 	cmnvs	r1, #-1073741818	; 0xc0000006
    112c:	534f006b 	movtpl	r0, #61547	; 0xf06b
    1130:	456d654d 	strbmi	r6, [sp, #-1357]!	; 0x54d
    1134:	6e70006e 	cdpvs	0, 7, cr0, cr0, cr14, {3}
    1138:	5f65646f 	svcpl	0x0065646f
    113c:	7478656e 	ldrbtvc	r6, [r8], #-1390	; 0x56e
    1140:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    1144:	436b7361 	cmnmi	fp, #-2080374783	; 0x84000001
    1148:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    114c:	69725065 	ldmdbvs	r2!, {r0, r2, r5, r6, ip, lr}^
    1150:	534f006f 	movtpl	r0, #61551	; 0xf06f
    1154:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    1158:	646e6550 	strbtvs	r6, [lr], #-1360	; 0x550
    115c:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    1160:	7367616c 	cmnvc	r7, #27
    1164:	00796452 	rsbseq	r6, r9, r2, asr r4
    1168:	6154534f 	cmpvs	r4, pc, asr #6
    116c:	64496b73 	strbvs	r6, [r9], #-2931	; 0xb73
    1170:	7453656c 	ldrbvc	r6, [r3], #-1388	; 0x56c
    1174:	7a69536b 	bvc	1a55f28 <MEM_SIZE+0x1255f28>
    1178:	534f0065 	movtpl	r0, #61541	; 0xf065
    117c:	4f424354 	svcmi	0x00424354
    1180:	70007470 	andvc	r7, r0, r0, ror r4
    1184:	6f697265 	svcvs	0x00697265
    1188:	534f0064 	movtpl	r0, #61540	; 0xf064
    118c:	6574754d 	ldrbvs	r7, [r4, #-1357]!	; 0x54d
    1190:	50495078 	subpl	r5, r9, r8, ror r0
    1194:	5f534f00 	svcpl	0x00534f00
    1198:	47414c46 	strbmi	r4, [r1, -r6, asr #24]
    119c:	534f0053 	movtpl	r0, #61523	; 0xf053
    11a0:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
    11a4:	70795474 	rsbsvc	r5, r9, r4, ror r4
    11a8:	534f0065 	movtpl	r0, #61541	; 0xf065
    11ac:	4e6d654d 	cdpmi	5, 6, cr6, cr13, cr13, {2}
    11b0:	53656d61 	cmnpl	r5, #6208	; 0x1840
    11b4:	4f007465 	svcmi	0x00007465
    11b8:	72464e53 	subvc	r4, r6, #1328	; 0x530
    11bc:	4f006565 	svcmi	0x00006565
    11c0:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
    11c4:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    11c8:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
    11cc:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    11d0:	62544243 	subsvs	r4, r4, #805306372	; 0x30000004
    11d4:	534f006c 	movtpl	r0, #61548	; 0xf06c
    11d8:	426d654d 	rsbmi	r6, sp, #322961408	; 0x13400000
    11dc:	69536b6c 	ldmdbvs	r3, {r2, r3, r5, r6, r8, r9, fp, sp, lr}^
    11e0:	4f00657a 	svcmi	0x0000657a
    11e4:	42435453 	submi	r5, r3, #1392508928	; 0x53000000
    11e8:	00727543 	rsbseq	r7, r2, r3, asr #10
    11ec:	70726770 	rsbsvc	r6, r2, r0, ror r7
    11f0:	7465725f 	strbtvc	r7, [r5], #-607	; 0x25f
    11f4:	006e7275 	rsbeq	r7, lr, r5, ror r2
    11f8:	6d5f736f 	ldclvs	3, cr7, [pc, #-444]	; 0xfffffe44
    11fc:	5f786f62 	svcpl	0x00786f62
    1200:	61746164 	cmnvs	r4, r4, ror #2
    1204:	5f736f00 	svcpl	0x00736f00
    1208:	5f6d6573 	svcpl	0x006d6573
    120c:	61746164 	cmnvs	r4, r4, ror #2
    1210:	5f534f00 	svcpl	0x00534f00
    1214:	436d654d 	cmnmi	sp, #322961408	; 0x13400000
    1218:	4f00726c 	svcmi	0x0000726c
    121c:	726d5453 	rsbvc	r5, sp, #1392508928	; 0x53000000
    1220:	76657250 	undefined instruction 0x76657250
    1224:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    1228:	72464243 	subvc	r4, r6, #805306372	; 0x30000004
    122c:	694c6565 	stmdbvs	ip, {r0, r2, r5, r6, r8, sl, sp, lr}^
    1230:	4f007473 	svcmi	0x00007473
    1234:	72655653 	rsbvc	r5, r5, #87031808	; 0x5300000
    1238:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
    123c:	72677000 	rsbvc	r7, r7, #0
    1240:	70003170 	andvc	r3, r0, r0, ror r1
    1244:	32707267 	rsbscc	r7, r0, #1879048198	; 0x70000006
    1248:	4d534f00 	ldclmi	15, cr4, [r3]
    124c:	50786f62 	rsbspl	r6, r8, r2, ror #30
    1250:	0074736f 	rsbseq	r7, r4, pc, ror #6
    1254:	5451534f 	ldrbpl	r5, [r1], #-847	; 0x34f
    1258:	4f006c62 	svcmi	0x00006c62
    125c:	43545f53 	cmpmi	r4, #332	; 0x14c
    1260:	534f0042 	movtpl	r0, #61506	; 0xf042
    1264:	53424354 	movtpl	r4, #9044	; 0x2354
    1268:	00657a69 	rsbeq	r7, r5, r9, ror #20
    126c:	735f736f 	cmpvc	pc, #-1140850687	; 0xbc000001
    1270:	645f6b74 	ldrbvs	r6, [pc], #2932	; 1278 <DISABLE_IRQ+0x11f8>
    1274:	00617461 	rsbeq	r7, r1, r1, ror #8
    1278:	4d5f534f 	ldclmi	3, cr5, [pc, #-316]	; 0xfffffec4
    127c:	5f584f42 	svcpl	0x00584f42
    1280:	41544144 	cmpmi	r4, r4, asr #2
    1284:	5f534f00 	svcpl	0x00534f00
    1288:	47414c46 	strbmi	r4, [r1, -r6, asr #24]
    128c:	5052475f 	subspl	r4, r2, pc, asr r7
    1290:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    1294:	6254726d 	subsvs	r7, r4, #-805306362	; 0xd0000006
    1298:	534f006c 	movtpl	r0, #61548	; 0xf06c
    129c:	4e6d654d 	cdpmi	5, 6, cr6, cr13, cr13, {2}
    12a0:	736b6c42 	cmnvc	fp, #16896	; 0x4200
    12a4:	46534f00 	ldrbmi	r4, [r3], -r0, lsl #30
    12a8:	4e67616c 	powmisz	f6, f7, #4.0
    12ac:	4e65646f 	cdpmi	4, 6, cr6, cr5, cr15, {3}
    12b0:	00747865 	rsbseq	r7, r4, r5, ror #16
    12b4:	65766570 	ldrbvs	r6, [r6, #-1392]!	; 0x570
    12b8:	725f746e 	subsvc	r7, pc, #1845493760	; 0x6e000000
    12bc:	72757465 	rsbsvc	r7, r5, #1694498816	; 0x65000000
    12c0:	534f006e 	movtpl	r0, #61550	; 0xf06e
    12c4:	6b636954 	blvs	18db81c <MEM_SIZE+0x10db81c>
    12c8:	72655073 	rsbvc	r5, r5, #115	; 0x73
    12cc:	00636553 	rsbeq	r6, r3, r3, asr r5
    12d0:	6d54534f 	ldclvs	3, cr5, [r4, #-316]	; 0xfffffec4
    12d4:	67664372 	undefined instruction 0x67664372
    12d8:	656d614e 	strbvs	r6, [sp, #-334]!	; 0x14e
    12dc:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
    12e0:	5f736f00 	svcpl	0x00736f00
    12e4:	5f726d74 	svcpl	0x00726d74
    12e8:	65656877 	strbvs	r6, [r5, #-2167]!	; 0x877
    12ec:	534f006c 	movtpl	r0, #61548	; 0xf06c
    12f0:	786f624d 	stmdavc	pc!, {r0, r2, r3, r6, r9, sp, lr}^
    12f4:	72657551 	rsbvc	r7, r5, #339738624	; 0x14400000
    12f8:	534f0079 	movtpl	r0, #61561	; 0xf079
    12fc:	4e746e49 	cdpmi	14, 7, cr6, cr4, cr9, {2}
    1300:	69747365 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}^
    1304:	7000676e 	andvc	r6, r0, lr, ror #14
    1308:	6b6f7073 	blvs	1bdd4dc <MEM_SIZE+0x13dd4dc>
    130c:	534f0065 	movtpl	r0, #61541	; 0xf065
    1310:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    1314:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    1318:	49534f00 	ldmdbmi	r3, {r8, r9, sl, fp, lr}^
    131c:	43656c64 	cmnmi	r5, #25600	; 0x6400
    1320:	614d7274 	cmpvs	sp, r4, ror r2
    1324:	534f0078 	movtpl	r0, #61560	; 0xf078
    1328:	6b736154 	blvs	1cd9880 <MEM_SIZE+0x14d9880>
    132c:	72657551 	rsbvc	r7, r5, #339738624	; 0x14400000
    1330:	65740079 	ldrbvs	r0, [r4, #-121]!	; 0x79
    1334:	745f7473 	ldrbvc	r7, [pc], #1139	; 133c <DISABLE_IRQ+0x12bc>
    1338:	006b7361 	rsbeq	r7, fp, r1, ror #6
    133c:	316b7473 	smccc	46915	; 0xb743
    1340:	6b747300 	blvs	1d1df48 <MEM_SIZE+0x151df48>
    1344:	74730032 	ldrbtvc	r0, [r3], #-50	; 0x32
    1348:	7400336b 	strvc	r3, [r0], #-875	; 0x36b
    134c:	5f747365 	svcpl	0x00747365
    1350:	6b736174 	blvs	1cd9928 <MEM_SIZE+0x14d9928>
    1354:	7400632e 	strvc	r6, [r0], #-814	; 0x32e
    1358:	5f747365 	svcpl	0x00747365
    135c:	6b736174 	blvs	1cd9934 <MEM_SIZE+0x14d9934>
    1360:	65740031 	ldrbvs	r0, [r4, #-49]!	; 0x31
    1364:	745f7473 	ldrbvc	r7, [pc], #1139	; 136c <DISABLE_IRQ+0x12ec>
    1368:	326b7361 	rsbcc	r7, fp, #-2080374783	; 0x84000001
    136c:	73657400 	cmnvc	r5, #0
    1370:	61745f74 	cmnvs	r4, r4, ror pc
    1374:	00336b73 	eorseq	r6, r3, r3, ror fp
    1378:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
    137c:	6d65735f 	stclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
    1380:	7400632e 	strvc	r6, [r0], #-814	; 0x32e
    1384:	5f747365 	svcpl	0x00747365
    1388:	006d6573 	rsbeq	r6, sp, r3, ror r5
    138c:	65735f70 	ldrbvs	r5, [r3, #-3952]!	; 0xf70
    1390:	6574006d 	ldrbvs	r0, [r4, #-109]!	; 0x6d
    1394:	6d5f7473 	cfldrdvs	mvd7, [pc, #-460]	; 0xfffffe34
    1398:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    139c:	7400632e 	strvc	r6, [r0], #-814	; 0x32e
    13a0:	5f747365 	svcpl	0x00747365
    13a4:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0x56d
    13a8:	5f700078 	svcpl	0x00700078
    13ac:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0x56d
    13b0:	65740078 	ldrbvs	r0, [r4, #-120]!	; 0x78
    13b4:	6d5f7473 	cfldrdvs	mvd7, [pc, #-460]	; 0xfffffe34
    13b8:	2e786f62 	cdpcs	15, 7, cr6, cr8, cr2, {3}
    13bc:	5f700063 	svcpl	0x00700063
    13c0:	61746164 	cmnvs	r4, r4, ror #2
    13c4:	6d5f7000 	ldclvs	0, cr7, [pc]
    13c8:	00786f62 	rsbseq	r6, r8, r2, ror #30
    13cc:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
    13d0:	6f626d5f 	svcvs	0x00626d5f
    13d4:	69740078 	ldmdbvs	r4!, {r3, r4, r5, r6}^
    13d8:	5f72656d 	svcpl	0x0072656d
    13dc:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
    13e0:	745f7000 	ldrbvc	r7, [pc], #0	; 13e8 <DISABLE_IRQ+0x1368>
    13e4:	7400726d 	strvc	r7, [r0], #-621	; 0x26d
    13e8:	5f747365 	svcpl	0x00747365
    13ec:	2e726d74 	mrccs	13, 3, r6, cr2, cr4, {3}
    13f0:	65740063 	ldrbvs	r0, [r4, #-99]!	; 0x63
    13f4:	745f7473 	ldrbvc	r7, [pc], #1139	; 13fc <DISABLE_IRQ+0x137c>
    13f8:	7000726d 	andvc	r7, r0, sp, ror #4
    13fc:	6575715f 	ldrbvs	r7, [r5, #-351]!	; 0x15f
    1400:	74006575 	strvc	r6, [r0], #-1397	; 0x575
    1404:	5f747365 	svcpl	0x00747365
    1408:	75657571 	strbvc	r7, [r5, #-1393]!	; 0x571
    140c:	00632e65 	rsbeq	r2, r3, r5, ror #28
    1410:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
    1414:	7000715f 	andvc	r7, r0, pc, asr r1
    1418:	6d656d5f 	stclvs	13, cr6, [r5, #-380]!	; 0xfffffe84
    141c:	73657400 	cmnvc	r5, #0
    1420:	006d5f74 	rsbeq	r5, sp, r4, ror pc
    1424:	74736574 	ldrbtvc	r6, [r3], #-1396	; 0x574
    1428:	6d656d5f 	stclvs	13, cr6, [r5, #-380]!	; 0xfffffe84
    142c:	7000632e 	andvc	r6, r0, lr, lsr #6
    1430:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
    1434:	75620072 	strbvc	r0, [r2, #-114]!	; 0x72
    1438:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
    143c:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    1440:	496b7361 	stmdbmi	fp!, {r0, r5, r6, r8, r9, ip, sp, lr}^
    1444:	48656c64 	stmdami	r5!, {r2, r5, r6, sl, fp, sp, lr}^
    1448:	006b6f6f 	rsbeq	r6, fp, pc, ror #30
    144c:	6e49534f 	cdpvs	3, 4, cr5, cr9, cr15, {2}
    1450:	6f487469 	svcvs	0x00487469
    1454:	6e456b6f 	vmlsvs.f64	d22, d5, d31
    1458:	534f0064 	movtpl	r0, #61540	; 0xf064
    145c:	6b736154 	blvs	1cd99b4 <MEM_SIZE+0x14d99b4>
    1460:	496b7453 	stmdbmi	fp!, {r0, r1, r4, r6, sl, ip, sp, lr}^
    1464:	0074696e 	rsbseq	r6, r4, lr, ror #18
    1468:	74726f70 	ldrbtvc	r6, [r2], #-3952	; 0xf70
    146c:	7000632e 	andvc	r6, r0, lr, lsr #6
    1470:	6263745f 	rsbvs	r7, r3, #1593835520	; 0x5f000000
    1474:	49534f00 	ldmdbmi	r3, {r8, r9, sl, fp, lr}^
    1478:	4874696e 	ldmdami	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    147c:	426b6f6f 	rsbmi	r6, fp, #444	; 0x1bc
    1480:	6e696765 	cdpvs	7, 6, cr6, cr9, cr5, {3}
    1484:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    1488:	536b7361 	cmnpl	fp, #-2080374783	; 0x84000001
    148c:	48746174 	ldmdami	r4!, {r2, r4, r5, r6, r8, sp, lr}^
    1490:	006b6f6f 	rsbeq	r6, fp, pc, ror #30
    1494:	6154534f 	cmpvs	r4, pc, asr #6
    1498:	77536b73 	undefined instruction 0x77536b73
    149c:	6b6f6f48 	blvs	1bdd1c4 <MEM_SIZE+0x13dd1c4>
    14a0:	54534f00 	ldrbpl	r4, [r3], #-3840	; 0xf00
    14a4:	446b7361 	strbtmi	r7, [fp], #-865	; 0x361
    14a8:	6f486c65 	svcvs	0x00486c65
    14ac:	70006b6f 	andvc	r6, r0, pc, ror #22
    14b0:	7361745f 	cmnvc	r1, #1593835520	; 0x5f000000
    14b4:	534f006b 	movtpl	r0, #61547	; 0xf06b
    14b8:	49424354 	stmdbmi	r2, {r2, r4, r6, r8, r9, lr}^
    14bc:	4874696e 	ldmdami	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    14c0:	006b6f6f 	rsbeq	r6, fp, pc, ror #30
    14c4:	6954534f 	ldmdbvs	r4, {r0, r1, r2, r3, r6, r8, r9, ip, lr}^
    14c8:	6954656d 	ldmdbvs	r4, {r0, r2, r3, r5, r6, r8, sl, sp, lr}^
    14cc:	6f486b63 	svcvs	0x00486b63
    14d0:	4f006b6f 	svcmi	0x00006b6f
    14d4:	73615453 	cmnvc	r1, #1392508928	; 0x53000000
    14d8:	6572436b 	ldrbvs	r4, [r2, #-875]!	; 0x36b
    14dc:	48657461 	stmdami	r5!, {r0, r5, r6, sl, ip, sp, lr}^
    14e0:	006b6f6f 	rsbeq	r6, fp, pc, ror #30

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	00000064 	andeq	r0, r0, r4, rrx
   4:	00000074 	andeq	r0, r0, r4, ror r0
   8:	00000078 	andeq	r0, r0, r8, ror r0
   c:	0000007c 	andeq	r0, r0, ip, ror r0
	...
  18:	00000350 	andeq	r0, r0, r0, asr r3
  1c:	000003ac 	andeq	r0, r0, ip, lsr #7
  20:	000003dc 	ldrdeq	r0, [r0], -ip
  24:	000004b4 	undefined instruction 0x000004b4
	...
  30:	00000370 	andeq	r0, r0, r0, ror r3
  34:	00000388 	andeq	r0, r0, r8, lsl #7
  38:	0000038c 	andeq	r0, r0, ip, lsl #7
  3c:	00000390 	muleq	r0, r0, r3
	...
  48:	00000448 	andeq	r0, r0, r8, asr #8
  4c:	00000474 	andeq	r0, r0, r4, ror r4
  50:	0000047c 	andeq	r0, r0, ip, ror r4
  54:	00000498 	muleq	r0, r8, r4
	...
  60:	00000448 	andeq	r0, r0, r8, asr #8
  64:	00000474 	andeq	r0, r0, r4, ror r4
  68:	0000047c 	andeq	r0, r0, ip, ror r4
  6c:	00000498 	muleq	r0, r8, r4
	...
  78:	000004e8 	andeq	r0, r0, r8, ror #9
  7c:	00000500 	andeq	r0, r0, r0, lsl #10
  80:	00000504 	andeq	r0, r0, r4, lsl #10
  84:	00000508 	andeq	r0, r0, r8, lsl #10
	...
  90:	000009a4 	andeq	r0, r0, r4, lsr #19
  94:	000009ac 	andeq	r0, r0, ip, lsr #19
  98:	000009b4 	undefined instruction 0x000009b4
  9c:	000009cc 	andeq	r0, r0, ip, asr #19
	...
  a8:	000009a4 	andeq	r0, r0, r4, lsr #19
  ac:	000009ac 	andeq	r0, r0, ip, lsr #19
  b0:	000009b4 	undefined instruction 0x000009b4
  b4:	000009cc 	andeq	r0, r0, ip, asr #19
	...
  c0:	00000d18 	andeq	r0, r0, r8, lsl sp
  c4:	00000d1c 	andeq	r0, r0, ip, lsl sp
  c8:	00000d28 	andeq	r0, r0, r8, lsr #26
  cc:	00000d48 	andeq	r0, r0, r8, asr #26
	...
  d8:	00000d18 	andeq	r0, r0, r8, lsl sp
  dc:	00000d1c 	andeq	r0, r0, ip, lsl sp
  e0:	00000d28 	andeq	r0, r0, r8, lsr #26
  e4:	00000d48 	andeq	r0, r0, r8, asr #26
	...
  f0:	00000f28 	andeq	r0, r0, r8, lsr #30
  f4:	00000f2c 	andeq	r0, r0, ip, lsr #30
  f8:	00000f3c 	andeq	r0, r0, ip, lsr pc
  fc:	00000f58 	andeq	r0, r0, r8, asr pc
 100:	00000f30 	andeq	r0, r0, r0, lsr pc
 104:	00000f34 	andeq	r0, r0, r4, lsr pc
	...
 110:	00000f28 	andeq	r0, r0, r8, lsr #30
 114:	00000f2c 	andeq	r0, r0, ip, lsr #30
 118:	00000f3c 	andeq	r0, r0, ip, lsr pc
 11c:	00000f58 	andeq	r0, r0, r8, asr pc
 120:	00000f30 	andeq	r0, r0, r0, lsr pc
 124:	00000f34 	andeq	r0, r0, r4, lsr pc
	...
 130:	0000116c 	andeq	r1, r0, ip, ror #2
 134:	00001170 	andeq	r1, r0, r0, ror r1
 138:	0000117c 	andeq	r1, r0, ip, ror r1
 13c:	00001198 	muleq	r0, r8, r1
	...
 148:	0000116c 	andeq	r1, r0, ip, ror #2
 14c:	00001170 	andeq	r1, r0, r0, ror r1
 150:	0000117c 	andeq	r1, r0, ip, ror r1
 154:	00001198 	muleq	r0, r8, r1
	...
 160:	000013bc 	undefined instruction 0x000013bc
 164:	000013c4 	andeq	r1, r0, r4, asr #7
 168:	000013cc 	andeq	r1, r0, ip, asr #7
 16c:	000013e4 	andeq	r1, r0, r4, ror #7
	...
 178:	000013bc 	undefined instruction 0x000013bc
 17c:	000013c4 	andeq	r1, r0, r4, asr #7
 180:	000013cc 	andeq	r1, r0, ip, asr #7
 184:	000013e4 	andeq	r1, r0, r4, ror #7
	...
 190:	00001758 	andeq	r1, r0, r8, asr r7
 194:	0000175c 	andeq	r1, r0, ip, asr r7
 198:	00001768 	andeq	r1, r0, r8, ror #14
 19c:	00001788 	andeq	r1, r0, r8, lsl #15
	...
 1a8:	00001758 	andeq	r1, r0, r8, asr r7
 1ac:	0000175c 	andeq	r1, r0, ip, asr r7
 1b0:	00001768 	andeq	r1, r0, r8, ror #14
 1b4:	00001788 	andeq	r1, r0, r8, lsl #15
	...
 1c0:	0000189c 	muleq	r0, ip, r8
 1c4:	000018a4 	andeq	r1, r0, r4, lsr #17
 1c8:	000018ac 	andeq	r1, r0, ip, lsr #17
 1cc:	000018c4 	andeq	r1, r0, r4, asr #17
	...
 1d8:	0000189c 	muleq	r0, ip, r8
 1dc:	000018a4 	andeq	r1, r0, r4, lsr #17
 1e0:	000018ac 	andeq	r1, r0, ip, lsr #17
 1e4:	000018c4 	andeq	r1, r0, r4, asr #17
	...
 1f0:	00001f64 	andeq	r1, r0, r4, ror #30
 1f4:	00001f7c 	andeq	r1, r0, ip, ror pc
 1f8:	00001f98 	muleq	r0, r8, pc
 1fc:	00001f9c 	muleq	r0, ip, pc
 200:	00001f88 	andeq	r1, r0, r8, lsl #31
 204:	00001f94 	muleq	r0, r4, pc
 208:	00001f80 	andeq	r1, r0, r0, lsl #31
 20c:	00001f84 	andeq	r1, r0, r4, lsl #31
	...
 218:	00001f64 	andeq	r1, r0, r4, ror #30
 21c:	00001f7c 	andeq	r1, r0, ip, ror pc
 220:	00001f98 	muleq	r0, r8, pc
 224:	00001f9c 	muleq	r0, ip, pc
 228:	00001f88 	andeq	r1, r0, r8, lsl #31
 22c:	00001f94 	muleq	r0, r4, pc
 230:	00001f80 	andeq	r1, r0, r0, lsl #31
 234:	00001f84 	andeq	r1, r0, r4, lsl #31
	...
 240:	00002614 	andeq	r2, r0, r4, lsl r6
 244:	00002640 	andeq	r2, r0, r0, asr #12
 248:	00002720 	andeq	r2, r0, r0, lsr #14
 24c:	00002758 	andeq	r2, r0, r8, asr r7
	...
 258:	00002614 	andeq	r2, r0, r4, lsl r6
 25c:	00002640 	andeq	r2, r0, r0, asr #12
 260:	00002720 	andeq	r2, r0, r0, lsr #14
 264:	00002758 	andeq	r2, r0, r8, asr r7
	...
 270:	000028c0 	andeq	r2, r0, r0, asr #17
 274:	000028d8 	ldrdeq	r2, [r0], -r8
 278:	000028dc 	ldrdeq	r2, [r0], -ip
 27c:	000028e0 	andeq	r2, r0, r0, ror #17
	...
 288:	00002dfc 	strdeq	r2, [r0], -ip
 28c:	00002e00 	andeq	r2, r0, r0, lsl #28
 290:	00002e70 	andeq	r2, r0, r0, ror lr
 294:	00002e78 	andeq	r2, r0, r8, ror lr
 298:	00002e1c 	andeq	r2, r0, ip, lsl lr
 29c:	00002e6c 	andeq	r2, r0, ip, ror #28
 2a0:	00002e08 	andeq	r2, r0, r8, lsl #28
 2a4:	00002e0c 	andeq	r2, r0, ip, lsl #28
	...
 2b0:	00002dfc 	strdeq	r2, [r0], -ip
 2b4:	00002e00 	andeq	r2, r0, r0, lsl #28
 2b8:	00002e70 	andeq	r2, r0, r0, ror lr
 2bc:	00002e78 	andeq	r2, r0, r8, ror lr
 2c0:	00002e1c 	andeq	r2, r0, ip, lsl lr
 2c4:	00002e6c 	andeq	r2, r0, ip, ror #28
 2c8:	00002e08 	andeq	r2, r0, r8, lsl #28
 2cc:	00002e0c 	andeq	r2, r0, ip, lsl #28
	...
 2d8:	00003644 	andeq	r3, r0, r4, asr #12
 2dc:	00003674 	andeq	r3, r0, r4, ror r6
 2e0:	000036a0 	andeq	r3, r0, r0, lsr #13
 2e4:	000036a8 	andeq	r3, r0, r8, lsr #13
 2e8:	00003678 	andeq	r3, r0, r8, ror r6
 2ec:	00003680 	andeq	r3, r0, r0, lsl #13
	...
 2f8:	00003644 	andeq	r3, r0, r4, asr #12
 2fc:	00003674 	andeq	r3, r0, r4, ror r6
 300:	000036a0 	andeq	r3, r0, r0, lsr #13
 304:	000036a8 	andeq	r3, r0, r8, lsr #13
 308:	00003678 	andeq	r3, r0, r8, ror r6
 30c:	00003680 	andeq	r3, r0, r0, lsl #13
	...
 318:	00003cf4 	strdeq	r3, [r0], -r4
 31c:	00003cf8 	strdeq	r3, [r0], -r8
 320:	00003d14 	andeq	r3, r0, r4, lsl sp
 324:	00003d6c 	andeq	r3, r0, ip, ror #26
 328:	00003d00 	andeq	r3, r0, r0, lsl #26
 32c:	00003d04 	andeq	r3, r0, r4, lsl #26
	...
 338:	00003cf4 	strdeq	r3, [r0], -r4
 33c:	00003cf8 	strdeq	r3, [r0], -r8
 340:	00003d14 	andeq	r3, r0, r4, lsl sp
 344:	00003d6c 	andeq	r3, r0, ip, ror #26
 348:	00003d00 	andeq	r3, r0, r0, lsl #26
 34c:	00003d04 	andeq	r3, r0, r4, lsl #26
	...
 358:	0000409c 	muleq	r0, ip, r0
 35c:	000040c8 	andeq	r4, r0, r8, asr #1
 360:	000040cc 	andeq	r4, r0, ip, asr #1
 364:	0000412c 	andeq	r4, r0, ip, lsr #2
	...
 370:	0000409c 	muleq	r0, ip, r0
 374:	000040c8 	andeq	r4, r0, r8, asr #1
 378:	000040cc 	andeq	r4, r0, ip, asr #1
 37c:	0000412c 	andeq	r4, r0, ip, lsr #2
	...
 388:	000042d8 	ldrdeq	r4, [r0], -r8
 38c:	000042dc 	ldrdeq	r4, [r0], -ip
 390:	00004338 	andeq	r4, r0, r8, lsr r3
 394:	00004340 	andeq	r4, r0, r0, asr #6
 398:	000042e4 	andeq	r4, r0, r4, ror #5
 39c:	00004334 	andeq	r4, r0, r4, lsr r3
	...
 3a8:	000042d8 	ldrdeq	r4, [r0], -r8
 3ac:	000042dc 	ldrdeq	r4, [r0], -ip
 3b0:	00004338 	andeq	r4, r0, r8, lsr r3
 3b4:	00004340 	andeq	r4, r0, r0, asr #6
 3b8:	000042e4 	andeq	r4, r0, r4, ror #5
 3bc:	00004334 	andeq	r4, r0, r4, lsr r3
	...
 3c8:	00004658 	andeq	r4, r0, r8, asr r6
 3cc:	00004684 	andeq	r4, r0, r4, lsl #13
 3d0:	00004688 	andeq	r4, r0, r8, lsl #13
 3d4:	000046ec 	andeq	r4, r0, ip, ror #13
	...
 3e0:	00004658 	andeq	r4, r0, r8, asr r6
 3e4:	00004684 	andeq	r4, r0, r4, lsl #13
 3e8:	00004688 	andeq	r4, r0, r8, lsl #13
 3ec:	000046ec 	andeq	r4, r0, ip, ror #13
	...
 3f8:	00004920 	andeq	r4, r0, r0, lsr #18
 3fc:	00004924 	andeq	r4, r0, r4, lsr #18
 400:	00004994 	muleq	r0, r4, r9
 404:	0000499c 	muleq	r0, ip, r9
 408:	00004940 	andeq	r4, r0, r0, asr #18
 40c:	00004990 	muleq	r0, r0, r9
 410:	0000492c 	andeq	r4, r0, ip, lsr #18
 414:	00004930 	andeq	r4, r0, r0, lsr r9
	...
 420:	00004920 	andeq	r4, r0, r0, lsr #18
 424:	00004924 	andeq	r4, r0, r4, lsr #18
 428:	00004994 	muleq	r0, r4, r9
 42c:	0000499c 	muleq	r0, ip, r9
 430:	00004940 	andeq	r4, r0, r0, asr #18
 434:	00004990 	muleq	r0, r0, r9
 438:	0000492c 	andeq	r4, r0, ip, lsr #18
 43c:	00004930 	andeq	r4, r0, r0, lsr r9
	...
 448:	00004f84 	andeq	r4, r0, r4, lsl #31
 44c:	00004fac 	andeq	r4, r0, ip, lsr #31
 450:	0000500c 	andeq	r5, r0, ip
 454:	0000502c 	andeq	r5, r0, ip, lsr #32
 458:	00004fb0 	undefined instruction 0x00004fb0
 45c:	00004fb4 	undefined instruction 0x00004fb4
	...
 468:	00004f84 	andeq	r4, r0, r4, lsl #31
 46c:	00004fac 	andeq	r4, r0, ip, lsr #31
 470:	0000500c 	andeq	r5, r0, ip
 474:	0000502c 	andeq	r5, r0, ip, lsr #32
 478:	00004fb0 	undefined instruction 0x00004fb0
 47c:	00004fb4 	undefined instruction 0x00004fb4
	...
 488:	00005324 	andeq	r5, r0, r4, lsr #6
 48c:	00005348 	andeq	r5, r0, r8, asr #6
 490:	00005354 	andeq	r5, r0, r4, asr r3
 494:	00005358 	andeq	r5, r0, r8, asr r3
 498:	0000534c 	andeq	r5, r0, ip, asr #6
 49c:	00005350 	andeq	r5, r0, r0, asr r3
	...
 4a8:	00005324 	andeq	r5, r0, r4, lsr #6
 4ac:	00005348 	andeq	r5, r0, r8, asr #6
 4b0:	00005354 	andeq	r5, r0, r4, asr r3
 4b4:	00005358 	andeq	r5, r0, r8, asr r3
 4b8:	0000534c 	andeq	r5, r0, ip, asr #6
 4bc:	00005350 	andeq	r5, r0, r0, asr r3
	...
 4c8:	00005404 	andeq	r5, r0, r4, lsl #8
 4cc:	0000541c 	andeq	r5, r0, ip, lsl r4
 4d0:	00005438 	andeq	r5, r0, r8, lsr r4
 4d4:	0000543c 	andeq	r5, r0, ip, lsr r4
 4d8:	00005428 	andeq	r5, r0, r8, lsr #8
 4dc:	00005434 	andeq	r5, r0, r4, lsr r4
 4e0:	00005420 	andeq	r5, r0, r0, lsr #8
 4e4:	00005424 	andeq	r5, r0, r4, lsr #8
	...
 4f0:	00005404 	andeq	r5, r0, r4, lsl #8
 4f4:	0000541c 	andeq	r5, r0, ip, lsl r4
 4f8:	00005438 	andeq	r5, r0, r8, lsr r4
 4fc:	0000543c 	andeq	r5, r0, ip, lsr r4
 500:	00005428 	andeq	r5, r0, r8, lsr #8
 504:	00005434 	andeq	r5, r0, r4, lsr r4
 508:	00005420 	andeq	r5, r0, r0, lsr #8
 50c:	00005424 	andeq	r5, r0, r4, lsr #8
	...
 518:	000054ac 	andeq	r5, r0, ip, lsr #9
 51c:	000054c8 	andeq	r5, r0, r8, asr #9
 520:	000054cc 	andeq	r5, r0, ip, asr #9
 524:	00005508 	andeq	r5, r0, r8, lsl #10
	...
 530:	000054c8 	andeq	r5, r0, r8, asr #9
 534:	000054cc 	andeq	r5, r0, ip, asr #9
 538:	00005508 	andeq	r5, r0, r8, lsl #10
 53c:	00005550 	andeq	r5, r0, r0, asr r5
	...
 548:	000054c8 	andeq	r5, r0, r8, asr #9
 54c:	000054cc 	andeq	r5, r0, ip, asr #9
 550:	00005508 	andeq	r5, r0, r8, lsl #10
 554:	00005550 	andeq	r5, r0, r0, asr r5
	...
 560:	000055d0 	ldrdeq	r5, [r0], -r0
 564:	000055e8 	andeq	r5, r0, r8, ror #11
 568:	000055ec 	andeq	r5, r0, ip, ror #11
 56c:	000055f0 	strdeq	r5, [r0], -r0
	...
